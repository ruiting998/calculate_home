'use strict';

var tslib = require('tslib');
var gLite = require('@antv/g-lite');
var util = require('@antv/util');
var glMatrix = require('gl-matrix');
var EventEmitter = require('eventemitter3');
var earcut = require('earcut');
var gMath = require('@antv/g-math');

var Renderable3D = /** @class */ (function () {
    function Renderable3D() {
        this.meshes = [];
    }
    Renderable3D.tag = 'c-renderable-3d';
    return Renderable3D;
}());

var LightPool = /** @class */ (function () {
    function LightPool() {
        /**
         * lights
         */
        this.lights = [];
    }
    LightPool.prototype.addLight = function (light) {
        this.lights.push(light);
        this.sortLights();
    };
    LightPool.prototype.removeLight = function (light) {
        var i = this.lights.indexOf(light);
        this.lights.splice(i, 1);
        this.sortLights();
    };
    LightPool.prototype.addFog = function (fog) {
        this.fog = fog;
    };
    LightPool.prototype.removeFog = function (fog) {
        this.fog = null;
    };
    LightPool.prototype.getFog = function () {
        return this.fog;
    };
    LightPool.prototype.getAllLights = function () {
        return this.lights;
    };
    /**
     * USE_LIGHT
     * NUM_AMBIENT_LIGHTS
     * NUM_DIR_LIGHTS
     */
    LightPool.prototype.getDefines = function () {
        var defines = {
            USE_LIGHT: !!this.lights.length,
        };
        this.lights.forEach(function (light) {
            if (!defines[light.define]) {
                defines[light.define] = 0;
            }
            defines[light.define]++;
        });
        return defines;
    };
    LightPool.prototype.sortLights = function () {
        this.lights.sort(function (a, b) { return a.order - b.order; });
    };
    return LightPool;
}());

var Mesh = /** @class */ (function (_super) {
    tslib.__extends(Mesh, _super);
    function Mesh(_a) {
        var _this = this;
        var style = _a.style, rest = tslib.__rest(_a, ["style"]);
        _this = _super.call(this, tslib.__assign({ type: gLite.Shape.MESH, style: tslib.__assign({ x: '', y: '', z: '', lineWidth: 0, anchor: [0.5, 0.5, 0.5] }, style) }, rest)) || this;
        _this.cullable.enable = false;
        _this.style.geometry.meshes.push(_this);
        _this.style.material.meshes.push(_this);
        return _this;
    }
    // getVertexBufferData(bufferIndex: number) {
    //   return this.style.geometry.vertexBuffers[bufferIndex];
    // }
    // setVertexBufferData(descriptor: {
    //   bufferIndex: number;
    //   byteOffset: number;
    //   data: ArrayBufferView;
    // }) {}
    Mesh.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        // detach from geometry
        var meshes = this.style.geometry.meshes;
        var index = meshes.indexOf(this);
        meshes.splice(index, 1);
        // detach from material
        meshes = this.style.material.meshes;
        index = meshes.indexOf(this);
        meshes.splice(index, 1);
    };
    return Mesh;
}(gLite.DisplayObject));

var MeshUpdater = /** @class */ (function () {
    function MeshUpdater() {
    }
    MeshUpdater.prototype.update = function (parsedStyle) {
        var geometry = parsedStyle.geometry;
        var aabb = geometry.computeBoundingBox();
        var max = aabb.getMax();
        var min = aabb.getMin();
        var width = max[0] - min[0];
        var height = max[1] - min[1];
        var depth = max[2] - min[2];
        return {
            width: width,
            height: height,
            depth: depth,
        };
    };
    return MeshUpdater;
}());

var PickingIdGenerator = /** @class */ (function () {
    function PickingIdGenerator() {
        this.counter = 0;
        this.id2DisplayObjectMap = {};
    }
    PickingIdGenerator.prototype.getId = function (displayObject) {
        var id = this.counter++;
        this.id2DisplayObjectMap[id] = displayObject;
        return id;
    };
    PickingIdGenerator.prototype.getById = function (id) {
        return this.id2DisplayObjectMap[id];
    };
    PickingIdGenerator.prototype.reset = function () {
        this.counter = 0;
        this.id2DisplayObjectMap = {};
    };
    PickingIdGenerator.prototype.decodePickingColor = function (color) {
        var _a = tslib.__read(color, 3), i1 = _a[0], i2 = _a[1], i3 = _a[2];
        var index = i1 + i2 * 256 + i3 * 65536 - 1;
        return index;
    };
    PickingIdGenerator.prototype.encodePickingColor = function (featureIdx) {
        return [
            (featureIdx + 1) & 255,
            ((featureIdx + 1) >> 8) & 255,
            (((featureIdx + 1) >> 8) >> 8) & 255,
        ];
    };
    return PickingIdGenerator;
}());

/**
 * ported from @luma.gl/constants
 *
 * Standard WebGL and WebGL2 constants
 * These constants are also defined on the WebGLRenderingContext interface.
 */
exports.GL = void 0;
(function (GL) {
    // Clearing buffers
    // Constants passed to clear() to clear buffer masks.
    GL[GL["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    GL[GL["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    GL[GL["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    // Rendering primitives
    // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.
    GL[GL["POINTS"] = 0] = "POINTS";
    GL[GL["LINES"] = 1] = "LINES";
    GL[GL["LINE_LOOP"] = 2] = "LINE_LOOP";
    GL[GL["LINE_STRIP"] = 3] = "LINE_STRIP";
    GL[GL["TRIANGLES"] = 4] = "TRIANGLES";
    GL[GL["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GL[GL["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    // Blending modes
    // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).
    GL[GL["ZERO"] = 0] = "ZERO";
    GL[GL["ONE"] = 1] = "ONE";
    GL[GL["SRC_COLOR"] = 768] = "SRC_COLOR";
    GL[GL["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    GL[GL["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GL[GL["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GL[GL["DST_ALPHA"] = 772] = "DST_ALPHA";
    GL[GL["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    GL[GL["DST_COLOR"] = 774] = "DST_COLOR";
    GL[GL["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    GL[GL["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    GL[GL["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    GL[GL["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    GL[GL["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    GL[GL["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    // Blending equations
    // Constants passed to blendEquation() or blendEquationSeparate() to control
    // how the blending is calculated (for both, RBG and alpha, or separately).
    GL[GL["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GL[GL["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GL[GL["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    // Getting GL parameter information
    // Constants passed to getParameter() to specify what information to return.
    GL[GL["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    GL[GL["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    GL[GL["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    GL[GL["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
    GL[GL["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
    GL[GL["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
    GL[GL["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
    GL[GL["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
    GL[GL["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
    GL[GL["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
    GL[GL["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
    GL[GL["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
    GL[GL["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
    GL[GL["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
    GL[GL["FRONT_FACE"] = 2886] = "FRONT_FACE";
    GL[GL["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
    GL[GL["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
    GL[GL["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
    GL[GL["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
    GL[GL["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
    GL[GL["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
    GL[GL["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
    GL[GL["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
    GL[GL["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
    GL[GL["STENCIL_REF"] = 2967] = "STENCIL_REF";
    GL[GL["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
    GL[GL["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
    GL[GL["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
    GL[GL["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
    GL[GL["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    GL[GL["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
    GL[GL["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
    GL[GL["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
    GL[GL["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
    GL[GL["VIEWPORT"] = 2978] = "VIEWPORT";
    GL[GL["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
    GL[GL["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
    GL[GL["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
    GL[GL["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
    GL[GL["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
    GL[GL["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
    GL[GL["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
    GL[GL["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
    GL[GL["RED_BITS"] = 3410] = "RED_BITS";
    GL[GL["GREEN_BITS"] = 3411] = "GREEN_BITS";
    GL[GL["BLUE_BITS"] = 3412] = "BLUE_BITS";
    GL[GL["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
    GL[GL["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
    GL[GL["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
    GL[GL["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
    GL[GL["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
    GL[GL["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
    GL[GL["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
    GL[GL["SAMPLES"] = 32937] = "SAMPLES";
    GL[GL["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
    GL[GL["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
    GL[GL["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
    GL[GL["VENDOR"] = 7936] = "VENDOR";
    GL[GL["RENDERER"] = 7937] = "RENDERER";
    GL[GL["VERSION"] = 7938] = "VERSION";
    GL[GL["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
    GL[GL["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    GL[GL["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
    // Buffers
    // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or
    // getBufferParameter().
    GL[GL["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
    GL[GL["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
    GL[GL["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
    GL[GL["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    GL[GL["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    GL[GL["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
    GL[GL["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
    // Vertex attributes
    // Constants passed to getVertexAttrib().
    GL[GL["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
    GL[GL["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    GL[GL["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
    GL[GL["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    GL[GL["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
    GL[GL["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    GL[GL["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
    GL[GL["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    // Culling
    // Constants passed to cullFace().
    GL[GL["CULL_FACE"] = 2884] = "CULL_FACE";
    GL[GL["FRONT"] = 1028] = "FRONT";
    GL[GL["BACK"] = 1029] = "BACK";
    GL[GL["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
    // Enabling and disabling
    // Constants passed to enable() or disable().
    GL[GL["BLEND"] = 3042] = "BLEND";
    GL[GL["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    GL[GL["DITHER"] = 3024] = "DITHER";
    GL[GL["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    GL[GL["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    GL[GL["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
    GL[GL["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
    GL[GL["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
    // Errors
    // Constants returned from getError().
    GL[GL["NO_ERROR"] = 0] = "NO_ERROR";
    GL[GL["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    GL[GL["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    GL[GL["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    GL[GL["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    GL[GL["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
    // Front face directions
    // Constants passed to frontFace().
    GL[GL["CW"] = 2304] = "CW";
    GL[GL["CCW"] = 2305] = "CCW";
    // Hints
    // Constants passed to hint()
    GL[GL["DONT_CARE"] = 4352] = "DONT_CARE";
    GL[GL["FASTEST"] = 4353] = "FASTEST";
    GL[GL["NICEST"] = 4354] = "NICEST";
    GL[GL["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
    // Data types
    GL[GL["BYTE"] = 5120] = "BYTE";
    GL[GL["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GL[GL["SHORT"] = 5122] = "SHORT";
    GL[GL["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GL[GL["INT"] = 5124] = "INT";
    GL[GL["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GL[GL["FLOAT"] = 5126] = "FLOAT";
    GL[GL["DOUBLE"] = 5130] = "DOUBLE";
    // Pixel formats
    GL[GL["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GL[GL["ALPHA"] = 6406] = "ALPHA";
    GL[GL["RGB"] = 6407] = "RGB";
    GL[GL["RGBA"] = 6408] = "RGBA";
    GL[GL["LUMINANCE"] = 6409] = "LUMINANCE";
    GL[GL["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    // Pixel types
    // UNSIGNED_BYTE = 0x1401,
    GL[GL["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GL[GL["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GL[GL["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    // Shaders
    // Constants passed to createShader() or getShaderParameter()
    GL[GL["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
    GL[GL["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
    GL[GL["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
    GL[GL["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
    GL[GL["LINK_STATUS"] = 35714] = "LINK_STATUS";
    GL[GL["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
    GL[GL["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
    GL[GL["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
    GL[GL["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
    GL[GL["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
    GL[GL["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
    GL[GL["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
    GL[GL["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    GL[GL["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    GL[GL["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
    GL[GL["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    GL[GL["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
    GL[GL["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
    GL[GL["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
    // Depth or stencil tests
    // Constants passed to depthFunc() or stencilFunc().
    GL[GL["NEVER"] = 512] = "NEVER";
    GL[GL["ALWAYS"] = 519] = "ALWAYS";
    GL[GL["LESS"] = 513] = "LESS";
    GL[GL["EQUAL"] = 514] = "EQUAL";
    GL[GL["LEQUAL"] = 515] = "LEQUAL";
    GL[GL["GREATER"] = 516] = "GREATER";
    GL[GL["GEQUAL"] = 518] = "GEQUAL";
    GL[GL["NOTEQUAL"] = 517] = "NOTEQUAL";
    // Stencil actions
    // Constants passed to stencilOp().
    GL[GL["KEEP"] = 7680] = "KEEP";
    GL[GL["REPLACE"] = 7681] = "REPLACE";
    GL[GL["INCR"] = 7682] = "INCR";
    GL[GL["DECR"] = 7683] = "DECR";
    GL[GL["INVERT"] = 5386] = "INVERT";
    GL[GL["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GL[GL["DECR_WRAP"] = 34056] = "DECR_WRAP";
    // Textures
    // Constants passed to texParameteri(),
    // texParameterf(), bindTexture(), texImage2D(), and others.
    GL[GL["NEAREST"] = 9728] = "NEAREST";
    GL[GL["LINEAR"] = 9729] = "LINEAR";
    GL[GL["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GL[GL["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GL[GL["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GL[GL["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    GL[GL["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
    GL[GL["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    GL[GL["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
    GL[GL["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
    GL[GL["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GL[GL["TEXTURE"] = 5890] = "TEXTURE";
    GL[GL["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GL[GL["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
    GL[GL["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GL[GL["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GL[GL["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GL[GL["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GL[GL["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GL[GL["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    GL[GL["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.
    GL[GL["TEXTURE0"] = 33984] = "TEXTURE0";
    GL[GL["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
    GL[GL["REPEAT"] = 10497] = "REPEAT";
    GL[GL["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GL[GL["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    // Emulation
    GL[GL["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
    GL[GL["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
    // Uniform types
    GL[GL["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    GL[GL["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    GL[GL["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    GL[GL["INT_VEC2"] = 35667] = "INT_VEC2";
    GL[GL["INT_VEC3"] = 35668] = "INT_VEC3";
    GL[GL["INT_VEC4"] = 35669] = "INT_VEC4";
    GL[GL["BOOL"] = 35670] = "BOOL";
    GL[GL["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    GL[GL["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    GL[GL["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    GL[GL["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    GL[GL["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    GL[GL["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    GL[GL["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    GL[GL["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    // Shader precision-specified types
    GL[GL["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
    GL[GL["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
    GL[GL["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
    GL[GL["LOW_INT"] = 36339] = "LOW_INT";
    GL[GL["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
    GL[GL["HIGH_INT"] = 36341] = "HIGH_INT";
    // Framebuffers and renderbuffers
    GL[GL["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
    GL[GL["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
    GL[GL["RGBA4"] = 32854] = "RGBA4";
    GL[GL["RGB5_A1"] = 32855] = "RGB5_A1";
    GL[GL["RGB565"] = 36194] = "RGB565";
    GL[GL["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
    GL[GL["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
    GL[GL["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
    GL[GL["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    GL[GL["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
    GL[GL["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
    GL[GL["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
    GL[GL["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
    GL[GL["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
    GL[GL["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
    GL[GL["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
    GL[GL["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
    GL[GL["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    GL[GL["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    GL[GL["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    GL[GL["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
    GL[GL["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
    GL[GL["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
    GL[GL["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
    GL[GL["NONE"] = 0] = "NONE";
    GL[GL["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
    GL[GL["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    GL[GL["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    GL[GL["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    GL[GL["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
    GL[GL["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
    GL[GL["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
    GL[GL["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
    GL[GL["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
    GL[GL["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
    GL[GL["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
    // Pixel storage modes
    // Constants passed to pixelStorei().
    GL[GL["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
    GL[GL["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    GL[GL["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    // /////////////////////////////////////////////////////
    // Additional constants defined WebGL 2
    // These constants are defined on the WebGL2RenderingContext interface.
    // All WebGL 1 constants are also available in a WebGL 2 context.
    // /////////////////////////////////////////////////////
    // Getting GL parameter information
    // Constants passed to getParameter()
    // to specify what information to return.
    GL[GL["READ_BUFFER"] = 3074] = "READ_BUFFER";
    GL[GL["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
    GL[GL["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
    GL[GL["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
    GL[GL["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
    GL[GL["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
    GL[GL["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
    GL[GL["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
    GL[GL["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
    GL[GL["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
    GL[GL["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
    GL[GL["MAX_ELEMENTS_VERTICES"] = 33000] = "MAX_ELEMENTS_VERTICES";
    GL[GL["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
    GL[GL["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
    GL[GL["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    GL[GL["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    GL[GL["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
    GL[GL["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
    GL[GL["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
    GL[GL["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
    GL[GL["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    GL[GL["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
    GL[GL["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
    GL[GL["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    GL[GL["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    GL[GL["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
    GL[GL["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
    // Textures
    // Constants passed to texParameteri(),
    // texParameterf(), bindTexture(), texImage2D(), and others.
    GL[GL["RED"] = 6403] = "RED";
    GL[GL["RGB8"] = 32849] = "RGB8";
    GL[GL["RGBA8"] = 32856] = "RGBA8";
    GL[GL["RGB10_A2"] = 32857] = "RGB10_A2";
    GL[GL["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
    GL[GL["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
    GL[GL["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
    GL[GL["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
    GL[GL["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
    GL[GL["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
    GL[GL["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
    GL[GL["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
    GL[GL["SRGB"] = 35904] = "SRGB";
    GL[GL["SRGB8"] = 35905] = "SRGB8";
    GL[GL["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GL[GL["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
    GL[GL["RGBA32F"] = 34836] = "RGBA32F";
    GL[GL["RGB32F"] = 34837] = "RGB32F";
    GL[GL["RGBA16F"] = 34842] = "RGBA16F";
    GL[GL["RGB16F"] = 34843] = "RGB16F";
    GL[GL["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GL[GL["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
    GL[GL["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
    GL[GL["RGB9_E5"] = 35901] = "RGB9_E5";
    GL[GL["RGBA32UI"] = 36208] = "RGBA32UI";
    GL[GL["RGB32UI"] = 36209] = "RGB32UI";
    GL[GL["RGBA16UI"] = 36214] = "RGBA16UI";
    GL[GL["RGB16UI"] = 36215] = "RGB16UI";
    GL[GL["RGBA8UI"] = 36220] = "RGBA8UI";
    GL[GL["RGB8UI"] = 36221] = "RGB8UI";
    GL[GL["RGBA32I"] = 36226] = "RGBA32I";
    GL[GL["RGB32I"] = 36227] = "RGB32I";
    GL[GL["RGBA16I"] = 36232] = "RGBA16I";
    GL[GL["RGB16I"] = 36233] = "RGB16I";
    GL[GL["RGBA8I"] = 36238] = "RGBA8I";
    GL[GL["RGB8I"] = 36239] = "RGB8I";
    GL[GL["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GL[GL["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GL[GL["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GL[GL["R8"] = 33321] = "R8";
    GL[GL["RG8"] = 33323] = "RG8";
    GL[GL["R16F"] = 33325] = "R16F";
    GL[GL["R32F"] = 33326] = "R32F";
    GL[GL["RG16F"] = 33327] = "RG16F";
    GL[GL["RG32F"] = 33328] = "RG32F";
    GL[GL["R8I"] = 33329] = "R8I";
    GL[GL["R8UI"] = 33330] = "R8UI";
    GL[GL["R16I"] = 33331] = "R16I";
    GL[GL["R16UI"] = 33332] = "R16UI";
    GL[GL["R32I"] = 33333] = "R32I";
    GL[GL["R32UI"] = 33334] = "R32UI";
    GL[GL["RG8I"] = 33335] = "RG8I";
    GL[GL["RG8UI"] = 33336] = "RG8UI";
    GL[GL["RG16I"] = 33337] = "RG16I";
    GL[GL["RG16UI"] = 33338] = "RG16UI";
    GL[GL["RG32I"] = 33339] = "RG32I";
    GL[GL["RG32UI"] = 33340] = "RG32UI";
    GL[GL["R8_SNORM"] = 36756] = "R8_SNORM";
    GL[GL["RG8_SNORM"] = 36757] = "RG8_SNORM";
    GL[GL["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
    GL[GL["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GL[GL["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    /* covered by extension
    COMPRESSED_R11_EAC  = 0x9270,
    COMPRESSED_SIGNED_R11_EAC = 0x9271,
    COMPRESSED_RG11_EAC = 0x9272,
    COMPRESSED_SIGNED_RG11_EAC  = 0x9273,
    COMPRESSED_RGB8_ETC2  = 0x9274,
    COMPRESSED_SRGB8_ETC2 = 0x9275,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = 0x9276,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC  = 0x9277,
    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC  = 0x9279,
    */
    GL[GL["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
    GL[GL["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
    // Pixel types
    GL[GL["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GL[GL["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GL[GL["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GL[GL["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GL[GL["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GL[GL["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
    GL[GL["RG"] = 33319] = "RG";
    GL[GL["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GL[GL["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
    // Queries
    GL[GL["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
    GL[GL["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
    GL[GL["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
    GL[GL["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
    GL[GL["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    // Draw buffers
    GL[GL["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
    GL[GL["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
    GL[GL["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
    GL[GL["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
    GL[GL["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
    GL[GL["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
    GL[GL["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
    GL[GL["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
    GL[GL["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
    GL[GL["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
    GL[GL["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
    GL[GL["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
    GL[GL["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
    GL[GL["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
    GL[GL["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
    GL[GL["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
    GL[GL["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
    GL[GL["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
    GL[GL["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
    GL[GL["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
    GL[GL["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
    GL[GL["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
    GL[GL["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
    GL[GL["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
    GL[GL["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
    GL[GL["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
    GL[GL["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
    GL[GL["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
    GL[GL["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
    GL[GL["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
    GL[GL["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
    GL[GL["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
    GL[GL["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
    // Samplers
    GL[GL["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
    GL[GL["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
    GL[GL["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
    GL[GL["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
    GL[GL["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
    GL[GL["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
    GL[GL["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
    GL[GL["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
    GL[GL["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
    GL[GL["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
    GL[GL["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
    GL[GL["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
    GL[GL["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    GL[GL["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
    GL[GL["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
    // Buffers
    GL[GL["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
    GL[GL["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
    GL[GL["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
    GL[GL["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
    GL[GL["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
    GL[GL["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
    GL[GL["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
    GL[GL["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
    // Data types
    GL[GL["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
    GL[GL["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
    GL[GL["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
    GL[GL["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
    GL[GL["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
    GL[GL["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
    GL[GL["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
    GL[GL["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
    GL[GL["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
    GL[GL["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
    GL[GL["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
    // Vertex attributes
    GL[GL["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    GL[GL["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    // Transform feedback
    GL[GL["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    GL[GL["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    GL[GL["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
    GL[GL["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
    GL[GL["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    GL[GL["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    GL[GL["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    GL[GL["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    GL[GL["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
    GL[GL["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
    GL[GL["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
    GL[GL["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    GL[GL["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
    GL[GL["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
    GL[GL["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
    GL[GL["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
    // Framebuffers and renderbuffers
    GL[GL["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    GL[GL["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    GL[GL["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    GL[GL["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
    // DEPTH_STENCIL_ATTACHMENT  = 0x821A,
    // DEPTH_STENCIL = 0x84F9,
    GL[GL["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    GL[GL["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
    GL[GL["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
    GL[GL["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
    GL[GL["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    GL[GL["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    // Uniforms
    GL[GL["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    GL[GL["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
    GL[GL["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
    GL[GL["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
    GL[GL["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
    GL[GL["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    GL[GL["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
    GL[GL["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
    GL[GL["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
    GL[GL["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    GL[GL["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    GL[GL["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    GL[GL["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
    GL[GL["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
    GL[GL["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
    GL[GL["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
    GL[GL["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
    GL[GL["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
    GL[GL["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
    GL[GL["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
    GL[GL["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
    GL[GL["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
    GL[GL["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    GL[GL["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    GL[GL["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    GL[GL["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    // Sync objects
    GL[GL["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
    GL[GL["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
    GL[GL["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
    GL[GL["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
    GL[GL["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
    GL[GL["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
    GL[GL["UNSIGNALED"] = 37144] = "UNSIGNALED";
    GL[GL["SIGNALED"] = 37145] = "SIGNALED";
    GL[GL["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
    GL[GL["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
    GL[GL["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
    GL[GL["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
    GL[GL["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
    // Miscellaneous constants
    GL[GL["COLOR"] = 6144] = "COLOR";
    GL[GL["DEPTH"] = 6145] = "DEPTH";
    GL[GL["STENCIL"] = 6146] = "STENCIL";
    GL[GL["MIN"] = 32775] = "MIN";
    GL[GL["MAX"] = 32776] = "MAX";
    GL[GL["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    GL[GL["STREAM_READ"] = 35041] = "STREAM_READ";
    GL[GL["STREAM_COPY"] = 35042] = "STREAM_COPY";
    GL[GL["STATIC_READ"] = 35045] = "STATIC_READ";
    GL[GL["STATIC_COPY"] = 35046] = "STATIC_COPY";
    GL[GL["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
    GL[GL["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
    GL[GL["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    GL[GL["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
    GL[GL["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
    GL[GL["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
    GL[GL["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    // Constants defined in WebGL extensions
    // ANGLE_instanced_arrays
    GL[GL["VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE";
    // WEBGL_debug_renderer_info
    GL[GL["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
    GL[GL["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
    // EXT_texture_filter_anisotropic
    GL[GL["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
    GL[GL["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
    // WEBGL_compressed_texture_s3tc
    GL[GL["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    GL[GL["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    GL[GL["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    GL[GL["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    // WEBGL_compressed_texture_es3
    GL[GL["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    GL[GL["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    GL[GL["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    GL[GL["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    GL[GL["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    GL[GL["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
    GL[GL["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
    GL[GL["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    GL[GL["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GL[GL["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    // WEBGL_compressed_texture_pvrtc
    GL[GL["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    GL[GL["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    GL[GL["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    GL[GL["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    // WEBGL_compressed_texture_etc1
    GL[GL["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    // WEBGL_compressed_texture_atc
    GL[GL["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    GL[GL["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    GL[GL["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    // WEBGL_depth_texture
    GL[GL["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
    // OES_texture_half_float
    GL[GL["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
    // WEBGL_color_buffer_float
    GL[GL["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
    GL[GL["RGB32F_EXT"] = 34837] = "RGB32F_EXT";
    GL[GL["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
    GL[GL["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
    // EXT_blend_minmax
    GL[GL["MIN_EXT"] = 32775] = "MIN_EXT";
    GL[GL["MAX_EXT"] = 32776] = "MAX_EXT";
    // EXT_sRGB
    GL[GL["SRGB_EXT"] = 35904] = "SRGB_EXT";
    GL[GL["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
    GL[GL["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
    GL[GL["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT";
    // OES_standard_derivatives
    GL[GL["FRAGMENT_SHADER_DERIVATIVE_HINT_OES"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT_OES";
    // WEBGL_draw_buffers
    GL[GL["COLOR_ATTACHMENT0_WEBGL"] = 36064] = "COLOR_ATTACHMENT0_WEBGL";
    GL[GL["COLOR_ATTACHMENT1_WEBGL"] = 36065] = "COLOR_ATTACHMENT1_WEBGL";
    GL[GL["COLOR_ATTACHMENT2_WEBGL"] = 36066] = "COLOR_ATTACHMENT2_WEBGL";
    GL[GL["COLOR_ATTACHMENT3_WEBGL"] = 36067] = "COLOR_ATTACHMENT3_WEBGL";
    GL[GL["COLOR_ATTACHMENT4_WEBGL"] = 36068] = "COLOR_ATTACHMENT4_WEBGL";
    GL[GL["COLOR_ATTACHMENT5_WEBGL"] = 36069] = "COLOR_ATTACHMENT5_WEBGL";
    GL[GL["COLOR_ATTACHMENT6_WEBGL"] = 36070] = "COLOR_ATTACHMENT6_WEBGL";
    GL[GL["COLOR_ATTACHMENT7_WEBGL"] = 36071] = "COLOR_ATTACHMENT7_WEBGL";
    GL[GL["COLOR_ATTACHMENT8_WEBGL"] = 36072] = "COLOR_ATTACHMENT8_WEBGL";
    GL[GL["COLOR_ATTACHMENT9_WEBGL"] = 36073] = "COLOR_ATTACHMENT9_WEBGL";
    GL[GL["COLOR_ATTACHMENT10_WEBGL"] = 36074] = "COLOR_ATTACHMENT10_WEBGL";
    GL[GL["COLOR_ATTACHMENT11_WEBGL"] = 36075] = "COLOR_ATTACHMENT11_WEBGL";
    GL[GL["COLOR_ATTACHMENT12_WEBGL"] = 36076] = "COLOR_ATTACHMENT12_WEBGL";
    GL[GL["COLOR_ATTACHMENT13_WEBGL"] = 36077] = "COLOR_ATTACHMENT13_WEBGL";
    GL[GL["COLOR_ATTACHMENT14_WEBGL"] = 36078] = "COLOR_ATTACHMENT14_WEBGL";
    GL[GL["COLOR_ATTACHMENT15_WEBGL"] = 36079] = "COLOR_ATTACHMENT15_WEBGL";
    GL[GL["DRAW_BUFFER0_WEBGL"] = 34853] = "DRAW_BUFFER0_WEBGL";
    GL[GL["DRAW_BUFFER1_WEBGL"] = 34854] = "DRAW_BUFFER1_WEBGL";
    GL[GL["DRAW_BUFFER2_WEBGL"] = 34855] = "DRAW_BUFFER2_WEBGL";
    GL[GL["DRAW_BUFFER3_WEBGL"] = 34856] = "DRAW_BUFFER3_WEBGL";
    GL[GL["DRAW_BUFFER4_WEBGL"] = 34857] = "DRAW_BUFFER4_WEBGL";
    GL[GL["DRAW_BUFFER5_WEBGL"] = 34858] = "DRAW_BUFFER5_WEBGL";
    GL[GL["DRAW_BUFFER6_WEBGL"] = 34859] = "DRAW_BUFFER6_WEBGL";
    GL[GL["DRAW_BUFFER7_WEBGL"] = 34860] = "DRAW_BUFFER7_WEBGL";
    GL[GL["DRAW_BUFFER8_WEBGL"] = 34861] = "DRAW_BUFFER8_WEBGL";
    GL[GL["DRAW_BUFFER9_WEBGL"] = 34862] = "DRAW_BUFFER9_WEBGL";
    GL[GL["DRAW_BUFFER10_WEBGL"] = 34863] = "DRAW_BUFFER10_WEBGL";
    GL[GL["DRAW_BUFFER11_WEBGL"] = 34864] = "DRAW_BUFFER11_WEBGL";
    GL[GL["DRAW_BUFFER12_WEBGL"] = 34865] = "DRAW_BUFFER12_WEBGL";
    GL[GL["DRAW_BUFFER13_WEBGL"] = 34866] = "DRAW_BUFFER13_WEBGL";
    GL[GL["DRAW_BUFFER14_WEBGL"] = 34867] = "DRAW_BUFFER14_WEBGL";
    GL[GL["DRAW_BUFFER15_WEBGL"] = 34868] = "DRAW_BUFFER15_WEBGL";
    GL[GL["MAX_COLOR_ATTACHMENTS_WEBGL"] = 36063] = "MAX_COLOR_ATTACHMENTS_WEBGL";
    GL[GL["MAX_DRAW_BUFFERS_WEBGL"] = 34852] = "MAX_DRAW_BUFFERS_WEBGL";
    // OES_vertex_array_object
    GL[GL["VERTEX_ARRAY_BINDING_OES"] = 34229] = "VERTEX_ARRAY_BINDING_OES";
    // EXT_disjoint_timer_query
    GL[GL["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
    GL[GL["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
    GL[GL["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
    GL[GL["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
    GL[GL["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
    GL[GL["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
    GL[GL["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
})(exports.GL || (exports.GL = {}));

exports.ResourceType = void 0;
(function (ResourceType) {
    ResourceType[ResourceType["Buffer"] = 0] = "Buffer";
    ResourceType[ResourceType["Texture"] = 1] = "Texture";
    ResourceType[ResourceType["RenderTarget"] = 2] = "RenderTarget";
    ResourceType[ResourceType["Sampler"] = 3] = "Sampler";
    ResourceType[ResourceType["Program"] = 4] = "Program";
    ResourceType[ResourceType["Bindings"] = 5] = "Bindings";
    ResourceType[ResourceType["InputLayout"] = 6] = "InputLayout";
    ResourceType[ResourceType["InputState"] = 7] = "InputState";
    ResourceType[ResourceType["RenderPipeline"] = 8] = "RenderPipeline";
    ResourceType[ResourceType["ComputePipeline"] = 9] = "ComputePipeline";
    ResourceType[ResourceType["Readback"] = 10] = "Readback";
    ResourceType[ResourceType["QueryPool"] = 11] = "QueryPool";
})(exports.ResourceType || (exports.ResourceType = {}));
exports.CompareMode = void 0;
(function (CompareMode) {
    CompareMode[CompareMode["Never"] = 512] = "Never";
    CompareMode[CompareMode["Less"] = 513] = "Less";
    CompareMode[CompareMode["Equal"] = 514] = "Equal";
    CompareMode[CompareMode["LessEqual"] = 515] = "LessEqual";
    CompareMode[CompareMode["Greater"] = 516] = "Greater";
    CompareMode[CompareMode["NotEqual"] = 517] = "NotEqual";
    CompareMode[CompareMode["GreaterEqual"] = 518] = "GreaterEqual";
    CompareMode[CompareMode["Always"] = 519] = "Always";
})(exports.CompareMode || (exports.CompareMode = {}));
exports.FrontFaceMode = void 0;
(function (FrontFaceMode) {
    FrontFaceMode[FrontFaceMode["CCW"] = 2305] = "CCW";
    FrontFaceMode[FrontFaceMode["CW"] = 2304] = "CW";
})(exports.FrontFaceMode || (exports.FrontFaceMode = {}));
exports.CullMode = void 0;
(function (CullMode) {
    CullMode[CullMode["None"] = 0] = "None";
    CullMode[CullMode["Front"] = 1] = "Front";
    CullMode[CullMode["Back"] = 2] = "Back";
    CullMode[CullMode["FrontAndBack"] = 3] = "FrontAndBack";
})(exports.CullMode || (exports.CullMode = {}));
exports.BlendFactor = void 0;
(function (BlendFactor) {
    BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
    BlendFactor[BlendFactor["One"] = 1] = "One";
    BlendFactor[BlendFactor["Src"] = 768] = "Src";
    BlendFactor[BlendFactor["OneMinusSrc"] = 769] = "OneMinusSrc";
    BlendFactor[BlendFactor["Dst"] = 774] = "Dst";
    BlendFactor[BlendFactor["OneMinusDst"] = 775] = "OneMinusDst";
    BlendFactor[BlendFactor["SrcAlpha"] = 770] = "SrcAlpha";
    BlendFactor[BlendFactor["OneMinusSrcAlpha"] = 771] = "OneMinusSrcAlpha";
    BlendFactor[BlendFactor["DstAlpha"] = 772] = "DstAlpha";
    BlendFactor[BlendFactor["OneMinusDstAlpha"] = 773] = "OneMinusDstAlpha";
})(exports.BlendFactor || (exports.BlendFactor = {}));
exports.BlendMode = void 0;
(function (BlendMode) {
    BlendMode[BlendMode["Add"] = 32774] = "Add";
    BlendMode[BlendMode["Subtract"] = 32778] = "Subtract";
    BlendMode[BlendMode["ReverseSubtract"] = 32779] = "ReverseSubtract";
})(exports.BlendMode || (exports.BlendMode = {}));
exports.WrapMode = void 0;
(function (WrapMode) {
    WrapMode[WrapMode["Clamp"] = 0] = "Clamp";
    WrapMode[WrapMode["Repeat"] = 1] = "Repeat";
    WrapMode[WrapMode["Mirror"] = 2] = "Mirror";
})(exports.WrapMode || (exports.WrapMode = {}));
exports.TexFilterMode = void 0;
(function (TexFilterMode) {
    TexFilterMode[TexFilterMode["Point"] = 0] = "Point";
    TexFilterMode[TexFilterMode["Bilinear"] = 1] = "Bilinear";
})(exports.TexFilterMode || (exports.TexFilterMode = {}));
exports.MipFilterMode = void 0;
(function (MipFilterMode) {
    MipFilterMode[MipFilterMode["NoMip"] = 0] = "NoMip";
    MipFilterMode[MipFilterMode["Nearest"] = 1] = "Nearest";
    MipFilterMode[MipFilterMode["Linear"] = 2] = "Linear";
})(exports.MipFilterMode || (exports.MipFilterMode = {}));
exports.PrimitiveTopology = void 0;
(function (PrimitiveTopology) {
    PrimitiveTopology[PrimitiveTopology["Points"] = 0] = "Points";
    PrimitiveTopology[PrimitiveTopology["Triangles"] = 1] = "Triangles";
    PrimitiveTopology[PrimitiveTopology["TriangleStrip"] = 2] = "TriangleStrip";
    PrimitiveTopology[PrimitiveTopology["Lines"] = 3] = "Lines";
    PrimitiveTopology[PrimitiveTopology["LineStrip"] = 4] = "LineStrip";
})(exports.PrimitiveTopology || (exports.PrimitiveTopology = {}));
/**
 * @see https://www.w3.org/TR/webgpu/#buffer-usage
 */
exports.BufferUsage = void 0;
(function (BufferUsage) {
    BufferUsage[BufferUsage["MAP_READ"] = 1] = "MAP_READ";
    BufferUsage[BufferUsage["MAP_WRITE"] = 2] = "MAP_WRITE";
    BufferUsage[BufferUsage["COPY_SRC"] = 4] = "COPY_SRC";
    BufferUsage[BufferUsage["COPY_DST"] = 8] = "COPY_DST";
    BufferUsage[BufferUsage["INDEX"] = 16] = "INDEX";
    BufferUsage[BufferUsage["VERTEX"] = 32] = "VERTEX";
    BufferUsage[BufferUsage["UNIFORM"] = 64] = "UNIFORM";
    BufferUsage[BufferUsage["STORAGE"] = 128] = "STORAGE";
    BufferUsage[BufferUsage["INDIRECT"] = 256] = "INDIRECT";
    BufferUsage[BufferUsage["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
})(exports.BufferUsage || (exports.BufferUsage = {}));
exports.BufferFrequencyHint = void 0;
(function (BufferFrequencyHint) {
    BufferFrequencyHint[BufferFrequencyHint["Static"] = 1] = "Static";
    BufferFrequencyHint[BufferFrequencyHint["Dynamic"] = 2] = "Dynamic";
})(exports.BufferFrequencyHint || (exports.BufferFrequencyHint = {}));
exports.VertexBufferFrequency = void 0;
(function (VertexBufferFrequency) {
    VertexBufferFrequency[VertexBufferFrequency["PerVertex"] = 1] = "PerVertex";
    VertexBufferFrequency[VertexBufferFrequency["PerInstance"] = 2] = "PerInstance";
})(exports.VertexBufferFrequency || (exports.VertexBufferFrequency = {}));
exports.TextureEvent = void 0;
(function (TextureEvent) {
    TextureEvent["LOADED"] = "loaded";
})(exports.TextureEvent || (exports.TextureEvent = {}));
exports.TextureDimension = void 0;
(function (TextureDimension) {
    TextureDimension[TextureDimension["n2D"] = 0] = "n2D";
    TextureDimension[TextureDimension["n2DArray"] = 1] = "n2DArray";
    TextureDimension[TextureDimension["n3D"] = 2] = "n3D";
    TextureDimension[TextureDimension["Cube"] = 3] = "Cube";
})(exports.TextureDimension || (exports.TextureDimension = {}));
exports.TextureUsage = void 0;
(function (TextureUsage) {
    TextureUsage[TextureUsage["Sampled"] = 1] = "Sampled";
    TextureUsage[TextureUsage["RenderTarget"] = 2] = "RenderTarget";
})(exports.TextureUsage || (exports.TextureUsage = {}));
exports.ChannelWriteMask = void 0;
(function (ChannelWriteMask) {
    ChannelWriteMask[ChannelWriteMask["None"] = 0] = "None";
    ChannelWriteMask[ChannelWriteMask["Red"] = 1] = "Red";
    ChannelWriteMask[ChannelWriteMask["Green"] = 2] = "Green";
    ChannelWriteMask[ChannelWriteMask["Blue"] = 4] = "Blue";
    ChannelWriteMask[ChannelWriteMask["Alpha"] = 8] = "Alpha";
    ChannelWriteMask[ChannelWriteMask["RGB"] = 7] = "RGB";
    ChannelWriteMask[ChannelWriteMask["AllChannels"] = 15] = "AllChannels";
})(exports.ChannelWriteMask || (exports.ChannelWriteMask = {}));
exports.StencilOp = void 0;
(function (StencilOp) {
    StencilOp[StencilOp["Keep"] = 7680] = "Keep";
    StencilOp[StencilOp["Zero"] = 0] = "Zero";
    StencilOp[StencilOp["Replace"] = 7681] = "Replace";
    StencilOp[StencilOp["Invert"] = 5386] = "Invert";
    StencilOp[StencilOp["IncrementClamp"] = 7682] = "IncrementClamp";
    StencilOp[StencilOp["DecrementClamp"] = 7683] = "DecrementClamp";
    StencilOp[StencilOp["IncrementWrap"] = 34055] = "IncrementWrap";
    StencilOp[StencilOp["DecrementWrap"] = 34056] = "DecrementWrap";
})(exports.StencilOp || (exports.StencilOp = {}));
function makeTextureDescriptor2D(pixelFormat, width, height, numLevels) {
    var dimension = exports.TextureDimension.n2D, depth = 1;
    var usage = exports.TextureUsage.Sampled;
    return { dimension: dimension, pixelFormat: pixelFormat, width: width, height: height, depth: depth, numLevels: numLevels, usage: usage };
}
exports.SamplerFormatKind = void 0;
(function (SamplerFormatKind) {
    SamplerFormatKind[SamplerFormatKind["Float"] = 0] = "Float";
    SamplerFormatKind[SamplerFormatKind["Uint"] = 1] = "Uint";
    SamplerFormatKind[SamplerFormatKind["Sint"] = 2] = "Sint";
    SamplerFormatKind[SamplerFormatKind["Depth"] = 3] = "Depth";
})(exports.SamplerFormatKind || (exports.SamplerFormatKind = {}));
exports.ViewportOrigin = void 0;
(function (ViewportOrigin) {
    ViewportOrigin[ViewportOrigin["LowerLeft"] = 0] = "LowerLeft";
    ViewportOrigin[ViewportOrigin["UpperLeft"] = 1] = "UpperLeft";
})(exports.ViewportOrigin || (exports.ViewportOrigin = {}));
exports.ClipSpaceNearZ = void 0;
(function (ClipSpaceNearZ) {
    ClipSpaceNearZ[ClipSpaceNearZ["NegativeOne"] = 0] = "NegativeOne";
    ClipSpaceNearZ[ClipSpaceNearZ["Zero"] = 1] = "Zero";
})(exports.ClipSpaceNearZ || (exports.ClipSpaceNearZ = {}));
exports.QueryPoolType = void 0;
(function (QueryPoolType) {
    QueryPoolType[QueryPoolType["OcclusionConservative"] = 0] = "OcclusionConservative";
})(exports.QueryPoolType || (exports.QueryPoolType = {}));

exports.FormatTypeFlags = void 0;
(function (FormatTypeFlags) {
    FormatTypeFlags[FormatTypeFlags["U8"] = 1] = "U8";
    FormatTypeFlags[FormatTypeFlags["U16"] = 2] = "U16";
    FormatTypeFlags[FormatTypeFlags["U32"] = 3] = "U32";
    FormatTypeFlags[FormatTypeFlags["S8"] = 4] = "S8";
    FormatTypeFlags[FormatTypeFlags["S16"] = 5] = "S16";
    FormatTypeFlags[FormatTypeFlags["S32"] = 6] = "S32";
    FormatTypeFlags[FormatTypeFlags["F16"] = 7] = "F16";
    FormatTypeFlags[FormatTypeFlags["F32"] = 8] = "F32";
    // Compressed texture formats.
    FormatTypeFlags[FormatTypeFlags["BC1"] = 65] = "BC1";
    FormatTypeFlags[FormatTypeFlags["BC2"] = 66] = "BC2";
    FormatTypeFlags[FormatTypeFlags["BC3"] = 67] = "BC3";
    FormatTypeFlags[FormatTypeFlags["BC4_UNORM"] = 68] = "BC4_UNORM";
    FormatTypeFlags[FormatTypeFlags["BC4_SNORM"] = 69] = "BC4_SNORM";
    FormatTypeFlags[FormatTypeFlags["BC5_UNORM"] = 70] = "BC5_UNORM";
    FormatTypeFlags[FormatTypeFlags["BC5_SNORM"] = 71] = "BC5_SNORM";
    // Special-case packed texture formats.
    FormatTypeFlags[FormatTypeFlags["U16_PACKED_5551"] = 97] = "U16_PACKED_5551";
    // Depth/stencil texture formats.
    FormatTypeFlags[FormatTypeFlags["D24"] = 129] = "D24";
    FormatTypeFlags[FormatTypeFlags["D32F"] = 130] = "D32F";
    FormatTypeFlags[FormatTypeFlags["D24S8"] = 131] = "D24S8";
    FormatTypeFlags[FormatTypeFlags["D32FS8"] = 132] = "D32FS8";
})(exports.FormatTypeFlags || (exports.FormatTypeFlags = {}));
exports.FormatCompFlags = void 0;
(function (FormatCompFlags) {
    FormatCompFlags[FormatCompFlags["R"] = 1] = "R";
    FormatCompFlags[FormatCompFlags["RG"] = 2] = "RG";
    FormatCompFlags[FormatCompFlags["RGB"] = 3] = "RGB";
    FormatCompFlags[FormatCompFlags["RGBA"] = 4] = "RGBA";
    FormatCompFlags[FormatCompFlags["A"] = 5] = "A";
})(exports.FormatCompFlags || (exports.FormatCompFlags = {}));
function getFormatCompFlagsComponentCount(n) {
    // The number of components is the flag value. Easy.
    return n;
}
exports.FormatFlags = void 0;
(function (FormatFlags) {
    FormatFlags[FormatFlags["None"] = 0] = "None";
    FormatFlags[FormatFlags["Normalized"] = 1] = "Normalized";
    FormatFlags[FormatFlags["sRGB"] = 2] = "sRGB";
    FormatFlags[FormatFlags["Depth"] = 4] = "Depth";
    FormatFlags[FormatFlags["Stencil"] = 8] = "Stencil";
    FormatFlags[FormatFlags["RenderTarget"] = 16] = "RenderTarget";
})(exports.FormatFlags || (exports.FormatFlags = {}));
function makeFormat(type, comp, flags) {
    return (type << 16) | (comp << 8) | flags;
}
exports.Format = void 0;
(function (Format) {
    Format[Format["ALPHA"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.A, exports.FormatFlags.None)] = "ALPHA";
    Format[Format["F16_R"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "F16_R";
    Format[Format["F16_RG"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = "F16_RG";
    Format[Format["F16_RGB"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = "F16_RGB";
    Format[Format["F16_RGBA"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = "F16_RGBA";
    Format[Format["F32_R"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "F32_R";
    Format[Format["F32_RG"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = "F32_RG";
    Format[Format["F32_RGB"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = "F32_RGB";
    Format[Format["F32_RGBA"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = "F32_RGBA";
    Format[Format["U8_R"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "U8_R";
    Format[Format["U8_R_NORM"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = "U8_R_NORM";
    Format[Format["U8_RG"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = "U8_RG";
    Format[Format["U8_RG_NORM"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = "U8_RG_NORM";
    Format[Format["U8_RGB"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = "U8_RGB";
    Format[Format["U8_RGB_NORM"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.Normalized)] = "U8_RGB_NORM";
    Format[Format["U8_RGB_SRGB"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.sRGB | exports.FormatFlags.Normalized)] = "U8_RGB_SRGB";
    Format[Format["U8_RGBA"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = "U8_RGBA";
    Format[Format["U8_RGBA_NORM"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "U8_RGBA_NORM";
    Format[Format["U8_RGBA_SRGB"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.sRGB | exports.FormatFlags.Normalized)] = "U8_RGBA_SRGB";
    Format[Format["U16_R"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "U16_R";
    Format[Format["U16_R_NORM"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = "U16_R_NORM";
    Format[Format["U16_RG_NORM"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = "U16_RG_NORM";
    Format[Format["U16_RGBA_NORM"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "U16_RGBA_NORM";
    Format[Format["U16_RGB"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = "U16_RGB";
    Format[Format["U32_R"] = makeFormat(exports.FormatTypeFlags.U32, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "U32_R";
    Format[Format["U32_RG"] = makeFormat(exports.FormatTypeFlags.U32, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = "U32_RG";
    Format[Format["S8_R"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "S8_R";
    Format[Format["S8_R_NORM"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = "S8_R_NORM";
    Format[Format["S8_RG_NORM"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = "S8_RG_NORM";
    Format[Format["S8_RGB_NORM"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.RGB, exports.FormatFlags.Normalized)] = "S8_RGB_NORM";
    Format[Format["S8_RGBA_NORM"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "S8_RGBA_NORM";
    Format[Format["S16_R"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "S16_R";
    Format[Format["S16_RG"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = "S16_RG";
    Format[Format["S16_RG_NORM"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = "S16_RG_NORM";
    Format[Format["S16_RGB_NORM"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RGB, exports.FormatFlags.Normalized)] = "S16_RGB_NORM";
    Format[Format["S16_RGBA"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = "S16_RGBA";
    Format[Format["S16_RGBA_NORM"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "S16_RGBA_NORM";
    Format[Format["S32_R"] = makeFormat(exports.FormatTypeFlags.S32, exports.FormatCompFlags.R, exports.FormatFlags.None)] = "S32_R";
    // Packed texture formats.
    Format[Format["U16_RGBA_5551"] = makeFormat(exports.FormatTypeFlags.U16_PACKED_5551, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "U16_RGBA_5551";
    // Compressed
    Format[Format["BC1"] = makeFormat(exports.FormatTypeFlags.BC1, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "BC1";
    Format[Format["BC1_SRGB"] = makeFormat(exports.FormatTypeFlags.BC1, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = "BC1_SRGB";
    Format[Format["BC2"] = makeFormat(exports.FormatTypeFlags.BC2, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "BC2";
    Format[Format["BC2_SRGB"] = makeFormat(exports.FormatTypeFlags.BC2, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = "BC2_SRGB";
    Format[Format["BC3"] = makeFormat(exports.FormatTypeFlags.BC3, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = "BC3";
    Format[Format["BC3_SRGB"] = makeFormat(exports.FormatTypeFlags.BC3, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = "BC3_SRGB";
    Format[Format["BC4_UNORM"] = makeFormat(exports.FormatTypeFlags.BC4_UNORM, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = "BC4_UNORM";
    Format[Format["BC4_SNORM"] = makeFormat(exports.FormatTypeFlags.BC4_SNORM, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = "BC4_SNORM";
    Format[Format["BC5_UNORM"] = makeFormat(exports.FormatTypeFlags.BC5_UNORM, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = "BC5_UNORM";
    Format[Format["BC5_SNORM"] = makeFormat(exports.FormatTypeFlags.BC5_SNORM, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = "BC5_SNORM";
    // Depth/Stencil
    Format[Format["D24"] = makeFormat(exports.FormatTypeFlags.D24, exports.FormatCompFlags.R, exports.FormatFlags.Depth)] = "D24";
    Format[Format["D24_S8"] = makeFormat(exports.FormatTypeFlags.D24S8, exports.FormatCompFlags.RG, exports.FormatFlags.Depth | exports.FormatFlags.Stencil)] = "D24_S8";
    Format[Format["D32F"] = makeFormat(exports.FormatTypeFlags.D32F, exports.FormatCompFlags.R, exports.FormatFlags.Depth)] = "D32F";
    Format[Format["D32F_S8"] = makeFormat(exports.FormatTypeFlags.D32FS8, exports.FormatCompFlags.RG, exports.FormatFlags.Depth | exports.FormatFlags.Stencil)] = "D32F_S8";
    // Special RT formats for preferred backend support.
    Format[Format["U8_RGB_RT"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.RenderTarget | exports.FormatFlags.Normalized)] = "U8_RGB_RT";
    Format[Format["U8_RGBA_RT"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.RenderTarget | exports.FormatFlags.Normalized)] = "U8_RGBA_RT";
    Format[Format["U8_RGBA_RT_SRGB"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.RenderTarget | exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = "U8_RGBA_RT_SRGB";
})(exports.Format || (exports.Format = {}));
function getFormatCompFlags(fmt) {
    return (fmt >>> 8) & 0xff;
}
function getFormatTypeFlags(fmt) {
    return (fmt >>> 16) & 0xff;
}
function getFormatFlags(fmt) {
    return fmt & 0xff;
}
function getFormatTypeFlagsByteSize(typeFlags) {
    switch (typeFlags) {
        case exports.FormatTypeFlags.F32:
        case exports.FormatTypeFlags.U32:
        case exports.FormatTypeFlags.S32:
            return 4;
        case exports.FormatTypeFlags.U16:
        case exports.FormatTypeFlags.S16:
        case exports.FormatTypeFlags.F16:
            return 2;
        case exports.FormatTypeFlags.U8:
        case exports.FormatTypeFlags.S8:
            return 1;
        default:
            throw new Error('whoops');
    }
}
/**
 * Gets the byte size for an individual component.
 * e.g. for F32_RGB, this will return "4", since F32 has 4 bytes.
 */
function getFormatCompByteSize(fmt) {
    return getFormatTypeFlagsByteSize(getFormatTypeFlags(fmt));
}
function getFormatComponentCount(fmt) {
    return getFormatCompFlagsComponentCount(getFormatCompFlags(fmt));
}
function getFormatByteSize(fmt) {
    var typeByteSize = getFormatTypeFlagsByteSize(getFormatTypeFlags(fmt));
    var componentCount = getFormatCompFlagsComponentCount(getFormatCompFlags(fmt));
    return typeByteSize * componentCount;
}
function setFormatFlags(fmt, flags) {
    return (fmt & 0xffffff00) | flags;
}
function setFormatComponentCount(fmt, compFlags) {
    return (fmt & 0xffff00ff) | (compFlags << 8);
}
function getFormatSamplerKind(fmt) {
    var flags = getFormatFlags(fmt);
    if (flags & exports.FormatFlags.Depth) {
        return exports.SamplerFormatKind.Depth;
    }
    if (flags & exports.FormatFlags.Normalized) {
        return exports.SamplerFormatKind.Float;
    }
    var typeFlags = getFormatTypeFlags(fmt);
    if (typeFlags === exports.FormatTypeFlags.F16 || typeFlags === exports.FormatTypeFlags.F32) {
        return exports.SamplerFormatKind.Float;
    }
    else if (typeFlags === exports.FormatTypeFlags.U8 ||
        typeFlags === exports.FormatTypeFlags.U16 ||
        typeFlags === exports.FormatTypeFlags.U32) {
        return exports.SamplerFormatKind.Uint;
    }
    else if (typeFlags === exports.FormatTypeFlags.S8 ||
        typeFlags === exports.FormatTypeFlags.S16 ||
        typeFlags === exports.FormatTypeFlags.S32) {
        return exports.SamplerFormatKind.Sint;
    }
    else {
        throw new Error('whoops');
    }
}

function assert(b, message) {
    if (message === void 0) { message = ''; }
    if (!b) {
        console.error(new Error().stack);
        throw new Error("Assert fail: ".concat(message));
    }
}
function assertExists(v) {
    if (v !== undefined && v !== null)
        return v;
    else
        throw new Error('Missing object');
}

function colorEqual(c0, c1) {
    return c0.r === c1.r && c0.g === c1.g && c0.b === c1.b && c0.a === c1.a;
}
function colorCopy(dst, src) {
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = src.a;
}
function colorNewCopy(src) {
    var r = src.r, g = src.g, b = src.b, a = src.a;
    return { r: r, g: g, b: b, a: a };
}
function colorNewFromRGBA(r, g, b, a) {
    if (a === void 0) { a = 1.0; }
    return { r: r, g: g, b: b, a: a };
}
var TransparentBlack = colorNewFromRGBA(0, 0, 0, 0);
var OpaqueBlack = colorNewFromRGBA(0, 0, 0, 1);
var TransparentWhite = colorNewFromRGBA(1, 1, 1, 0);
var OpaqueWhite = colorNewFromRGBA(1, 1, 1, 1);

/**
 * @see https://forum.babylonjs.com/t/reverse-depth-buffer-z-buffer/6905/2
 */
var IsDepthReversed = true;
function reverseDepthForPerspectiveProjectionMatrix(m, isDepthReversed) {
    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }
    if (isDepthReversed) {
        m[10] = -m[10];
        m[14] = -m[14];
    }
}
function reverseDepthForOrthographicProjectionMatrix(m, isDepthReversed) {
    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }
    if (isDepthReversed) {
        m[10] = -m[10];
        m[14] = -m[14] + 1;
    }
}
function reverseDepthForCompareMode(compareMode, isDepthReversed) {
    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }
    if (isDepthReversed) {
        switch (compareMode) {
            case exports.CompareMode.Less:
                return exports.CompareMode.Greater;
            case exports.CompareMode.LessEqual:
                return exports.CompareMode.GreaterEqual;
            case exports.CompareMode.GreaterEqual:
                return exports.CompareMode.LessEqual;
            case exports.CompareMode.Greater:
                return exports.CompareMode.Less;
            default:
                return compareMode;
        }
    }
    else {
        return compareMode;
    }
}
function reverseDepthForClearValue(n, isDepthReversed) {
    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }
    if (isDepthReversed) {
        return 1.0 - n;
    }
    else {
        return n;
    }
}
function reverseDepthForDepthOffset(n, isDepthReversed) {
    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }
    if (isDepthReversed) {
        return -n;
    }
    else {
        return n;
    }
}
function compareDepthValues(a, b, op, isDepthReversed) {
    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }
    op = reverseDepthForCompareMode(op, isDepthReversed);
    if (op === exports.CompareMode.Less)
        return a < b;
    else if (op === exports.CompareMode.LessEqual)
        return a <= b;
    else if (op === exports.CompareMode.Greater)
        return a > b;
    else if (op === exports.CompareMode.GreaterEqual)
        return a >= b;
    else
        throw new Error('whoops');
}

// import { reverseDepthForCompareMode } from './depth';
function isPowerOfTwo(n) {
    return n && (n & (n - 1)) === 0;
}
function fallbackUndefined(v, fallback) {
    return v !== null && v !== undefined ? v : fallback;
}
function nullify(v) {
    return v === undefined ? null : v;
}
function fillArray(L, n, v) {
    L.length = n;
    L.fill(v);
}
function align(n, multiple) {
    var mask = multiple - 1;
    return (n + mask) & ~mask;
}
function alignNonPowerOfTwo(n, multiple) {
    return (((n + multiple - 1) / multiple) | 0) * multiple;
}
// @see https://github.com/d3/d3-array#bisectRight
function bisectRight(L, e, compare) {
    var lo = 0, hi = L.length;
    while (lo < hi) {
        var mid = lo + ((hi - lo) >>> 1);
        var cmp = compare(e, L[mid]);
        if (cmp < 0)
            hi = mid;
        else
            lo = mid + 1;
    }
    return lo;
}
function spliceBisectRight(L, e, compare) {
    var idx = bisectRight(L, e, compare);
    L.splice(idx, 0, e);
}
function setBitFlagEnabled(v, mask, enabled) {
    if (enabled)
        v |= mask;
    else
        v &= ~mask;
    return v;
}
function nArray(n, c) {
    var d = new Array(n);
    for (var i = 0; i < n; i++)
        d[i] = c();
    return d;
}
function prependLineNo(str, lineStart) {
    if (lineStart === void 0) { lineStart = 1; }
    var lines = str.split('\n');
    return lines
        .map(function (s, i) { return "".concat(leftPad('' + (lineStart + i), 4, ' '), "  ").concat(s); })
        .join('\n');
}
function leftPad(S, spaces, ch) {
    if (ch === void 0) { ch = '0'; }
    while (S.length < spaces)
        S = "".concat(ch).concat(S);
    return S;
}
function range(start, count) {
    var L = [];
    for (var i = start; i < start + count; i++)
        L.push(i);
    return L;
}
function copyChannelBlendState(dst, src) {
    dst.blendDstFactor = src.blendDstFactor;
    dst.blendSrcFactor = src.blendSrcFactor;
    dst.blendMode = src.blendMode;
}
function copyAttachmentState(dst, src) {
    if (dst === undefined) {
        dst = {
            rgbBlendState: {},
            alphaBlendState: {},
            channelWriteMask: 0,
        };
    }
    copyChannelBlendState(dst.rgbBlendState, src.rgbBlendState);
    copyChannelBlendState(dst.alphaBlendState, src.alphaBlendState);
    dst.channelWriteMask = src.channelWriteMask;
    return dst;
}
function copyAttachmentsState(dst, src) {
    if (dst.length !== src.length)
        dst.length = src.length;
    for (var i = 0; i < src.length; i++)
        dst[i] = copyAttachmentState(dst[i], src[i]);
}
function setMegaStateFlags(dst, src) {
    if (src.attachmentsState !== undefined) {
        copyAttachmentsState(dst.attachmentsState, src.attachmentsState);
    }
    if (src.blendConstant !== undefined) {
        colorCopy(dst.blendConstant, src.blendConstant);
    }
    dst.depthCompare = fallbackUndefined(src.depthCompare, dst.depthCompare);
    dst.depthWrite = fallbackUndefined(src.depthWrite, dst.depthWrite);
    dst.stencilCompare = fallbackUndefined(src.stencilCompare, dst.stencilCompare);
    dst.stencilWrite = fallbackUndefined(src.stencilWrite, dst.stencilWrite);
    dst.stencilPassOp = fallbackUndefined(src.stencilPassOp, dst.stencilPassOp);
    dst.stencilRef = fallbackUndefined(src.stencilRef, dst.stencilRef);
    dst.cullMode = fallbackUndefined(src.cullMode, dst.cullMode);
    dst.frontFace = fallbackUndefined(src.frontFace, dst.frontFace);
    dst.polygonOffset = fallbackUndefined(src.polygonOffset, dst.polygonOffset);
}
function copyMegaState(src) {
    var dst = Object.assign({}, src);
    // Copy fields that need copying.
    dst.attachmentsState = [];
    copyAttachmentsState(dst.attachmentsState, src.attachmentsState);
    dst.blendConstant = colorNewCopy(dst.blendConstant);
    return dst;
}
function copyAttachmentStateFromSimple(dst, src) {
    if (src.channelWriteMask !== undefined) {
        dst.channelWriteMask = src.channelWriteMask;
    }
    if (src.rgbBlendMode !== undefined) {
        dst.rgbBlendState.blendMode = src.rgbBlendMode;
    }
    if (src.alphaBlendMode !== undefined) {
        dst.alphaBlendState.blendMode = src.alphaBlendMode;
    }
    if (src.rgbBlendSrcFactor !== undefined) {
        dst.rgbBlendState.blendSrcFactor = src.rgbBlendSrcFactor;
    }
    if (src.alphaBlendSrcFactor !== undefined) {
        dst.alphaBlendState.blendSrcFactor = src.alphaBlendSrcFactor;
    }
    if (src.rgbBlendDstFactor !== undefined) {
        dst.rgbBlendState.blendDstFactor = src.rgbBlendDstFactor;
    }
    if (src.alphaBlendDstFactor !== undefined) {
        dst.alphaBlendState.blendDstFactor = src.alphaBlendDstFactor;
    }
}
var defaultBlendState = {
    blendMode: exports.BlendMode.Add,
    blendSrcFactor: exports.BlendFactor.One,
    blendDstFactor: exports.BlendFactor.Zero,
};
var defaultMegaState = {
    attachmentsState: [
        {
            channelWriteMask: exports.ChannelWriteMask.RGB,
            rgbBlendState: defaultBlendState,
            alphaBlendState: defaultBlendState,
        },
    ],
    blendConstant: colorNewCopy(TransparentBlack),
    depthWrite: true,
    depthCompare: exports.CompareMode.LessEqual,
    // depthCompare: reverseDepthForCompareMode(CompareMode.LessEqual),
    // stencilCompare: CompareMode.Never,
    stencilCompare: exports.CompareMode.Always,
    stencilWrite: false,
    stencilPassOp: exports.StencilOp.Keep,
    stencilRef: 0,
    cullMode: exports.CullMode.None,
    frontFace: exports.FrontFaceMode.CCW,
    polygonOffset: false,
};
function makeMegaState(other, src) {
    if (other === void 0) { other = null; }
    if (src === void 0) { src = defaultMegaState; }
    var dst = copyMegaState(src);
    if (other !== null)
        setMegaStateFlags(dst, other);
    return dst;
}
var fullscreenMegaState = makeMegaState({ depthCompare: exports.CompareMode.Always, depthWrite: false }, defaultMegaState);
function setAttachmentStateSimple(dst, simple) {
    if (dst.attachmentsState === undefined) {
        dst.attachmentsState = [];
        copyAttachmentsState(dst.attachmentsState, defaultMegaState.attachmentsState);
    }
    copyAttachmentStateFromSimple(dst.attachmentsState[0], simple);
    return dst;
}
var defaultBindingLayoutSamplerDescriptor = {
    formatKind: exports.SamplerFormatKind.Float,
    dimension: exports.TextureDimension.n2D,
};

function arrayEqual(a, b, e) {
    if (a.length !== b.length)
        return false;
    for (var i = 0; i < a.length; i++)
        if (!e(a[i], b[i]))
            return false;
    return true;
}
function arrayCopy(a, copyFunc) {
    var b = Array(a.length);
    for (var i = 0; i < a.length; i++)
        b[i] = copyFunc(a[i]);
    return b;
}
function bufferBindingEquals(a, b) {
    return a.buffer === b.buffer && a.wordCount === b.wordCount;
}
function bindingLayoutSamplerDescriptorEqual(a, b) {
    return a.dimension === b.dimension && a.formatKind === b.formatKind;
}
function samplerBindingEquals(a, b) {
    if (a === null)
        return b === null;
    if (b === null)
        return false;
    return a.sampler === b.sampler && a.texture === b.texture;
}
function bindingLayoutDescriptorEqual(a, b) {
    if (a.numSamplers !== b.numSamplers)
        return false;
    if (a.numUniformBuffers !== b.numUniformBuffers)
        return false;
    if ((a.samplerEntries === undefined) !== (b.samplerEntries === undefined))
        return false;
    if (a.samplerEntries !== undefined &&
        !arrayEqual(a.samplerEntries, b.samplerEntries, bindingLayoutSamplerDescriptorEqual))
        return false;
    return true;
}
function bindingsDescriptorEquals(a, b) {
    if (a.samplerBindings.length !== b.samplerBindings.length)
        return false;
    if (!arrayEqual(a.samplerBindings, b.samplerBindings, samplerBindingEquals))
        return false;
    if (!arrayEqual(a.uniformBufferBindings, b.uniformBufferBindings, bufferBindingEquals))
        return false;
    if (!bindingLayoutEquals(a.bindingLayout, b.bindingLayout))
        return false;
    return true;
}
function channelBlendStateEquals(a, b) {
    return (a.blendMode == b.blendMode &&
        a.blendSrcFactor === b.blendSrcFactor &&
        a.blendDstFactor === b.blendDstFactor);
}
function attachmentStateEquals(a, b) {
    if (!channelBlendStateEquals(a.rgbBlendState, b.rgbBlendState))
        return false;
    if (!channelBlendStateEquals(a.alphaBlendState, b.alphaBlendState))
        return false;
    if (a.channelWriteMask !== b.channelWriteMask)
        return false;
    return true;
}
function megaStateDescriptorEquals(a, b) {
    if (!arrayEqual(a.attachmentsState, b.attachmentsState, attachmentStateEquals))
        return false;
    if (!colorEqual(a.blendConstant, b.blendConstant))
        return false;
    return (a.depthCompare === b.depthCompare &&
        a.depthWrite === b.depthWrite &&
        a.stencilCompare === b.stencilCompare &&
        a.stencilWrite === b.stencilWrite &&
        a.stencilPassOp === b.stencilPassOp &&
        a.stencilRef === b.stencilRef &&
        a.cullMode === b.cullMode &&
        a.frontFace === b.frontFace &&
        a.polygonOffset === b.polygonOffset);
}
function bindingLayoutEquals(a, b) {
    return (a.numSamplers === b.numSamplers &&
        a.numUniformBuffers === b.numUniformBuffers);
}
function programEquals(a, b) {
    return a.id === b.id;
}
function formatEquals(a, b) {
    return a === b;
}
function renderPipelineDescriptorEquals(a, b) {
    if (a.topology !== b.topology)
        return false;
    if (a.inputLayout !== b.inputLayout)
        return false;
    if (a.sampleCount !== b.sampleCount)
        return false;
    if (!megaStateDescriptorEquals(a.megaStateDescriptor, b.megaStateDescriptor))
        return false;
    if (!programEquals(a.program, b.program))
        return false;
    if (!arrayEqual(a.bindingLayouts, b.bindingLayouts, bindingLayoutEquals))
        return false;
    if (!arrayEqual(a.colorAttachmentFormats, b.colorAttachmentFormats, formatEquals))
        return false;
    if (a.depthStencilAttachmentFormat !== b.depthStencilAttachmentFormat)
        return false;
    return true;
}
function vertexAttributeDescriptorEquals(a, b) {
    return (a.bufferIndex === b.bufferIndex &&
        a.bufferByteOffset === b.bufferByteOffset &&
        a.location === b.location &&
        a.format === b.format &&
        a.divisor === b.divisor);
}
function inputLayoutBufferDescriptorEquals(a, b) {
    if (util.isNil(a))
        return util.isNil(b);
    if (util.isNil(b))
        return false;
    return a.byteStride === b.byteStride && a.frequency === b.frequency;
}
function inputLayoutDescriptorEquals(a, b) {
    if (a.indexBufferFormat !== b.indexBufferFormat)
        return false;
    if (!arrayEqual(a.vertexBufferDescriptors, b.vertexBufferDescriptors, inputLayoutBufferDescriptorEquals))
        return false;
    if (!arrayEqual(a.vertexAttributeDescriptors, b.vertexAttributeDescriptors, vertexAttributeDescriptorEquals))
        return false;
    return true;
}
function samplerDescriptorEquals(a, b) {
    return (a.wrapS === b.wrapS &&
        a.wrapT === b.wrapT &&
        a.minFilter === b.minFilter &&
        a.magFilter === b.magFilter &&
        a.mipFilter === b.mipFilter &&
        a.minLOD === b.minLOD &&
        a.maxLOD === b.maxLOD &&
        a.maxAnisotropy === b.maxAnisotropy &&
        a.compareMode === b.compareMode);
}
function samplerBindingCopy(a) {
    var sampler = a.sampler;
    var texture = a.texture;
    var lateBinding = a.lateBinding;
    return { sampler: sampler, texture: texture, lateBinding: lateBinding };
}
function samplerBindingNew() {
    return { sampler: null, texture: null, lateBinding: null };
}
function bufferBindingCopy(a) {
    var buffer = a.buffer;
    var wordCount = a.wordCount;
    return { buffer: buffer, wordCount: wordCount };
}
function bindingsDescriptorCopy(a) {
    var bindingLayout = a.bindingLayout;
    var samplerBindings = arrayCopy(a.samplerBindings, samplerBindingCopy);
    var uniformBufferBindings = arrayCopy(a.uniformBufferBindings, bufferBindingCopy);
    return {
        bindingLayout: bindingLayout,
        samplerBindings: samplerBindings,
        uniformBufferBindings: uniformBufferBindings,
        pipeline: a.pipeline,
    };
}
function bindingLayoutSamplerDescriptorCopy(a) {
    var dimension = a.dimension, formatKind = a.formatKind;
    return { dimension: dimension, formatKind: formatKind };
}
function bindingLayoutDescriptorCopy(a) {
    var numSamplers = a.numSamplers;
    var numUniformBuffers = a.numUniformBuffers;
    var samplerEntries = a.samplerEntries !== undefined
        ? arrayCopy(a.samplerEntries, bindingLayoutSamplerDescriptorCopy)
        : undefined;
    return { numSamplers: numSamplers, numUniformBuffers: numUniformBuffers, samplerEntries: samplerEntries };
}
function renderPipelineDescriptorCopy(a) {
    var bindingLayouts = arrayCopy(a.bindingLayouts, bindingLayoutDescriptorCopy);
    var inputLayout = a.inputLayout;
    var program = a.program;
    var topology = a.topology;
    var megaStateDescriptor = copyMegaState(a.megaStateDescriptor);
    var colorAttachmentFormats = a.colorAttachmentFormats.slice();
    var depthStencilAttachmentFormat = a.depthStencilAttachmentFormat;
    var sampleCount = a.sampleCount;
    return {
        bindingLayouts: bindingLayouts,
        inputLayout: inputLayout,
        megaStateDescriptor: megaStateDescriptor,
        program: program,
        topology: topology,
        colorAttachmentFormats: colorAttachmentFormats,
        depthStencilAttachmentFormat: depthStencilAttachmentFormat,
        sampleCount: sampleCount,
    };
}
function vertexAttributeDescriptorCopy(a) {
    var location = a.location;
    var format = a.format;
    var bufferIndex = a.bufferIndex;
    var bufferByteOffset = a.bufferByteOffset;
    var byteStride = a.byteStride;
    var divisor = a.divisor;
    return {
        location: location,
        format: format,
        bufferIndex: bufferIndex,
        bufferByteOffset: bufferByteOffset,
        byteStride: byteStride,
        divisor: divisor,
    };
}
function inputLayoutBufferDescriptorCopy(a) {
    if (!util.isNil(a)) {
        var byteStride = a.byteStride;
        var frequency = a.frequency;
        return { byteStride: byteStride, frequency: frequency };
    }
    else {
        return a;
    }
}
function inputLayoutDescriptorCopy(a) {
    var vertexAttributeDescriptors = arrayCopy(a.vertexAttributeDescriptors, vertexAttributeDescriptorCopy);
    var vertexBufferDescriptors = arrayCopy(a.vertexBufferDescriptors, inputLayoutBufferDescriptorCopy);
    var indexBufferFormat = a.indexBufferFormat;
    return {
        vertexAttributeDescriptors: vertexAttributeDescriptors,
        vertexBufferDescriptors: vertexBufferDescriptors,
        indexBufferFormat: indexBufferFormat,
    };
}

exports.Endianness = void 0;
(function (Endianness) {
    Endianness[Endianness["LITTLE_ENDIAN"] = 0] = "LITTLE_ENDIAN";
    Endianness[Endianness["BIG_ENDIAN"] = 1] = "BIG_ENDIAN";
})(exports.Endianness || (exports.Endianness = {}));
var test = new Uint16Array([0xfeff]);
var testView = new DataView(test.buffer);
var systemEndianness = testView.getUint8(0) == 0xff ? exports.Endianness.LITTLE_ENDIAN : exports.Endianness.BIG_ENDIAN;
function getSystemEndianness() {
    return systemEndianness;
}

var _a;
// if array name then clean the array brackets
var UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
function parseUniformName(name) {
    // Shortcut to avoid redundant or bad matches
    if (name[name.length - 1] !== ']') {
        return {
            name: name,
            length: 1,
            isArray: false,
        };
    }
    var matches = name.match(UNIFORM_NAME_REGEXP);
    if (!matches || matches.length < 2) {
        throw new Error("Failed to parse GLSL uniform name ".concat(name));
    }
    return {
        name: matches[1],
        length: Number(matches[2]) || 1,
        isArray: Boolean(matches[2]),
    };
}
function getSamplerSetter() {
    var cache = null;
    return function (gl, location, value) {
        var update = cache !== value;
        if (update) {
            gl.uniform1i(location, value);
            cache = value;
        }
        return update;
    };
}
function getArraySetter(functionName, toArray, size, uniformSetter) {
    var cache = null;
    var cacheLength = null;
    return function (gl, location, value) {
        var arrayValue = toArray(value, size);
        var length = arrayValue.length;
        var update = false;
        if (cache === null) {
            cache = new Float32Array(length);
            cacheLength = length;
            update = true;
        }
        else {
            assert(cacheLength === length, 'Uniform length cannot change.');
            for (var i = 0; i < length; ++i) {
                if (arrayValue[i] !== cache[i]) {
                    update = true;
                    break;
                }
            }
        }
        if (update) {
            uniformSetter(gl, functionName, location, arrayValue);
            cache.set(arrayValue);
        }
        return update;
    };
}
function setVectorUniform(gl, functionName, location, value) {
    gl[functionName](location, value);
}
function setMatrixUniform(gl, functionName, location, value) {
    gl[functionName](location, false, value);
}
var FLOAT_ARRAY = {};
var INT_ARRAY = {};
var UINT_ARRAY = {};
var array1 = [0];
function toTypedArray(value, uniformLength, Type, cache) {
    // convert boolean uniforms to Number
    if (uniformLength === 1 && typeof value === 'boolean') {
        value = value ? 1 : 0;
    }
    if (Number.isFinite(value)) {
        array1[0] = value;
        value = array1;
    }
    var length = value.length;
    if (value instanceof Type) {
        return value;
    }
    var result = cache[length];
    if (!result) {
        result = new Type(length);
        cache[length] = result;
    }
    for (var i = 0; i < length; i++) {
        result[i] = value[i];
    }
    return result;
}
function toFloatArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}
function toIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}
function toUIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}
var UNIFORM_SETTERS = (_a = {},
    // WEBGL1
    _a[exports.GL.FLOAT] = getArraySetter.bind(null, 'uniform1fv', toFloatArray, 1, setVectorUniform),
    _a[exports.GL.FLOAT_VEC2] = getArraySetter.bind(null, 'uniform2fv', toFloatArray, 2, setVectorUniform),
    _a[exports.GL.FLOAT_VEC3] = getArraySetter.bind(null, 'uniform3fv', toFloatArray, 3, setVectorUniform),
    _a[exports.GL.FLOAT_VEC4] = getArraySetter.bind(null, 'uniform4fv', toFloatArray, 4, setVectorUniform),
    _a[exports.GL.INT] = getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
    _a[exports.GL.INT_VEC2] = getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
    _a[exports.GL.INT_VEC3] = getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
    _a[exports.GL.INT_VEC4] = getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
    _a[exports.GL.BOOL] = getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
    _a[exports.GL.BOOL_VEC2] = getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
    _a[exports.GL.BOOL_VEC3] = getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
    _a[exports.GL.BOOL_VEC4] = getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
    // uniformMatrix(false): don't transpose the matrix
    _a[exports.GL.FLOAT_MAT2] = getArraySetter.bind(null, 'uniformMatrix2fv', toFloatArray, 4, setMatrixUniform),
    _a[exports.GL.FLOAT_MAT3] = getArraySetter.bind(null, 'uniformMatrix3fv', toFloatArray, 9, setMatrixUniform),
    _a[exports.GL.FLOAT_MAT4] = getArraySetter.bind(null, 'uniformMatrix4fv', toFloatArray, 16, setMatrixUniform),
    // WEBGL2 - unsigned integers, irregular matrices, additional texture samplers
    _a[exports.GL.UNSIGNED_INT] = getArraySetter.bind(null, 'uniform1uiv', toUIntArray, 1, setVectorUniform),
    _a[exports.GL.UNSIGNED_INT_VEC2] = getArraySetter.bind(null, 'uniform2uiv', toUIntArray, 2, setVectorUniform),
    _a[exports.GL.UNSIGNED_INT_VEC3] = getArraySetter.bind(null, 'uniform3uiv', toUIntArray, 3, setVectorUniform),
    _a[exports.GL.UNSIGNED_INT_VEC4] = getArraySetter.bind(null, 'uniform4uiv', toUIntArray, 4, setVectorUniform),
    // uniformMatrix(false): don't transpose the matrix
    _a[exports.GL.FLOAT_MAT2x3] = getArraySetter.bind(null, 'uniformMatrix2x3fv', toFloatArray, 6, setMatrixUniform),
    _a[exports.GL.FLOAT_MAT2x4] = getArraySetter.bind(null, 'uniformMatrix2x4fv', toFloatArray, 8, setMatrixUniform),
    _a[exports.GL.FLOAT_MAT3x2] = getArraySetter.bind(null, 'uniformMatrix3x2fv', toFloatArray, 6, setMatrixUniform),
    _a[exports.GL.FLOAT_MAT3x4] = getArraySetter.bind(null, 'uniformMatrix3x4fv', toFloatArray, 12, setMatrixUniform),
    _a[exports.GL.FLOAT_MAT4x2] = getArraySetter.bind(null, 'uniformMatrix4x2fv', toFloatArray, 8, setMatrixUniform),
    _a[exports.GL.FLOAT_MAT4x3] = getArraySetter.bind(null, 'uniformMatrix4x3fv', toFloatArray, 12, setMatrixUniform),
    _a[exports.GL.SAMPLER_2D] = getSamplerSetter,
    _a[exports.GL.SAMPLER_CUBE] = getSamplerSetter,
    _a[exports.GL.SAMPLER_3D] = getSamplerSetter,
    _a[exports.GL.SAMPLER_2D_SHADOW] = getSamplerSetter,
    _a[exports.GL.SAMPLER_2D_ARRAY] = getSamplerSetter,
    _a[exports.GL.SAMPLER_2D_ARRAY_SHADOW] = getSamplerSetter,
    _a[exports.GL.SAMPLER_CUBE_SHADOW] = getSamplerSetter,
    _a[exports.GL.INT_SAMPLER_2D] = getSamplerSetter,
    _a[exports.GL.INT_SAMPLER_3D] = getSamplerSetter,
    _a[exports.GL.INT_SAMPLER_CUBE] = getSamplerSetter,
    _a[exports.GL.INT_SAMPLER_2D_ARRAY] = getSamplerSetter,
    _a[exports.GL.UNSIGNED_INT_SAMPLER_2D] = getSamplerSetter,
    _a[exports.GL.UNSIGNED_INT_SAMPLER_3D] = getSamplerSetter,
    _a[exports.GL.UNSIGNED_INT_SAMPLER_CUBE] = getSamplerSetter,
    _a[exports.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = getSamplerSetter,
    _a);
function getUniformSetter(gl, location, info) {
    var setter = UNIFORM_SETTERS[info.type];
    if (!setter) {
        throw new Error("Unknown GLSL uniform type ".concat(info.type));
    }
    return setter().bind(null, gl, location);
}

var ES100_REPLACEMENTS = [
    // In GLSL 1.00 ES these functions are provided by an extension
    [/\btexture(2D|2DProj|Cube)Lod\(/g, 'texture$1LodEXT('],
    // Overloads in GLSL 3.00 map to individual functions. Note that we cannot
    // differentiate 2D,2DProj,Cube without type analysis so we choose the most common variant.
    [/\btexture\(/g, 'texture2D('],
    [/\btextureLod\(/g, 'texture2DLodEXT('],
];
function defineStr(k, v) {
    return "#define ".concat(k, " ").concat(v);
}
function getDefines(shader) {
    var defines = {};
    shader.replace(/^\s*#define\s*(\S*)\s*(\S*)\s*$/gm, function (_, name, value) {
        var v = Number(value);
        defines[name] = isNaN(v) ? value : v;
        return '';
    });
    return defines;
}
function getAttributeLocations(vert, defines) {
    var locations = [];
    vert.replace(/^\s*layout\(location\s*=\s*(\S*)\)\s*in\s+\S+\s*(.*);$/gm, function (_, location, name) {
        var l = Number(location);
        locations.push({ location: isNaN(l) ? defines[location] : l, name: name });
        return '';
    });
    return locations;
}
function getUniforms(vert) {
    var uniformNames = [];
    var structs = [];
    vert.replace(/\s*struct\s*(.*)\s*{((?:\s*.*\s*)*?)};/g, function (_, type, uniformStr) {
        var uniforms = [];
        uniformStr
            .trim()
            .split('\n')
            .forEach(function (line) {
            var _a = tslib.__read(line.trim().split(/\s+/), 2), type = _a[0], name = _a[1];
            uniforms.push({
                type: type.trim(),
                name: name.replace(';', '').trim(),
            });
        });
        structs.push({
            type: type.trim(),
            uniforms: uniforms,
        });
        return '';
    });
    vert.replace(/\s*uniform\s*.*\s*{((?:\s*.*\s*)*?)};/g, function (_, uniforms) {
        uniforms
            .trim()
            .split('\n')
            .forEach(function (line) {
            var result = line.trim().split(' ');
            var type = result[0] || '';
            var name = result[1] || '';
            // DirectionalLight directionalLights[  NUM_DIR_LIGHTS ];
            var isArray = name.indexOf('[') > -1;
            name = name.replace(';', '').replace('[', '').trim();
            // ignore conditional comments
            if (type.startsWith('#')) {
                return;
            }
            // account for structs
            if (type) {
                var struct = structs.find(function (struct) { return type === struct.type; });
                if (struct) {
                    if (isArray) {
                        var _loop_1 = function (i) {
                            struct.uniforms.forEach(function (uniform) {
                                uniformNames.push("".concat(name, "[").concat(i, "].").concat(uniform.name));
                            });
                        };
                        for (var i = 0; i < 5; i++) {
                            _loop_1(i);
                        }
                    }
                    else {
                        struct.uniforms.forEach(function (uniform) {
                            uniformNames.push("".concat(name, ".").concat(uniform.name));
                        });
                    }
                }
            }
            if (name) {
                uniformNames.push(name);
            }
        });
        return '';
    });
    return uniformNames;
}
function preprocessShader_GLSL(vendorInfo, type, source, defines, features) {
    var e_1, _a;
    if (defines === void 0) { defines = null; }
    var isGLSL100 = vendorInfo.glslVersion === '#version 100';
    // const supportMRT = vendorInfo.supportMRT && !!features.MRT;
    var supportMRT = false;
    var lines = source
        .split('\n')
        .map(function (n) {
        // Remove comments.
        return n.replace(/[/][/].*$/, '');
    })
        .filter(function (n) {
        // Filter whitespace.
        var isEmpty = !n || /^\s+$/.test(n);
        return !isEmpty;
    });
    // #define KEY VAR
    var definesString = '';
    if (defines !== null)
        definesString = Object.keys(defines)
            .map(function (key) { return defineStr(key, defines[key]); })
            .join('\n');
    var precision = lines.find(function (line) { return line.startsWith('precision'); }) ||
        'precision mediump float;';
    var rest = lines.filter(function (line) { return !line.startsWith('precision'); }).join('\n');
    var extraDefines = '';
    if (vendorInfo.viewportOrigin === exports.ViewportOrigin.UpperLeft) {
        extraDefines += "".concat(defineStr("VIEWPORT_ORIGIN_TL", "1"), "\n");
    }
    if (vendorInfo.clipSpaceNearZ === exports.ClipSpaceNearZ.Zero) {
        extraDefines += "".concat(defineStr("CLIPSPACE_NEAR_ZERO", "1"), "\n");
    }
    if (vendorInfo.explicitBindingLocations) {
        var set_1 = 0, binding_1 = 0, location_1 = 0;
        rest = rest.replace(/^(layout\((.*)\))?\s*uniform(.+{)$/gm, function (substr, cap, layout, rest) {
            var layout2 = layout ? "".concat(layout, ", ") : "";
            return "layout(".concat(layout2, "set = ").concat(set_1, ", binding = ").concat(binding_1++, ") uniform ").concat(rest);
        });
        // XXX(jstpierre): WebGPU now binds UBOs and textures in different sets as a porting hack, hrm...
        set_1++;
        binding_1 = 0;
        assert(vendorInfo.separateSamplerTextures);
        rest = rest.replace(/uniform sampler2D (.*);/g, function (substr, samplerName) {
            // Can't have samplers in vertex for some reason.
            return type === 'frag'
                ? "\nlayout(set = ".concat(set_1, ", binding = ").concat(binding_1++, ") uniform texture2D T_").concat(samplerName, ";\nlayout(set = ").concat(set_1, ", binding = ").concat(binding_1++, ") uniform sampler S_").concat(samplerName, ";\n")
                : '';
        });
        rest = rest.replace(type === 'frag' ? /^\s*\b\s*(varying|in)\b/gm : /^\s*\b(varying|out)\b/gm, function (substr, tok) {
            return "layout(location = ".concat(location_1++, ") ").concat(tok);
        });
        extraDefines += "".concat(defineStr("gl_VertexID", "gl_VertexIndex"), "\n");
    }
    if (vendorInfo.separateSamplerTextures) {
        rest = rest.replace(/\bPD_SAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return "texture2D T_P_".concat(samplerName, ", sampler S_P_").concat(samplerName);
        });
        rest = rest.replace(/\bPU_SAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return "SAMPLER_2D(P_".concat(samplerName, ")");
        });
        rest = rest.replace(/\bPP_SAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return "T_".concat(samplerName, ", S_").concat(samplerName);
        });
        rest = rest.replace(/\bSAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return "sampler2D(T_".concat(samplerName, ", S_").concat(samplerName, ")");
        });
    }
    else {
        rest = rest.replace(/\bPD_SAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return "sampler2D P_".concat(samplerName);
        });
        rest = rest.replace(/\bPU_SAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return "SAMPLER_2D(P_".concat(samplerName, ")");
        });
        rest = rest.replace(/\bPP_SAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return samplerName;
        });
        rest = rest.replace(/\bSAMPLER_2D\((.*?)\)/g, function (substr, samplerName) {
            return samplerName;
        });
    }
    // using #define means we can't use `const in/out` in params
    //   ${isGLSL100 && type === 'vert' ? '#define in attribute\n#define out varying' : ''}
    // ${isGLSL100 && type === 'frag' ? '#define in varying' : ''}
    // headless-gl will throw the following error if we prepend `#version 100`:
    // #version directive must occur before anything else, except for comments and white space
    var concat = "".concat(isGLSL100 ? '' : vendorInfo.glslVersion, "\n").concat(isGLSL100 && supportMRT ? '#extension GL_EXT_draw_buffers : require' : '', "\n").concat(isGLSL100 && type === 'frag'
        ? '#extension GL_OES_standard_derivatives : enable'
        : '', "\n").concat(precision, "\n").concat(extraDefines, "\n").concat(definesString, "\n").concat(rest, "\n").trim();
    // out vec4 outputColor; -> layout(location = 0) out vec4 outputColor;
    if (vendorInfo.explicitBindingLocations && type === 'frag') {
        concat = concat.replace(/^\b(out)\b/gm, function (substr, tok) {
            return "layout(location = 0) ".concat(tok);
        });
    }
    // GLSL 300 -> 100
    // @see https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html
    if (isGLSL100) {
        // in -> varying
        if (type === 'frag') {
            concat = concat.replace(/^\s*in\s+(\S+)\s*(.*);$/gm, function (_, dataType, name) {
                return "varying ".concat(dataType, " ").concat(name, ";\n");
            });
        }
        if (type === 'vert') {
            // out -> varying
            concat = concat.replace(/^\s*out\s+(\S+)\s*(.*);$/gm, function (_, dataType, name) {
                return "varying ".concat(dataType, " ").concat(name, ";\n");
            });
            // in -> attribute
            concat = concat.replace(
            // /^\s*layout\(location\s*=\s*\d*\)\s*in\s*(.*)\s*(.*);$/gm,
            /^\s*layout\(location\s*=\s*\S*\)\s*in\s+(\S+)\s*(.*);$/gm, function (_, dataType, name) {
                return "attribute ".concat(dataType, " ").concat(name, ";\n");
            });
        }
        // interface blocks supported in GLSL ES 3.00 and above only
        concat = concat.replace(/\s*uniform\s*.*\s*{((?:\s*.*\s*)*?)};/g, function (substr, uniforms) {
            return uniforms.trim().replace(/^.*$/gm, function (uniform) {
                // eg. #ifdef
                var trimmed = uniform.trim();
                if (trimmed.startsWith('#')) {
                    return trimmed;
                }
                return uniform ? "uniform ".concat(trimmed) : '';
            });
        });
        if (type === 'frag') {
            var glFragColor_1;
            concat = concat.replace(/^\s*out\s+(\S+)\s*(.*);$/gm, function (_, dataType, name) {
                glFragColor_1 = name;
                return "".concat(dataType, " ").concat(name, ";\n");
            });
            var lastIndexOfMain = concat.lastIndexOf('}');
            concat =
                concat.substring(0, lastIndexOfMain) +
                    "\n  gl_FragColor = vec4(".concat(glFragColor_1, ");\n") +
                    concat.substring(lastIndexOfMain);
        }
        // MRT
        // if (supportMRT) {
        //   if (type === 'frag') {
        //     const gBuffers = [];
        //     concat = concat.replace(
        //       /^\s*layout\(location\s*=\s*\d*\)\s*out\s+vec4\s*(.*);$/gm,
        //       (_, buffer) => {
        //         gBuffers.push(buffer);
        //         return `vec4 ${buffer};\n`;
        //       },
        //     );
        //     const lastIndexOfMain = concat.lastIndexOf('}');
        //     concat =
        //       concat.substring(0, lastIndexOfMain) +
        //       `
        // ${gBuffers
        //   .map(
        //     (gBuffer, i) => `gl_FragData[${i}] = ${gBuffer};
        // `,
        //   )
        //   .join('\n')}` +
        //       concat.substring(lastIndexOfMain);
        //   }
        // }
        // remove layout(location = 0)
        concat = concat.replace(/^\s*layout\((.*)\)/gm, '');
        try {
            // replace texture with texture2D
            for (var ES100_REPLACEMENTS_1 = tslib.__values(ES100_REPLACEMENTS), ES100_REPLACEMENTS_1_1 = ES100_REPLACEMENTS_1.next(); !ES100_REPLACEMENTS_1_1.done; ES100_REPLACEMENTS_1_1 = ES100_REPLACEMENTS_1.next()) {
                var _b = tslib.__read(ES100_REPLACEMENTS_1_1.value, 2), pattern = _b[0], replacement = _b[1];
                concat = concat.replace(pattern, replacement);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ES100_REPLACEMENTS_1_1 && !ES100_REPLACEMENTS_1_1.done && (_a = ES100_REPLACEMENTS_1.return)) _a.call(ES100_REPLACEMENTS_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return concat;
}
function preprocessProgram_GLSL(vendorInfo, vert, frag, defines, features) {
    if (defines === void 0) { defines = null; }
    var preprocessedVert = preprocessShader_GLSL(vendorInfo, 'vert', vert, defines);
    var preprocessedFrag = preprocessShader_GLSL(vendorInfo, 'frag', frag, defines);
    return { vert: vert, frag: frag, preprocessedVert: preprocessedVert, preprocessedFrag: preprocessedFrag };
}
function preprocessProgramObj_GLSL(device, obj) {
    var defines = obj.defines !== undefined ? obj.defines : null;
    obj.features !== undefined ? obj.features : null;
    var vert = obj.both !== undefined ? obj.both + obj.vert : obj.vert;
    var frag = obj.both !== undefined ? obj.both + obj.frag : obj.frag;
    return preprocessProgram_GLSL(device.queryVendorInfo(), vert, frag, defines);
}

var DeviceProgram = /** @class */ (function () {
    function DeviceProgram() {
        this.name = '(unnamed)';
        // Compiled program.
        this.preprocessedVert = '';
        this.preprocessedFrag = '';
        // Inputs.
        this.both = '';
        this.vert = '';
        this.frag = '';
        this.defines = {};
        this.features = {
            MRT: true,
        };
    }
    DeviceProgram.prototype.definesChanged = function () {
        this.preprocessedVert = '';
        this.preprocessedFrag = '';
    };
    DeviceProgram.prototype.setDefineString = function (name, v) {
        if (v !== null) {
            if (this.defines[name] === v)
                return false;
            this.defines[name] = v;
        }
        else {
            if (util.isNil(this.defines[name]))
                return false;
            delete this.defines[name];
        }
        this.definesChanged();
        return true;
    };
    DeviceProgram.prototype.setDefineBool = function (name, v) {
        return this.setDefineString(name, v ? '1' : null);
    };
    DeviceProgram.prototype.getDefineString = function (name) {
        return nullify(this.defines[name]);
    };
    DeviceProgram.prototype.getDefineBool = function (name) {
        var str = this.getDefineString(name);
        if (str !== null)
            assert(str === '1');
        return str !== null;
    };
    DeviceProgram.prototype.ensurePreprocessed = function (vendorInfo) {
        if (this.preprocessedVert === '') {
            this.preprocessedVert = preprocessShader_GLSL(vendorInfo, 'vert', this.both + this.vert, this.defines, this.features);
            this.preprocessedFrag = preprocessShader_GLSL(vendorInfo, 'frag', this.both + this.frag, this.defines, this.features);
        }
    };
    return DeviceProgram;
}());

// This is a very basic linear allocator. We allocate offsets in-order.
var DynamicUniformBuffer = /** @class */ (function () {
    function DynamicUniformBuffer(device) {
        /**
         * Word count, 4 bytes per word
         */
        this.currentBufferWordSize = -1;
        this.currentWordOffset = 0;
        this.buffer = null;
        this.shadowBufferF32 = null;
        this.shadowBufferU8 = null;
        this.device = device;
        var limits = device.queryLimits();
        this.uniformBufferWordAlignment = limits.uniformBufferWordAlignment;
        this.uniformBufferMaxPageWordSize = limits.uniformBufferMaxPageWordSize;
    }
    DynamicUniformBuffer.prototype.isSupportedUBO = function () {
        // UBO not supported in WebGL1
        return this.device.queryVendorInfo().platformString !== 'WebGL1';
    };
    DynamicUniformBuffer.prototype.findPageIndex = function (wordOffset) {
        return (wordOffset / this.uniformBufferMaxPageWordSize) | 0;
    };
    DynamicUniformBuffer.prototype.allocateChunk = function (wordCount) {
        wordCount = alignNonPowerOfTwo(wordCount, this.uniformBufferWordAlignment);
        assert(wordCount < this.uniformBufferMaxPageWordSize);
        var wordOffset = this.currentWordOffset;
        // If we straddle the page, then put it at the start of the next one.
        if (this.findPageIndex(wordOffset) !==
            this.findPageIndex(wordOffset + wordCount - 1))
            wordOffset = alignNonPowerOfTwo(wordOffset, this.uniformBufferMaxPageWordSize);
        this.currentWordOffset = wordOffset + wordCount;
        this.ensureShadowBuffer(wordOffset, wordCount);
        return wordOffset;
    };
    DynamicUniformBuffer.prototype.ensureShadowBuffer = function (wordOffset, wordCount) {
        if (this.shadowBufferU8 === null || this.shadowBufferF32 === null) {
            var newWordCount = alignNonPowerOfTwo(this.currentWordOffset, this.uniformBufferMaxPageWordSize);
            this.shadowBufferU8 = new Uint8Array(newWordCount * 4);
            this.shadowBufferF32 = new Float32Array(this.shadowBufferU8.buffer);
        }
        else if (wordOffset + wordCount >= this.shadowBufferF32.length) {
            assert(wordOffset < this.currentWordOffset &&
                wordOffset + wordCount <= this.currentWordOffset);
            // Grow logarithmically, aligned to page size.
            var newWordCount = alignNonPowerOfTwo(Math.max(this.currentWordOffset, this.shadowBufferF32.length * 2), this.uniformBufferMaxPageWordSize);
            var newBuffer = new Uint8Array(newWordCount * 4);
            newBuffer.set(this.shadowBufferU8, 0);
            this.shadowBufferU8 = newBuffer;
            this.shadowBufferF32 = new Float32Array(this.shadowBufferU8.buffer);
            if (!(this.currentWordOffset <= newWordCount))
                throw new Error("Assert fail: this.currentWordOffset [".concat(this.currentWordOffset, "] <= newWordCount [").concat(newWordCount, "]"));
        }
    };
    /**
     * Return the CPU data buffer used internally. Fill this in to submit data to the CPU. Write to
     * it with the offset that was returned from {@see allocateChunk}.
     */
    DynamicUniformBuffer.prototype.mapBufferF32 = function () {
        return assertExists(this.shadowBufferF32);
    };
    DynamicUniformBuffer.prototype.prepareToRender = function () {
        if (this.shadowBufferF32 === null) {
            return;
        }
        var shadowBufferF32 = assertExists(this.shadowBufferF32);
        if (shadowBufferF32.length !== this.currentBufferWordSize) {
            this.currentBufferWordSize = shadowBufferF32.length;
            if (this.buffer !== null) {
                this.buffer.destroy();
            }
            this.buffer = this.device.createBuffer({
                // in bytes length
                viewOrSize: this.currentBufferWordSize * 4,
                usage: exports.BufferUsage.UNIFORM,
                hint: exports.BufferFrequencyHint.Dynamic,
            });
        }
        var wordCount = alignNonPowerOfTwo(this.currentWordOffset, this.uniformBufferMaxPageWordSize);
        if (!(wordCount <= this.currentBufferWordSize))
            throw new Error("Assert fail: wordCount [".concat(wordCount, "] (").concat(this.currentWordOffset, " aligned ").concat(this.uniformBufferMaxPageWordSize, ") <= this.currentBufferWordSize [").concat(this.currentBufferWordSize, "]"));
        if (this.isSupportedUBO()) {
            var buffer = assertExists(this.buffer);
            buffer.setSubData(0, this.shadowBufferU8, 0, wordCount * 4);
        }
        // Reset the offset for next frame.
        this.currentWordOffset = 0;
    };
    DynamicUniformBuffer.prototype.destroy = function () {
        if (this.buffer !== null)
            this.buffer.destroy();
        this.shadowBufferF32 = null;
        this.shadowBufferU8 = null;
    };
    return DynamicUniformBuffer;
}());

// Jenkins One-at-a-Time hash from http://www.burtleburtle.net/bob/hash/doobs.html
function hashCodeNumberUpdate(hash, v) {
    hash += v;
    hash += hash << 10;
    hash += hash >>> 6;
    return hash >>> 0;
}
function hashCodeNumberFinish(hash) {
    hash += hash << 3;
    hash ^= hash >>> 11;
    hash += hash << 15;
    return hash >>> 0;
}
// Pass this as a hash function to use a one-bucket HashMap (equivalent to linear search in an array),
// which can be efficient for small numbers of items.
function nullHashFunc(k) {
    return 0;
}
var HashBucket = /** @class */ (function () {
    function HashBucket() {
        this.keys = [];
        this.values = [];
    }
    return HashBucket;
}());
var HashMap = /** @class */ (function () {
    function HashMap(keyEqualFunc, keyHashFunc) {
        this.keyEqualFunc = keyEqualFunc;
        this.keyHashFunc = keyHashFunc;
        this.buckets = new Map();
    }
    HashMap.prototype.findBucketIndex = function (bucket, k) {
        for (var i = 0; i < bucket.keys.length; i++)
            if (this.keyEqualFunc(k, bucket.keys[i]))
                return i;
        return -1;
    };
    HashMap.prototype.findBucket = function (k) {
        var bw = this.keyHashFunc(k);
        return this.buckets.get(bw);
    };
    HashMap.prototype.get = function (k) {
        var bucket = this.findBucket(k);
        if (bucket === undefined)
            return null;
        var bi = this.findBucketIndex(bucket, k);
        if (bi < 0)
            return null;
        return bucket.values[bi];
    };
    HashMap.prototype.add = function (k, v) {
        var bw = this.keyHashFunc(k);
        if (this.buckets.get(bw) === undefined)
            this.buckets.set(bw, new HashBucket());
        var bucket = this.buckets.get(bw);
        bucket.keys.push(k);
        bucket.values.push(v);
    };
    HashMap.prototype.delete = function (k) {
        var bucket = this.findBucket(k);
        if (bucket === undefined)
            return;
        var bi = this.findBucketIndex(bucket, k);
        if (bi === -1)
            return;
        bucket.keys.splice(bi, 1);
        bucket.values.splice(bi, 1);
    };
    HashMap.prototype.clear = function () {
        this.buckets.clear();
    };
    HashMap.prototype.size = function () {
        var e_1, _a;
        var acc = 0;
        try {
            for (var _b = tslib.__values(this.buckets.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var bucket = _c.value;
                acc += bucket.values.length;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return acc;
    };
    HashMap.prototype.values = function () {
        var _a, _b, bucket, j, e_2_1;
        var e_2, _c;
        return tslib.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _d.trys.push([0, 7, 8, 9]);
                    _a = tslib.__values(this.buckets.values()), _b = _a.next();
                    _d.label = 1;
                case 1:
                    if (!!_b.done) return [3 /*break*/, 6];
                    bucket = _b.value;
                    j = bucket.values.length - 1;
                    _d.label = 2;
                case 2:
                    if (!(j >= 0)) return [3 /*break*/, 5];
                    return [4 /*yield*/, bucket.values[j]];
                case 3:
                    _d.sent();
                    _d.label = 4;
                case 4:
                    j--;
                    return [3 /*break*/, 2];
                case 5:
                    _b = _a.next();
                    return [3 /*break*/, 1];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_2_1 = _d.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_2) throw e_2.error; }
                    return [7 /*endfinally*/];
                case 9: return [2 /*return*/];
            }
        });
    };
    return HashMap;
}());

function programDescriptorSimpleEquals(a, b) {
    assert(a.preprocessedVert !== '' && b.preprocessedVert !== '');
    assert(a.preprocessedFrag !== '' && b.preprocessedFrag !== '');
    return (a.preprocessedVert === b.preprocessedVert &&
        a.preprocessedFrag === b.preprocessedFrag);
}
function programDescriptorSimpleCopy(a) {
    var preprocessedVert = a.preprocessedVert;
    var preprocessedFrag = a.preprocessedFrag;
    var vert = a.vert;
    var frag = a.frag;
    return { preprocessedVert: preprocessedVert, preprocessedFrag: preprocessedFrag, vert: vert, frag: frag };
}
function renderBindingLayoutHash(hash, a) {
    hash = hashCodeNumberUpdate(hash, a.numUniformBuffers);
    hash = hashCodeNumberUpdate(hash, a.numSamplers);
    return hash;
}
function blendStateHash(hash, a) {
    hash = hashCodeNumberUpdate(hash, a.blendMode);
    hash = hashCodeNumberUpdate(hash, a.blendSrcFactor);
    hash = hashCodeNumberUpdate(hash, a.blendDstFactor);
    return hash;
}
function attachmentStateHash(hash, a) {
    hash = blendStateHash(hash, a.rgbBlendState);
    hash = blendStateHash(hash, a.alphaBlendState);
    hash = hashCodeNumberUpdate(hash, a.channelWriteMask);
    return hash;
}
function colorHash(hash, a) {
    hash = hashCodeNumberUpdate(hash, (a.r << 24) | (a.g << 16) | (a.b << 8) | a.a);
    return hash;
}
function megaStateDescriptorHash(hash, a) {
    for (var i = 0; i < a.attachmentsState.length; i++)
        hash = attachmentStateHash(hash, a.attachmentsState[i]);
    hash = colorHash(hash, a.blendConstant);
    hash = hashCodeNumberUpdate(hash, a.depthCompare);
    hash = hashCodeNumberUpdate(hash, a.depthWrite ? 1 : 0);
    hash = hashCodeNumberUpdate(hash, a.stencilCompare);
    hash = hashCodeNumberUpdate(hash, a.stencilPassOp);
    hash = hashCodeNumberUpdate(hash, a.stencilWrite ? 1 : 0);
    hash = hashCodeNumberUpdate(hash, a.cullMode);
    hash = hashCodeNumberUpdate(hash, a.frontFace ? 1 : 0);
    hash = hashCodeNumberUpdate(hash, a.polygonOffset ? 1 : 0);
    return hash;
}
function renderPipelineDescriptorHash(a) {
    var hash = 0;
    hash = hashCodeNumberUpdate(hash, a.program.id);
    if (a.inputLayout !== null)
        hash = hashCodeNumberUpdate(hash, a.inputLayout.id);
    for (var i = 0; i < a.bindingLayouts.length; i++)
        hash = renderBindingLayoutHash(hash, a.bindingLayouts[i]);
    hash = megaStateDescriptorHash(hash, a.megaStateDescriptor);
    for (var i = 0; i < a.colorAttachmentFormats.length; i++)
        hash = hashCodeNumberUpdate(hash, a.colorAttachmentFormats[i] || 0);
    hash = hashCodeNumberUpdate(hash, a.depthStencilAttachmentFormat || 0);
    return hashCodeNumberFinish(hash);
}
function bindingsDescriptorHash(a) {
    var hash = 0;
    for (var i = 0; i < a.samplerBindings.length; i++) {
        var binding = a.samplerBindings[i];
        if (binding !== null && binding.texture !== null)
            hash = hashCodeNumberUpdate(hash, binding.texture.id);
    }
    for (var i = 0; i < a.uniformBufferBindings.length; i++) {
        var binding = a.uniformBufferBindings[i];
        if (binding !== null && binding.buffer !== null) {
            hash = hashCodeNumberUpdate(hash, binding.buffer.id);
            hash = hashCodeNumberUpdate(hash, binding.wordCount);
        }
    }
    return hashCodeNumberFinish(hash);
}
var RenderCache = /** @class */ (function () {
    function RenderCache(device) {
        this.bindingsCache = new HashMap(bindingsDescriptorEquals, bindingsDescriptorHash);
        this.renderPipelinesCache = new HashMap(renderPipelineDescriptorEquals, renderPipelineDescriptorHash);
        this.inputLayoutsCache = new HashMap(inputLayoutDescriptorEquals, nullHashFunc);
        this.programCache = new HashMap(programDescriptorSimpleEquals, nullHashFunc);
        this.samplerCache = new HashMap(samplerDescriptorEquals, nullHashFunc);
        this.device = device;
    }
    RenderCache.prototype.createBindings = function (descriptor) {
        var bindings = this.bindingsCache.get(descriptor);
        if (bindings === null) {
            var descriptorCopy = bindingsDescriptorCopy(descriptor);
            bindings = this.device.createBindings(descriptorCopy);
            this.bindingsCache.add(descriptorCopy, bindings);
        }
        return bindings;
    };
    RenderCache.prototype.createRenderPipeline = function (descriptor) {
        var renderPipeline = this.renderPipelinesCache.get(descriptor);
        if (renderPipeline === null) {
            var descriptorCopy = renderPipelineDescriptorCopy(descriptor);
            renderPipeline = this.device.createRenderPipeline(descriptorCopy);
            this.renderPipelinesCache.add(descriptorCopy, renderPipeline);
        }
        return renderPipeline;
    };
    RenderCache.prototype.createInputLayout = function (descriptor) {
        var inputLayout = this.inputLayoutsCache.get(descriptor);
        if (inputLayout === null) {
            var descriptorCopy = inputLayoutDescriptorCopy(descriptor);
            inputLayout = this.device.createInputLayout(descriptorCopy);
            this.inputLayoutsCache.add(descriptorCopy, inputLayout);
        }
        return inputLayout;
    };
    RenderCache.prototype.createProgramSimple = function (programDescriptorSimple) {
        var program = this.programCache.get(programDescriptorSimple);
        if (program === null) {
            var descriptorCopy = programDescriptorSimpleCopy(programDescriptorSimple);
            program = this.device.createProgramSimple(descriptorCopy);
            this.programCache.add(descriptorCopy, program);
        }
        return program;
    };
    RenderCache.prototype.createProgram = function (programDescriptor) {
        programDescriptor.ensurePreprocessed(this.device.queryVendorInfo());
        return this.createProgramSimple(programDescriptor);
    };
    RenderCache.prototype.createSampler = function (descriptor) {
        var sampler = this.samplerCache.get(descriptor);
        if (sampler === null) {
            sampler = this.device.createSampler(descriptor);
            this.samplerCache.add(descriptor, sampler);
        }
        return sampler;
    };
    RenderCache.prototype.destroy = function () {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;
        try {
            for (var _f = tslib.__values(this.bindingsCache.values()), _g = _f.next(); !_g.done; _g = _f.next()) {
                var bindings = _g.value;
                bindings.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _h = tslib.__values(this.renderPipelinesCache.values()), _j = _h.next(); !_j.done; _j = _h.next()) {
                var renderPipeline = _j.value;
                renderPipeline.destroy();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var _k = tslib.__values(this.inputLayoutsCache.values()), _l = _k.next(); !_l.done; _l = _k.next()) {
                var inputLayout = _l.value;
                inputLayout.destroy();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var _m = tslib.__values(this.programCache.values()), _o = _m.next(); !_o.done; _o = _m.next()) {
                var program = _o.value;
                program.destroy();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
            }
            finally { if (e_4) throw e_4.error; }
        }
        try {
            for (var _p = tslib.__values(this.samplerCache.values()), _q = _p.next(); !_q.done; _q = _p.next()) {
                var sampler = _q.value;
                sampler.destroy();
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
            }
            finally { if (e_5) throw e_5.error; }
        }
        this.bindingsCache.clear();
        this.renderPipelinesCache.clear();
        this.inputLayoutsCache.clear();
        this.programCache.clear();
        this.samplerCache.clear();
    };
    return RenderCache;
}());

exports.ToneMapping = void 0;
(function (ToneMapping) {
    ToneMapping["NONE"] = "none";
    ToneMapping["LINEAR"] = "LinearToneMapping";
    ToneMapping["REINHARD"] = "ReinhardToneMapping";
    ToneMapping["CINEON"] = "OptimizedCineonToneMapping";
    ToneMapping["ACES_FILMIC"] = "ACESFilmicToneMapping";
    ToneMapping["CUSTOM"] = "CustomToneMapping";
})(exports.ToneMapping || (exports.ToneMapping = {}));

exports.RGAttachmentSlot = void 0;
(function (RGAttachmentSlot) {
    RGAttachmentSlot[RGAttachmentSlot["Color0"] = 0] = "Color0";
    RGAttachmentSlot[RGAttachmentSlot["Color1"] = 1] = "Color1";
    RGAttachmentSlot[RGAttachmentSlot["Color2"] = 2] = "Color2";
    RGAttachmentSlot[RGAttachmentSlot["Color3"] = 3] = "Color3";
    RGAttachmentSlot[RGAttachmentSlot["ColorMax"] = 3] = "ColorMax";
    RGAttachmentSlot[RGAttachmentSlot["DepthStencil"] = 4] = "DepthStencil";
})(exports.RGAttachmentSlot || (exports.RGAttachmentSlot = {}));

var RenderGraphPass = /** @class */ (function () {
    function RenderGraphPass() {
        // RenderTargetAttachmentSlot => renderTargetID
        this.renderTargetIDs = [];
        this.renderTargetLevels = [];
        // RenderTargetAttachmentSlot => resolveTextureID
        this.resolveTextureOutputIDs = [];
        // RenderTargetAttachmentSlot => Texture
        this.resolveTextureOutputExternalTextures = [];
        this.resolveTextureOutputExternalTextureLevel = [];
        // List of resolveTextureIDs that we have a reference to.
        this.resolveTextureInputIDs = [];
        // RGAttachmentSlot => refcount.
        this.renderTargetExtraRefs = [];
        this.resolveTextureInputTextures = [];
        this.renderTargets = [];
        // Execution state computed by scheduling.
        this.descriptor = {
            colorAttachment: [],
            colorAttachmentLevel: [],
            colorResolveTo: [],
            colorResolveToLevel: [],
            colorStore: [],
            depthStencilAttachment: null,
            depthStencilResolveTo: null,
            depthStencilStore: true,
            colorClearColor: ['load'],
            depthClearValue: 'load',
            stencilClearValue: 'load',
            occlusionQueryPool: null,
        };
        this.viewportX = 0;
        this.viewportY = 0;
        this.viewportW = 1;
        this.viewportH = 1;
        // Execution callback from user.
        this.execFunc = null;
        this.postFunc = null;
        this.debugThumbnails = [];
    }
    RenderGraphPass.prototype.setDebugName = function (debugName) {
        this.debugName = debugName;
    };
    RenderGraphPass.prototype.pushDebugThumbnail = function (attachmentSlot) {
        this.debugThumbnails[attachmentSlot] = true;
    };
    RenderGraphPass.prototype.setViewport = function (x, y, w, h) {
        this.viewportX = x;
        this.viewportY = y;
        this.viewportW = w;
        this.viewportH = h;
    };
    RenderGraphPass.prototype.attachRenderTargetID = function (attachmentSlot, renderTargetID, level) {
        if (level === void 0) { level = 0; }
        assert(this.renderTargetIDs[attachmentSlot] === undefined);
        this.renderTargetIDs[attachmentSlot] = renderTargetID;
        this.renderTargetLevels[attachmentSlot] = level;
    };
    RenderGraphPass.prototype.attachResolveTexture = function (resolveTextureID) {
        this.resolveTextureInputIDs.push(resolveTextureID);
    };
    RenderGraphPass.prototype.attachOcclusionQueryPool = function (queryPool) {
        this.descriptor.occlusionQueryPool = queryPool;
    };
    RenderGraphPass.prototype.resolveToExternalTexture = function (attachmentSlot, texture) {
        this.resolveTextureOutputExternalTextures[attachmentSlot] = texture;
    };
    RenderGraphPass.prototype.exec = function (func) {
        assert(this.execFunc === null);
        this.execFunc = func;
    };
    RenderGraphPass.prototype.post = function (func) {
        assert(this.postFunc === null);
        this.postFunc = func;
    };
    RenderGraphPass.prototype.addExtraRef = function (slot) {
        this.renderTargetExtraRefs[slot] = true;
    };
    return RenderGraphPass;
}());

var RGRenderTarget = /** @class */ (function () {
    function RGRenderTarget(device, desc) {
        this.dimension = exports.TextureDimension.n2D;
        this.depth = 1;
        this.numLevels = 1;
        this.width = 0;
        this.height = 0;
        this.sampleCount = 0;
        this.usage = exports.TextureUsage.RenderTarget;
        this.immutable = true;
        this.needsClear = true;
        this.texture = null;
        this.age = 0;
        this.pixelFormat = desc.pixelFormat;
        this.width = desc.width;
        this.height = desc.height;
        this.sampleCount = desc.sampleCount;
        assert(this.sampleCount >= 1);
        if (this.sampleCount > 1) {
            // MSAA render targets must be backed by attachments.
            this.attachment = device.createRenderTarget(this);
        }
        else {
            // Single-sampled textures can be backed by regular textures.
            this.texture = device.createTexture(this);
            this.attachment = device.createRenderTargetFromTexture(this.texture);
        }
    }
    RGRenderTarget.prototype.setDebugName = function (device, debugName) {
        this.debugName = debugName;
        if (this.texture !== null) {
            device.setResourceName(this.texture, this.debugName);
        }
        device.setResourceName(this.attachment, this.debugName);
    };
    RGRenderTarget.prototype.matchesDescription = function (desc) {
        return (this.pixelFormat === desc.pixelFormat &&
            this.width === desc.width &&
            this.height === desc.height &&
            this.sampleCount === desc.sampleCount);
    };
    RGRenderTarget.prototype.reset = function (desc) {
        assert(this.matchesDescription(desc));
        this.age = 0;
    };
    RGRenderTarget.prototype.destroy = function () {
        if (this.texture !== null) {
            this.texture.destroy();
        }
        this.attachment.destroy();
    };
    return RGRenderTarget;
}());

// Whenever we need to resolve a multi-sampled render target to a single-sampled texture,
// we record an extra single-sampled texture here.
var SingleSampledTexture = /** @class */ (function () {
    function SingleSampledTexture(device, desc) {
        this.dimension = exports.TextureDimension.n2D;
        this.depth = 1;
        this.numLevels = 1;
        this.usage = exports.TextureUsage.RenderTarget;
        this.width = 0;
        this.height = 0;
        this.age = 0;
        this.immutable = true;
        this.pixelFormat = desc.pixelFormat;
        this.width = desc.width;
        this.height = desc.height;
        this.texture = device.createTexture(this);
    }
    SingleSampledTexture.prototype.matchesDescription = function (desc) {
        return (this.pixelFormat === desc.pixelFormat &&
            this.width === desc.width &&
            this.height === desc.height);
    };
    SingleSampledTexture.prototype.reset = function (desc) {
        assert(this.matchesDescription(desc));
        this.age = 0;
    };
    SingleSampledTexture.prototype.destroy = function () {
        this.texture.destroy();
    };
    return SingleSampledTexture;
}());

var GraphImpl = /** @class */ (function () {
    function GraphImpl() {
        // [Symbol.species]?: 'RGGraph';
        // Used for determining scheduling.
        this.renderTargetDescriptions = [];
        this.resolveTextureRenderTargetIDs = [];
        this.passes = [];
        // Debugging.
        this.renderTargetDebugNames = [];
    }
    return GraphImpl;
}());
var RenderGraph = /** @class */ (function () {
    function RenderGraph(device) {
        // For scope callbacks.
        this.currentPass = null;
        //#region Resource Creation & Caching
        this.renderTargetDeadPool = [];
        this.singleSampledTextureDeadPool = [];
        //#endregion
        //#region Graph Builder
        this.currentGraph = null;
        //#endregion
        //#region Scheduling
        this.renderTargetOutputCount = [];
        this.renderTargetResolveCount = [];
        this.resolveTextureUseCount = [];
        this.renderTargetAliveForID = [];
        this.singleSampledTextureForResolveTextureID = [];
        this.device = device;
    }
    RenderGraph.prototype.acquireRenderTargetForDescription = function (desc) {
        for (var i = 0; i < this.renderTargetDeadPool.length; i++) {
            var freeRenderTarget = this.renderTargetDeadPool[i];
            if (freeRenderTarget.matchesDescription(desc)) {
                // Pop it off the list.
                freeRenderTarget.reset(desc);
                this.renderTargetDeadPool.splice(i--, 1);
                return freeRenderTarget;
            }
        }
        // Allocate a new render target.
        return new RGRenderTarget(this.device, desc);
    };
    RenderGraph.prototype.acquireSingleSampledTextureForDescription = function (desc) {
        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++) {
            var freeSingleSampledTexture = this.singleSampledTextureDeadPool[i];
            if (freeSingleSampledTexture.matchesDescription(desc)) {
                // Pop it off the list.
                freeSingleSampledTexture.reset(desc);
                this.singleSampledTextureDeadPool.splice(i--, 1);
                return freeSingleSampledTexture;
            }
        }
        // Allocate a new resolve texture.
        return new SingleSampledTexture(this.device, desc);
    };
    RenderGraph.prototype.beginGraphBuilder = function () {
        assert(this.currentGraph === null);
        this.currentGraph = new GraphImpl();
    };
    RenderGraph.prototype.pushPass = function (setupFunc) {
        var pass = new RenderGraphPass();
        setupFunc(pass);
        this.currentGraph.passes.push(pass);
    };
    RenderGraph.prototype.createRenderTargetID = function (desc, debugName) {
        this.currentGraph.renderTargetDebugNames.push(debugName);
        return this.currentGraph.renderTargetDescriptions.push(desc) - 1;
    };
    RenderGraph.prototype.createResolveTextureID = function (renderTargetID) {
        return (this.currentGraph.resolveTextureRenderTargetIDs.push(renderTargetID) - 1);
    };
    /**
     * 查找最靠近输出的一个关联目标 RT 的 RGPass
     */
    RenderGraph.prototype.findMostRecentPassThatAttachedRenderTarget = function (renderTargetID) {
        for (var i = this.currentGraph.passes.length - 1; i >= 0; i--) {
            var pass = this.currentGraph.passes[i];
            if (pass.renderTargetIDs.includes(renderTargetID))
                return pass;
        }
        return null;
    };
    RenderGraph.prototype.resolveRenderTargetPassAttachmentSlot = function (pass, attachmentSlot) {
        var renderPass = pass;
        if (renderPass.resolveTextureOutputIDs[attachmentSlot] === undefined) {
            var renderTargetID = renderPass.renderTargetIDs[attachmentSlot];
            var resolveTextureID = this.createResolveTextureID(renderTargetID);
            renderPass.resolveTextureOutputIDs[attachmentSlot] = resolveTextureID;
        }
        return renderPass.resolveTextureOutputIDs[attachmentSlot];
    };
    RenderGraph.prototype.findPassForResolveRenderTarget = function (renderTargetID) {
        // Find the last pass that rendered to this render target, and resolve it now.
        // If you wanted a previous snapshot copy of it, you should have created a separate,
        // intermediate pass to copy that out. Perhaps we should have a helper for that use case?
        // If there was no pass that wrote to this RT, well there's no point in resolving it, is there?
        var renderPass = assertExists(this.findMostRecentPassThatAttachedRenderTarget(renderTargetID));
        // Check which attachment we're in. This could possibly be explicit from the user, but it's
        // easy enough to find...
        var attachmentSlot = renderPass.renderTargetIDs.indexOf(renderTargetID);
        // Check that the pass isn't resolving its attachment to another texture. Can't do both!
        assert(renderPass.resolveTextureOutputExternalTextures[attachmentSlot] ===
            undefined);
        return renderPass;
    };
    RenderGraph.prototype.resolveRenderTarget = function (renderTargetID) {
        var renderPass = this.findPassForResolveRenderTarget(renderTargetID);
        var attachmentSlot = renderPass.renderTargetIDs.indexOf(renderTargetID);
        return this.resolveRenderTargetPassAttachmentSlot(renderPass, attachmentSlot);
    };
    RenderGraph.prototype.resolveRenderTargetToExternalTexture = function (renderTargetID, texture, level) {
        if (level === void 0) { level = 0; }
        var renderPass = this.findPassForResolveRenderTarget(renderTargetID);
        var attachmentSlot = renderPass.renderTargetIDs.indexOf(renderTargetID);
        // We shouldn't be resolving to a resolve texture ID in this case.
        assert(renderPass.resolveTextureOutputIDs[attachmentSlot] === undefined);
        renderPass.resolveTextureOutputExternalTextures[attachmentSlot] = texture;
        renderPass.resolveTextureOutputExternalTextureLevel[attachmentSlot] = level;
    };
    RenderGraph.prototype.getRenderTargetDescription = function (renderTargetID) {
        return assertExists(this.currentGraph.renderTargetDescriptions[renderTargetID]);
    };
    RenderGraph.prototype.scheduleAddUseCount = function (graph, pass) {
        for (var slot = 0; slot < pass.renderTargetIDs.length; slot++) {
            var renderTargetID = pass.renderTargetIDs[slot];
            if (renderTargetID === undefined)
                continue;
            this.renderTargetOutputCount[renderTargetID]++;
            if (pass.renderTargetExtraRefs[slot])
                this.renderTargetOutputCount[renderTargetID]++;
        }
        for (var i = 0; i < pass.resolveTextureInputIDs.length; i++) {
            var resolveTextureID = pass.resolveTextureInputIDs[i];
            if (resolveTextureID === undefined)
                continue;
            this.resolveTextureUseCount[resolveTextureID]++;
            var renderTargetID = graph.resolveTextureRenderTargetIDs[resolveTextureID];
            this.renderTargetResolveCount[renderTargetID]++;
        }
    };
    RenderGraph.prototype.acquireRenderTargetForID = function (graph, renderTargetID) {
        if (renderTargetID === undefined)
            return null;
        assert(this.renderTargetOutputCount[renderTargetID] > 0);
        if (!this.renderTargetAliveForID[renderTargetID]) {
            var desc = graph.renderTargetDescriptions[renderTargetID];
            var newRenderTarget = this.acquireRenderTargetForDescription(desc);
            newRenderTarget.setDebugName(this.device, graph.renderTargetDebugNames[renderTargetID]);
            this.renderTargetAliveForID[renderTargetID] = newRenderTarget;
        }
        return this.renderTargetAliveForID[renderTargetID];
    };
    RenderGraph.prototype.releaseRenderTargetForID = function (renderTargetID, forOutput) {
        if (renderTargetID === undefined)
            return null;
        var renderTarget = assertExists(this.renderTargetAliveForID[renderTargetID]);
        if (forOutput) {
            assert(this.renderTargetOutputCount[renderTargetID] > 0);
            this.renderTargetOutputCount[renderTargetID]--;
        }
        else {
            assert(this.renderTargetResolveCount[renderTargetID] > 0);
            this.renderTargetResolveCount[renderTargetID]--;
        }
        if (this.renderTargetOutputCount[renderTargetID] === 0 &&
            this.renderTargetResolveCount[renderTargetID] === 0) {
            // This was the last reference to this RT -- steal it from the alive list, and put it back into the pool.
            renderTarget.needsClear = true;
            delete this.renderTargetAliveForID[renderTargetID];
            this.renderTargetDeadPool.push(renderTarget);
        }
        return renderTarget;
    };
    RenderGraph.prototype.acquireResolveTextureInputTextureForID = function (graph, resolveTextureID) {
        var renderTargetID = graph.resolveTextureRenderTargetIDs[resolveTextureID];
        assert(this.resolveTextureUseCount[resolveTextureID] > 0);
        this.resolveTextureUseCount[resolveTextureID]--;
        var renderTarget = assertExists(this.releaseRenderTargetForID(renderTargetID, false));
        if (this.singleSampledTextureForResolveTextureID[resolveTextureID] !==
            undefined) {
            // The resolved texture belonging to this RT is backed by our own single-sampled texture.
            var singleSampledTexture = this.singleSampledTextureForResolveTextureID[resolveTextureID];
            if (this.resolveTextureUseCount[resolveTextureID] === 0) {
                // Release this single-sampled texture back to the pool, if this is the last use of it.
                this.singleSampledTextureDeadPool.push(singleSampledTexture);
            }
            return singleSampledTexture.texture;
        }
        else {
            // The resolved texture belonging to this RT is backed by our render target.
            return assertExists(renderTarget.texture);
        }
    };
    RenderGraph.prototype.determineResolveParam = function (graph, pass, slot) {
        var renderTargetID = pass.renderTargetIDs[slot];
        var resolveTextureOutputID = pass.resolveTextureOutputIDs[slot];
        var externalTexture = pass.resolveTextureOutputExternalTextures[slot];
        // We should have either an output ID or an external texture, not both.
        var hasResolveTextureOutputID = resolveTextureOutputID !== undefined;
        var hasExternalTexture = externalTexture !== undefined;
        assert(!(hasResolveTextureOutputID && hasExternalTexture));
        var resolveTo = null;
        var store = false;
        var level = 0;
        if (this.renderTargetOutputCount[renderTargetID] > 1) {
            // A future pass is going to render to this RT, we need to store the results.
            store = true;
        }
        if (hasResolveTextureOutputID) {
            assert(graph.resolveTextureRenderTargetIDs[resolveTextureOutputID] ===
                renderTargetID);
            assert(this.resolveTextureUseCount[resolveTextureOutputID] > 0);
            assert(this.renderTargetOutputCount[renderTargetID] > 0);
            var renderTarget = assertExists(this.renderTargetAliveForID[renderTargetID]);
            // If we're the last user of this RT, then we don't need to resolve -- the texture itself will be enough.
            // Note that this isn't exactly an exactly correct algorithm. If we have pass A writing to RenderTargetA,
            // pass B resolving RenderTargetA to ResolveTextureA, and pass C writing to RenderTargetA, then we don't
            // strictly need to copy, but in order to determine that at the time of pass A, we'd need a much fancier
            // schedule than just tracking refcounts...
            if (renderTarget.texture !== null &&
                this.renderTargetOutputCount[renderTargetID] === 1) {
                resolveTo = null;
                store = true;
            }
            else {
                if (!this.singleSampledTextureForResolveTextureID[resolveTextureOutputID]) {
                    var desc = assertExists(graph.renderTargetDescriptions[renderTargetID]);
                    this.singleSampledTextureForResolveTextureID[resolveTextureOutputID] =
                        this.acquireSingleSampledTextureForDescription(desc);
                    this.device.setResourceName(this.singleSampledTextureForResolveTextureID[resolveTextureOutputID]
                        .texture, renderTarget.debugName + " (Resolve ".concat(resolveTextureOutputID, ")"));
                }
                resolveTo =
                    this.singleSampledTextureForResolveTextureID[resolveTextureOutputID]
                        .texture;
            }
        }
        else if (hasExternalTexture) {
            resolveTo = externalTexture;
            level = pass.resolveTextureOutputExternalTextureLevel[slot];
        }
        else {
            resolveTo = null;
        }
        return { resolveTo: resolveTo, store: store, level: level };
    };
    RenderGraph.prototype.schedulePass = function (graph, pass) {
        var depthStencilRenderTargetID = pass.renderTargetIDs[exports.RGAttachmentSlot.DepthStencil];
        for (var slot = exports.RGAttachmentSlot.Color0; slot <= exports.RGAttachmentSlot.ColorMax; slot++) {
            var colorRenderTargetID = pass.renderTargetIDs[slot];
            var colorRenderTarget = this.acquireRenderTargetForID(graph, colorRenderTargetID);
            pass.renderTargets[slot] = colorRenderTarget;
            pass.descriptor.colorAttachment[slot] =
                colorRenderTarget !== null ? colorRenderTarget.attachment : null;
            pass.descriptor.colorAttachmentLevel[slot] =
                pass.renderTargetLevels[slot];
            var _a = this.determineResolveParam(graph, pass, slot), resolveTo_1 = _a.resolveTo, store_1 = _a.store, level = _a.level;
            pass.descriptor.colorResolveTo[slot] = resolveTo_1;
            pass.descriptor.colorResolveToLevel[slot] = level;
            pass.descriptor.colorStore[slot] = store_1;
            pass.descriptor.colorClearColor[slot] =
                colorRenderTarget !== null && colorRenderTarget.needsClear
                    ? graph.renderTargetDescriptions[colorRenderTargetID].colorClearColor
                    : 'load';
        }
        var depthStencilRenderTarget = this.acquireRenderTargetForID(graph, depthStencilRenderTargetID);
        pass.renderTargets[exports.RGAttachmentSlot.DepthStencil] =
            depthStencilRenderTarget;
        pass.descriptor.depthStencilAttachment =
            depthStencilRenderTarget !== null
                ? depthStencilRenderTarget.attachment
                : null;
        var _b = this.determineResolveParam(graph, pass, exports.RGAttachmentSlot.DepthStencil), resolveTo = _b.resolveTo, store = _b.store;
        pass.descriptor.depthStencilResolveTo = resolveTo;
        pass.descriptor.depthStencilStore = store;
        pass.descriptor.depthClearValue =
            depthStencilRenderTarget !== null && depthStencilRenderTarget.needsClear
                ? graph.renderTargetDescriptions[depthStencilRenderTargetID]
                    .depthClearValue
                : 'load';
        pass.descriptor.stencilClearValue =
            depthStencilRenderTarget !== null && depthStencilRenderTarget.needsClear
                ? graph.renderTargetDescriptions[depthStencilRenderTargetID]
                    .stencilClearValue
                : 'load';
        var rtWidth = 0;
        var rtHeight = 0;
        var rtSampleCount = 0;
        for (var i = 0; i < pass.renderTargets.length; i++) {
            var renderTarget = pass.renderTargets[i];
            if (!renderTarget)
                continue;
            var width = renderTarget.width >>> pass.renderTargetLevels[i];
            var height = renderTarget.height >>> pass.renderTargetLevels[i];
            if (rtWidth === 0) {
                rtWidth = width;
                rtHeight = height;
                rtSampleCount = renderTarget.sampleCount;
            }
            assert(width === rtWidth);
            assert(height === rtHeight);
            assert(renderTarget.sampleCount === rtSampleCount);
            renderTarget.needsClear = false;
        }
        if (rtWidth > 0 && rtHeight > 0) {
            pass.viewportX *= rtWidth;
            pass.viewportY *= rtHeight;
            pass.viewportW *= rtWidth;
            pass.viewportH *= rtHeight;
        }
        for (var i = 0; i < pass.resolveTextureInputIDs.length; i++) {
            var resolveTextureID = pass.resolveTextureInputIDs[i];
            pass.resolveTextureInputTextures[i] =
                this.acquireResolveTextureInputTextureForID(graph, resolveTextureID);
        }
        for (var i = 0; i < pass.renderTargetIDs.length; i++)
            this.releaseRenderTargetForID(pass.renderTargetIDs[i], true);
        for (var slot = 0; slot < pass.renderTargetExtraRefs.length; slot++)
            if (pass.renderTargetExtraRefs[slot])
                this.releaseRenderTargetForID(pass.renderTargetIDs[slot], true);
    };
    RenderGraph.prototype.scheduleGraph = function (graph) {
        assert(this.renderTargetOutputCount.length === 0);
        assert(this.renderTargetResolveCount.length === 0);
        assert(this.resolveTextureUseCount.length === 0);
        // Go through and increment the age of everything in our dead pools to mark that it's old.
        for (var i = 0; i < this.renderTargetDeadPool.length; i++)
            this.renderTargetDeadPool[i].age++;
        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++)
            this.singleSampledTextureDeadPool[i].age++;
        // Schedule our resources -- first, count up all uses of resources, then hand them out.
        // Initialize our accumulators.
        fillArray(this.renderTargetOutputCount, graph.renderTargetDescriptions.length, 0);
        fillArray(this.renderTargetResolveCount, graph.renderTargetDescriptions.length, 0);
        fillArray(this.resolveTextureUseCount, graph.resolveTextureRenderTargetIDs.length, 0);
        // Count.
        for (var i = 0; i < graph.passes.length; i++)
            this.scheduleAddUseCount(graph, graph.passes[i]);
        // Now hand out resources.
        for (var i = 0; i < graph.passes.length; i++)
            this.schedulePass(graph, graph.passes[i]);
        // Double-check that all resources were handed out.
        for (var i = 0; i < this.renderTargetOutputCount.length; i++)
            assert(this.renderTargetOutputCount[i] === 0);
        for (var i = 0; i < this.renderTargetResolveCount.length; i++)
            assert(this.renderTargetResolveCount[i] === 0);
        for (var i = 0; i < this.resolveTextureUseCount.length; i++)
            assert(this.resolveTextureUseCount[i] === 0);
        for (var i = 0; i < this.renderTargetAliveForID.length; i++)
            assert(this.renderTargetAliveForID[i] === undefined);
        // Now go through and kill anything that's over our age threshold (hasn't been used in a bit)
        var ageThreshold = 1;
        for (var i = 0; i < this.renderTargetDeadPool.length; i++) {
            if (this.renderTargetDeadPool[i].age >= ageThreshold) {
                this.renderTargetDeadPool[i].destroy();
                this.renderTargetDeadPool.splice(i--, 1);
            }
        }
        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++) {
            if (this.singleSampledTextureDeadPool[i].age >= ageThreshold) {
                this.singleSampledTextureDeadPool[i].destroy();
                this.singleSampledTextureDeadPool.splice(i--, 1);
            }
        }
        // Clear out our transient scheduling state.
        this.renderTargetResolveCount.length = 0;
        this.renderTargetOutputCount.length = 0;
        this.resolveTextureUseCount.length = 0;
    };
    //#endregion
    //#region Execution
    RenderGraph.prototype.execPass = function (pass) {
        assert(this.currentPass === null);
        this.currentPass = pass;
        var renderPass = this.device.createRenderPass(pass.descriptor);
        renderPass.beginDebugGroup(pass.debugName);
        renderPass.setViewport(pass.viewportX, pass.viewportY, pass.viewportW, pass.viewportH);
        if (pass.execFunc !== null)
            pass.execFunc(renderPass, this);
        renderPass.endDebugGroup();
        this.device.submitPass(renderPass);
        if (pass.postFunc !== null)
            pass.postFunc(this);
        this.currentPass = null;
    };
    RenderGraph.prototype.execGraph = function (graph) {
        var _this = this;
        this.scheduleGraph(graph);
        this.device.beginFrame();
        graph.passes.forEach(function (pass) {
            _this.execPass(pass);
        });
        this.device.endFrame();
        // Clear our transient scope state.
        this.singleSampledTextureForResolveTextureID.length = 0;
    };
    RenderGraph.prototype.execute = function () {
        var graph = assertExists(this.currentGraph);
        this.execGraph(graph);
        this.currentGraph = null;
    };
    RenderGraph.prototype.getDebug = function () {
        return this;
    };
    //#endregion
    //#region GfxrGraphBuilderDebug
    RenderGraph.prototype.getPasses = function () {
        return this.currentGraph.passes;
    };
    RenderGraph.prototype.getPassDebugThumbnails = function (pass) {
        return pass.debugThumbnails;
    };
    RenderGraph.prototype.getPassRenderTargetID = function (pass, slot) {
        return pass.renderTargetIDs[slot];
    };
    RenderGraph.prototype.getRenderTargetIDDebugName = function (renderTargetID) {
        return this.currentGraph.renderTargetDebugNames[renderTargetID];
    };
    //#endregion
    //#region GfxrPassScope
    RenderGraph.prototype.getResolveTextureForID = function (resolveTextureID) {
        var currentGraphPass = this.currentPass;
        var i = currentGraphPass.resolveTextureInputIDs.indexOf(resolveTextureID);
        assert(i >= 0);
        return assertExists(currentGraphPass.resolveTextureInputTextures[i]);
    };
    RenderGraph.prototype.getRenderTargetAttachment = function (slot) {
        var currentGraphPass = this.currentPass;
        var renderTarget = currentGraphPass.renderTargets[slot];
        if (!renderTarget)
            return null;
        return renderTarget.attachment;
    };
    RenderGraph.prototype.getRenderTargetTexture = function (slot) {
        var currentGraphPass = this.currentPass;
        var renderTarget = currentGraphPass.renderTargets[slot];
        if (!renderTarget)
            return null;
        return renderTarget.texture;
    };
    //#endregion
    RenderGraph.prototype.newGraphBuilder = function () {
        this.beginGraphBuilder();
        return this;
    };
    RenderGraph.prototype.destroy = function () {
        // At the time this is called, we shouldn't have anything alive.
        for (var i = 0; i < this.renderTargetAliveForID.length; i++)
            assert(this.renderTargetAliveForID[i] === undefined);
        for (var i = 0; i < this.singleSampledTextureForResolveTextureID.length; i++)
            assert(this.singleSampledTextureForResolveTextureID[i] === undefined);
        for (var i = 0; i < this.renderTargetDeadPool.length; i++)
            this.renderTargetDeadPool[i].destroy();
        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++)
            this.singleSampledTextureDeadPool[i].destroy();
    };
    return RenderGraph;
}());

// Suggested values for the "layer" of makeSortKey. These are rough groups, and you can define your own
// ordering within the rough groups (e.g. you might use BACKGROUND + 1, or BACKGROUND + 2).
// TRANSLUCENT is meant to be used as a bitflag. It's special as it changes the behavior of the generic sort key
// functions like makeSortKey and setSortKeyDepth.
exports.RendererLayer = void 0;
(function (RendererLayer) {
    RendererLayer[RendererLayer["BACKGROUND"] = 0] = "BACKGROUND";
    RendererLayer[RendererLayer["ALPHA_TEST"] = 16] = "ALPHA_TEST";
    RendererLayer[RendererLayer["OPAQUE"] = 32] = "OPAQUE";
    RendererLayer[RendererLayer["TRANSLUCENT"] = 128] = "TRANSLUCENT";
})(exports.RendererLayer || (exports.RendererLayer = {}));
var MAX_DEPTH = 0x10000;
var DEPTH_BITS = 16;
function makeDepthKey(depth, flipDepth, maxDepth) {
    if (maxDepth === void 0) { maxDepth = MAX_DEPTH; }
    // Input depth here is: 0 is the closest to the camera, positive values are further away. Negative values (behind camera) are clamped to 0.
    // normalizedDepth: 0.0 is closest to camera, 1.0 is farthest from camera.
    // These values are flipped if flipDepth is set.
    var normalizedDepth = util.clamp(depth, 0, maxDepth) / maxDepth;
    if (flipDepth)
        normalizedDepth = 1.0 - normalizedDepth;
    var depthKey = normalizedDepth * ((1 << DEPTH_BITS) - 1);
    return depthKey & 0xffff;
}
// Common sort key kinds.
// Indexed:     TLLLLLLL IIIIIIII IIIIIIII IIIIIIII
// Opaque:      0LLLLLLL PPPPPPPP PPPPPPPP DDDDDDDD
// Translucent: 1LLLLLLL DDDDDDDD DDDDDDDD BBBBBBBB
function getSortKeyLayer(sortKey) {
    return (sortKey >>> 24) & 0xff;
}
function setSortKeyLayer(sortKey, layer) {
    return ((sortKey & 0x00ffffff) | ((layer & 0xff) << 24)) >>> 0;
}
function setSortKeyProgramKey(sortKey, programKey) {
    var isTransparent = !!((sortKey >>> 31) & 1);
    if (isTransparent)
        return sortKey;
    else
        return ((sortKey & 0xff0000ff) | ((programKey & 0xffff) << 8)) >>> 0;
}
function setSortKeyBias(sortKey, bias) {
    var isTransparent = !!((sortKey >>> 31) & 1);
    if (isTransparent)
        return ((sortKey & 0xffffff00) | (bias & 0xff)) >>> 0;
    else
        return sortKey;
}
function makeSortKeyOpaque(layer, programKey) {
    return setSortKeyLayer(setSortKeyProgramKey(0, programKey), layer);
}
function setSortKeyOpaqueDepth(sortKey, depthKey) {
    assert(depthKey >= 0);
    return ((sortKey & 0xffffff00) | ((depthKey >>> 8) & 0xff)) >>> 0;
}
function makeSortKeyTranslucent(layer) {
    return setSortKeyLayer(0, layer);
}
function setSortKeyTranslucentDepth(sortKey, depthKey) {
    assert(depthKey >= 0);
    return ((sortKey & 0xff0000ff) | (depthKey << 8)) >>> 0;
}
function makeSortKey(layer, programKey) {
    if (programKey === void 0) { programKey = 0; }
    if (layer & exports.RendererLayer.TRANSLUCENT)
        return makeSortKeyTranslucent(layer);
    else
        return makeSortKeyOpaque(layer, programKey);
}
function setSortKeyDepthKey(sortKey, depthKey) {
    var isTranslucent = !!((sortKey >>> 31) & 1);
    return isTranslucent
        ? setSortKeyTranslucentDepth(sortKey, depthKey)
        : setSortKeyOpaqueDepth(sortKey, depthKey);
}
function setSortKeyDepth(sortKey, depth, maxDepth) {
    if (maxDepth === void 0) { maxDepth = MAX_DEPTH; }
    var isTranslucent = !!((sortKey >>> 31) & 1);
    var depthKey = makeDepthKey(depth, isTranslucent, maxDepth);
    return isTranslucent
        ? setSortKeyTranslucentDepth(sortKey, depthKey)
        : setSortKeyOpaqueDepth(sortKey, depthKey);
}
function getSortKeyDepth(sortKey) {
    var isTranslucent = !!((sortKey >>> 31) & 1);
    if (isTranslucent)
        return (sortKey >>> 8) & 0xffff;
    else {
        return ((sortKey >>> 8) & 0xfffc) | (sortKey & 0x03);
    }
}

var mtxOpenGLFromD3D = glMatrix.mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, -1, 1);
// Converts a projection matrix from D3D-style Z range [0, 1] to OpenGL-style Z range [-1, 1]
function projectionMatrixOpenGLFromD3D(m) {
    glMatrix.mat4.mul(m, mtxOpenGLFromD3D, m);
}
var mtxD3DFromOpenGL = glMatrix.mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
// Converts a projection matrix from OpenGL-style Z range [-1, 1] to D3D-style Z range [0, 1]
function projectionMatrixD3DFromOpenGL(m) {
    glMatrix.mat4.mul(m, mtxD3DFromOpenGL, m);
}
/**
 * Convert a projection matrix {@param m} between differing clip spaces.
 *
 * There are two kinds of clip-space conventions in active use in graphics APIs, differing in the
 * range of the Z axis: OpenGL (and thus GL ES and WebGL) use a Z range of [-1, 1] which matches
 * the X and Y axis ranges. Direct3D, Vulkan, Metal, and WebGPU all use a Z range of [0, 1], which
 * differs from the X and Y axis ranges, but makes sense from the perspective of a camera: a camera
 * can see to the left and right of it, above and below it, but only in front and not behind it.
 *
 * The [0, 1] convention for Z range also has better characteristics for "reversed depth". Since
 * floating point numbers have higher precision around 0 than around 1. We then get to choose where
 * to put the extra precise bits: close to the near plane, or close to the far plane.
 *
 * With OpenGL's [-1, 1] convention, both -1 and 1 have similar amounts of precision, so we don't
 * get to make the same choice, and our higher precision around 0 is stuck in the middle of the
 * scene, which doesn't particularly help.
 *
 * The gl-matrix library has two different kinds of entry points: {@method mat4.perpsective} will
 * generate a matrix with a [-1, 1] clip space, corresponding to {@see ClipSpaceNearZ.NegativeOne},
 * but {@method mat4.perspectiveZO} will generate a matrix with a [0, 1] clip space, corresponding
 * to {@see ClipSpaceNearZ.Zero}.
 *
 * This function does nothing if {@param dst} and {@param src} are the same.
 */
function projectionMatrixConvertClipSpaceNearZ(m, dst, src) {
    if (dst === src)
        return;
    if (dst === exports.ClipSpaceNearZ.NegativeOne)
        projectionMatrixOpenGLFromD3D(m);
    else if (dst === exports.ClipSpaceNearZ.Zero)
        projectionMatrixD3DFromOpenGL(m);
}

function fillVec3v(d, offs, v, v3) {
    if (v3 === void 0) { v3 = 0; }
    d[offs + 0] = v[0];
    d[offs + 1] = v[1];
    d[offs + 2] = v[2];
    d[offs + 3] = v3;
    return 4;
}
function fillVec4(d, offs, v0, v1, v2, v3) {
    if (v1 === void 0) { v1 = 0; }
    if (v2 === void 0) { v2 = 0; }
    if (v3 === void 0) { v3 = 0; }
    d[offs + 0] = v0;
    d[offs + 1] = v1;
    d[offs + 2] = v2;
    d[offs + 3] = v3;
    return 4;
}
function fillVec4v(d, offs, v) {
    d[offs + 0] = v[0];
    d[offs + 1] = v[1];
    d[offs + 2] = v[2];
    d[offs + 3] = v[3];
    return 4;
}
function fillColor(d, offs, c, a) {
    if (a === void 0) { a = c.a; }
    d[offs + 0] = c.r;
    d[offs + 1] = c.g;
    d[offs + 2] = c.b;
    d[offs + 3] = a;
    return 4;
}
// All of our matrices are row-major.
function fillMatrix4x4(d, offs, m) {
    // d[offs + 0] = m[0];
    // d[offs + 1] = m[4];
    // d[offs + 2] = m[8];
    // d[offs + 3] = m[12];
    // d[offs + 4] = m[1];
    // d[offs + 5] = m[5];
    // d[offs + 6] = m[9];
    // d[offs + 7] = m[13];
    // d[offs + 8] = m[2];
    // d[offs + 9] = m[6];
    // d[offs + 10] = m[10];
    // d[offs + 11] = m[14];
    // d[offs + 12] = m[3];
    // d[offs + 13] = m[7];
    // d[offs + 14] = m[11];
    // d[offs + 15] = m[15];
    d[offs + 0] = m[0];
    d[offs + 1] = m[1];
    d[offs + 2] = m[2];
    d[offs + 3] = m[3];
    d[offs + 4] = m[4];
    d[offs + 5] = m[5];
    d[offs + 6] = m[6];
    d[offs + 7] = m[7];
    d[offs + 8] = m[8];
    d[offs + 9] = m[9];
    d[offs + 10] = m[10];
    d[offs + 11] = m[11];
    d[offs + 12] = m[12];
    d[offs + 13] = m[13];
    d[offs + 14] = m[14];
    d[offs + 15] = m[15];
    return 4 * 4;
}
// export function fillMatrix4x3(d: Float32Array, offs: number, m: ReadonlyMat4): number {
//   d[offs + 0] = m[0];
//   d[offs + 1] = m[4];
//   d[offs + 2] = m[8];
//   d[offs + 3] = m[12];
//   d[offs + 4] = m[1];
//   d[offs + 5] = m[5];
//   d[offs + 6] = m[9];
//   d[offs + 7] = m[13];
//   d[offs + 8] = m[2];
//   d[offs + 9] = m[6];
//   d[offs + 10] = m[10];
//   d[offs + 11] = m[14];
//   return 4 * 3;
// }
// export function fillMatrix3x2(d: Float32Array, offs: number, m: ReadonlyMat2d): number {
//   // 3x2 matrices are actually sent across as 4x2.
//   const ma = m[0],
//     mb = m[1];
//   const mc = m[2],
//     md = m[3];
//   const mx = m[4],
//     my = m[5];
//   d[offs + 0] = ma;
//   d[offs + 1] = mc;
//   d[offs + 2] = mx;
//   d[offs + 3] = 0;
//   d[offs + 4] = mb;
//   d[offs + 5] = md;
//   d[offs + 6] = my;
//   d[offs + 7] = 0;
//   return 4 * 2;
// }
// export function fillMatrix4x2(d: Float32Array, offs: number, m: ReadonlyMat4): number {
//   // The bottom two rows are basically just ignored in a 4x2.
//   d[offs + 0] = m[0];
//   d[offs + 1] = m[4];
//   d[offs + 2] = m[8];
//   d[offs + 3] = m[12];
//   d[offs + 4] = m[1];
//   d[offs + 5] = m[5];
//   d[offs + 6] = m[9];
//   d[offs + 7] = m[13];
//   return 4 * 2;
// }

exports.RenderInstFlags = void 0;
(function (RenderInstFlags) {
    RenderInstFlags[RenderInstFlags["None"] = 0] = "None";
    RenderInstFlags[RenderInstFlags["Indexed"] = 1] = "Indexed";
    RenderInstFlags[RenderInstFlags["AllowSkippingIfPipelineNotReady"] = 2] = "AllowSkippingIfPipelineNotReady";
    // Mostly for error checking.
    RenderInstFlags[RenderInstFlags["Template"] = 4] = "Template";
    RenderInstFlags[RenderInstFlags["Draw"] = 8] = "Draw";
    // Which flags are inherited from templates...
    RenderInstFlags[RenderInstFlags["InheritedFlags"] = 3] = "InheritedFlags";
})(exports.RenderInstFlags || (exports.RenderInstFlags = {}));
var RenderInst = /** @class */ (function () {
    function RenderInst() {
        this.sortKey = 0;
        // Debugging pointer for whomever wants it...
        this.debug = null;
        this.uniforms = [];
        this.bindingDescriptors = nArray(1, function () { return ({
            bindingLayout: null,
            samplerBindings: [],
            uniformBufferBindings: [],
        }); });
        this.dynamicUniformBufferByteOffsets = nArray(4, function () { return 0; });
        this.flags = 0;
        this.inputState = null;
        this.drawStart = 0;
        this.drawCount = 0;
        this.drawInstanceCount = 0;
        this.renderPipelineDescriptor = {
            bindingLayouts: [],
            inputLayout: null,
            megaStateDescriptor: copyMegaState(defaultMegaState),
            program: null,
            topology: exports.PrimitiveTopology.Triangles,
            colorAttachmentFormats: [],
            depthStencilAttachmentFormat: null,
            sampleCount: 1,
        };
        this.reset();
    }
    /**
     * Resets a render inst to be boring, so it can re-enter the pool.
     * Normally, you should not need to call this.
     */
    RenderInst.prototype.reset = function () {
        this.sortKey = 0;
        this.flags = exports.RenderInstFlags.AllowSkippingIfPipelineNotReady;
        this.inputState = null;
        this.renderPipelineDescriptor.inputLayout = null;
    };
    /**
     * Copies the fields from another render inst {@param o} to this render inst.
     * Normally, you should not need to call this.
     */
    RenderInst.prototype.setFromTemplate = function (o) {
        setMegaStateFlags(this.renderPipelineDescriptor.megaStateDescriptor, o.renderPipelineDescriptor.megaStateDescriptor);
        this.renderPipelineDescriptor.program = o.renderPipelineDescriptor.program;
        this.renderPipelineDescriptor.inputLayout =
            o.renderPipelineDescriptor.inputLayout;
        this.renderPipelineDescriptor.topology =
            o.renderPipelineDescriptor.topology;
        this.renderPipelineDescriptor.colorAttachmentFormats.length = Math.max(this.renderPipelineDescriptor.colorAttachmentFormats.length, o.renderPipelineDescriptor.colorAttachmentFormats.length);
        for (var i = 0; i < o.renderPipelineDescriptor.colorAttachmentFormats.length; i++)
            this.renderPipelineDescriptor.colorAttachmentFormats[i] =
                o.renderPipelineDescriptor.colorAttachmentFormats[i];
        this.renderPipelineDescriptor.depthStencilAttachmentFormat =
            o.renderPipelineDescriptor.depthStencilAttachmentFormat;
        this.renderPipelineDescriptor.sampleCount =
            o.renderPipelineDescriptor.sampleCount;
        this.inputState = o.inputState;
        this.uniformBuffer = o.uniformBuffer;
        this.uniforms = tslib.__spreadArray([], tslib.__read(o.uniforms), false);
        this.drawCount = o.drawCount;
        this.drawStart = o.drawStart;
        this.drawInstanceCount = o.drawInstanceCount;
        this.flags =
            (this.flags & ~exports.RenderInstFlags.InheritedFlags) |
                (o.flags & exports.RenderInstFlags.InheritedFlags);
        this.sortKey = o.sortKey;
        var tbd = this.bindingDescriptors[0], obd = o.bindingDescriptors[0];
        if (obd.bindingLayout !== null)
            this.setBindingLayout(obd.bindingLayout);
        for (var i = 0; i <
            Math.min(tbd.uniformBufferBindings.length, obd.uniformBufferBindings.length); i++)
            tbd.uniformBufferBindings[i].wordCount =
                o.bindingDescriptors[0].uniformBufferBindings[i].wordCount;
        this.setSamplerBindingsFromTextureMappings(obd.samplerBindings);
        for (var i = 0; i < o.dynamicUniformBufferByteOffsets.length; i++)
            this.dynamicUniformBufferByteOffsets[i] =
                o.dynamicUniformBufferByteOffsets[i];
    };
    /**
     * Set the {@see Program} that this render inst will render with. This is part of the automatic
     * pipeline building facilities. At render time, a pipeline will be automatically and constructed from
     * the pipeline parameters.
     */
    RenderInst.prototype.setProgram = function (program) {
        this.renderPipelineDescriptor.program = program;
    };
    /**
     * Set the {@see MegaStateDescriptor} that this render inst will render with. This is part of the automatic
     * pipeline building facilities. At render time, a pipeline will be automatically and constructed from
     * the pipeline parameters.
     */
    RenderInst.prototype.setMegaStateFlags = function (r) {
        setMegaStateFlags(this.renderPipelineDescriptor.megaStateDescriptor, r);
        return this.renderPipelineDescriptor.megaStateDescriptor;
    };
    /**
     * Retrieve the {@see MegaStateDescriptor} property bag that this will render with. This is similar to
     * {@see setMegaStateFlags} but allows you to set fields directly on the internal property bag, rather than
     * merge them. This can be slightly more efficient.
     */
    RenderInst.prototype.getMegaStateFlags = function () {
        return this.renderPipelineDescriptor.megaStateDescriptor;
    };
    /**
     * Sets both the {@see InputLayout} and {@see InputState} to be used by this render instance.
     * The {@see InputLayout} is used to construct the pipeline as part of the automatic pipeline building
     * facilities, while {@see InputState} is used for the render.
     */
    RenderInst.prototype.setInputLayoutAndState = function (inputLayout, inputState) {
        this.inputState = inputState;
        this.renderPipelineDescriptor.inputLayout = inputLayout;
    };
    RenderInst.prototype.setBindingLayout = function (bindingLayout) {
        assert(bindingLayout.numUniformBuffers <
            this.dynamicUniformBufferByteOffsets.length);
        this.renderPipelineDescriptor.bindingLayouts[0] = bindingLayout;
        this.bindingDescriptors[0].bindingLayout = bindingLayout;
        for (var i = this.bindingDescriptors[0].uniformBufferBindings.length; i < bindingLayout.numUniformBuffers; i++)
            this.bindingDescriptors[0].uniformBufferBindings.push({
                buffer: null,
                wordCount: 0,
            });
        for (var i = this.bindingDescriptors[0].samplerBindings.length; i < bindingLayout.numSamplers; i++)
            this.bindingDescriptors[0].samplerBindings.push({
                sampler: null,
                texture: null,
                lateBinding: null,
            });
    };
    /**
     * Sets the {@see BindingLayoutDescriptor}s that this render inst will render with.
     */
    RenderInst.prototype.setBindingLayouts = function (bindingLayouts) {
        assert(bindingLayouts.length <= this.bindingDescriptors.length);
        assert(bindingLayouts.length === 1);
        this.setBindingLayout(bindingLayouts[0]);
    };
    RenderInst.prototype.drawIndexes = function (indexCount, indexStart) {
        if (indexStart === void 0) { indexStart = 0; }
        this.flags = setBitFlagEnabled(this.flags, exports.RenderInstFlags.Indexed, true);
        this.drawCount = indexCount;
        this.drawStart = indexStart;
        this.drawInstanceCount = 1;
    };
    RenderInst.prototype.drawIndexesInstanced = function (indexCount, instanceCount, indexStart) {
        if (indexStart === void 0) { indexStart = 0; }
        this.flags = setBitFlagEnabled(this.flags, exports.RenderInstFlags.Indexed, true);
        this.drawCount = indexCount;
        this.drawStart = indexStart;
        this.drawInstanceCount = instanceCount;
    };
    RenderInst.prototype.drawPrimitives = function (primitiveCount, primitiveStart) {
        if (primitiveStart === void 0) { primitiveStart = 0; }
        this.flags = setBitFlagEnabled(this.flags, exports.RenderInstFlags.Indexed, false);
        this.drawCount = primitiveCount;
        this.drawStart = primitiveStart;
        this.drawInstanceCount = 1;
    };
    /**
     * account for WebGL1
     */
    RenderInst.prototype.setUniforms = function (bufferIndex, uniforms) {
        if (uniforms.length === 0) {
            return;
        }
        // use later in WebGL1
        this.uniforms[bufferIndex] = uniforms;
        // calc buffer size
        var offset = 0;
        var uboBuffer = [];
        uniforms.forEach(function (uniform) {
            var value = uniform.value;
            // number | number[] | Float32Array
            if (util.isNumber(value) ||
                Array.isArray(value) ||
                value instanceof Float32Array) {
                var array = util.isNumber(value) ? [value] : value;
                var formatByteSize = array.length > 4 ? 4 : array.length;
                // std140 UBO layout
                var emptySpace_1 = 4 - (offset % 4);
                if (emptySpace_1 !== 4) {
                    if (emptySpace_1 >= formatByteSize) ;
                    else {
                        offset += emptySpace_1;
                        for (var j = 0; j < emptySpace_1; j++) {
                            uboBuffer.push(0); // padding
                        }
                    }
                }
                offset += array.length;
                uboBuffer.push.apply(uboBuffer, tslib.__spreadArray([], tslib.__read(array), false));
            }
        });
        // padding
        var emptySpace = 4 - (uboBuffer.length % 4);
        if (emptySpace !== 4) {
            for (var j = 0; j < emptySpace; j++) {
                uboBuffer.push(0);
            }
        }
        // upload UBO
        var offs = this.allocateUniformBuffer(bufferIndex, uboBuffer.length);
        var d = this.mapUniformBufferF32(bufferIndex);
        for (var i = 0; i < uboBuffer.length; i += 4) {
            offs += fillVec4(d, offs, uboBuffer[i], uboBuffer[i + 1], uboBuffer[i + 2], uboBuffer[i + 3]);
        }
    };
    RenderInst.prototype.setUniformBuffer = function (uniformBuffer) {
        this.uniformBuffer = uniformBuffer;
    };
    /**
     * Allocates {@param wordCount} words from the uniform buffer and assigns it to the buffer
     * slot at index {@param bufferIndex}. As a convenience, this also directly returns the same
     * offset into the uniform buffer, in words, that would be returned by a subsequent call to
     * {@see getUniformBufferOffset}.
     */
    RenderInst.prototype.allocateUniformBuffer = function (bufferIndex, wordCount) {
        assert(this.bindingDescriptors[0].bindingLayout.numUniformBuffers <
            this.dynamicUniformBufferByteOffsets.length);
        this.dynamicUniformBufferByteOffsets[bufferIndex] =
            this.uniformBuffer.allocateChunk(wordCount) << 2;
        var dst = this.bindingDescriptors[0].uniformBufferBindings[bufferIndex];
        dst.wordCount = wordCount;
        return this.getUniformBufferOffset(bufferIndex);
    };
    /**
     * Returns the offset into the uniform buffer, in words, that is assigned to the buffer slot
     * at index {@param bufferIndex}, to be used with e.g. {@see mapUniformBufferF32}.
     */
    RenderInst.prototype.getUniformBufferOffset = function (bufferIndex) {
        var wordOffset = this.dynamicUniformBufferByteOffsets[bufferIndex] >>> 2;
        return wordOffset;
    };
    /**
     * Directly sets the uniform buffer assigned to the buffer slot at index {@param bufferIndex}
     * to be {@param wordOffset}. Use this if you have already allocated a uniform buffer chunk through
     * some other means and wish to directly assign it to this render inst.
     */
    RenderInst.prototype.setUniformBufferOffset = function (bufferIndex, wordOffset, wordCount) {
        this.dynamicUniformBufferByteOffsets[bufferIndex] = wordOffset << 2;
        var dst = this.bindingDescriptors[0].uniformBufferBindings[bufferIndex];
        dst.wordCount = wordCount;
    };
    /**
     * This is a convenience wrapper for {@see RenderDynamicUniformBuffer.mapBufferF32}, but uses
     * the values previously assigned for the uniform buffer slot at index {@param bufferIndex}.
     * Like {@see RenderDynamicUniformBuffer.mapBufferF32}, this does not return a slice for the
     * buffer; you need to write to it with the correct uniform buffer offset; this will usually be
     * returned by {@see allocateUniformBuffer}.
     */
    RenderInst.prototype.mapUniformBufferF32 = function (bufferIndex) {
        return this.uniformBuffer.mapBufferF32();
    };
    /**
     * Retrieve the {@see RenderDynamicUniformBuffer} that this render inst will use to allocate.
     */
    RenderInst.prototype.getUniformBuffer = function () {
        return this.uniformBuffer;
    };
    /**
     * Sets the {@param SamplerBinding}s in use by this render instance.
     *
     * Note that {@see RenderInst} has a method of doing late binding, intended to solve cases where live render
     * targets are used, which can have difficult control flow consequences for users. Pass a string instead of a
     * SamplerBinding to record that it can be resolved later, and use {@see RenderInst.resolveLateSamplerBinding}
     * or equivalent to fill it in later.
     */
    RenderInst.prototype.setSamplerBindingsFromTextureMappings = function (mappings) {
        mappings = mappings.filter(function (m) { return m; });
        for (var i = 0; i < this.bindingDescriptors[0].samplerBindings.length; i++) {
            var dst = this.bindingDescriptors[0].samplerBindings[i];
            var binding = mappings[i];
            if (binding === undefined || binding === null) {
                dst.texture = null;
                dst.sampler = null;
                dst.lateBinding = null;
                continue;
            }
            dst.texture = binding.texture;
            dst.sampler = binding.sampler;
            dst.lateBinding = binding.lateBinding;
        }
    };
    RenderInst.prototype.hasLateSamplerBinding = function (name) {
        for (var i = 0; i < this.bindingDescriptors[0].samplerBindings.length; i++) {
            var dst = this.bindingDescriptors[0].samplerBindings[i];
            if (dst.lateBinding === name)
                return true;
        }
        return false;
    };
    /**
     * Resolve a previously registered "late bound" sampler binding for the given {@param name} to the provided
     * {@param binding}, as registered through {@see setSamplerBindingsFromTextureMappings}.
     *
     * This is intended to be called by high-level code, and is especially helpful when juggling render targets
     * for framebuffer effects.
     */
    RenderInst.prototype.resolveLateSamplerBinding = function (name, binding) {
        for (var i = 0; i < this.bindingDescriptors[0].samplerBindings.length; i++) {
            var dst = this.bindingDescriptors[0].samplerBindings[i];
            if (dst.lateBinding === name) {
                if (binding === null) {
                    dst.texture = null;
                    dst.sampler = null;
                }
                else {
                    assert(binding.lateBinding === null);
                    dst.texture = binding.texture;
                    if (binding.sampler !== null) {
                        dst.sampler = binding.sampler;
                    }
                }
                dst.lateBinding = null;
            }
        }
    };
    /**
     * Sets whether this render inst should be skipped if the render pipeline isn't ready.
     *
     * Some draws of objects can be skipped if the pipelines aren't ready. Others are more
     * crucial to draw, and so this can be set to force for the pipeline to become available.
     *
     * By default, this is true.
     */
    RenderInst.prototype.setAllowSkippingIfPipelineNotReady = function (v) {
        this.flags = setBitFlagEnabled(this.flags, exports.RenderInstFlags.AllowSkippingIfPipelineNotReady, v);
    };
    RenderInst.prototype.setAttachmentFormatsFromRenderPass = function (device, passRenderer) {
        var passDescriptor = device.queryRenderPass(passRenderer);
        var sampleCount = -1;
        for (var i = 0; i < passDescriptor.colorAttachment.length; i++) {
            var colorAttachmentDescriptor = passDescriptor.colorAttachment[i] !== null
                ? device.queryRenderTarget(passDescriptor.colorAttachment[i])
                : null;
            this.renderPipelineDescriptor.colorAttachmentFormats[i] =
                colorAttachmentDescriptor !== null
                    ? colorAttachmentDescriptor.pixelFormat
                    : null;
            if (colorAttachmentDescriptor !== null) {
                if (sampleCount === -1)
                    sampleCount = colorAttachmentDescriptor.sampleCount;
                else
                    assert(sampleCount === colorAttachmentDescriptor.sampleCount);
            }
        }
        var depthStencilAttachmentDescriptor = passDescriptor.depthStencilAttachment !== null
            ? device.queryRenderTarget(passDescriptor.depthStencilAttachment)
            : null;
        this.renderPipelineDescriptor.depthStencilAttachmentFormat =
            depthStencilAttachmentDescriptor !== null
                ? depthStencilAttachmentDescriptor.pixelFormat
                : null;
        if (depthStencilAttachmentDescriptor !== null) {
            if (sampleCount === -1)
                sampleCount = depthStencilAttachmentDescriptor.sampleCount;
            else
                assert(sampleCount == depthStencilAttachmentDescriptor.sampleCount);
        }
        assert(sampleCount > 0);
        this.renderPipelineDescriptor.sampleCount = sampleCount;
    };
    RenderInst.prototype.drawOnPass = function (cache, passRenderer) {
        var _this = this;
        var device = cache.device;
        this.setAttachmentFormatsFromRenderPass(device, passRenderer);
        var gfxPipeline = cache.createRenderPipeline(this.renderPipelineDescriptor);
        var pipelineReady = device.pipelineQueryReady(gfxPipeline);
        if (!pipelineReady) {
            if (this.flags & exports.RenderInstFlags.AllowSkippingIfPipelineNotReady) {
                return false;
            }
            device.pipelineForceReady(gfxPipeline);
        }
        passRenderer.setPipeline(gfxPipeline);
        passRenderer.setInputState(this.inputState);
        // upload uniforms
        for (var i = 0; i < this.bindingDescriptors[0].uniformBufferBindings.length; i++)
            this.bindingDescriptors[0].uniformBufferBindings[i].buffer = assertExists(this.uniformBuffer.buffer);
        if (this.renderPipelineDescriptor.program.gl_program) {
            this.uniforms.forEach(function (uniforms) {
                var uniformsMap = {};
                uniforms.forEach(function (_a) {
                    var name = _a.name, value = _a.value;
                    uniformsMap[name] = value;
                });
                _this.renderPipelineDescriptor.program.setUniforms(uniformsMap);
            });
        }
        // TODO: Support multiple binding descriptors.
        var gfxBindings = cache.createBindings(tslib.__assign(tslib.__assign({}, this.bindingDescriptors[0]), { pipeline: gfxPipeline }));
        passRenderer.setBindings(0, gfxBindings, this.dynamicUniformBufferByteOffsets);
        if (this.drawInstanceCount > 1) {
            assert(!!(this.flags & exports.RenderInstFlags.Indexed));
            passRenderer.drawIndexedInstanced(this.drawCount, this.drawStart, this.drawInstanceCount);
        }
        else if (this.flags & exports.RenderInstFlags.Indexed) {
            passRenderer.drawIndexed(this.drawCount, this.drawStart);
        }
        else {
            passRenderer.draw(this.drawCount, this.drawStart);
        }
        return true;
    };
    return RenderInst;
}());

var renderInstCompareNone = null;
function renderInstCompareSortKey(a, b) {
    return a.sortKey - b.sortKey;
}
exports.RenderInstExecutionOrder = void 0;
(function (RenderInstExecutionOrder) {
    RenderInstExecutionOrder[RenderInstExecutionOrder["Forwards"] = 0] = "Forwards";
    RenderInstExecutionOrder[RenderInstExecutionOrder["Backwards"] = 1] = "Backwards";
})(exports.RenderInstExecutionOrder || (exports.RenderInstExecutionOrder = {}));
var RenderInstList = /** @class */ (function () {
    function RenderInstList(compareFunction, executionOrder) {
        if (compareFunction === void 0) { compareFunction = renderInstCompareSortKey; }
        if (executionOrder === void 0) { executionOrder = exports.RenderInstExecutionOrder.Forwards; }
        this.renderInsts = [];
        this.usePostSort = false;
        this.compareFunction = compareFunction;
        this.executionOrder = executionOrder;
    }
    /**
     * Determine whether to use post-sorting, based on some heuristics.
     */
    RenderInstList.prototype.checkUsePostSort = function () {
        // Over a certain threshold, it's faster to push and then sort than insort directly...
        this.usePostSort =
            this.compareFunction !== null && this.renderInsts.length >= 500;
    };
    /**
     * Insert a render inst to the list. This directly inserts the render inst to
     * the position specified by the compare function, so the render inst must be
     * fully constructed at this point.
     */
    RenderInstList.prototype.insertSorted = function (renderInst) {
        if (this.compareFunction === null) {
            this.renderInsts.push(renderInst);
        }
        else if (this.usePostSort) {
            this.renderInsts.push(renderInst);
        }
        else {
            spliceBisectRight(this.renderInsts, renderInst, this.compareFunction);
        }
        this.checkUsePostSort();
    };
    RenderInstList.prototype.submitRenderInst = function (renderInst) {
        renderInst.flags |= exports.RenderInstFlags.Draw;
        this.insertSorted(renderInst);
    };
    RenderInstList.prototype.hasLateSamplerBinding = function (name) {
        for (var i = 0; i < this.renderInsts.length; i++)
            if (this.renderInsts[i].hasLateSamplerBinding(name)) {
                return true;
            }
        return false;
    };
    /**
     * Resolve sampler bindings for all render insts on this render inst list.
     */
    RenderInstList.prototype.resolveLateSamplerBinding = function (name, binding) {
        for (var i = 0; i < this.renderInsts.length; i++)
            this.renderInsts[i].resolveLateSamplerBinding(name, binding);
    };
    RenderInstList.prototype.ensureSorted = function () {
        if (this.usePostSort) {
            if (this.renderInsts.length !== 0)
                this.renderInsts.sort(this.compareFunction);
            this.usePostSort = false;
        }
    };
    RenderInstList.prototype.drawOnPassRendererNoReset = function (cache, passRenderer) {
        this.ensureSorted();
        var numDrawn = 0;
        if (this.executionOrder === exports.RenderInstExecutionOrder.Forwards) {
            for (var i = 0; i < this.renderInsts.length; i++)
                if (this.renderInsts[i].drawOnPass(cache, passRenderer))
                    numDrawn++;
        }
        else {
            for (var i = this.renderInsts.length - 1; i >= 0; i--)
                if (this.renderInsts[i].drawOnPass(cache, passRenderer))
                    numDrawn++;
        }
        return numDrawn;
    };
    RenderInstList.prototype.reset = function () {
        this.renderInsts.length = 0;
    };
    RenderInstList.prototype.drawOnPassRenderer = function (cache, passRenderer) {
        this.drawOnPassRendererNoReset(cache, passRenderer);
        this.reset();
    };
    return RenderInstList;
}());

var RenderInstPool = /** @class */ (function () {
    function RenderInstPool() {
        // The pool contains all render insts that we've ever created.
        this.pool = [];
        // The number of render insts currently allocated out to the user.
        this.allocCount = 0;
    }
    RenderInstPool.prototype.allocRenderInstIndex = function () {
        this.allocCount++;
        if (this.allocCount > this.pool.length) {
            this.pool.push(new RenderInst());
        }
        return this.allocCount - 1;
    };
    RenderInstPool.prototype.popRenderInst = function () {
        this.allocCount--;
    };
    RenderInstPool.prototype.reset = function () {
        for (var i = 0; i < this.pool.length; i++) {
            this.pool[i].reset();
        }
        this.allocCount = 0;
    };
    RenderInstPool.prototype.destroy = function () {
        this.pool.length = 0;
        this.allocCount = 0;
    };
    return RenderInstPool;
}());

var RenderInstManager = /** @class */ (function () {
    function RenderInstManager(renderCache) {
        this.renderCache = renderCache;
        this.instPool = new RenderInstPool();
        this.templatePool = new RenderInstPool();
        this.simpleRenderInstList = new RenderInstList();
        this.currentRenderInstList = this.simpleRenderInstList;
    }
    /**
     * Creates a new RenderInst object and returns it. If there is a template
     * pushed onto the template stack, then its values will be used as a base for this
     * render inst.
     */
    RenderInstManager.prototype.newRenderInst = function () {
        var templateIndex = this.templatePool.allocCount - 1;
        var renderInstIndex = this.instPool.allocRenderInstIndex();
        var renderInst = this.instPool.pool[renderInstIndex];
        renderInst.debug = null;
        if (templateIndex >= 0)
            renderInst.setFromTemplate(this.templatePool.pool[templateIndex]);
        return renderInst;
    };
    /**
     * Submits RenderInst to the current render inst list. Note that
     * this assumes the render inst was fully filled in, so do not modify it
     * after submitting it.
     */
    RenderInstManager.prototype.submitRenderInst = function (renderInst, list) {
        if (list === void 0) { list = this.currentRenderInstList; }
        list.submitRenderInst(renderInst);
    };
    /**
     * Sets the currently active render inst list. This is the list that will
     * be used by @param submitRenderInst}. If you use this function, please
     * make sure to call {@see disableSimpleMode} when the RenderInstManager
     * is created, to ensure that nobody uses the "legacy" APIs. Failure to do
     * so might cause memory leaks or other problems.
     */
    RenderInstManager.prototype.setCurrentRenderInstList = function (list) {
        assert(this.simpleRenderInstList === null);
        this.currentRenderInstList = list;
    };
    /**
     * Pushes a new template render inst to the template stack. All properties set
     * on the topmost template on the template stack will be the defaults for both
     * for any future render insts created. Once done with a template, call
     * {@param popTemplateRenderInst} to pop it off the template stack.
     */
    RenderInstManager.prototype.pushTemplateRenderInst = function () {
        var templateIndex = this.templatePool.allocCount - 1;
        var newTemplateIndex = this.templatePool.allocRenderInstIndex();
        var newTemplate = this.templatePool.pool[newTemplateIndex];
        if (templateIndex >= 0)
            newTemplate.setFromTemplate(this.templatePool.pool[templateIndex]);
        newTemplate.flags |= exports.RenderInstFlags.Template;
        return newTemplate;
    };
    RenderInstManager.prototype.popTemplateRenderInst = function () {
        this.templatePool.popRenderInst();
    };
    /**
     * Retrieves the current template render inst on the top of the template stack.
     */
    RenderInstManager.prototype.getTemplateRenderInst = function () {
        var templateIndex = this.templatePool.allocCount - 1;
        return this.templatePool.pool[templateIndex];
    };
    /**
     * Reset all allocated render insts. This should be called at the end of the frame,
     * once done with all of the allocated render insts and render inst lists.
     */
    RenderInstManager.prototype.resetRenderInsts = function () {
        // Retire the existing render insts.
        this.instPool.reset();
        if (this.simpleRenderInstList !== null)
            this.simpleRenderInstList.reset();
        // Ensure we aren't leaking templates.
        assert(this.templatePool.allocCount === 0);
    };
    RenderInstManager.prototype.destroy = function () {
        this.instPool.destroy();
        this.renderCache.destroy();
    };
    /**
     * Disables the "simple" render inst list management API.
     */
    RenderInstManager.prototype.disableSimpleMode = function () {
        // This is a one-way street!
        this.simpleRenderInstList = null;
    };
    // /**
    //  * Execute all scheduled render insts in {@param list} onto the {@param RenderPass},
    //  * using {@param device} and {@param cache} to create any device-specific resources
    //  * necessary to complete the draws.
    //  */
    // drawListOnPassRenderer(list: RenderInstList, passRenderer: RenderPass): void {
    //   list.drawOnPassRenderer(this.renderCache, passRenderer);
    // }
    RenderInstManager.prototype.drawOnPassRenderer = function (passRenderer) {
        var list = assertExists(this.simpleRenderInstList);
        list.drawOnPassRenderer(this.renderCache, passRenderer);
    };
    RenderInstManager.prototype.drawOnPassRendererNoReset = function (passRenderer) {
        var list = assertExists(this.simpleRenderInstList);
        list.drawOnPassRendererNoReset(this.renderCache, passRenderer);
    };
    return RenderInstManager;
}());

var RenderHelper = /** @class */ (function () {
    function RenderHelper(parameters) {
        this.parameters = parameters;
    }
    RenderHelper.prototype.getDevice = function () {
        return this.device;
    };
    RenderHelper.prototype.setDevice = function (device) {
        this.device = device;
        this.renderCache = new RenderCache(device);
        this.renderGraph = new RenderGraph(this.device);
        this.renderInstManager = new RenderInstManager(this.renderCache);
        this.uniformBuffer = new DynamicUniformBuffer(this.device);
        // this.debugThumbnails = new DebugThumbnailDrawer(this);
    };
    RenderHelper.prototype.pushTemplateRenderInst = function () {
        var template = this.renderInstManager.pushTemplateRenderInst();
        template.setUniformBuffer(this.uniformBuffer);
        return template;
    };
    RenderHelper.prototype.prepareToRender = function () {
        this.uniformBuffer.prepareToRender();
    };
    RenderHelper.prototype.destroy = function () {
        if (this.uniformBuffer) {
            this.uniformBuffer.destroy();
        }
        if (this.renderInstManager) {
            this.renderInstManager.destroy();
        }
        if (this.renderCache) {
            this.renderCache.destroy();
        }
        if (this.renderGraph) {
            this.renderGraph.destroy();
        }
    };
    // getDebugTextDrawer(): TextDrawer | null {
    //   return null;
    // }
    RenderHelper.prototype.getCache = function () {
        return this.renderCache;
    };
    RenderHelper.prototype.getDefines = function () {
        var _a, _b, _c;
        return {
            USE_TONEMAPPING: ((_a = this.parameters) === null || _a === void 0 ? void 0 : _a.toneMapping) &&
                ((_b = this.parameters) === null || _b === void 0 ? void 0 : _b.toneMapping) !== exports.ToneMapping.NONE,
            toneMapping: (_c = this.parameters) === null || _c === void 0 ? void 0 : _c.toneMapping,
        };
    };
    return RenderHelper;
}());

var RGRenderTargetDescription = /** @class */ (function () {
    function RGRenderTargetDescription(pixelFormat) {
        this.pixelFormat = pixelFormat;
        this.width = 0;
        this.height = 0;
        this.sampleCount = 0;
        this.colorClearColor = 'load';
        this.depthClearValue = 'load';
        this.stencilClearValue = 'load';
    }
    /**
     * Set the dimensions of a render target description.
     */
    RGRenderTargetDescription.prototype.setDimensions = function (width, height, sampleCount) {
        this.width = width;
        this.height = height;
        this.sampleCount = sampleCount;
    };
    RGRenderTargetDescription.prototype.copyDimensions = function (desc) {
        this.width = desc.width;
        this.height = desc.height;
        this.sampleCount = desc.sampleCount;
    };
    return RGRenderTargetDescription;
}());

function makeAttachmentClearDescriptor(clearColor) {
    return {
        colorClearColor: clearColor,
        // depthClearValue: reverseDepthForClearValue(1.0),
        depthClearValue: 1,
        stencilClearValue: 0.0,
    };
}
var standardFullClearRenderPassDescriptor = makeAttachmentClearDescriptor(colorNewFromRGBA(0.88, 0.88, 0.88, 1.0));
var opaqueBlackFullClearRenderPassDescriptor = makeAttachmentClearDescriptor(OpaqueBlack);
var opaqueWhiteFullClearRenderPassDescriptor = makeAttachmentClearDescriptor(OpaqueWhite);
exports.AntialiasingMode = void 0;
(function (AntialiasingMode) {
    AntialiasingMode[AntialiasingMode["None"] = 0] = "None";
    AntialiasingMode[AntialiasingMode["FXAA"] = 1] = "FXAA";
    AntialiasingMode[AntialiasingMode["MSAAx4"] = 2] = "MSAAx4";
})(exports.AntialiasingMode || (exports.AntialiasingMode = {}));
function selectFormatSimple(slot) {
    if (slot === exports.RGAttachmentSlot.Color0) {
        return exports.Format.U8_RGBA_RT;
    }
    else if (slot === exports.RGAttachmentSlot.DepthStencil) {
        return exports.Format.D24_S8;
    }
    else {
        throw new Error('whoops');
    }
}
function selectSampleCount(renderInput) {
    if (renderInput.antialiasingMode === exports.AntialiasingMode.MSAAx4) {
        return 4;
    }
    else {
        return 1;
    }
}
function setBackbufferDescSimple(desc, renderInput) {
    var sampleCount = selectSampleCount(renderInput);
    desc.setDimensions(renderInput.backbufferWidth, renderInput.backbufferHeight, sampleCount);
}
function makeBackbufferDescSimple(slot, renderInput, clearDescriptor) {
    var pixelFormat = selectFormatSimple(slot);
    var desc = new RGRenderTargetDescription(pixelFormat);
    setBackbufferDescSimple(desc, renderInput);
    if (clearDescriptor !== null) {
        desc.colorClearColor = clearDescriptor.colorClearColor;
        desc.depthClearValue = clearDescriptor.depthClearValue;
        desc.stencilClearValue = clearDescriptor.stencilClearValue;
    }
    return desc;
}

var TextureMapping = /** @class */ (function () {
    function TextureMapping() {
        this.texture = null;
        this.sampler = null;
        this.lateBinding = null;
        // These are not used when binding to samplers, and are conveniences for custom behavior.
        // TODO(jstpierre): Are any of these really worth anything?
        this.width = 0;
        this.height = 0;
        this.lodBias = 0;
    }
    // GL sucks. This is a convenience when building texture matrices.
    // The core renderer does not use this code at all.
    // flipY: boolean = false;
    TextureMapping.prototype.reset = function () {
        this.texture = null;
        this.sampler = null;
        this.lateBinding = null;
        this.width = 0;
        this.height = 0;
        this.lodBias = 0;
        // this.flipY = false;
    };
    TextureMapping.prototype.copy = function (other) {
        this.texture = other.texture;
        this.sampler = other.sampler;
        this.lateBinding = other.lateBinding;
        this.width = other.width;
        this.height = other.height;
        this.lodBias = other.lodBias;
        // this.flipY = other.flipY;
    };
    return TextureMapping;
}());

// Public API for saving off copies of images for temporal-style effects.
var TemporalTexture = /** @class */ (function () {
    function TemporalTexture() {
        // These names might be a bit confusing, but they're named relative to the graph.
        // outputTexture is the target of a resolve, inputTexture is the source for sampling.
        this.inputTexture = null;
        this.outputTexture = null;
    }
    TemporalTexture.prototype.setDescription = function (device, desc) {
        // Updating the description will happen at the start of the frame,
        // so we need to keep the inputTexture alive (the previous frame's texture),
        // and create a new outputTexture.
        if (this.inputTexture !== this.outputTexture) {
            if (this.inputTexture !== null)
                this.inputTexture.destroy();
            // Set the input texture to our old output texture.
            this.inputTexture = this.outputTexture;
        }
        assert(this.inputTexture === this.outputTexture);
        if (this.outputTexture !== null && this.outputTexture.matchesDescription(desc))
            return;
        this.outputTexture = new SingleSampledTexture(device, desc);
        if (this.inputTexture === null)
            this.inputTexture = this.outputTexture;
    };
    TemporalTexture.prototype.getTextureForSampling = function () {
        return this.inputTexture !== null ? this.inputTexture.texture : null;
    };
    TemporalTexture.prototype.getTextureForResolving = function () {
        var _a;
        return (_a = this.outputTexture) === null || _a === void 0 ? void 0 : _a.texture;
    };
    TemporalTexture.prototype.destroy = function () {
        if (this.outputTexture !== null && this.outputTexture !== this.inputTexture) {
            this.outputTexture.destroy();
            this.outputTexture = null;
        }
        if (this.inputTexture !== null) {
            this.inputTexture.destroy();
            this.inputTexture = null;
        }
    };
    return TemporalTexture;
}());

var Light = /** @class */ (function (_super) {
    tslib.__extends(Light, _super);
    function Light(_a) {
        if (_a === void 0) { _a = {}; }
        var style = _a.style, rest = tslib.__rest(_a, ["style"]);
        return _super.call(this, tslib.__assign({ type: Light.tag, style: tslib.__assign({ intensity: Math.PI }, style) }, rest)) || this;
    }
    Light.tag = 'light';
    return Light;
}(gLite.DisplayObject));

exports.FogType = void 0;
(function (FogType) {
    FogType[FogType["NONE"] = 0] = "NONE";
    FogType[FogType["EXP"] = 1] = "EXP";
    FogType[FogType["EXP2"] = 2] = "EXP2";
    FogType[FogType["LINEAR"] = 3] = "LINEAR";
})(exports.FogType || (exports.FogType = {}));
var Fog = /** @class */ (function (_super) {
    tslib.__extends(Fog, _super);
    function Fog(_a) {
        if (_a === void 0) { _a = {}; }
        var style = _a.style, rest = tslib.__rest(_a, ["style"]);
        return _super.call(this, tslib.__assign({ type: Fog.tag, style: tslib.__assign({ type: exports.FogType.NONE, fill: 'black', start: 1, end: 1000, density: 0 }, style) }, rest)) || this;
    }
    Fog.tag = 'fog';
    return Fog;
}(gLite.DisplayObject));

// scene uniform block index
var SceneUniformBufferIndex = 0;
// uniforms in scene level
var SceneUniform;
(function (SceneUniform) {
    SceneUniform["PROJECTION_MATRIX"] = "u_ProjectionMatrix";
    SceneUniform["VIEW_MATRIX"] = "u_ViewMatrix";
    SceneUniform["CAMERA_POSITION"] = "u_CameraPosition";
    SceneUniform["DEVICE_PIXEL_RATIO"] = "u_DevicePixelRatio";
    SceneUniform["VIEWPORT"] = "u_Viewport";
    SceneUniform["IS_ORTHO"] = "u_IsOrtho";
    SceneUniform["IS_PICKING"] = "u_IsPicking";
})(SceneUniform || (SceneUniform = {}));
var RenderGraphPlugin = /** @class */ (function () {
    function RenderGraphPlugin(renderHelper, lightPool, texturePool, batchManager) {
        this.renderHelper = renderHelper;
        this.lightPool = lightPool;
        this.texturePool = texturePool;
        this.batchManager = batchManager;
        this.renderLists = {
            /**
             * used in main forward rendering pass
             */
            world: new RenderInstList(),
            /**
             * used in picking pass, should disable blending
             */
            picking: new RenderInstList(),
        };
    }
    RenderGraphPlugin.prototype.getDevice = function () {
        return this.device;
    };
    RenderGraphPlugin.prototype.getSwapChain = function () {
        return this.swapChain;
    };
    RenderGraphPlugin.prototype.getRenderLists = function () {
        return this.renderLists;
    };
    RenderGraphPlugin.prototype.apply = function (context) {
        var _this = this;
        this.context = context;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var handleMounted = function (e) {
            var object = e.target;
            // collect lights
            if (object.nodeName === Light.tag) {
                _this.lightPool.addLight(object);
                return;
            }
            else if (object.nodeName === Fog.tag) {
                _this.lightPool.addFog(object);
                return;
            }
            // @ts-ignore
            if (!object.renderable3D) {
                // @ts-ignore
                object.renderable3D = new Renderable3D();
            }
            _this.batchManager.add(object);
        };
        var handleUnmounted = function (e) {
            var object = e.target;
            if (object.nodeName === Light.tag) {
                _this.lightPool.removeLight(object);
                return;
            }
            else if (object.nodeName === Fog.tag) {
                _this.lightPool.removeFog(object);
                return;
            }
            if (_this.swapChain) {
                _this.batchManager.remove(object);
            }
            // @ts-ignore
            delete object.renderable3D;
            // entity.removeComponent(Geometry3D, true);
            // entity.removeComponent(Material3D, true);
            // entity.removeComponent(Renderable3D, true);
        };
        var handleAttributeChanged = function (e) {
            if (_this.swapChain) {
                var object = e.target;
                var attrName = e.attrName, newValue = e.newValue;
                if (attrName === 'zIndex') {
                    object.parentNode.forEach(function (child) {
                        _this.batchManager.changeRenderOrder(child, child.sortable.renderOrder);
                    });
                }
                else {
                    _this.batchManager.updateAttribute(object, attrName, newValue);
                }
            }
        };
        var handleBoundsChanged = function (e) {
            if (_this.swapChain) {
                var object = e.target;
                _this.batchManager.updateAttribute(object, 'modelMatrix', null);
            }
        };
        renderingService.hooks.initAsync.tapPromise(RenderGraphPlugin.tag, function () { return tslib.__awaiter(_this, void 0, void 0, function () {
            var $canvas, width, height, _a;
            var _b;
            var _this = this;
            return tslib.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        canvas.addEventListener(gLite.ElementEvent.MOUNTED, handleMounted);
                        canvas.addEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);
                        canvas.addEventListener(gLite.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
                        canvas.addEventListener(gLite.ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
                        this.context.config.renderer.getConfig().enableDirtyRectangleRendering =
                            false;
                        $canvas = this.context.contextService.getDomElement();
                        width = (_b = this.context.config, _b.width), height = _b.height;
                        this.context.contextService.resize(width, height);
                        // create swap chain and get device
                        // @ts-ignore
                        _a = this;
                        return [4 /*yield*/, this.context.deviceContribution.createSwapChain($canvas)];
                    case 1:
                        // create swap chain and get device
                        // @ts-ignore
                        _a.swapChain = _c.sent();
                        this.device = this.swapChain.getDevice();
                        this.renderHelper.setDevice(this.device);
                        this.renderHelper.renderInstManager.disableSimpleMode();
                        this.swapChain.configureSwapChain($canvas.width, $canvas.height);
                        canvas.addEventListener(gLite.CanvasEvent.RESIZE, function () {
                            _this.swapChain.configureSwapChain($canvas.width, $canvas.height);
                        });
                        this.batchManager.attach(tslib.__assign({ device: this.device }, context));
                        return [2 /*return*/];
                }
            });
        }); });
        renderingService.hooks.destroy.tap(RenderGraphPlugin.tag, function () {
            _this.renderHelper.destroy();
            canvas.removeEventListener(gLite.ElementEvent.MOUNTED, handleMounted);
            canvas.removeEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);
            canvas.removeEventListener(gLite.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
            canvas.removeEventListener(gLite.ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
        /**
         * build frame graph at the beginning of each frame
         */
        renderingService.hooks.beginFrame.tap(RenderGraphPlugin.tag, function () {
            var canvas = _this.swapChain.getCanvas();
            var renderInstManager = _this.renderHelper.renderInstManager;
            _this.builder = _this.renderHelper.renderGraph.newGraphBuilder();
            var clearColor;
            if (_this.context.config.background === 'transparent') {
                clearColor = TransparentBlack;
            }
            else {
                // use canvas.background
                var backgroundColor = gLite.parseColor(_this.context.config.background);
                clearColor = _this.context.config.background
                    ? // use premultipliedAlpha
                        // @see https://canvatechblog.com/alpha-blending-and-webgl-99feb392779e
                        colorNewFromRGBA((Number(backgroundColor.r) / 255) * Number(backgroundColor.alpha), (Number(backgroundColor.g) / 255) * Number(backgroundColor.alpha), (Number(backgroundColor.b) / 255) * Number(backgroundColor.alpha), Number(backgroundColor.alpha))
                    : TransparentWhite;
            }
            // retrieve at each frame since canvas may resize
            var renderInput = {
                backbufferWidth: canvas.width,
                backbufferHeight: canvas.height,
                antialiasingMode: exports.AntialiasingMode.None,
            };
            // create main Color RT
            var mainRenderDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.Color0, renderInput, makeAttachmentClearDescriptor(clearColor));
            // create main Depth RT
            var mainDepthDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.DepthStencil, renderInput, opaqueWhiteFullClearRenderPassDescriptor);
            var mainColorTargetID = _this.builder.createRenderTargetID(mainRenderDesc, 'Main Color');
            var mainDepthTargetID = _this.builder.createRenderTargetID(mainDepthDesc, 'Main Depth');
            // main render pass
            _this.builder.pushPass(function (pass) {
                pass.setDebugName('Main Render Pass');
                pass.attachRenderTargetID(exports.RGAttachmentSlot.Color0, mainColorTargetID);
                pass.attachRenderTargetID(exports.RGAttachmentSlot.DepthStencil, mainDepthTargetID);
                pass.exec(function (passRenderer) {
                    _this.renderLists.world.drawOnPassRenderer(renderInstManager.renderCache, passRenderer);
                });
            });
            // TODO: other post-processing passes
            // FXAA
            // pushFXAAPass(
            //   this.builder,
            //   this.renderHelper,
            //   renderInput,
            //   mainColorTargetID,
            // );
            // output to screen
            _this.builder.resolveRenderTargetToExternalTexture(mainColorTargetID, _this.swapChain.getOnscreenTexture());
        });
        renderingService.hooks.endFrame.tap(RenderGraphPlugin.tag, function () {
            var _a, _b;
            var renderInstManager = _this.renderHelper.renderInstManager;
            // TODO: time for GPU Animation
            // const timeInMilliseconds = window.performance.now();
            // Push our outer template, which contains the dynamic UBO bindings...
            var template = _this.renderHelper.pushTemplateRenderInst();
            // SceneParams: binding = 0, ObjectParams: binding = 1
            template.setBindingLayouts([{ numUniformBuffers: 2, numSamplers: 0 }]);
            template.setMegaStateFlags(setAttachmentStateSimple({
                depthWrite: true,
                blendConstant: TransparentBlack,
            }, {
                rgbBlendMode: exports.BlendMode.Add,
                alphaBlendMode: exports.BlendMode.Add,
                rgbBlendSrcFactor: exports.BlendFactor.SrcAlpha,
                alphaBlendSrcFactor: exports.BlendFactor.One,
                rgbBlendDstFactor: exports.BlendFactor.OneMinusSrcAlpha,
                alphaBlendDstFactor: exports.BlendFactor.OneMinusSrcAlpha,
            }));
            // Update Scene Params
            var width = (_a = _this.context.config, _a.width), height = _a.height;
            var camera = _this.context.camera;
            template.setUniforms(SceneUniformBufferIndex, [
                {
                    name: SceneUniform.PROJECTION_MATRIX,
                    value: camera.getPerspective(),
                },
                {
                    name: SceneUniform.VIEW_MATRIX,
                    value: camera.getViewTransform(),
                },
                {
                    name: SceneUniform.CAMERA_POSITION,
                    value: camera.getPosition(),
                },
                {
                    name: SceneUniform.DEVICE_PIXEL_RATIO,
                    value: _this.context.contextService.getDPR(),
                },
                {
                    name: SceneUniform.VIEWPORT,
                    value: [width, height],
                },
                {
                    name: SceneUniform.IS_ORTHO,
                    value: camera.isOrtho() ? 1 : 0,
                },
                {
                    name: SceneUniform.IS_PICKING,
                    value: 0,
                },
            ]);
            _this.batchManager.render(_this.renderLists.world);
            renderInstManager.popTemplateRenderInst();
            _this.renderHelper.prepareToRender();
            _this.renderHelper.renderGraph.execute();
            renderInstManager.resetRenderInsts();
            // capture here since we don't preserve drawing buffer
            if (_this.enableCapture && _this.resolveCapturePromise) {
                var type = (_b = _this.captureOptions, _b.type), encoderOptions = _b.encoderOptions;
                var dataURL = _this.context.contextService.getDomElement().toDataURL(type, encoderOptions);
                _this.resolveCapturePromise(dataURL);
                _this.enableCapture = false;
                _this.captureOptions = undefined;
                _this.resolveCapturePromise = undefined;
            }
        });
    };
    /**
     * load texture in an async way and render when loaded
     */
    RenderGraphPlugin.prototype.loadTexture = function (src, descriptor, successCallback) {
        return this.texturePool.getOrCreateTexture(this.device, src, descriptor, function (t) {
            if (successCallback) {
                successCallback(t);
            }
        });
    };
    RenderGraphPlugin.prototype.toDataURL = function (options) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib.__generator(this, function (_a) {
                // trigger re-render
                this.enableCapture = true;
                this.captureOptions = options;
                this.capturePromise = new Promise(function (resolve) {
                    _this.resolveCapturePromise = function (dataURL) {
                        resolve(dataURL);
                    };
                });
                return [2 /*return*/, this.capturePromise];
            });
        });
    };
    RenderGraphPlugin.tag = 'RenderGraph';
    return RenderGraphPlugin;
}());

/**
 * max depth when doing multi-layer picking
 */
var MAX_PICKING_DEPTH = 100;
/**
 * Use color-based picking in GPU
 */
var PickingPlugin = /** @class */ (function () {
    function PickingPlugin(renderHelper, renderGraphPlugin, pickingIdGenerator, batchManager) {
        this.renderHelper = renderHelper;
        this.renderGraphPlugin = renderGraphPlugin;
        this.pickingIdGenerator = pickingIdGenerator;
        this.batchManager = batchManager;
    }
    PickingPlugin.prototype.apply = function (context) {
        var _this = this;
        this.context = context;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var handleMounted = function (e) {
            var object = e.target;
            // @ts-ignore
            if (!object.renderable3D) {
                // @ts-ignore
                object.renderable3D = new Renderable3D();
            }
            // @ts-ignore
            var renderable3D = object.renderable3D;
            // generate picking id for later use
            var pickingId = _this.pickingIdGenerator.getId(object);
            renderable3D.pickingId = pickingId;
            renderable3D.encodedPickingColor =
                _this.pickingIdGenerator.encodePickingColor(pickingId);
        };
        renderingService.hooks.init.tap(PickingPlugin.tag, function () {
            canvas.addEventListener(gLite.ElementEvent.MOUNTED, handleMounted);
        });
        renderingService.hooks.destroy.tap(PickingPlugin.tag, function () {
            canvas.removeEventListener(gLite.ElementEvent.MOUNTED, handleMounted);
        });
        /**
         * Sync version is not implemented.
         */
        renderingService.hooks.pickSync.tap(PickingPlugin.tag, function (result) {
            return _this.pick(result);
        });
        renderingService.hooks.pick.tapPromise(PickingPlugin.tag, function (result) { return tslib.__awaiter(_this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, this.pick(result)];
            });
        }); });
    };
    PickingPlugin.prototype.pick = function (result) {
        var topmost = result.topmost, position = result.position;
        // use viewportX/Y
        var x = position.viewportX, y = position.viewportY;
        var dpr = this.context.contextService.getDPR();
        var width = this.context.config.width * dpr;
        var height = this.context.config.height * dpr;
        var xInDevicePixel = x * dpr;
        var yInDevicePixel = y * dpr;
        if (!this.renderHelper.renderGraph ||
            xInDevicePixel > width ||
            xInDevicePixel < 0 ||
            yInDevicePixel > height ||
            yInDevicePixel < 0) {
            result.picked = [];
            return result;
        }
        // implements multi-layer picking
        // @see https://github.com/antvis/g/issues/948
        var pickedDisplayObjects = this.pickByRectangleInDepth(new gLite.Rectangle(util.clamp(Math.round(xInDevicePixel), 0, width - 1), util.clamp(Math.round(yInDevicePixel), 0, height - 1), 1, 1), topmost ? 1 : MAX_PICKING_DEPTH);
        result.picked = pickedDisplayObjects;
        return result;
    };
    PickingPlugin.prototype.pickByRectangleInDepth = function (rect, depth) {
        if (depth === void 0) { depth = MAX_PICKING_DEPTH; }
        var picked = null;
        var counter = 1;
        var targets = [];
        do {
            picked = this.pickByRectangle(rect, picked);
            if (picked) {
                counter++;
                targets.push(picked);
            }
            else {
                break;
            }
        } while (picked && counter <= depth);
        if (depth > 1) {
            // restore encoded picking color
            this.restorePickingColor(targets);
        }
        return targets;
    };
    PickingPlugin.prototype.restorePickingColor = function (displayObjects) {
        var _this = this;
        displayObjects.forEach(function (picked) {
            _this.batchManager.updateAttribute(picked, 'pointerEvents', true, true);
        });
    };
    /**
     * return displayobjects in target rectangle
     */
    PickingPlugin.prototype.pickByRectangle = function (rect, picked) {
        var _a;
        var _this = this;
        var device = this.renderGraphPlugin.getDevice();
        var renderLists = this.renderGraphPlugin.getRenderLists();
        var renderInstManager = this.renderHelper.renderInstManager;
        var builder = this.renderHelper.renderGraph.newGraphBuilder();
        var clearColor = TransparentBlack;
        var camera = this.context.camera;
        // retrieve at each frame since canvas may resize
        var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
        // use a small picking area(like 1x1) instead of a fullscreen rt
        var renderInput = {
            backbufferWidth: width,
            backbufferHeight: height,
            antialiasingMode: exports.AntialiasingMode.None,
        };
        var mainPickingDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.Color0, renderInput, makeAttachmentClearDescriptor(clearColor));
        var pickingColorTargetID = builder.createRenderTargetID(mainPickingDesc, 'Picking Color');
        // create main Depth RT
        var mainDepthDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.DepthStencil, renderInput, opaqueWhiteFullClearRenderPassDescriptor);
        var mainDepthTargetID = builder.createRenderTargetID(mainDepthDesc, 'Picking Depth');
        // account for current view offset
        var currentView = tslib.__assign({}, camera.getView());
        // prevent unused RTs like main color being destroyed
        this.renderHelper.renderGraph.renderTargetDeadPool.forEach(function (rt) {
            rt.age = -1;
        });
        // picking pass
        var target;
        builder.pushPass(function (pass) {
            pass.setDebugName('Picking Pass');
            pass.attachRenderTargetID(exports.RGAttachmentSlot.Color0, pickingColorTargetID);
            pass.attachRenderTargetID(exports.RGAttachmentSlot.DepthStencil, mainDepthTargetID);
            pass.exec(function (passRenderer) {
                renderLists.picking.drawOnPassRenderer(renderInstManager.renderCache, passRenderer);
            });
            pass.post(function (scope) {
                var texture = scope.getRenderTargetTexture(exports.RGAttachmentSlot.Color0);
                var readback = device.createReadback();
                // restore previous view
                if (currentView && currentView.enabled) {
                    camera.setViewOffset(currentView.fullWidth, currentView.fullHeight, currentView.offsetX, currentView.offsetY, currentView.width, currentView.height);
                }
                else {
                    camera.clearViewOffset();
                }
                camera.setEnableUpdate(true);
                var pickedColors = readback.readTextureSync(texture, 0, 0, width, height, new Uint8Array(width * height * 4));
                var pickedFeatureIdx = -1;
                if (pickedColors &&
                    (pickedColors[0] !== 0 ||
                        pickedColors[1] !== 0 ||
                        pickedColors[2] !== 0)) {
                    pickedFeatureIdx =
                        _this.pickingIdGenerator.decodePickingColor(pickedColors);
                }
                if (pickedFeatureIdx > -1) {
                    var pickedDisplayObject = _this.pickingIdGenerator.getById(pickedFeatureIdx);
                    if (pickedDisplayObject &&
                        pickedDisplayObject.isVisible() &&
                        pickedDisplayObject.isInteractive()) {
                        target = pickedDisplayObject;
                    }
                }
                readback.destroy();
            });
        });
        // Push our outer template, which contains the dynamic UBO bindings...
        var template = this.renderHelper.pushTemplateRenderInst();
        // SceneParams: binding = 0, ObjectParams: binding = 1
        template.setBindingLayouts([{ numUniformBuffers: 2, numSamplers: 0 }]);
        template.setMegaStateFlags(setAttachmentStateSimple({
            depthWrite: true,
        }, {
            rgbBlendMode: exports.BlendMode.Add,
            rgbBlendSrcFactor: exports.BlendFactor.One,
            rgbBlendDstFactor: exports.BlendFactor.Zero,
            alphaBlendMode: exports.BlendMode.Add,
            alphaBlendSrcFactor: exports.BlendFactor.One,
            alphaBlendDstFactor: exports.BlendFactor.Zero,
        }));
        // Update Scene Params
        var canvasWidth = (_a = this.context.config, _a.width), canvasHeight = _a.height;
        var dpr = this.context.contextService.getDPR();
        camera.setEnableUpdate(false);
        camera.setViewOffset(canvasWidth * dpr, canvasHeight * dpr, x, y, width, height);
        template.setUniforms(SceneUniformBufferIndex, [
            {
                name: SceneUniform.PROJECTION_MATRIX,
                value: camera.getPerspective(),
            },
            {
                name: SceneUniform.VIEW_MATRIX,
                value: camera.getViewTransform(),
            },
            {
                name: SceneUniform.CAMERA_POSITION,
                value: camera.getPosition(),
            },
            {
                name: SceneUniform.DEVICE_PIXEL_RATIO,
                value: this.context.contextService.getDPR(),
            },
            {
                name: SceneUniform.VIEWPORT,
                value: [canvasWidth, canvasHeight],
            },
            {
                name: SceneUniform.IS_ORTHO,
                value: camera.isOrtho() ? 1 : 0,
            },
            {
                name: SceneUniform.IS_PICKING,
                value: 1,
            },
        ]);
        if (picked) {
            this.batchManager.updateAttribute(picked, 'pointerEvents', false, true);
        }
        this.batchManager.render(renderLists.picking, true);
        renderInstManager.popTemplateRenderInst();
        this.renderHelper.prepareToRender();
        this.renderHelper.renderGraph.execute();
        renderInstManager.resetRenderInsts();
        return target;
    };
    PickingPlugin.tag = 'WebGLPicker';
    return PickingPlugin;
}());

/**
 * render order start from 0, our default camera's Z is 500
 */
var RENDER_ORDER_SCALE = 1 / 200;
/**
 * A container for multiple display objects with the same `style`,
 * eg. 1000 Circles with the same stroke color, but their position, radius can be different
 */
var Batch = /** @class */ (function () {
    function Batch() {
        /**
         * describe render insts used in this draw call
         * eg. a Polygon with stroke will use 2 renderInsts
         */
        this.meshes = [];
        this.clipPathMeshCreated = false;
        // private findClipPath(): DisplayObject | null {
        //   let node = this.instance;
        //   while (node && node.style) {
        //     if (node.style.clipPath) {
        //       return node.style.clipPath;
        //     }
        //     node = node.parentNode as DisplayObject;
        //   }
        //   return null;
        // }
        // private applyClipPath() {
        //   // find clipPath
        //   const clipPathShape = this.findClipPath();
        //   if (clipPathShape && !this.clipPathMeshCreated) {
        //     if (this.batchMeshList.length === 0) {
        //       return;
        //     }
        //     const clipPathMesh = this.meshFactory(clipPathShape.nodeName);
        //     clipPathMesh.clipPathTarget = this.instance;
        //     // draw clipPath first
        //     this.batchMeshList.unshift(clipPathMesh);
        //     this.clipPathMeshCreated = true;
        //     this.batchMeshList.forEach((mesh, i) => {
        //       mesh.clipPath = clipPathShape;
        //       if (!mesh.material) {
        //         mesh.material = new ShaderMaterial(this.device);
        //       }
        //       mesh.material.stencilRef = this.batchManager.getStencilRef(clipPathShape);
        //     });
        //   }
        //   // remove clipPath from render queue
        //   if (!clipPathShape) {
        //     if (this.batchMeshList.length && this.batchMeshList[0].clipPathTarget) {
        //       this.batchMeshList.shift();
        //     }
        //   }
        // }
    }
    Batch.prototype.shouldSubmitRenderInst = function (object, index) {
        return true;
    };
    Batch.prototype.beforeUploadUBO = function (renderInst, mesh, index) { };
    Batch.prototype.beforeInitMesh = function (mesh) { };
    Batch.prototype.afterInitMesh = function (mesh) { };
    return Batch;
}());

function makeDataBuffer(device, usage, data, hint) {
    if (hint === void 0) { hint = exports.BufferFrequencyHint.Static; }
    var buffer = device.createBuffer({
        viewOrSize: data.byteLength,
        usage: usage,
        hint: hint,
    });
    buffer.setSubData(0, new Uint8Array(data));
    return buffer;
}
exports.GeometryEvent = void 0;
(function (GeometryEvent) {
    GeometryEvent["CHANGED"] = "changed";
})(exports.GeometryEvent || (exports.GeometryEvent = {}));
/**
 * just hold descriptors of buffers & indices, won't use underlying GPU resources
 */
var BufferGeometry = /** @class */ (function (_super) {
    tslib.__extends(BufferGeometry, _super);
    function BufferGeometry(device, props) {
        if (props === void 0) { props = {}; }
        var _this = _super.call(this) || this;
        _this.device = device;
        _this.props = props;
        /**
         * 绘制模式
         */
        _this.drawMode = exports.PrimitiveTopology.Triangles;
        /**
         * 存放 Attribute Buffer 列表
         */
        _this.vertexBuffers = [];
        _this.vertices = [];
        _this.inputLayoutDescriptor = {
            vertexBufferDescriptors: [],
            vertexAttributeDescriptors: [],
            indexBufferFormat: exports.Format.U32_R,
        };
        _this.vertexCount = 0;
        _this.instancedCount = 0;
        _this.indexStart = 0;
        _this.primitiveStart = 0;
        _this.dirty = true;
        _this.meshes = [];
        return _this;
    }
    BufferGeometry.prototype.validate = function (mesh) {
        return true;
    };
    BufferGeometry.prototype.build = function (meshes) { };
    BufferGeometry.prototype.computeBoundingBox = function () {
        return new gLite.AABB();
    };
    BufferGeometry.prototype.setIndexBuffer = function (indices) {
        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }
        this.indexBuffer = makeDataBuffer(this.device, exports.BufferUsage.INDEX, new Uint32Array(ArrayBuffer.isView(indices) ? indices.buffer : indices)
            .buffer);
        this.indices = indices;
        return this;
    };
    BufferGeometry.prototype.setVertexBuffer = function (descriptor) {
        var _this = this;
        var bufferIndex = descriptor.bufferIndex, byteStride = descriptor.byteStride, frequency = descriptor.frequency, attributes = descriptor.attributes, data = descriptor.data;
        this.inputLayoutDescriptor.vertexBufferDescriptors[bufferIndex] = {
            byteStride: byteStride,
            frequency: frequency,
        };
        this.vertices[bufferIndex] = data;
        attributes.forEach(function (_a) {
            var format = _a.format, bufferByteOffset = _a.bufferByteOffset, location = _a.location, divisor = _a.divisor, byteStride = _a.byteStride;
            var existed = _this.inputLayoutDescriptor.vertexAttributeDescriptors.find(function (e) { return e.bufferIndex === bufferIndex && e.location === location; });
            if (existed) {
                existed.format = format;
                existed.bufferByteOffset = bufferByteOffset;
                existed.byteStride = byteStride;
                existed.divisor = divisor;
            }
            else {
                _this.inputLayoutDescriptor.vertexAttributeDescriptors.push({
                    format: format,
                    bufferIndex: bufferIndex,
                    bufferByteOffset: bufferByteOffset,
                    location: location,
                    byteStride: byteStride,
                    divisor: divisor,
                });
            }
        });
        // create GPUBuffer
        if (this.vertexBuffers[bufferIndex]) {
            this.vertexBuffers[bufferIndex].destroy();
        }
        var buffer = makeDataBuffer(this.device, exports.BufferUsage.VERTEX, data.buffer, exports.BufferFrequencyHint.Dynamic);
        this.vertexBuffers[bufferIndex] = buffer;
        return this;
    };
    BufferGeometry.prototype.getVertexBuffer = function (bufferIndex) {
        return this.vertexBuffers[bufferIndex];
    };
    BufferGeometry.prototype.updateVertexBuffer = function (bufferIndex, location, index, data) {
        var byteStride = this.inputLayoutDescriptor.vertexBufferDescriptors[bufferIndex].byteStride;
        var descriptor = this.inputLayoutDescriptor.vertexAttributeDescriptors.find(function (d) { return d.location === location; });
        if (descriptor) {
            var vertexBuffer = this.getVertexBuffer(bufferIndex);
            var offset = index * byteStride;
            vertexBuffer.setSubData(descriptor.bufferByteOffset + offset, data);
            // TODO: update vertices
            // this.vertices[bufferIndex] = data;
        }
        this.emit(exports.GeometryEvent.CHANGED);
    };
    BufferGeometry.prototype.updateIndices = function (indices, offset) {
        if (offset === void 0) { offset = 0; }
        if (this.indexBuffer) {
            this.indexBuffer.setSubData(offset, new Uint8Array(ArrayBuffer.isView(indices) ? indices : new Uint32Array(indices)));
        }
        return this;
    };
    BufferGeometry.prototype.destroy = function () {
        this.vertexBuffers.forEach(function (buffer) {
            if (buffer) {
                buffer.destroy();
            }
        });
        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }
        this.inputLayoutDescriptor.vertexAttributeDescriptors = [];
        this.inputLayoutDescriptor.vertexBufferDescriptors = [];
        this.indexBuffer = undefined;
        this.vertexBuffers = [];
        this.indices = undefined;
        this.vertices = [];
        this.vertexCount = 0;
        this.instancedCount = 0;
    };
    return BufferGeometry;
}(EventEmitter));

function isTexture(t) {
    return !!(t && t.type);
}
exports.MaterialEvent = void 0;
(function (MaterialEvent) {
    MaterialEvent["CHANGED"] = "changed";
})(exports.MaterialEvent || (exports.MaterialEvent = {}));
/**
 * an encapsulation on top of shaders
 * @see https://doc.babylonjs.com/divingDeeper/materials/using/materials_introduction
 */
var Material = /** @class */ (function (_super) {
    tslib.__extends(Material, _super);
    function Material(device, props) {
        var _this = _super.call(this) || this;
        _this.props = {};
        /**
         * relative meshes
         */
        _this.meshes = [];
        // USE_XXX
        _this.defines = {};
        _this.uniforms = {};
        _this.uboBuffer = [];
        _this.textures = {};
        _this.samplers = [];
        /**
         * need re-compiling like vs/fs changed
         */
        _this.programDirty = true;
        /**
         * need re-upload textures
         */
        _this.textureDirty = true;
        /**
         * inform geometry to rebuild, eg. wireframe
         */
        _this.geometryDirty = true;
        var _a = copyMegaState(defaultMegaState), cullMode = _a.cullMode, depthCompare = _a.depthCompare, depthWrite = _a.depthWrite, stencilCompare = _a.stencilCompare, stencilWrite = _a.stencilWrite, stencilPassOp = _a.stencilPassOp, frontFace = _a.frontFace, polygonOffset = _a.polygonOffset, attachmentsState = _a.attachmentsState;
        _this.device = device;
        // @ts-ignore
        _this.props = tslib.__assign({ cullMode: cullMode, depthTest: true, depthCompare: depthCompare, depthWrite: depthWrite, stencilCompare: stencilCompare, stencilWrite: stencilWrite, stencilPassOp: stencilPassOp, frontFace: frontFace, polygonOffset: polygonOffset, attachmentsState: attachmentsState, dithering: false, wireframe: false, wireframeColor: 'black', wireframeLineWidth: 1, vertexShader: '', fragmentShader: '' }, props);
        _this.compile();
        return _this;
    }
    Object.defineProperty(Material.prototype, "cullMode", {
        /**
         * cullFace
         */
        get: function () {
            return this.props.cullMode;
        },
        set: function (value) {
            this.props.cullMode = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "frontFace", {
        get: function () {
            return this.props.frontFace;
        },
        set: function (value) {
            this.props.frontFace = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendConstant", {
        /**
         * Blending state
         */
        get: function () {
            return this.props.blendConstant;
        },
        set: function (value) {
            this.props.blendConstant = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendEquation", {
        get: function () {
            return this.props.blendEquation;
        },
        set: function (value) {
            this.props.blendEquation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendEquationAlpha", {
        get: function () {
            return this.props.blendEquationAlpha;
        },
        set: function (value) {
            this.props.blendEquationAlpha = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendSrc", {
        get: function () {
            return this.props.blendSrc;
        },
        set: function (value) {
            this.props.blendSrc = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendDst", {
        get: function () {
            return this.props.blendDst;
        },
        set: function (value) {
            this.props.blendDst = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendSrcAlpha", {
        get: function () {
            return this.props.blendSrcAlpha;
        },
        set: function (value) {
            this.props.blendSrcAlpha = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendDstAlpha", {
        get: function () {
            return this.props.blendDstAlpha;
        },
        set: function (value) {
            this.props.blendDstAlpha = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthCompare", {
        get: function () {
            return this.props.depthCompare;
        },
        set: function (value) {
            this.props.depthCompare = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthTest", {
        get: function () {
            return this.props.depthTest;
        },
        set: function (value) {
            this.props.depthTest = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthWrite", {
        get: function () {
            return this.props.depthWrite;
        },
        set: function (value) {
            this.props.depthWrite = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilCompare", {
        get: function () {
            return this.props.stencilCompare;
        },
        set: function (value) {
            this.props.stencilCompare = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilWrite", {
        get: function () {
            return this.props.stencilWrite;
        },
        set: function (value) {
            this.props.stencilWrite = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilPassOp", {
        get: function () {
            return this.props.stencilPassOp;
        },
        set: function (value) {
            this.props.stencilPassOp = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilRef", {
        get: function () {
            return this.props.stencilRef;
        },
        set: function (value) {
            this.props.stencilRef = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "polygonOffset", {
        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/polygonOffset
        get: function () {
            return this.props.polygonOffset;
        },
        set: function (value) {
            this.props.polygonOffset = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "dithering", {
        // gl.DITHER
        get: function () {
            return this.props.dithering;
        },
        set: function (value) {
            this.props.dithering = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "wireframe", {
        // @see https://doc.babylonjs.com/divingDeeper/materials/using/materials_introduction#wireframe
        get: function () {
            return this.props.wireframe;
        },
        set: function (value) {
            if (this.props.wireframe !== value) {
                // need re-generate geometry
                this.geometryDirty = true;
                this.programDirty = true;
                this.props.wireframe = value;
                this.dispatchMutationEvent();
            }
            this.defines.USE_WIREFRAME = !!value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "wireframeColor", {
        get: function () {
            return this.props.wireframeColor;
        },
        set: function (value) {
            this.props.wireframeColor = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "wireframeLineWidth", {
        get: function () {
            return this.props.wireframeLineWidth;
        },
        set: function (value) {
            this.props.wireframeLineWidth = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "vertexShader", {
        // shader pairs
        get: function () {
            return this.props.vertexShader;
        },
        set: function (value) {
            if (this.props.vertexShader !== value) {
                this.programDirty = true;
                this.props.vertexShader = value;
                this.compile();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "fragmentShader", {
        get: function () {
            return this.props.fragmentShader;
        },
        set: function (value) {
            if (this.props.fragmentShader !== value) {
                this.programDirty = true;
                this.props.fragmentShader = value;
                this.compile();
            }
        },
        enumerable: false,
        configurable: true
    });
    Material.prototype.compile = function () {
        var _this = this;
        // uniform sampler2D u_Texture0;
        this.props.fragmentShader.replace(/^\s*uniform\s*sampler2D\s*(.*)\s*;$/gm, function (_, name) {
            _this.samplers.push(name);
            return '';
        });
        /**
         * extract from uniform buffer object, should account for struct & pre-defines, eg.
         * layout(std140) uniform ub_ObjectParams {
         *   mat4 u_ModelMatrix;
         *   vec4 u_Color;
         *   vec4 u_StrokeColor;
         *   #ifdef NUM_DIR_LIGHTS
         *     DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
         *   #endif
         * }
         */
        this.uniformNames = getUniforms(this.props.fragmentShader);
    };
    /**
     * @example
     * material.setUniforms({
     *   u_ModelMatrix: [1, 2, 3, 4],
     *   u_Time: 1,
     *   u_Map: texture,
     * })
     */
    Material.prototype.setUniforms = function (uniforms) {
        var _this = this;
        var shoudDispatchMutationEvent = false;
        Object.keys(uniforms).forEach(function (key) {
            var value = uniforms[key];
            var existedTexture = _this.textures[key];
            if (existedTexture && existedTexture !== value) {
                // existedTexture.destroy();
                _this.textureDirty = true;
            }
            if (isTexture(value)) {
                _this.textures[key] = value;
                _this.textureDirty = true;
                value.on(exports.TextureEvent.LOADED, function () {
                    _this.dispatchMutationEvent();
                });
            }
            else {
                _this.uniforms[key] = value;
                shoudDispatchMutationEvent = true;
            }
            if (util.isNil(uniforms[key])) {
                delete _this.textures[key];
                delete _this.uniforms[key];
            }
        });
        if (shoudDispatchMutationEvent) {
            this.dispatchMutationEvent();
        }
    };
    Material.prototype.dispatchMutationEvent = function () {
        this.emit(exports.MaterialEvent.CHANGED);
    };
    return Material;
}(EventEmitter));

var ShaderMaterial = /** @class */ (function (_super) {
    tslib.__extends(ShaderMaterial, _super);
    function ShaderMaterial(device, props) {
        var _this = _super.call(this, device, tslib.__assign({}, props)) || this;
        _this.defines = tslib.__assign(tslib.__assign({}, _this.defines), { USE_UV: false, USE_MAP: false, USE_WIREFRAME: false, USE_FOG: false, USE_LIGHT: false });
        return _this;
    }
    return ShaderMaterial;
}(Material));

function enumToObject(enumObject) {
    var result = {};
    Object.keys(enumObject).forEach(function (key) {
        if (typeof enumObject[key] === 'number') {
            result[key] = enumObject[key];
        }
    });
    return result;
}
function compareDefines(d1, d2) {
    var d1Keys = Object.keys(d1);
    var d2Keys = Object.keys(d2);
    if (d1Keys.length !== d2Keys.length) {
        return false;
    }
    return d1Keys.every(function (key) { return d1[key] === d2[key]; });
}
var definedProps = function (obj) {
    return Object.fromEntries(Object.entries(obj).filter(function (_a) {
        var _b = tslib.__read(_a, 2); _b[0]; var v = _b[1];
        return v !== undefined;
    }));
};

function packUint8ToFloat(a, b) {
    a = util.clamp(Math.floor(a), 0, 255);
    b = util.clamp(Math.floor(b), 0, 255);
    return 256 * a + b;
}

var counter = 1;
var FILL_TEXTURE_MAPPING = 'FillTextureMapping';
/**
 * WebGPU has max vertex attribute num(8)
 */
exports.VertexAttributeBufferIndex = void 0;
(function (VertexAttributeBufferIndex) {
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["MODEL_MATRIX"] = 0] = "MODEL_MATRIX";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["PACKED_COLOR"] = 1] = "PACKED_COLOR";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["PACKED_STYLE"] = 2] = "PACKED_STYLE";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["PICKING_COLOR"] = 3] = "PICKING_COLOR";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["POSITION"] = 4] = "POSITION";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["NORMAL"] = 5] = "NORMAL";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["UV"] = 6] = "UV";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["BARYCENTRIC"] = 7] = "BARYCENTRIC";
    VertexAttributeBufferIndex[VertexAttributeBufferIndex["MAX"] = 8] = "MAX";
})(exports.VertexAttributeBufferIndex || (exports.VertexAttributeBufferIndex = {}));
/**
 * GL.MAX_VERTEX_ATTRIBS
 */
exports.VertexAttributeLocation = void 0;
(function (VertexAttributeLocation) {
    // TODO: bind mat4 in WebGL2 instead of decomposed 4 * vec4?
    // @see https://stackoverflow.com/questions/38853096/webgl-how-to-bind-values-to-a-mat4-attribute/38853623#38853623
    VertexAttributeLocation[VertexAttributeLocation["MODEL_MATRIX0"] = 0] = "MODEL_MATRIX0";
    VertexAttributeLocation[VertexAttributeLocation["MODEL_MATRIX1"] = 1] = "MODEL_MATRIX1";
    VertexAttributeLocation[VertexAttributeLocation["MODEL_MATRIX2"] = 2] = "MODEL_MATRIX2";
    VertexAttributeLocation[VertexAttributeLocation["MODEL_MATRIX3"] = 3] = "MODEL_MATRIX3";
    VertexAttributeLocation[VertexAttributeLocation["PACKED_COLOR"] = 4] = "PACKED_COLOR";
    VertexAttributeLocation[VertexAttributeLocation["PACKED_STYLE1"] = 5] = "PACKED_STYLE1";
    VertexAttributeLocation[VertexAttributeLocation["PACKED_STYLE2"] = 6] = "PACKED_STYLE2";
    VertexAttributeLocation[VertexAttributeLocation["PICKING_COLOR"] = 7] = "PICKING_COLOR";
    VertexAttributeLocation[VertexAttributeLocation["POSITION"] = 8] = "POSITION";
    VertexAttributeLocation[VertexAttributeLocation["NORMAL"] = 9] = "NORMAL";
    VertexAttributeLocation[VertexAttributeLocation["UV"] = 10] = "UV";
    VertexAttributeLocation[VertexAttributeLocation["BARYCENTRIC"] = 11] = "BARYCENTRIC";
    VertexAttributeLocation[VertexAttributeLocation["MAX"] = 12] = "MAX";
})(exports.VertexAttributeLocation || (exports.VertexAttributeLocation = {}));
/**
 * Draw call.
 */
var Instanced = /** @class */ (function () {
    function Instanced(renderHelper, texturePool, lightPool, object) {
        this.renderHelper = renderHelper;
        this.texturePool = texturePool;
        this.lightPool = lightPool;
        /**
         * unique ID
         */
        this.id = counter++;
        /**
         * index in renderer.meshes
         */
        this.index = -1;
        /**
         * instances
         */
        this.objects = [];
        this.program = new DeviceProgram();
        this.geometryDirty = true;
        /**
         * the same material maybe shared between different canvases
         */
        this.materialDirty = true;
        this.inputStateDirty = true;
        /**
         * texture mappings
         */
        this.textureMappings = [];
        /**
         * Receiving light e.g. Mesh.
         */
        this.lightReceived = false;
        /**
         * Divisor of instanced array.
         */
        this.divisor = 1;
        /**
         * Account for anchor and merge it into modelMatrix.
         */
        this.mergeAnchorIntoModelMatrix = false;
        /**
         * Create a new batch if the number of instances exceeds.
         */
        this.maxInstances = 5000;
        this.inited = false;
    }
    Object.defineProperty(Instanced.prototype, "instance", {
        get: function () {
            return this.objects[0];
        },
        enumerable: false,
        configurable: true
    });
    Instanced.prototype.init = function (context) {
        if (this.inited) {
            return;
        }
        this.renderer.beforeInitMesh(this);
        this.context = context;
        this.material = new ShaderMaterial(this.context.device);
        this.material.defines = tslib.__assign(tslib.__assign({}, enumToObject(exports.VertexAttributeLocation)), this.material.defines);
        this.geometry = new BufferGeometry(this.context.device);
        // make refs so that we can trigger MutationEvent on every object
        this.geometry.meshes = this.objects;
        this.material.meshes = this.objects;
        this.observeGeometryChanged();
        this.observeMaterialChanged();
        this.inited = true;
        this.renderer.afterInitMesh(this);
    };
    Instanced.prototype.observeGeometryChanged = function () {
        var _this = this;
        this.geometry.on(exports.GeometryEvent.CHANGED, function () {
            _this.geometry.meshes.forEach(function (mesh) {
                mesh.renderable.dirty = true;
            });
            _this.context.renderingService.dirtify();
        });
    };
    Instanced.prototype.observeMaterialChanged = function () {
        var _this = this;
        this.material.on(exports.MaterialEvent.CHANGED, function () {
            _this.material.meshes.forEach(function (mesh) {
                mesh.renderable.dirty = true;
            });
            _this.context.renderingService.dirtify();
        });
    };
    Instanced.prototype.shouldMergeColor = function (o1, o2, name) {
        // c1: CSSRGB | CSSGradientValue[] | Pattern, c2: CSSRGB | CSSGradientValue[] | Pattern
        // can't be merged if gradients & pattern used
        var source = o1.parsedStyle[name];
        var target = o2.parsedStyle[name];
        // constant color value
        if (gLite.isCSSRGB(source) && gLite.isCSSRGB(target)) {
            return true;
        }
        // pattern
        if (gLite.isPattern(source) &&
            gLite.isPattern(target) &&
            source.image === target.image) {
            return true;
        }
        // gradients
        if (Array.isArray(source) &&
            Array.isArray(target) &&
            o1.style[name] === o2.style[name]) {
            return true;
        }
        return false;
    };
    /**
     * should be merged into current InstancedMesh
     */
    Instanced.prototype.shouldMerge = function (object, index) {
        if (!this.instance) {
            return true;
        }
        // Path / Polyline could be rendered as Line
        if (this.instance.nodeName !== object.nodeName &&
            this.instance.nodeName !== object.renderable.proxyNodeName &&
            this.instance.renderable.proxyNodeName !== object.nodeName &&
            this.instance.renderable.proxyNodeName !== object.renderable.proxyNodeName) {
            return false;
        }
        // can't be merged when using clipPath
        if (object.parsedStyle.clipPath) {
            return false;
        }
        if (!this.shouldMergeColor(this.instance, object, 'fill') ||
            !this.shouldMergeColor(this.instance, object, 'stroke')) {
            return false;
        }
        return true;
    };
    Instanced.prototype.createGeometry = function (objects) {
        var _this = this;
        var modelMatrix = glMatrix.mat4.create();
        var modelViewMatrix = glMatrix.mat4.create();
        // const normalMatrix = mat3.create();
        var packedModelMatrix = [];
        var packedFillStroke = [];
        var packedStyle = [];
        var packedPicking = [];
        var divisor = this.divisor;
        // const useNormal = this.material.defines.NORMAL;
        objects.forEach(function (object) {
            var _a;
            var _b = object.parsedStyle, fill = _b.fill, stroke = _b.stroke, opacity = _b.opacity, fillOpacity = _b.fillOpacity, strokeOpacity = _b.strokeOpacity, lineWidth = _b.lineWidth, anchor = _b.anchor, visibility = _b.visibility, increasedLineWidthForHitTesting = _b.increasedLineWidthForHitTesting;
            var fillColor = [0, 0, 0, 0];
            if (gLite.isCSSRGB(fill)) {
                fillColor = [
                    Number(fill.r),
                    Number(fill.g),
                    Number(fill.b),
                    Number(fill.alpha) * 255,
                ];
            }
            var strokeColor = [0, 0, 0, 0];
            if (gLite.isCSSRGB(stroke)) {
                strokeColor = [
                    Number(stroke.r),
                    Number(stroke.g),
                    Number(stroke.b),
                    Number(stroke.alpha) * 255,
                ];
            }
            // if (this.clipPathTarget) {
            //   // account for target's rts
            //   mat4.copy(modelMatrix, object.getLocalTransform());
            //   fillColor = [255, 255, 255, 255];
            //   mat4.mul(
            //     modelMatrix,
            //     this.clipPathTarget.getWorldTransform(),
            //     modelMatrix,
            //   );
            // } else {
            //   mat4.copy(modelMatrix, object.getWorldTransform());
            // }
            glMatrix.mat4.mul(modelViewMatrix, _this.context.camera.getViewTransform(), modelMatrix);
            var encodedPickingColor = (object.isInteractive() &&
                (
                // @ts-ignore
                (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];
            if (_this.mergeAnchorIntoModelMatrix) {
                var anchor_1 = object.parsedStyle.anchor;
                var translateX = 0;
                var translateY = 0;
                var translateZ = 0;
                var contentBounds = object.getGeometryBounds();
                if (contentBounds) {
                    var halfExtents = contentBounds.halfExtents;
                    translateX = -halfExtents[0] * anchor_1[0] * 2;
                    translateY = -halfExtents[1] * anchor_1[1] * 2;
                    translateZ = -halfExtents[2] * (anchor_1[2] || 0) * 2;
                }
                glMatrix.mat4.mul(modelMatrix, object.getWorldTransform(), // apply anchor
                glMatrix.mat4.fromTranslation(modelMatrix, glMatrix.vec3.fromValues(translateX, translateY, translateZ)));
            }
            else {
                glMatrix.mat4.copy(modelMatrix, object.getWorldTransform());
            }
            packedModelMatrix.push.apply(packedModelMatrix, tslib.__spreadArray([], tslib.__read(modelMatrix), false));
            packedFillStroke.push(packUint8ToFloat(fillColor[0], fillColor[1]), packUint8ToFloat(fillColor[2], fillColor[3]), packUint8ToFloat(strokeColor[0], strokeColor[1]), packUint8ToFloat(strokeColor[2], strokeColor[3]));
            packedStyle.push(opacity, fillOpacity, strokeOpacity, lineWidth, visibility === 'visible' ? 1 : 0, anchor[0], anchor[1], increasedLineWidthForHitTesting || 0);
            packedPicking.push.apply(packedPicking, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(encodedPickingColor), false), [object.sortable.renderOrder * RENDER_ORDER_SCALE], false));
            // if (useNormal) {
            //   // should not calc normal matrix in shader, mat3.invert is not cheap
            //   // @see https://stackoverflow.com/a/21079741
            //   mat3.fromMat4(normalMatrix, modelViewMatrix);
            //   mat3.invert(normalMatrix, normalMatrix);
            //   mat3.transpose(normalMatrix, normalMatrix);
            //   const { NORMAL_MATRIX0, NORMAL_MATRIX1, NORMAL_MATRIX2 } = this.material.defines;
            //   this.bufferGeometry.setVertexBuffer({
            //     bufferIndex: 4,
            //     byteStride: 4 * (3 * 3),
            //     frequency: VertexBufferFrequency.PerInstance,
            //     attributes: [
            //       {
            //         format: Format.F32_RGB,
            //         bufferByteOffset: 4 * 0,
            //         location: Number(NORMAL_MATRIX0),
            //         divisor
            //       },
            //       {
            //         format: Format.F32_RGB,
            //         bufferByteOffset: 4 * 3,
            //         location: Number(NORMAL_MATRIX1),
            //         divisor
            //       },
            //       {
            //         format: Format.F32_RGB,
            //         bufferByteOffset: 4 * 6,
            //         location: Number(NORMAL_MATRIX2),
            //         divisor
            //       },
            //     ],
            //     data: new Float32Array(normalMatrix),
            //   });
            // }
        });
        this.geometry.instancedCount = objects.length;
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.MODEL_MATRIX,
            byteStride: 4 * (4 * 4),
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX0,
                    divisor: divisor,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 4,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX1,
                    divisor: divisor,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 8,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX2,
                    divisor: divisor,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 12,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX3,
                    divisor: divisor,
                },
            ],
            data: new Float32Array(packedModelMatrix),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.PACKED_COLOR,
            byteStride: 4 * 4,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.PACKED_COLOR,
                    divisor: divisor,
                },
            ],
            data: new Float32Array(packedFillStroke),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.PACKED_STYLE,
            byteStride: 4 * 8,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.PACKED_STYLE1,
                    divisor: divisor,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 4,
                    location: exports.VertexAttributeLocation.PACKED_STYLE2,
                    divisor: divisor,
                },
            ],
            data: new Float32Array(packedStyle),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.PICKING_COLOR,
            byteStride: 4 * 4,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.PICKING_COLOR,
                    divisor: divisor,
                },
            ],
            data: new Float32Array(packedPicking),
        });
    };
    Instanced.prototype.destroy = function () {
        if (this.geometry) {
            this.geometry.destroy();
        }
        if (this.inputState) {
            this.inputState.destroy();
        }
    };
    Instanced.prototype.applyRenderInst = function (renderInst, objects) {
        var _this = this;
        // detect if scene changed, eg. lights & fog
        var lights = this.lightPool.getAllLights();
        var fog = this.lightPool.getFog();
        var useFog = !!fog;
        var useLight = !!lights.length;
        if (this.clipPathTarget || this.clipPath) {
            if (this.clipPathTarget) {
                this.material.stencilWrite = true;
                // @see https://open.gl/depthstencils
                this.material.depthWrite = false;
                this.material.stencilCompare = exports.CompareMode.Always;
                this.material.stencilPassOp = exports.StencilOp.Replace;
            }
            else {
                this.material.stencilWrite = false;
                this.material.depthWrite = true;
                this.material.stencilCompare = exports.CompareMode.Equal;
                this.material.stencilPassOp = exports.StencilOp.Keep;
            }
        }
        else {
            this.material.stencilWrite = false;
        }
        if (this.materialDirty || this.material.programDirty) {
            this.createMaterial(objects);
        }
        var oldDefines = tslib.__assign({}, this.material.defines);
        this.material.defines.USE_FOG = useFog;
        this.material.defines.USE_LIGHT = useLight;
        this.material.defines = tslib.__assign(tslib.__assign(tslib.__assign({}, this.material.defines), this.lightPool.getDefines()), this.renderHelper.getDefines());
        // re-upload textures
        if (this.material.textureDirty) {
            this.textureMappings = [];
            // set texture mappings
            var fillTextureMapping = this.createFillGradientTextureMapping(objects);
            if (fillTextureMapping) {
                this.textureMappings.push(fillTextureMapping);
            }
            Object.keys(this.material.textures)
                .sort(function (a, b) {
                return _this.material.samplers.indexOf(a) -
                    _this.material.samplers.indexOf(b);
            })
                .forEach(function (key) {
                var mapping = new TextureMapping();
                mapping.name = key;
                mapping.texture = _this.material.textures[key];
                _this.context.device.setResourceName(mapping.texture, 'Material Texture ' + key);
                mapping.sampler = _this.renderHelper.getCache().createSampler({
                    wrapS: exports.WrapMode.Clamp,
                    wrapT: exports.WrapMode.Clamp,
                    minFilter: exports.TexFilterMode.Point,
                    magFilter: exports.TexFilterMode.Bilinear,
                    mipFilter: exports.MipFilterMode.Linear,
                    minLOD: 0,
                    maxLOD: 0,
                });
                _this.textureMappings.push(mapping);
            });
            if (this.textureMappings.length) {
                this.material.defines.USE_UV = true;
                this.material.defines.USE_MAP = true;
            }
            else {
                this.material.defines.USE_UV = false;
                this.material.defines.USE_MAP = false;
            }
            this.material.textureDirty = false;
        }
        var needRecompileProgram = !compareDefines(oldDefines, this.material.defines);
        // re-compile program, eg. DEFINE changed
        if (needRecompileProgram ||
            this.material.programDirty ||
            this.materialDirty) {
            // set defines
            this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(exports.VertexAttributeLocation));
            Object.keys(this.material.defines).forEach(function (key) {
                var value = _this.material.defines[key];
                if (typeof value === 'boolean') {
                    _this.program.setDefineBool(key, value);
                }
                else {
                    _this.program.setDefineString(key, "".concat(value));
                }
            });
            // build shaders
            this.program.vert = this.material.vertexShader;
            this.program.frag = this.material.fragmentShader;
            // use cached program
            this.programDescriptorSimpleWithOrig = preprocessProgramObj_GLSL(this.context.device, this.program);
            this.material.programDirty = false;
            this.materialDirty = false;
        }
        if (this.material.geometryDirty) {
            // wireframe 需要额外生成 geometry 重心坐标
            this.geometryDirty = true;
            this.inputStateDirty = true;
            this.material.geometryDirty = false;
        }
        if (this.geometryDirty || this.geometry.dirty) {
            // destroy first
            if (this.geometry) {
                this.geometry.destroy();
            }
            // re-create buffer geometry
            this.createGeometry(objects);
            // generate wireframe
            if (this.material.wireframe) {
                this.generateWireframe(this.geometry);
            }
            // sync to internal Geometry
            this.geometryDirty = false;
            this.geometry.dirty = false;
            this.inputStateDirty = true;
        }
        // cached input layout
        var inputLayout = this.renderHelper
            .getCache()
            .createInputLayout(this.geometry.inputLayoutDescriptor);
        var program = this.renderHelper
            .getCache()
            .createProgramSimple(this.programDescriptorSimpleWithOrig);
        var useIndexes = !!this.geometry.indexBuffer;
        // prevent rebinding VAO too many times
        if (this.inputStateDirty) {
            if (this.inputState) {
                this.inputState.destroy();
            }
            this.inputState = this.context.device.createInputState(inputLayout, this.geometry.vertexBuffers.map(function (buffer) { return ({
                buffer: buffer,
                byteOffset: 0,
            }); }), useIndexes
                ? { buffer: this.geometry.indexBuffer, byteOffset: 0 }
                : null, program);
            this.inputStateDirty = false;
        }
        renderInst.renderPipelineDescriptor.topology = this.geometry.drawMode;
        renderInst.setProgram(program);
        renderInst.setInputLayoutAndState(inputLayout, this.inputState);
        this.renderer.beforeUploadUBO(renderInst, this, this.index);
        // upload uniform buffer object
        this.uploadUBO(renderInst);
        if (useIndexes) {
            // drawElements
            renderInst.drawIndexesInstanced(this.geometry.vertexCount, this.geometry.instancedCount, this.geometry.indexStart);
        }
        else {
            // drawArrays
            renderInst.drawPrimitives(this.geometry.vertexCount, this.geometry.primitiveStart);
        }
        // FIXME: 暂时都当作非透明物体，按照创建顺序排序
        renderInst.sortKey = makeSortKeyOpaque(exports.RendererLayer.OPAQUE, objects[0].sortable.renderOrder);
    };
    /**
     * update a continuous GPU buffer
     */
    Instanced.prototype.updateBatchedAttribute = function (objects, startIndex, name, value) {
        var _this = this;
        var stylePacked = [
            'opacity',
            'fillOpacity',
            'strokeOpacity',
            'lineWidth',
            'visibility',
            'anchor',
            'increasedLineWidthForHitTesting',
        ];
        if (name === 'fill' || name === 'stroke') {
            var packedFillStroke_1 = [];
            objects.forEach(function (object) {
                var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke;
                var fillColor = [0, 0, 0, 0];
                if (gLite.isCSSRGB(fill)) {
                    fillColor = [
                        Number(fill.r),
                        Number(fill.g),
                        Number(fill.b),
                        Number(fill.alpha) * 255,
                    ];
                }
                var strokeColor = [0, 0, 0, 0];
                if (gLite.isCSSRGB(stroke)) {
                    strokeColor = [
                        Number(stroke.r),
                        Number(stroke.g),
                        Number(stroke.b),
                        Number(stroke.alpha) * 255,
                    ];
                }
                packedFillStroke_1.push(packUint8ToFloat(fillColor[0], fillColor[1]), packUint8ToFloat(fillColor[2], fillColor[3]), packUint8ToFloat(strokeColor[0], strokeColor[1]), packUint8ToFloat(strokeColor[2], strokeColor[3]));
            });
            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PACKED_COLOR, exports.VertexAttributeLocation.PACKED_COLOR, startIndex, new Uint8Array(new Float32Array(packedFillStroke_1).buffer));
            var fill = this.instance.parsedStyle.fill;
            var i = this.textureMappings.findIndex(function (m) { return m.name === FILL_TEXTURE_MAPPING; });
            if (gLite.isCSSRGB(fill)) {
                if (i >= 0) {
                    // remove original fill texture mapping
                    this.textureMappings.splice(i, -1);
                    this.material.textureDirty = true;
                }
            }
            else {
                var fillTextureMapping = this.createFillGradientTextureMapping([
                    this.instance,
                ]);
                if (i >= 0) {
                    this.textureMappings.splice(i, 1, fillTextureMapping);
                }
                this.material.textureDirty = true;
            }
        }
        else if (stylePacked.indexOf(name) > -1) {
            var packed_1 = [];
            objects.forEach(function (object) {
                var _a = object.parsedStyle, opacity = _a.opacity, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity, lineWidth = _a.lineWidth, visibility = _a.visibility, anchor = _a.anchor, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting;
                packed_1.push(opacity, fillOpacity, strokeOpacity, lineWidth, visibility === 'visible' ? 1 : 0, anchor[0], anchor[1], increasedLineWidthForHitTesting || 0);
            });
            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PACKED_STYLE, exports.VertexAttributeLocation.PACKED_STYLE1, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));
        }
        else if (name === 'modelMatrix') {
            var packed_2 = [];
            var modelMatrix_1 = glMatrix.mat4.create();
            objects.forEach(function (object) {
                if (_this.mergeAnchorIntoModelMatrix) {
                    var anchor = object.parsedStyle.anchor;
                    var translateX = 0;
                    var translateY = 0;
                    var translateZ = 0;
                    var contentBounds = object.getGeometryBounds();
                    if (contentBounds) {
                        var halfExtents = contentBounds.halfExtents;
                        translateX = -halfExtents[0] * anchor[0] * 2;
                        translateY = -halfExtents[1] * anchor[1] * 2;
                        translateZ = -halfExtents[2] * (anchor[2] || 0) * 2;
                    }
                    glMatrix.mat4.mul(modelMatrix_1, object.getWorldTransform(), // apply anchor
                    glMatrix.mat4.fromTranslation(modelMatrix_1, glMatrix.vec3.fromValues(translateX, translateY, translateZ)));
                }
                else {
                    glMatrix.mat4.copy(modelMatrix_1, object.getWorldTransform());
                }
                packed_2.push.apply(packed_2, tslib.__spreadArray([], tslib.__read(modelMatrix_1), false));
            });
            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.MODEL_MATRIX, exports.VertexAttributeLocation.MODEL_MATRIX0, startIndex, new Uint8Array(new Float32Array(packed_2).buffer));
        }
        else if (name === 'pointerEvents') {
            var packed_3 = [];
            objects.forEach(function (object) {
                var _a;
                var encodedPickingColor = (value &&
                    object.isInteractive() &&
                    (
                    // @ts-ignore
                    (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];
                packed_3.push.apply(packed_3, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(encodedPickingColor), false), [object.sortable.renderOrder * RENDER_ORDER_SCALE], false));
            });
            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PICKING_COLOR, exports.VertexAttributeLocation.PICKING_COLOR, startIndex, new Uint8Array(new Float32Array(packed_3).buffer));
        }
    };
    Instanced.prototype.updateAttribute = function (objects, startIndex, name, value) {
        if (name === 'clipPath') {
            if (this.clipPath) {
                this.geometryDirty = true;
            }
        }
    };
    Instanced.prototype.changeRenderOrder = function (object, renderOrder) {
        var _a;
        var index = this.objects.indexOf(object);
        var encodedPickingColor = (object.isInteractive() &&
            (
            // @ts-ignore
            (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];
        this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PICKING_COLOR, exports.VertexAttributeLocation.PICKING_COLOR, index, new Uint8Array(new Float32Array(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(encodedPickingColor), false), [
            renderOrder * RENDER_ORDER_SCALE,
        ], false)).buffer));
    };
    Instanced.prototype.generateWireframe = function (geometry) {
        // need generate barycentric coordinates
        var indices = geometry.indices;
        var indiceNum = geometry.indices.length;
        var originalVertexBuffers = geometry.vertices.map(function (buffer) {
            // @ts-ignore
            return buffer.slice();
        });
        for (var i = exports.VertexAttributeBufferIndex.PICKING_COLOR; i < geometry.vertexBuffers.length; i++) {
            var byteStride = geometry.inputLayoutDescriptor.vertexBufferDescriptors[i].byteStride;
            geometry.vertices[i] = new Float32Array((byteStride / 4) * indiceNum);
        }
        // reallocate attribute data
        var cursor = 0;
        var uniqueIndices = new Uint32Array(indiceNum);
        for (var i = 0; i < indiceNum; i++) {
            var ii = indices[i];
            for (var j = 1; j < geometry.vertices.length; j++) {
                var byteStride = geometry.inputLayoutDescriptor.vertexBufferDescriptors[j].byteStride;
                var size = byteStride / 4;
                for (var k = 0; k < size; k++) {
                    geometry.vertices[j][cursor * size + k] =
                        originalVertexBuffers[j][ii * size + k];
                }
            }
            uniqueIndices[i] = cursor;
            cursor++;
        }
        var _loop_1 = function (i) {
            // if (i === 3) {
            //   continue;
            // }
            var _a = geometry.inputLayoutDescriptor.vertexBufferDescriptors[i], frequency = _a.frequency, byteStride = _a.byteStride;
            var descriptor = geometry.inputLayoutDescriptor.vertexAttributeDescriptors.find(function (_a) {
                var bufferIndex = _a.bufferIndex;
                return bufferIndex === i;
            });
            if (descriptor) {
                var location_1 = descriptor.location, bufferIndex = descriptor.bufferIndex, bufferByteOffset = descriptor.bufferByteOffset, format = descriptor.format, divisor = descriptor.divisor;
                geometry.setVertexBuffer({
                    bufferIndex: bufferIndex,
                    byteStride: byteStride,
                    frequency: frequency,
                    attributes: [
                        {
                            format: format,
                            bufferByteOffset: bufferByteOffset,
                            location: location_1,
                            divisor: divisor,
                        },
                    ],
                    data: geometry.vertices[i],
                });
            }
        };
        for (var i = exports.VertexAttributeBufferIndex.PICKING_COLOR + 1; i < geometry.vertexBuffers.length; i++) {
            _loop_1(i);
        }
        // create barycentric attributes
        var barycentricBuffer = new Float32Array(indiceNum * 3);
        for (var i = 0; i < indiceNum;) {
            for (var j = 0; j < 3; j++) {
                var ii = uniqueIndices[i++];
                barycentricBuffer[ii * 3 + j] = 1;
            }
        }
        geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.BARYCENTRIC,
            byteStride: 4 * 3,
            frequency: exports.VertexBufferFrequency.PerVertex,
            attributes: [
                {
                    format: exports.Format.F32_RGB,
                    bufferByteOffset: 4 * 0,
                    location: Number(exports.VertexAttributeLocation.BARYCENTRIC),
                },
            ],
            data: barycentricBuffer,
        });
        geometry.setIndexBuffer(uniqueIndices);
    };
    Instanced.prototype.beforeUploadUBO = function (renderInst, objects, i) { };
    Instanced.prototype.uploadUBO = function (renderInst) {
        var _this = this;
        var numUniformBuffers = 1; // Scene UBO
        var material = this.material;
        var lights = this.lightPool.getAllLights();
        var fog = this.lightPool.getFog();
        var useFog = !!fog;
        var useLight = this.lightReceived && !!lights.length;
        var useWireframe = material.defines.USE_WIREFRAME;
        // collect uniforms
        var uniforms = [];
        if (useWireframe) {
            var wireframeColor = gLite.parseColor(material.wireframeColor);
            uniforms.push({
                name: 'u_WireframeLineColor',
                value: [
                    Number(wireframeColor.r) / 255,
                    Number(wireframeColor.g) / 255,
                    Number(wireframeColor.b) / 255,
                ],
            });
            uniforms.push({
                name: 'u_WireframeLineWidth',
                value: material.wireframeLineWidth,
            });
        }
        if (useFog) {
            this.uploadFog(uniforms, fog);
        }
        this.uploadMaterial(uniforms, material);
        if (useLight) {
            var counter_1 = {};
            lights.forEach(function (light) {
                if (!counter_1[light.define]) {
                    counter_1[light.define] = -1;
                }
                counter_1[light.define]++;
                light.uploadUBO(uniforms, counter_1[light.define]);
            });
        }
        uniforms.sort(function (a, b) {
            return _this.material.uniformNames.indexOf(a.name) -
                _this.material.uniformNames.indexOf(b.name);
        });
        // TODO: should not upload all uniforms if no change
        renderInst.setUniforms(numUniformBuffers, uniforms);
        var depthCompare = material.depthCompare, depthWrite = material.depthWrite, stencilCompare = material.stencilCompare, stencilWrite = material.stencilWrite, stencilPassOp = material.stencilPassOp, stencilRef = material.stencilRef, cullMode = material.cullMode, frontFace = material.frontFace, polygonOffset = material.polygonOffset, blendConstant = material.blendConstant, blendEquation = material.blendEquation, blendEquationAlpha = material.blendEquationAlpha, blendSrc = material.blendSrc, blendDst = material.blendDst, blendSrcAlpha = material.blendSrcAlpha, blendDstAlpha = material.blendDstAlpha;
        var materialMegaState = definedProps({
            blendConstant: blendConstant,
            depthCompare: depthCompare,
            depthWrite: depthWrite,
            stencilCompare: stencilCompare,
            stencilWrite: stencilWrite,
            stencilPassOp: stencilPassOp,
            stencilRef: stencilRef,
            cullMode: cullMode,
            frontFace: frontFace,
            polygonOffset: polygonOffset,
        });
        var currentAttachmentsState = renderInst.getMegaStateFlags().attachmentsState[0];
        renderInst.setMegaStateFlags(tslib.__assign({ attachmentsState: [
                {
                    // should not affect color buffer when drawing stencil
                    channelWriteMask: this.material.stencilWrite
                        ? exports.ChannelWriteMask.None
                        : exports.ChannelWriteMask.AllChannels,
                    // channelWriteMask: ChannelWriteMask.AllChannels,
                    rgbBlendState: tslib.__assign(tslib.__assign({}, currentAttachmentsState.rgbBlendState), definedProps({
                        blendMode: blendEquation,
                        blendSrcFactor: blendSrc,
                        blendDstFactor: blendDst,
                    })),
                    alphaBlendState: tslib.__assign(tslib.__assign({}, currentAttachmentsState.alphaBlendState), definedProps({
                        blendMode: blendEquationAlpha,
                        blendSrcFactor: blendSrcAlpha,
                        blendDstFactor: blendDstAlpha,
                    })),
                },
            ] }, materialMegaState));
        renderInst.setBindingLayouts([
            {
                numUniformBuffers: numUniformBuffers,
                numSamplers: this.textureMappings.length,
                samplerEntries: this.samplerEntries,
            },
        ]);
        renderInst.setSamplerBindingsFromTextureMappings(this.textureMappings);
    };
    Instanced.prototype.uploadFog = function (uniforms, fog) {
        var _a = fog.parsedStyle, type = _a.type, fill = _a.fill, start = _a.start, end = _a.end, density = _a.density;
        if (gLite.isCSSRGB(fill)) {
            var fillColor = [
                Number(fill.r) / 255,
                Number(fill.g) / 255,
                Number(fill.b) / 255,
                Number(fill.alpha),
            ];
            uniforms.push({
                name: 'u_FogInfos',
                value: [type, start, end, density],
            });
            uniforms.push({
                name: 'u_FogColor',
                value: fillColor,
            });
        }
    };
    Instanced.prototype.uploadMaterial = function (uniforms, material) {
        // sort
        var materialUniforms = Object.keys(material.uniforms).map(function (name) { return ({
            name: name,
            value: material.uniforms[name],
        }); });
        uniforms.push.apply(uniforms, tslib.__spreadArray([], tslib.__read(materialUniforms), false));
    };
    Instanced.prototype.createFillGradientTextureMapping = function (objects) {
        var _this = this;
        var instance = objects[0];
        var fill = (instance.nodeName === gLite.Shape.LINE
            ? instance.parsedStyle.stroke
            : instance.parsedStyle.fill);
        var texImageSource;
        // use pattern & gradient
        if (fill && (gLite.isPattern(fill) || Array.isArray(fill))) {
            if (Array.isArray(fill)) {
                this.program.setDefineBool('USE_PATTERN', false);
                this.texturePool.getOrCreateGradient({
                    gradients: fill,
                    width: 128,
                    height: 128,
                    instance: instance,
                });
            }
            else if (gLite.isPattern(fill)) {
                this.program.setDefineBool('USE_PATTERN', true);
                this.texturePool.getOrCreatePattern(fill, instance, function () {
                    // need re-render
                    objects.forEach(function (object) {
                        object.renderable.dirty = true;
                    });
                    _this.material.textureDirty = true;
                });
            }
            texImageSource = this.texturePool.getOrCreateCanvas();
            var texture = this.texturePool.getOrCreateTexture(this.context.device, texImageSource, makeTextureDescriptor2D(exports.Format.U8_RGBA_NORM, 1, 1, 1));
            if (texture) {
                var fillMapping = new TextureMapping();
                fillMapping.name = FILL_TEXTURE_MAPPING;
                fillMapping.texture = texture;
                fillMapping.texture.on('loaded', function () {
                    // need re-render
                    objects.forEach(function (object) {
                        object.renderable.dirty = true;
                    });
                    _this.material.textureDirty = true;
                });
                this.context.device.setResourceName(fillMapping.texture, 'Fill Texture' + this.id);
                fillMapping.sampler = this.renderHelper.getCache().createSampler({
                    wrapS: exports.WrapMode.Repeat,
                    wrapT: exports.WrapMode.Repeat,
                    minFilter: exports.TexFilterMode.Point,
                    magFilter: exports.TexFilterMode.Bilinear,
                    mipFilter: exports.MipFilterMode.Linear,
                    minLOD: 0,
                    maxLOD: 0,
                });
                return fillMapping;
            }
        }
        return null;
    };
    return Instanced;
}());

var frag$6 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n\nin vec3 v_Data;\nin vec2 v_Radius;\nin vec4 v_StylePacked3;\n\nout vec4 outputColor;\n\n/**\n * 2D signed distance field functions\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n */\n\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// @see http://www.iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\nfloat sdEllipsoidApproximated(vec2 p, vec2 r) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\n// @see https://www.shadertoy.com/view/4llXD7\nfloat sdRoundedBox(vec2 p, vec2 b, float r) {\n  p = abs(p) - b + r;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0) - r;\n}\n\nvoid main() {\n  int shape = int(floor(v_StylePacked3.x + 0.5));\n  float epsilon = 0.000001;\n\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n  #ifdef USE_MAP\n  #ifdef USE_PATTERN\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #else\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #endif\n#endif\n\n  bool omitStroke = v_StylePacked3.z == 1.0;\n\n  float antialiasblur = v_Data.z;\n  float antialiased_blur = -max(0.0, antialiasblur);\n  vec2 r = (v_Radius - (omitStroke ? 0.0 : u_StrokeWidth)) / v_Radius.y;\n  float wh = v_Radius.x / v_Radius.y;\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'ellipse', 'rect'\n  if (shape == 0) {\n    outer_df = sdCircle(v_Data.xy, 1.0);\n    inner_df = sdCircle(v_Data.xy, r.x);\n  } else if (shape == 1) {\n    outer_df = sdEllipsoidApproximated(v_Data.xy, vec2(wh, 1.0));\n    inner_df = sdEllipsoidApproximated(v_Data.xy, r);\n  } else if (shape == 2) {\n    bool useRadius = v_StylePacked3.y > epsilon;\n    outer_df = sdRoundedBox(v_Data.xy, vec2(wh, 1.0), useRadius ? (v_StylePacked3.y + u_StrokeWidth / 2.0) / v_Radius.y : 0.0);\n    inner_df = sdRoundedBox(v_Data.xy, r, useRadius ? (v_StylePacked3.y - u_StrokeWidth / 2.0) / v_Radius.y : 0.0);\n  }\n\n  float opacity_t = smoothstep(0.0, antialiased_blur, outer_df);\n\n  float color_t = u_StrokeWidth < 0.01 ? 0.0 : smoothstep(\n    antialiased_blur,\n    0.0,\n    inner_df\n  );\n\n  vec4 diffuseColor;\n  vec4 strokeColor;\n  if (u_IsPicking > 0.5) {\n    diffuseColor = vec4(u_PickingColor, 1.0);\n    strokeColor = vec4(u_PickingColor, 1.0);\n  } else {\n    diffuseColor = u_Color;\n    strokeColor = (u_StrokeColor == vec4(0) || omitStroke) ? vec4(0.0) : u_StrokeColor;\n  }\n\n  outputColor = mix(vec4(diffuseColor.rgb, diffuseColor.a * u_FillOpacity), strokeColor * u_StrokeOpacity, color_t);\n  outputColor.a = outputColor.a * u_Opacity * opacity_t;\n\n  if (outputColor.a < epsilon)\n    discard;\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n  }\n}"; // eslint-disable-line

var vert$5 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec2 a_Extrude;\n// shape, radius, omitStroke, isBillboard\nlayout(location = PACKED_STYLE3) in vec4 a_StylePacked3;\nlayout(location = SIZE) in vec2 a_Size;\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\n\nout vec3 v_Data;\nout vec2 v_Radius;\nout vec4 v_StylePacked3;\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n  #ifdef VIEWPORT_ORIGIN_TL\n    v_Uv.y = 1.0 - v_Uv.y;\n  #endif\n#endif\n\n  float strokeWidth;\n  if (u_IsPicking > 0.5) {\n    strokeWidth = u_IncreasedLineWidthForHitTesting + u_StrokeWidth;\n  } else {\n    strokeWidth = u_StrokeWidth;\n  }\n\n  bool omitStroke = a_StylePacked3.z == 1.0;\n  vec2 radius = a_Size + vec2(omitStroke ? 0.0 : strokeWidth / 2.0);\n  vec2 offset = (a_Extrude + vec2(1.0) - 2.0 * u_Anchor.xy) * a_Size + a_Extrude * vec2(omitStroke ? 0.0 : strokeWidth / 2.0);\n  float antialiasblur = 1.0 / radius.y;\n\n  bool isBillboard = a_StylePacked3.w > 0.5;\n  if (isBillboard) {\n    vec4 mvPosition = u_ViewMatrix * u_ModelMatrix * vec4(0.0, 0.0, u_ZIndex, 1.0);\nvec2 scale;\nscale.x = length(vec3(u_ModelMatrix[0][0], u_ModelMatrix[0][1], u_ModelMatrix[0][2]));\nscale.y = length(vec3(u_ModelMatrix[1][0], u_ModelMatrix[1][1], u_ModelMatrix[1][2]));\n\n// if (sizeAttenuation < 0.5) {\n// bool isPerspective = isPerspectiveMatrix( u_ProjectionMatrix );\n// if ( isPerspective ) scale *= - mvPosition.z;\n// }\n\nvec2 alignedPosition = offset * scale;\n\nfloat rotation = 0.0;\nvec2 rotatedPosition;\nrotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\nrotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\n\nmvPosition.xy += rotatedPosition;\n\ngl_Position = u_ProjectionMatrix * mvPosition;\n  } else {\n    gl_Position = project(vec4(offset, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n  }\n  \n  v_Radius = radius;\n  v_Data = vec3(a_Extrude * radius / radius.y, antialiasblur);\n  v_StylePacked3 = a_StylePacked3;\n}"; // eslint-disable-line

var SDFVertexAttributeBufferIndex;
(function (SDFVertexAttributeBufferIndex) {
    SDFVertexAttributeBufferIndex[SDFVertexAttributeBufferIndex["PACKED_STYLE"] = 5] = "PACKED_STYLE";
})(SDFVertexAttributeBufferIndex || (SDFVertexAttributeBufferIndex = {}));
var SDFVertexAttributeLocation;
(function (SDFVertexAttributeLocation) {
    SDFVertexAttributeLocation[SDFVertexAttributeLocation["PACKED_STYLE3"] = 12] = "PACKED_STYLE3";
    SDFVertexAttributeLocation[SDFVertexAttributeLocation["SIZE"] = 13] = "SIZE";
})(SDFVertexAttributeLocation || (SDFVertexAttributeLocation = {}));
var SDF_Shape = [gLite.Shape.CIRCLE, gLite.Shape.ELLIPSE, gLite.Shape.RECT];
/**
 * Use SDF to render 2D shapes, eg. circle, ellipse.
 * Use less triangles(2) and vertices compared with normal triangulation.
 */
var SDFMesh = /** @class */ (function (_super) {
    tslib.__extends(SDFMesh, _super);
    function SDFMesh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SDFMesh.prototype.shouldMerge = function (object, index) {
        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);
        if (!shouldMerge) {
            return false;
        }
        // if (
        //   this.needDrawStrokeSeparately(object.parsedStyle) ||
        //   this.needDrawStrokeSeparately(this.instance.parsedStyle)
        // ) {
        //   return false;
        // }
        // const { fill: instanceFill } = this.instance
        //   .parsedStyle as ParsedBaseStyleProps;
        // const { fill } = object.parsedStyle as ParsedBaseStyleProps;
        // if ((instanceFill as CSSRGB).isNone !== (fill as CSSRGB).isNone) {
        //   return false;
        // }
        return true;
    };
    SDFMesh.prototype.createMaterial = function (objects) {
        this.material.vertexShader = vert$5;
        this.material.fragmentShader = frag$6;
        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(SDFVertexAttributeLocation));
    };
    SDFMesh.prototype.createGeometry = function (objects) {
        var _this = this;
        // use default common attributes
        _super.prototype.createGeometry.call(this, objects);
        var instanced = [];
        objects.forEach(function (object, i) {
            var circle = object;
            // @ts-ignore
            var radius = circle.parsedStyle.radius;
            var omitStroke = _this.shouldOmitStroke(circle.parsedStyle);
            var size = _this.getSize(object.parsedStyle, circle.nodeName);
            instanced.push.apply(instanced, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(size), false), [SDF_Shape.indexOf(circle.nodeName),
                (radius && radius[0]) || 0,
                omitStroke ? 1 : 0,
                circle.parsedStyle.isBillboard ? 1 : 0], false));
        });
        this.geometry.setIndexBuffer(new Uint32Array([0, 2, 1, 0, 3, 2]));
        this.geometry.vertexCount = 6;
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.POSITION,
            byteStride: 4 * 4,
            frequency: exports.VertexBufferFrequency.PerVertex,
            attributes: [
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.POSITION,
                },
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 2,
                    location: exports.VertexAttributeLocation.UV,
                },
            ],
            data: new Float32Array([
                -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1,
            ]),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: SDFVertexAttributeBufferIndex.PACKED_STYLE,
            byteStride: 4 * 6,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 0,
                    location: SDFVertexAttributeLocation.SIZE,
                    divisor: 1,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 2,
                    location: SDFVertexAttributeLocation.PACKED_STYLE3,
                    divisor: 1,
                },
            ],
            data: new Float32Array(instanced),
        });
    };
    SDFMesh.prototype.updateAttribute = function (objects, startIndex, name, value) {
        var _this = this;
        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);
        this.updateBatchedAttribute(objects, startIndex, name, value);
        if (name === 'r' ||
            name === 'rx' ||
            name === 'ry' ||
            name === 'width' ||
            name === 'height' ||
            name === 'lineWidth' ||
            name === 'stroke' ||
            name === 'lineDash' ||
            name === 'strokeOpacity' ||
            name === 'radius' ||
            name === 'isBillboard') {
            var packed_1 = [];
            objects.forEach(function (object) {
                var circle = object;
                var omitStroke = _this.shouldOmitStroke(circle.parsedStyle);
                var _a = tslib.__read(_this.getSize(object.parsedStyle, object.nodeName), 2), halfWidth = _a[0], halfHeight = _a[1];
                var size = [halfWidth, halfHeight];
                packed_1.push.apply(packed_1, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(size), false), [SDF_Shape.indexOf(object.nodeName),
                    (object.parsedStyle.radius && object.parsedStyle.radius[0]) || 0,
                    omitStroke ? 1 : 0,
                    circle.parsedStyle.isBillboard ? 1 : 0], false));
            });
            this.geometry.updateVertexBuffer(SDFVertexAttributeBufferIndex.PACKED_STYLE, SDFVertexAttributeLocation.SIZE, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));
        }
    };
    SDFMesh.prototype.getSize = function (parsed, tagName) {
        var size = [0, 0];
        if (tagName === gLite.Shape.CIRCLE) {
            var r = parsed.r;
            size = [r, r];
        }
        else if (tagName === gLite.Shape.ELLIPSE) {
            var _a = parsed, rx = _a.rx, ry = _a.ry;
            size = [rx, ry];
        }
        else if (tagName === gLite.Shape.RECT) {
            var _b = parsed, width = _b.width, height = _b.height;
            size = [width / 2, height / 2];
        }
        return size;
    };
    SDFMesh.prototype.shouldOmitStroke = function (parsedStyle) {
        var lineDash = parsedStyle.lineDash, stroke = parsedStyle.stroke, strokeOpacity = parsedStyle.strokeOpacity;
        var hasStroke = stroke && !stroke.isNone;
        var hasLineDash = lineDash &&
            lineDash.length &&
            lineDash.every(function (item) { return item !== 0; });
        var hasStrokeOpacity = strokeOpacity < 1;
        return !hasStroke || (hasStroke && (hasLineDash || hasStrokeOpacity));
    };
    SDFMesh.prototype.needDrawStrokeSeparately = function (parsedStyle) {
        var stroke = parsedStyle.stroke, lineDash = parsedStyle.lineDash, lineWidth = parsedStyle.lineWidth, strokeOpacity = parsedStyle.strokeOpacity;
        var hasStroke = stroke && !stroke.isNone;
        var hasLineDash = lineDash &&
            lineDash.length &&
            lineDash.every(function (item) { return item !== 0; });
        var hasStrokeOpacity = strokeOpacity < 1;
        return hasStroke && lineWidth > 0 && (hasLineDash || hasStrokeOpacity);
    };
    return SDFMesh;
}(Instanced));

var frag$5 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n\nin vec4 v_Dash;\nin vec2 v_Distance;\n\nout vec4 outputColor;\n\nvoid main() {\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n  #ifdef USE_MAP\n  #ifdef USE_PATTERN\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #else\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #endif\n#endif\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n    outputColor = u_StrokeColor;\n    #ifdef USE_MAP\n        outputColor = u_Color;\n    #endif\n\n    float blur;\n    if (v_Distance.y < 1.0) {\n      blur = smoothstep(0.0, v_Distance.y, 1.0 - abs(v_Distance.x));\n    } else {\n      blur = 1.0 / v_Distance.y;\n    }\n    float u_dash_offset = v_Dash.y;\n    float u_dash_array = v_Dash.z;\n    float u_dash_ratio = v_Dash.w;\n\n    outputColor.a = outputColor.a\n      * blur\n      * u_Opacity * u_StrokeOpacity\n      * ceil(mod(v_Dash.x + u_dash_offset, u_dash_array) - (u_dash_array * u_dash_ratio));\n  }\n}"; // eslint-disable-line

var vert$4 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec3 a_Position;\nlayout(location = POINTA) in vec3 a_PointA;\nlayout(location = POINTB) in vec3 a_PointB;\nlayout(location = CAP) in float a_Cap;\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\nlayout(location = DASH) in vec4 a_Dash;\n\nout vec4 v_Dash;\nout vec2 v_Distance;\n\nbool isPerspectiveMatrix(mat4 m) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n  #ifdef VIEWPORT_ORIGIN_TL\n    v_Uv.y = 1.0 - v_Uv.y;\n  #endif\n#endif\n\n  float strokeWidth;\n  if (u_IsPicking > 0.5) {\n    strokeWidth = u_IncreasedLineWidthForHitTesting + u_StrokeWidth;\n  } else {\n    strokeWidth = u_StrokeWidth;\n  }\n  float clampedStrokeWidth = max(strokeWidth, 1.0);\n\n  float isBillboard = a_Dash.w;\n  bool isPerspective = isPerspectiveMatrix(u_ProjectionMatrix);\n\n  if (isBillboard > 0.5 && isPerspective) {\n    // clip space\n    vec4 clip0 = project(vec4(a_PointA, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n    vec4 clip1 = project(vec4(a_PointB, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n    // screen space\n    vec2 screen0 = u_Viewport * (0.5 * clip0.xy / clip0.w + 0.5);\n    vec2 screen1 = u_Viewport * (0.5 * clip1.xy / clip1.w + 0.5);\n    vec2 xBasis = normalize(screen1 - screen0);\n    vec2 yBasis = vec2(-xBasis.y, xBasis.x);\n    vec2 pt0 = screen0 + clampedStrokeWidth * (a_Position.x * xBasis + a_Position.y * yBasis);\n    vec2 pt1 = screen1 + clampedStrokeWidth * (a_Position.x * xBasis + a_Position.y * yBasis);\n    vec2 pt = mix(pt0, pt1, a_Position.z);\n    vec4 clip = mix(clip0, clip1, a_Position.z);\n    gl_Position = vec4(clip.w * (2.0 * pt / u_Viewport - 1.0), clip.z, clip.w);\n  } else {\n    vec2 xBasis = a_PointB.xy - a_PointA.xy;\n    vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n    vec2 point = a_PointA.xy + xBasis * a_Position.x + yBasis * clampedStrokeWidth * a_Position.y;\n    point = point - u_Anchor.xy * abs(xBasis);\n\n    // round & square\n    if (a_Cap > 1.0) {\n      point += sign(a_Position.x - 0.5) * normalize(xBasis) * vec2(clampedStrokeWidth / 2.0);\n    }\n    gl_Position = project(vec4(point, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n  }\n\n  float antialiasblur = 1.0 / strokeWidth;\n  v_Distance = vec2(a_Position.y * 2.0, antialiasblur);\n  v_Dash = vec4(a_Position.x, a_Dash.xyz);\n}"; // eslint-disable-line

var segmentInstanceGeometry = [
    0, -0.5, 0, 0, 0, 1, -0.5, 1, 1, 0, 1, 0.5, 1, 1, 1, 0, 0.5, 0, 0, 1,
];
var InstancedLineVertexAttributeBufferIndex;
(function (InstancedLineVertexAttributeBufferIndex) {
    InstancedLineVertexAttributeBufferIndex[InstancedLineVertexAttributeBufferIndex["POINT"] = 5] = "POINT";
    InstancedLineVertexAttributeBufferIndex[InstancedLineVertexAttributeBufferIndex["CAP"] = 6] = "CAP";
    InstancedLineVertexAttributeBufferIndex[InstancedLineVertexAttributeBufferIndex["DASH"] = 7] = "DASH";
})(InstancedLineVertexAttributeBufferIndex || (InstancedLineVertexAttributeBufferIndex = {}));
var InstancedLineVertexAttributeLocation;
(function (InstancedLineVertexAttributeLocation) {
    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation["POSITION"] = 8] = "POSITION";
    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation["UV"] = 10] = "UV";
    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation["POINTA"] = 9] = "POINTA";
    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation["POINTB"] = 11] = "POINTB";
    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation["CAP"] = 12] = "CAP";
    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation["DASH"] = 13] = "DASH";
})(InstancedLineVertexAttributeLocation || (InstancedLineVertexAttributeLocation = {}));
var LineCap_MAP = {
    butt: 1,
    round: 2,
    square: 3,
};
var InstancedLineMesh = /** @class */ (function (_super) {
    tslib.__extends(InstancedLineMesh, _super);
    function InstancedLineMesh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InstancedLineMesh.isLine = function (object) {
        if (object.nodeName === gLite.Shape.PATH) {
            var absolutePath = object.parsedStyle.path.absolutePath;
            // only contains M & L commands
            if (absolutePath.length === 2 &&
                absolutePath[0][0] === 'M' &&
                absolutePath[1][0] === 'L') {
                return true;
            }
        }
        else if (object.nodeName === gLite.Shape.POLYLINE) {
            var points = object.parsedStyle.points.points;
            var tangent = (points[1][0] - points[1][1]) / (points[0][0] - points[0][1]);
            for (var i = 1; i < points.length - 1; i++) {
                if ((points[i + 1][0] - points[i + 1][1]) /
                    (points[i][0] - points[i][1]) !==
                    tangent) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    InstancedLineMesh.prototype.shouldMerge = function (object, index) {
        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);
        if (!shouldMerge) {
            return false;
        }
        return true;
    };
    InstancedLineMesh.prototype.createMaterial = function (objects) {
        this.material.vertexShader = vert$4;
        this.material.fragmentShader = frag$5;
        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(InstancedLineVertexAttributeLocation));
    };
    InstancedLineMesh.prototype.createGeometry = function (objects) {
        var _this = this;
        // use default common attributes
        _super.prototype.createGeometry.call(this, objects);
        var interleaved = [];
        var packedCap = [];
        var packedDash = [];
        var indices = [];
        var offset = 0;
        objects.forEach(function (object) {
            var parsedLineStyleProps;
            var totalLength;
            if (object.nodeName === gLite.Shape.LINE) {
                parsedLineStyleProps = object.parsedStyle;
                totalLength = object.getTotalLength();
            }
            else if (object.nodeName === gLite.Shape.POLYLINE) {
                var _a = object.parsedStyle, points = _a.points.points, defX_1 = _a.defX, defY_1 = _a.defY, lineCap_1 = _a.lineCap, lineDash = _a.lineDash, lineDashOffset = _a.lineDashOffset, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset;
                parsedLineStyleProps = {
                    x1: points[0][0],
                    y1: points[0][1],
                    x2: points[points.length - 1][0],
                    y2: points[points.length - 1][1],
                    z1: 0,
                    z2: 0,
                    defX: defX_1,
                    defY: defY_1,
                    lineCap: lineCap_1,
                    lineDash: lineDash,
                    lineDashOffset: lineDashOffset,
                    isBillboard: true,
                    markerStart: markerStart,
                    markerEnd: markerEnd,
                    markerStartOffset: markerStartOffset,
                    markerEndOffset: markerEndOffset,
                };
                totalLength = object.getTotalLength();
            }
            else if (object.nodeName === gLite.Shape.PATH) {
                var _b = object.parsedStyle, absolutePath = _b.path.absolutePath, defX_2 = _b.defX, defY_2 = _b.defY, lineCap_2 = _b.lineCap, lineDash = _b.lineDash, lineDashOffset = _b.lineDashOffset, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerStartOffset = _b.markerStartOffset, markerEndOffset = _b.markerEndOffset;
                parsedLineStyleProps = {
                    x1: absolutePath[0][1],
                    y1: absolutePath[0][2],
                    x2: absolutePath[1][1],
                    y2: absolutePath[1][2],
                    z1: 0,
                    z2: 0,
                    defX: defX_2,
                    defY: defY_2,
                    lineCap: lineCap_2,
                    lineDash: lineDash,
                    lineDashOffset: lineDashOffset,
                    isBillboard: false,
                    markerStart: markerStart,
                    markerEnd: markerEnd,
                    markerStartOffset: markerStartOffset,
                    markerEndOffset: markerEndOffset,
                };
                totalLength = object.getTotalLength();
            }
            var x1 = parsedLineStyleProps.x1, y1 = parsedLineStyleProps.y1, x2 = parsedLineStyleProps.x2, y2 = parsedLineStyleProps.y2, z1 = parsedLineStyleProps.z1, z2 = parsedLineStyleProps.z2, defX = parsedLineStyleProps.defX, defY = parsedLineStyleProps.defY, lineCap = parsedLineStyleProps.lineCap, isBillboard = parsedLineStyleProps.isBillboard;
            var _c = _this.calcOffset(parsedLineStyleProps), startOffsetX = _c.startOffsetX, startOffsetY = _c.startOffsetY, endOffsetX = _c.endOffsetX, endOffsetY = _c.endOffsetY;
            var _d = _this.calcDash(parsedLineStyleProps, totalLength), dashOffset = _d.dashOffset, dashSegmentPercent = _d.dashSegmentPercent, dashRatioInEachSegment = _d.dashRatioInEachSegment;
            packedCap.push(
            // caps
            LineCap_MAP[lineCap]);
            packedDash.push(dashOffset, dashSegmentPercent, dashRatioInEachSegment, 
            // isBillboard
            isBillboard ? 1 : 0);
            interleaved.push(x1 - defX + startOffsetX, y1 - defY + startOffsetY, z1, x2 - defX + endOffsetX, y2 - defY + endOffsetY, z2);
            indices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
            offset += 4;
        });
        this.geometry.setIndexBuffer(new Uint32Array(indices));
        this.geometry.vertexCount = 6;
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.POSITION,
            byteStride: 4 * 5,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGB,
                    bufferByteOffset: 4 * 0,
                    location: InstancedLineVertexAttributeLocation.POSITION,
                    divisor: 0,
                },
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 3,
                    location: InstancedLineVertexAttributeLocation.UV,
                    divisor: 0,
                },
            ],
            data: new Float32Array(segmentInstanceGeometry),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: InstancedLineVertexAttributeBufferIndex.POINT,
            byteStride: 4 * (3 + 3),
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGB,
                    bufferByteOffset: 4 * 0,
                    location: InstancedLineVertexAttributeLocation.POINTA,
                    divisor: 1,
                },
                {
                    format: exports.Format.F32_RGB,
                    bufferByteOffset: 4 * 3,
                    location: InstancedLineVertexAttributeLocation.POINTB,
                    divisor: 1,
                },
            ],
            data: new Float32Array(interleaved),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: InstancedLineVertexAttributeBufferIndex.CAP,
            byteStride: 4 * 1,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_R,
                    bufferByteOffset: 4 * 0,
                    location: InstancedLineVertexAttributeLocation.CAP,
                    divisor: 1,
                },
            ],
            data: new Float32Array(packedCap),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: InstancedLineVertexAttributeBufferIndex.DASH,
            byteStride: 4 * 4,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 0,
                    location: InstancedLineVertexAttributeLocation.DASH,
                    divisor: 1,
                },
            ],
            data: new Float32Array(packedDash),
        });
    };
    InstancedLineMesh.prototype.updateAttribute = function (objects, startIndex, name, value) {
        var _this = this;
        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);
        this.updateBatchedAttribute(objects, startIndex, name, value);
        if (name === 'x1' ||
            name === 'y1' ||
            name === 'x2' ||
            name === 'y2' ||
            name === 'z1' ||
            name === 'z2' ||
            name === 'markerStartOffset' ||
            name === 'markerEndOffset' ||
            name === 'markerStart' ||
            name === 'markerEnd' ||
            name === 'points' ||
            name === 'path') {
            var packed_1 = [];
            objects.forEach(function (object) {
                var parsedLineStyleProps;
                if (object.nodeName === gLite.Shape.LINE) {
                    parsedLineStyleProps = object.parsedStyle;
                }
                else if (object.nodeName === gLite.Shape.POLYLINE &&
                    object.renderable.proxyNodeName === gLite.Shape.LINE) {
                    var _a = object.parsedStyle, points = _a.points.points, defX_3 = _a.defX, defY_3 = _a.defY, lineCap = _a.lineCap, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset;
                    parsedLineStyleProps = {
                        x1: points[0][0],
                        y1: points[0][1],
                        x2: points[points.length - 1][0],
                        y2: points[points.length - 1][1],
                        z1: 0,
                        z2: 0,
                        defX: defX_3,
                        defY: defY_3,
                        lineCap: lineCap,
                        isBillboard: true,
                        markerStart: markerStart,
                        markerEnd: markerEnd,
                        markerStartOffset: markerStartOffset,
                        markerEndOffset: markerEndOffset,
                    };
                }
                else if (object.nodeName === gLite.Shape.PATH &&
                    object.renderable.proxyNodeName === gLite.Shape.LINE) {
                    var _b = object.parsedStyle, absolutePath = _b.path.absolutePath, defX_4 = _b.defX, defY_4 = _b.defY, lineCap = _b.lineCap, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerStartOffset = _b.markerStartOffset, markerEndOffset = _b.markerEndOffset;
                    parsedLineStyleProps = {
                        x1: absolutePath[0][1],
                        y1: absolutePath[0][2],
                        x2: absolutePath[1][1],
                        y2: absolutePath[1][2],
                        z1: 0,
                        z2: 0,
                        defX: defX_4,
                        defY: defY_4,
                        lineCap: lineCap,
                        isBillboard: true,
                        markerStart: markerStart,
                        markerEnd: markerEnd,
                        markerStartOffset: markerStartOffset,
                        markerEndOffset: markerEndOffset,
                    };
                }
                var x1 = parsedLineStyleProps.x1, y1 = parsedLineStyleProps.y1, x2 = parsedLineStyleProps.x2, y2 = parsedLineStyleProps.y2, z1 = parsedLineStyleProps.z1, z2 = parsedLineStyleProps.z2, defX = parsedLineStyleProps.defX, defY = parsedLineStyleProps.defY;
                var _c = _this.calcOffset(parsedLineStyleProps), startOffsetX = _c.startOffsetX, startOffsetY = _c.startOffsetY, endOffsetX = _c.endOffsetX, endOffsetY = _c.endOffsetY;
                packed_1.push(x1 - defX + startOffsetX, y1 - defY + startOffsetY, z1, x2 - defX + endOffsetX, y2 - defY + endOffsetY, z2);
            });
            this.geometry.updateVertexBuffer(InstancedLineVertexAttributeBufferIndex.POINT, InstancedLineVertexAttributeLocation.POINTA, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));
        }
        else if (name === 'lineDashOffset' ||
            name === 'lineDash' ||
            name === 'isBillboard') {
            var packed_2 = [];
            objects.forEach(function (object) {
                var totalLength = object.getTotalLength();
                var _a = _this.calcDash(object.parsedStyle, totalLength), dashOffset = _a.dashOffset, dashSegmentPercent = _a.dashSegmentPercent, dashRatioInEachSegment = _a.dashRatioInEachSegment;
                packed_2.push(dashOffset, dashSegmentPercent, dashRatioInEachSegment, // isBillboard
                object.parsedStyle.isBillboard ? 1 : 0);
            });
            this.geometry.updateVertexBuffer(InstancedLineVertexAttributeBufferIndex.DASH, InstancedLineVertexAttributeLocation.DASH, startIndex, new Uint8Array(new Float32Array(packed_2).buffer));
        }
        else if (name === 'lineCap') {
            var packed_3 = [];
            objects.forEach(function (object) {
                var lineCap = object.parsedStyle.lineCap;
                packed_3.push(LineCap_MAP[lineCap]);
            });
            this.geometry.updateVertexBuffer(InstancedLineVertexAttributeBufferIndex.CAP, InstancedLineVertexAttributeLocation.CAP, startIndex, new Uint8Array(new Float32Array(packed_3).buffer));
        }
    };
    InstancedLineMesh.prototype.calcOffset = function (parsedStyle) {
        var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
        var startOffsetX = 0;
        var startOffsetY = 0;
        var endOffsetX = 0;
        var endOffsetY = 0;
        var rad = 0;
        var x;
        var y;
        if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {
            x = x2 - x1;
            y = y2 - y1;
            rad = Math.atan2(y, x);
            startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
            startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
        }
        if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {
            x = x1 - x2;
            y = y1 - y2;
            rad = Math.atan2(y, x);
            endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
            endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
        }
        return {
            startOffsetX: startOffsetX,
            startOffsetY: startOffsetY,
            endOffsetX: endOffsetX,
            endOffsetY: endOffsetY,
        };
    };
    InstancedLineMesh.prototype.calcDash = function (parsedLineStyle, totalLength) {
        var lineDash = parsedLineStyle.lineDash, lineDashOffset = parsedLineStyle.lineDashOffset;
        var dashOffset = 0;
        var dashSegmentPercent = 1;
        var dashRatioInEachSegment = 0;
        if (lineDash && lineDash.length) {
            dashOffset = (lineDashOffset || 0) / totalLength;
            var segmentsLength = lineDash.reduce(function (cur, prev) { return cur + prev; }, 0);
            if (segmentsLength === 0) {
                dashSegmentPercent = 1;
                dashRatioInEachSegment = 0;
            }
            else {
                dashSegmentPercent = segmentsLength / totalLength;
                dashRatioInEachSegment = lineDash[1] / segmentsLength;
            }
        }
        return {
            dashOffset: dashOffset,
            dashSegmentPercent: dashSegmentPercent,
            dashRatioInEachSegment: dashRatioInEachSegment,
        };
    };
    return InstancedLineMesh;
}(Instanced));

var frag$4 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\n#ifdef INSTANCED\n  in vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n  in vec4 v_Dash;\n#else\n  layout(std140) uniform ub_ObjectParams {\n  mat4 u_ModelMatrix;\n  vec4 u_FillColor;\n  vec4 u_StrokeColor;\n  float u_StrokeWidth;\n  float u_Opacity;\n  float u_FillOpacity;\n  float u_StrokeOpacity;\n  float u_Expand;\n  float u_MiterLimit;\n  float u_ScaleMode;\n  float u_Alignment;\n  vec3 u_PickingColor;\n  float u_Dash;\n  float u_Gap;\n  float u_DashOffset;\n  float u_Visible;\n  float u_ZIndex;\n  float u_IncreasedLineWidthForHitTesting;\n};\n#endif\n\nin vec4 v_Distance;\nin vec4 v_Arc;\nin float v_Type;\nin float v_Travel;\nin float v_ScalingFactor;\n\nout vec4 outputColor;\n\nvoid main(){\n  #ifdef INSTANCED\n    vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n  #else\n    if (u_Visible < 0.5) {\n      discard;\n    }\n  #endif\n\n  float alpha = 1.0;\n  float lineWidth = v_Distance.w;\n  if (v_Type < 0.5) {\n    float left = max(v_Distance.x - 0.5, -v_Distance.w);\n    float right = min(v_Distance.x + 0.5, v_Distance.w);\n    float near = v_Distance.y - 0.5;\n    float far = min(v_Distance.y + 0.5, 0.0);\n    float top = v_Distance.z - 0.5;\n    float bottom = min(v_Distance.z + 0.5, 0.0);\n    alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n  } else if (v_Type < 1.5) {\n    float a1 = clamp(v_Distance.x + 0.5 - lineWidth, 0.0, 1.0);\n    float a2 = clamp(v_Distance.x + 0.5 + lineWidth, 0.0, 1.0);\n    float b1 = clamp(v_Distance.y + 0.5 - lineWidth, 0.0, 1.0);\n    float b2 = clamp(v_Distance.y + 0.5 + lineWidth, 0.0, 1.0);\n    alpha = a2 * b2 - a1 * b1;\n  } else if (v_Type < 2.5) {\n    alpha *= max(min(v_Distance.x + 0.5, 1.0), 0.0);\n    alpha *= max(min(v_Distance.y + 0.5, 1.0), 0.0);\n    alpha *= max(min(v_Distance.z + 0.5, 1.0), 0.0);\n  } else if (v_Type < 3.5) {\n    float a1 = clamp(v_Distance.x + 0.5 - lineWidth, 0.0, 1.0);\n    float a2 = clamp(v_Distance.x + 0.5 + lineWidth, 0.0, 1.0);\n    float b1 = clamp(v_Distance.y + 0.5 - lineWidth, 0.0, 1.0);\n    float b2 = clamp(v_Distance.y + 0.5 + lineWidth, 0.0, 1.0);\n    float alpha_miter = a2 * b2 - a1 * b1;\n    float alpha_plane = max(min(v_Distance.z + 0.5, 1.0), 0.0);\n    float d = length(v_Arc.xy);\n    float circle_hor = max(min(v_Arc.w, d + 0.5) - max(-v_Arc.w, d - 0.5), 0.0);\n    float circle_vert = min(v_Arc.w * 2.0, 1.0);\n    float alpha_circle = circle_hor * circle_vert;\n    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\n  } else {\n    float a1 = clamp(v_Distance.x + 0.5 - lineWidth, 0.0, 1.0);\n    float a2 = clamp(v_Distance.x + 0.5 + lineWidth, 0.0, 1.0);\n    float b1 = clamp(v_Distance.y + 0.5 - lineWidth, 0.0, 1.0);\n    float b2 = clamp(v_Distance.y + 0.5 + lineWidth, 0.0, 1.0);\n    alpha = a2 * b2 - a1 * b1;\n    alpha *= max(min(v_Distance.z + 0.5, 1.0), 0.0);\n  }\n\n  #ifdef INSTANCED\n    float u_Dash = v_Dash.x;\n    float u_Gap = v_Dash.y;\n    float u_DashOffset = v_Dash.z;\n  #endif\n  if (u_Dash + u_Gap > 1.0) {\n    float travel = mod(v_Travel + u_Gap * v_ScalingFactor * 0.5 + u_DashOffset, u_Dash * v_ScalingFactor + u_Gap * v_ScalingFactor) - (u_Gap * v_ScalingFactor * 0.5);\n    float left = max(travel - 0.5, -0.5);\n    float right = min(travel + 0.5, u_Gap * v_ScalingFactor + 0.5);\n    alpha *= max(0.0, right - left);\n  }\n\n  if (u_IsPicking > 0.5) {\n    #ifdef INSTANCED\n      vec3 pickingColor = u_PickingColor;\n    #else\n      vec3 pickingColor = u_PickingColor / 255.0;\n    #endif\n    if (pickingColor.x == 0.0 && pickingColor.y == 0.0 && pickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(pickingColor, 1.0);\n  } else {\n    outputColor = u_StrokeColor;\n    outputColor.a *= alpha * u_Opacity * u_StrokeOpacity;\n  }\n}"; // eslint-disable-line

var vert$3 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\n#ifdef INSTANCED\n  layout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\n#else\n  layout(std140) uniform ub_ObjectParams {\n  mat4 u_ModelMatrix;\n  vec4 u_FillColor;\n  vec4 u_StrokeColor;\n  float u_StrokeWidth;\n  float u_Opacity;\n  float u_FillOpacity;\n  float u_StrokeOpacity;\n  float u_Expand;\n  float u_MiterLimit;\n  float u_ScaleMode;\n  float u_Alignment;\n  vec3 u_PickingColor;\n  float u_Dash;\n  float u_Gap;\n  float u_DashOffset;\n  float u_Visible;\n  float u_ZIndex;\n  float u_IncreasedLineWidthForHitTesting;\n};\n#endif\n\nlayout(location = PREV) in vec2 a_Prev;\nlayout(location = POINT1) in vec2 a_Point1;\nlayout(location = POINT2) in vec2 a_Point2;\nlayout(location = NEXT) in vec2 a_Next;\nlayout(location = VERTEX_JOINT) in float a_VertexJoint;\nlayout(location = VERTEX_NUM) in float a_VertexNum;\nlayout(location = TRAVEL) in float a_Travel;\n\n#ifdef INSTANCED\n  layout(location = DASH) in vec4 a_Dash;\n  out vec4 v_Dash;\n#endif\n\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\nconst float FILL_EXPAND = 24.0;\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\n#ifdef INSTANCED\n  const float u_Expand = 1.0;\n  const float u_MiterLimit = 5.0;\n  const float u_ScaleMode = 1.0;\n  const float u_Alignment = 0.5;\n#endif\n\nout vec4 v_Distance;\nout vec4 v_Arc;\nout float v_Type;\nout float v_Travel;\nout float v_ScalingFactor;\n\nvec2 doBisect(\n  vec2 norm, float len, vec2 norm2, float len2, float dy, float inner\n) {\n  vec2 bisect = (norm + norm2) / 2.0;\n  bisect /= dot(norm, bisect);\n  vec2 shift = dy * bisect;\n  if (inner > 0.5) {\n    if (len < len2) {\n      if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n        return dy * norm;\n      }\n    } else {\n      if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n        return dy * norm;\n      }\n    }\n  }\n  return dy * bisect;\n}\n\nvoid main() {\n  #ifdef INSTANCED\n    vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n    v_Dash = a_Dash;\n  #endif\n\n  vec2 pointA = (u_ModelMatrix * vec4(a_Point1, 0., 1.0)).xy;\n  vec2 pointB = (u_ModelMatrix * vec4(a_Point2, 0., 1.0)).xy;\n\n  vec2 xBasis = pointB - pointA;\n  float len = length(xBasis);\n  vec2 forward = xBasis / len;\n  vec2 norm = vec2(forward.y, -forward.x);\n\n  float type = a_VertexJoint;\n\n  float lineWidth;\n  if (u_IsPicking > 0.5) {\n    lineWidth = u_IncreasedLineWidthForHitTesting + u_StrokeWidth;\n  } else {\n    lineWidth = u_StrokeWidth;\n  }\n\n  if (u_ScaleMode > 2.5) {\n    lineWidth *= length(u_ModelMatrix * vec4(1.0, 0.0, 0.0, 0.0));\n  } else if (u_ScaleMode > 1.5) {\n    lineWidth *= length(u_ModelMatrix * vec4(0.0, 1.0, 0.0, 0.0));\n  } else if (u_ScaleMode > 0.5) {\n    vec2 avgDiag = (u_ModelMatrix * vec4(1.0, 1.0, 0.0, 0.0)).xy;\n    lineWidth *= sqrt(dot(avgDiag, avgDiag) * 0.5);\n  }\n  float capType = floor(type / 32.0);\n  type -= capType * 32.0;\n  v_Arc = vec4(0.0);\n  lineWidth *= 0.5;\n  float lineAlignment = 2.0 * u_Alignment - 1.0;\n\n  vec2 pos;\n\n  if (capType == CAP_ROUND) {\n    if (a_VertexNum < 3.5) {\n      gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    type = JOINT_CAP_ROUND;\n    capType = 0.0;\n  }\n\n  if (type >= BEVEL) {\n    float dy = lineWidth + u_Expand;\n    float inner = 0.0;\n    if (a_VertexNum >= 1.5) {\n      dy = -dy;\n      inner = 1.0;\n    }\n\n    vec2 base, next, xBasis2, bisect;\n    float flag = 0.0;\n    float sign2 = 1.0;\n    if (a_VertexNum < 0.5 || a_VertexNum > 2.5 && a_VertexNum < 3.5) {\n      next = (u_ModelMatrix * vec4(a_Prev, 0.0, 1.0)).xy;\n      base = pointA;\n      flag = type - floor(type / 2.0) * 2.0;\n      sign2 = -1.0;\n    } else {\n      next = (u_ModelMatrix * vec4(a_Next, 0.0, 1.0)).xy;\n      base = pointB;\n      if (type >= MITER && type < MITER + 3.5) {\n        flag = step(MITER + 1.5, type);\n        // check miter limit here?\n      }\n    }\n    xBasis2 = next - base;\n    float len2 = length(xBasis2);\n    vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n    float D = norm.x * norm2.y - norm.y * norm2.x;\n    if (D < 0.0) {\n      inner = 1.0 - inner;\n    }\n    norm2 *= sign2;\n\n    if (abs(lineAlignment) > 0.01) {\n      float shift = lineWidth * lineAlignment;\n      pointA += norm * shift;\n      pointB += norm * shift;\n      if (abs(D) < 0.01) {\n        base += norm * shift;\n      } else {\n        base += doBisect(norm, len, norm2, len2, shift, 0.0);\n      }\n    }\n\n    float collinear = step(0.0, dot(norm, norm2));\n    v_Type = 0.0;\n    float dy2 = -1000.0;\n    float dy3 = -1000.0;\n    if (abs(D) < 0.01 && collinear < 0.5) {\n      if (type >= ROUND && type < ROUND + 1.5) {\n        type = JOINT_CAP_ROUND;\n      }\n      // TODO: BUTT here too\n    }\n\n    if (a_VertexNum < 3.5) {\n      if (abs(D) < 0.01) {\n        pos = dy * norm;\n      } else {\n        if (flag < 0.5 && inner < 0.5) {\n          pos = dy * norm;\n        } else {\n          pos = doBisect(norm, len, norm2, len2, dy, inner);\n        }\n      }\n      if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n        float extra = step(CAP_SQUARE, capType) * lineWidth;\n        vec2 back = -forward;\n        if (a_VertexNum < 0.5 || a_VertexNum > 2.5) {\n          pos += back * (u_Expand + extra);\n          dy2 = u_Expand;\n        } else {\n          dy2 = dot(pos + base - pointA, back) - extra;\n        }\n      }\n      if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n        float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n        if (a_VertexNum < 0.5 || a_VertexNum > 2.5) {\n          dy3 = dot(pos + base - pointB, forward) - extra;\n        } else {\n          pos += forward * (u_Expand + extra);\n          dy3 = u_Expand;\n          if (capType >= CAP_BUTT) {\n            dy2 -= u_Expand + extra;\n          }\n        }\n      }\n    } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n      if (inner > 0.5) {\n        dy = -dy;\n        inner = 0.0;\n      }\n      vec2 d2 = abs(dy) * forward;\n      if (a_VertexNum < 4.5) {\n        dy = -dy;\n        pos = dy * norm;\n      } else if (a_VertexNum < 5.5) {\n        pos = dy * norm;\n      } else if (a_VertexNum < 6.5) {\n        pos = dy * norm + d2;\n        v_Arc.x = abs(dy);\n      } else {\n        dy = -dy;\n        pos = dy * norm + d2;\n        v_Arc.x = abs(dy);\n      }\n      dy2 = 0.0;\n      v_Arc.y = dy;\n      v_Arc.z = 0.0;\n      v_Arc.w = lineWidth;\n      v_Type = 3.0;\n    } else if (abs(D) < 0.01) {\n      pos = dy * norm;\n    } else {\n      if (type >= ROUND && type < ROUND + 1.5) {\n        if (inner > 0.5) {\n          dy = -dy;\n          inner = 0.0;\n        }\n        if (a_VertexNum < 4.5) {\n          pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\n        } else if (a_VertexNum < 5.5) {\n          pos = dy * norm;\n        } else if (a_VertexNum > 7.5) {\n          pos = dy * norm2;\n        } else {\n          pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n          float d2 = abs(dy);\n          if (length(pos) > abs(dy) * 1.5) {\n            if (a_VertexNum < 6.5) {\n              pos.x = dy * norm.x - d2 * norm.y;\n              pos.y = dy * norm.y + d2 * norm.x;\n            } else {\n              pos.x = dy * norm2.x + d2 * norm2.y;\n              pos.y = dy * norm2.y - d2 * norm2.x;\n            }\n          }\n        }\n        vec2 norm3 = normalize(norm + norm2);\n        float sign = step(0.0, dy) * 2.0 - 1.0;\n        v_Arc.x = sign * dot(pos, norm3);\n        v_Arc.y = pos.x * norm3.y - pos.y * norm3.x;\n        v_Arc.z = dot(norm, norm3) * lineWidth;\n        v_Arc.w = lineWidth;\n        dy = -sign * dot(pos, norm);\n        dy2 = -sign * dot(pos, norm2);\n        dy3 = v_Arc.z - v_Arc.x;\n        v_Type = 3.0;\n      } else {\n        float hit = 0.0;\n        if (type >= BEVEL && type < BEVEL + 1.5) {\n          if (dot(norm, norm2) > 0.0) {\n            type = MITER;\n          }\n        }\n        if (type >= MITER && type < MITER + 3.5) {\n          if (inner > 0.5) {\n            dy = -dy;\n            inner = 0.0;\n          }\n          float sign = step(0.0, dy) * 2.0 - 1.0;\n          pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n          if (length(pos) > abs(dy) * u_MiterLimit) {\n            type = BEVEL;\n          } else {\n            if (a_VertexNum < 4.5) {\n              dy = -dy;\n              pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n            } else if (a_VertexNum < 5.5) {\n              pos = dy * norm;\n            } else if (a_VertexNum > 6.5) {\n              pos = dy * norm2;\n            }\n            v_Type = 1.0;\n            dy = -sign * dot(pos, norm);\n            dy2 = -sign * dot(pos, norm2);\n            hit = 1.0;\n          }\n        }\n        if (type >= BEVEL && type < BEVEL + 1.5) {\n          if (inner > 0.5) {\n            dy = -dy;\n            inner = 0.0;\n          }\n          float d2 = abs(dy);\n          vec2 pos3 = vec2(dy * norm.x - d2 * norm.y, dy * norm.y + d2 * norm.x);\n          vec2 pos4 = vec2(dy * norm2.x + d2 * norm2.y, dy * norm2.y - d2 * norm2.x);\n          if (a_VertexNum < 4.5) {\n            pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\n          } else if (a_VertexNum < 5.5) {\n            pos = dy * norm;\n          } else if (a_VertexNum > 7.5) {\n            pos = dy * norm2;\n          } else {\n            if (a_VertexNum < 6.5) {\n              pos = pos3;\n            } else {\n              pos = pos4;\n            }\n          }\n          vec2 norm3 = normalize(norm + norm2);\n          float sign = step(0.0, dy) * 2.0 - 1.0;\n          dy = -sign * dot(pos, norm);\n          dy2 = -sign * dot(pos, norm2);\n          dy3 = (-sign * dot(pos, norm3)) + lineWidth;\n          v_Type = 4.0;\n          hit = 1.0;\n        }\n        if (hit < 0.5) {\n          gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n          return;\n        }\n      }\n    }\n    pos += base;\n    v_Distance = vec4(dy, dy2, dy3, lineWidth) * u_DevicePixelRatio;\n    v_Arc = v_Arc * u_DevicePixelRatio;\n    v_Travel = a_Travel + dot(pos - pointA, vec2(-norm.y, norm.x));\n  }\n\n  v_ScalingFactor = sqrt(u_ModelMatrix[0][0] * u_ModelMatrix[0][0] + u_ModelMatrix[0][1] * u_ModelMatrix[0][1] + u_ModelMatrix[0][2] * u_ModelMatrix[0][2]);\n\n  gl_Position = u_ProjectionMatrix * u_ViewMatrix * vec4(pos, u_ZIndex, 1.0);\n}"; // eslint-disable-line

var SEGMENT_LENGTH = 10;
var MIN_SEGMENT_NUM = 8;
var MAX_SEGMENT_NUM = 100;
function quadCurveTo(cpX, cpY, toX, toY, points, segmentNum) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var n = segmentNum !== null && segmentNum !== void 0 ? segmentNum : util.clamp(gMath.quadLength(fromX, fromY, cpX, cpY, toX, toY) / SEGMENT_LENGTH, MIN_SEGMENT_NUM, MAX_SEGMENT_NUM);
    var xa = 0;
    var ya = 0;
    for (var i = 1; i <= n; ++i) {
        var j = i / n;
        xa = fromX + (cpX - fromX) * j;
        ya = fromY + (cpY - fromY) * j;
        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
    }
}
function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY, points, segmentNum) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    points.length -= 2;
    var n = segmentNum !== null && segmentNum !== void 0 ? segmentNum : util.clamp(gMath.cubicLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) /
        SEGMENT_LENGTH, MIN_SEGMENT_NUM, MAX_SEGMENT_NUM);
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;
    points.push(fromX, fromY);
    for (var i = 1, j = 0; i <= n; ++i) {
        j = i / n;
        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;
        t2 = j * j;
        t3 = t2 * j;
        points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
}

/**
 * Borrow from https://github.com/mapbox/tiny-sdf
 */
var INF = 1e20;
var TinySDF = /** @class */ (function () {
    function TinySDF(options) {
        var _a = options.fontSize, fontSize = _a === void 0 ? 24 : _a, _b = options.buffer, buffer = _b === void 0 ? 3 : _b, _c = options.radius, radius = _c === void 0 ? 8 : _c, _d = options.cutoff, cutoff = _d === void 0 ? 0.25 : _d, _e = options.fontFamily, fontFamily = _e === void 0 ? 'sans-serif' : _e, _f = options.fontWeight, fontWeight = _f === void 0 ? 'normal' : _f, _g = options.fontStyle, fontStyle = _g === void 0 ? 'normal' : _g, canvas = options.canvas;
        this.buffer = buffer;
        this.cutoff = cutoff;
        this.radius = radius;
        // make the canvas size big enough to both have the specified buffer around the glyph
        // for "halo", and account for some glyphs possibly being larger than their font size
        var size = (this.size = fontSize + buffer * 4);
        var $offscreenCanvas = gLite.runtime.offscreenCanvasCreator.getOrCreateCanvas(canvas);
        // canvas.width = canvas.height = size;
        // $offscreenCanvas.width = width * dpr;
        // $offscreenCanvas.height = height * dpr;
        $offscreenCanvas.width = size;
        $offscreenCanvas.height = size;
        var ctx = gLite.runtime.offscreenCanvasCreator.getOrCreateContext(canvas, {
            willReadFrequently: true,
        });
        this.ctx = ctx;
        // const ctx = (this.ctx = canvas.getContext('2d', {
        //   willReadFrequently: true,
        // }));
        ctx.font = "".concat(fontStyle, " ").concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
        ctx.textBaseline = 'alphabetic';
        ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
        ctx.fillStyle = 'black';
        // temporary arrays for the distance transform
        this.gridOuter = new Float64Array(size * size);
        this.gridInner = new Float64Array(size * size);
        this.f = new Float64Array(size);
        this.z = new Float64Array(size + 1);
        this.v = new Uint16Array(size);
    }
    // _createCanvas(size) {
    //   const canvas = document.createElement('canvas');
    //   canvas.width = canvas.height = size;
    //   return canvas;
    // }
    TinySDF.prototype.draw = function (char) {
        var _a = this.ctx.measureText(char), glyphAdvance = _a.width, actualBoundingBoxAscent = _a.actualBoundingBoxAscent, actualBoundingBoxDescent = _a.actualBoundingBoxDescent, actualBoundingBoxLeft = _a.actualBoundingBoxLeft, actualBoundingBoxRight = _a.actualBoundingBoxRight;
        // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
        // The remainder is implicitly encoded in the rasterization
        var glyphTop = Math.ceil(actualBoundingBoxAscent);
        var glyphLeft = 0;
        // If the glyph overflows the canvas size, it will be clipped at the bottom/right
        var glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
        var glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
        var width = glyphWidth + 2 * this.buffer;
        var height = glyphHeight + 2 * this.buffer;
        var len = Math.max(width * height, 0);
        var data = new Uint8ClampedArray(len);
        var glyph = {
            data: data,
            width: width,
            height: height,
            glyphWidth: glyphWidth,
            glyphHeight: glyphHeight,
            glyphTop: glyphTop,
            glyphLeft: glyphLeft,
            glyphAdvance: glyphAdvance,
        };
        if (glyphWidth === 0 || glyphHeight === 0)
            return glyph;
        var _b = this, ctx = _b.ctx, buffer = _b.buffer, gridInner = _b.gridInner, gridOuter = _b.gridOuter;
        ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
        ctx.fillText(char, buffer, buffer + glyphTop);
        var imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
        // Initialize grids outside the glyph range to alpha 0
        gridOuter.fill(INF, 0, len);
        gridInner.fill(0, 0, len);
        for (var y = 0; y < glyphHeight; y++) {
            for (var x = 0; x < glyphWidth; x++) {
                var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
                if (a === 0)
                    continue; // empty pixels
                var j = (y + buffer) * width + x + buffer;
                if (a === 1) {
                    // fully drawn pixels
                    gridOuter[j] = 0;
                    gridInner[j] = INF;
                }
                else {
                    // aliased pixels
                    var d = 0.5 - a;
                    gridOuter[j] = d > 0 ? d * d : 0;
                    gridInner[j] = d < 0 ? d * d : 0;
                }
            }
        }
        edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
        edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
        for (var i = 0; i < len; i++) {
            var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
            data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
        }
        return glyph;
    };
    return TinySDF;
}());
// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
function edt(data, x0, y0, width, height, gridSize, f, v, z) {
    for (var x = x0; x < x0 + width; x++)
        edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
    for (var y = y0; y < y0 + height; y++)
        edt1d(data, y * gridSize + x0, 1, width, f, v, z);
}
// 1D squared distance transform
function edt1d(grid, offset, stride, length, f, v, z) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = INF;
    f[0] = grid[offset];
    for (var q = 1, k = 0, s = 0; q < length; q++) {
        f[q] = grid[offset + q * stride];
        var q2 = q * q;
        do {
            var r = v[k];
            s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
        } while (s <= z[k] && --k > -1);
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = INF;
    }
    for (var q = 0, k = 0; q < length; q++) {
        while (z[k + 1] < q)
            k++;
        var r = v[k];
        var qr = q - r;
        grid[offset + q * stride] = f[r] + qr * qr;
    }
}

var LineVertexAttributeBufferIndex;
(function (LineVertexAttributeBufferIndex) {
    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex["PACKED"] = 5] = "PACKED";
    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex["VERTEX_NUM"] = 6] = "VERTEX_NUM";
    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex["TRAVEL"] = 7] = "TRAVEL";
    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex["DASH"] = 8] = "DASH";
})(LineVertexAttributeBufferIndex || (LineVertexAttributeBufferIndex = {}));
var LineVertexAttributeLocation;
(function (LineVertexAttributeLocation) {
    LineVertexAttributeLocation[LineVertexAttributeLocation["PREV"] = 8] = "PREV";
    LineVertexAttributeLocation[LineVertexAttributeLocation["POINT1"] = 9] = "POINT1";
    LineVertexAttributeLocation[LineVertexAttributeLocation["POINT2"] = 10] = "POINT2";
    LineVertexAttributeLocation[LineVertexAttributeLocation["NEXT"] = 11] = "NEXT";
    LineVertexAttributeLocation[LineVertexAttributeLocation["VERTEX_JOINT"] = 12] = "VERTEX_JOINT";
    LineVertexAttributeLocation[LineVertexAttributeLocation["VERTEX_NUM"] = 13] = "VERTEX_NUM";
    LineVertexAttributeLocation[LineVertexAttributeLocation["TRAVEL"] = 14] = "TRAVEL";
    LineVertexAttributeLocation[LineVertexAttributeLocation["DASH"] = 15] = "DASH";
})(LineVertexAttributeLocation || (LineVertexAttributeLocation = {}));
var SEGMENT_NUM$1 = 12;
/**
 * Used for Curve only contains 2 commands, e.g. [[M], [C | Q | A]]
 */
var InstancedPathMesh = /** @class */ (function (_super) {
    tslib.__extends(InstancedPathMesh, _super);
    function InstancedPathMesh(renderHelper, texturePool, lightPool, object) {
        var _this = _super.call(this, renderHelper, texturePool, lightPool, object) || this;
        _this.renderHelper = renderHelper;
        _this.texturePool = texturePool;
        _this.lightPool = lightPool;
        _this.mergeAnchorIntoModelMatrix = true;
        _this.segmentNum = -1;
        _this.segmentNum = _this.calcSegmentNum(object);
        return _this;
    }
    InstancedPathMesh.prototype.calcSegmentNum = function (object) {
        // FIXME: only need to collect instanced count
        var instancedCount = updateBuffer(object, false, SEGMENT_NUM$1).instancedCount;
        return instancedCount;
    };
    /**
     * Paths with the same number of vertices should be merged.
     */
    InstancedPathMesh.prototype.shouldMerge = function (object, index) {
        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);
        if (!shouldMerge) {
            return false;
        }
        var segmentNum = this.calcSegmentNum(object);
        return this.segmentNum === segmentNum;
    };
    InstancedPathMesh.prototype.createMaterial = function (objects) {
        this.material.vertexShader = vert$3;
        this.material.fragmentShader = frag$4;
        this.material.defines = tslib.__assign(tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(LineVertexAttributeLocation)), { INSTANCED: true });
    };
    InstancedPathMesh.prototype.createGeometry = function (objects) {
        var indices = [];
        var pointsBuffer = [];
        var travelBuffer = [];
        var packedDash = [];
        var instancedCount = 0;
        var offset = 0;
        objects.forEach(function (object) {
            var _a = updateBuffer(object, false, SEGMENT_NUM$1), pBuffer = _a.pointsBuffer, tBuffer = _a.travelBuffer, count = _a.instancedCount;
            var _b = object
                .parsedStyle, lineDash = _b.lineDash, lineDashOffset = _b.lineDashOffset, isBillboard = _b.isBillboard;
            packedDash.push((lineDash && lineDash[0]) || 0, // DASH
            (lineDash && lineDash[1]) || 0, // GAP
            lineDashOffset || 0, isBillboard ? 1 : 0);
            instancedCount += count;
            // Can't use interleaved buffer here, we should spread them like:
            // | prev - pointA - pointB - next |. This will allocate ~4x buffer memory space.
            for (var i = 0; i < pBuffer.length - 3 * 3; i += 3) {
                pointsBuffer.push(pBuffer[i], pBuffer[i + 1], pBuffer[i + 2], pBuffer[i + 3], pBuffer[i + 4], pBuffer[i + 5], pBuffer[i + 6], pBuffer[i + 7], pBuffer[i + 8], pBuffer[i + 9], pBuffer[i + 10], pBuffer[i + 11]);
            }
            travelBuffer.push.apply(travelBuffer, tslib.__spreadArray([], tslib.__read(tBuffer), false));
            indices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset, 4 + offset, 6 + offset, 5 + offset, 4 + offset, 7 + offset, 6 + offset, 4 + offset, 7 + offset, 8 + offset);
            offset += 9;
        });
        if (pointsBuffer.length) {
            this.geometry.setVertexBuffer({
                bufferIndex: LineVertexAttributeBufferIndex.PACKED,
                byteStride: 4 * (3 + 3 + 3 + 3),
                frequency: exports.VertexBufferFrequency.PerInstance,
                attributes: [
                    {
                        format: exports.Format.F32_RG,
                        bufferByteOffset: 4 * 0,
                        location: LineVertexAttributeLocation.PREV,
                        divisor: 1,
                    },
                    {
                        format: exports.Format.F32_RG,
                        bufferByteOffset: 4 * 3,
                        location: LineVertexAttributeLocation.POINT1,
                        divisor: 1,
                    },
                    {
                        format: exports.Format.F32_R,
                        bufferByteOffset: 4 * 5,
                        location: LineVertexAttributeLocation.VERTEX_JOINT,
                        divisor: 1,
                    },
                    {
                        format: exports.Format.F32_RG,
                        bufferByteOffset: 4 * 6,
                        location: LineVertexAttributeLocation.POINT2,
                        divisor: 1,
                    },
                    {
                        format: exports.Format.F32_RG,
                        bufferByteOffset: 4 * 9,
                        location: LineVertexAttributeLocation.NEXT,
                        divisor: 1,
                    },
                ],
                data: new Float32Array(pointsBuffer),
            });
            this.geometry.setVertexBuffer({
                bufferIndex: LineVertexAttributeBufferIndex.VERTEX_NUM,
                byteStride: 4 * 1,
                frequency: exports.VertexBufferFrequency.PerInstance,
                attributes: [
                    {
                        format: exports.Format.F32_R,
                        bufferByteOffset: 4 * 0,
                        byteStride: 4 * 1,
                        location: LineVertexAttributeLocation.VERTEX_NUM,
                        divisor: 0,
                    },
                ],
                data: new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 8]),
            });
            this.geometry.setVertexBuffer({
                bufferIndex: LineVertexAttributeBufferIndex.TRAVEL,
                byteStride: 4 * 1,
                frequency: exports.VertexBufferFrequency.PerInstance,
                attributes: [
                    {
                        format: exports.Format.F32_R,
                        bufferByteOffset: 4 * 0,
                        byteStride: 4 * 1,
                        location: LineVertexAttributeLocation.TRAVEL,
                        divisor: 1,
                    },
                ],
                data: new Float32Array(travelBuffer),
            });
            // this attribute only changes for each n instance
            this.divisor = instancedCount / objects.length;
            this.geometry.setVertexBuffer({
                bufferIndex: LineVertexAttributeBufferIndex.DASH,
                byteStride: 4 * 4,
                frequency: exports.VertexBufferFrequency.PerInstance,
                attributes: [
                    {
                        format: exports.Format.F32_RGBA,
                        bufferByteOffset: 4 * 0,
                        location: LineVertexAttributeLocation.DASH,
                        divisor: this.divisor,
                    },
                ],
                data: new Float32Array(packedDash),
            });
            // use default common attributes
            _super.prototype.createGeometry.call(this, objects);
            this.geometry.vertexCount = 15;
            this.geometry.instancedCount = instancedCount;
            this.geometry.setIndexBuffer(new Uint32Array(indices));
        }
    };
    InstancedPathMesh.prototype.updateAttribute = function (objects, startIndex, name, value) {
        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);
        this.updateBatchedAttribute(objects, startIndex, name, value);
        if (name === 'r' ||
            name === 'rx' ||
            name === 'ry' ||
            name === 'width' ||
            name === 'height' ||
            name === 'radius' ||
            name === 'x1' ||
            name === 'y1' ||
            name === 'x2' ||
            name === 'y2' ||
            name === 'points' ||
            name === 'path' ||
            name === 'lineJoin' ||
            name === 'lineCap' ||
            name === 'markerStartOffset' ||
            name === 'markerEndOffset' ||
            name === 'markerStart' ||
            name === 'markerEnd') {
            var pointsBuffer_1 = [];
            var travelBuffer_1 = [];
            var instancedCount_1 = 0;
            objects.forEach(function (object) {
                var _a = updateBuffer(object, false, SEGMENT_NUM$1), pBuffer = _a.pointsBuffer, tBuffer = _a.travelBuffer, iCount = _a.instancedCount;
                instancedCount_1 = iCount;
                // Can't use interleaved buffer here, we should spread them like:
                // | prev - pointA - pointB - next |. This will allocate ~4x buffer memory space.
                for (var i = 0; i < pBuffer.length - 3 * 3; i += 3) {
                    pointsBuffer_1.push(pBuffer[i], pBuffer[i + 1], pBuffer[i + 2], pBuffer[i + 3], pBuffer[i + 4], pBuffer[i + 5], pBuffer[i + 6], pBuffer[i + 7], pBuffer[i + 8], pBuffer[i + 9], pBuffer[i + 10], pBuffer[i + 11]);
                }
                travelBuffer_1.push.apply(travelBuffer_1, tslib.__spreadArray([], tslib.__read(tBuffer), false));
            });
            this.geometry.updateVertexBuffer(LineVertexAttributeBufferIndex.PACKED, LineVertexAttributeLocation.PREV, startIndex * instancedCount_1, new Uint8Array(new Float32Array(pointsBuffer_1).buffer));
            this.geometry.updateVertexBuffer(LineVertexAttributeBufferIndex.TRAVEL, LineVertexAttributeLocation.TRAVEL, startIndex, new Uint8Array(new Float32Array(travelBuffer_1).buffer));
        }
        else if (name === 'lineDashOffset' ||
            name === 'lineDash' ||
            name === 'isBillboard') {
            var packedDash_1 = [];
            objects.forEach(function (object) {
                var _a = object
                    .parsedStyle, lineDash = _a.lineDash, lineDashOffset = _a.lineDashOffset, isBillboard = _a.isBillboard;
                packedDash_1.push((lineDash && lineDash[0]) || 0, // DASH
                (lineDash && lineDash[1]) || 0, // GAP
                lineDashOffset || 0, isBillboard ? 1 : 0);
            });
            this.geometry.updateVertexBuffer(LineVertexAttributeBufferIndex.DASH, LineVertexAttributeBufferIndex.DASH, startIndex, new Uint8Array(new Float32Array(packedDash_1).buffer));
        }
    };
    return InstancedPathMesh;
}(Instanced));
exports.JOINT_TYPE = void 0;
(function (JOINT_TYPE) {
    JOINT_TYPE[JOINT_TYPE["NONE"] = 0] = "NONE";
    JOINT_TYPE[JOINT_TYPE["FILL"] = 1] = "FILL";
    JOINT_TYPE[JOINT_TYPE["JOINT_BEVEL"] = 4] = "JOINT_BEVEL";
    JOINT_TYPE[JOINT_TYPE["JOINT_MITER"] = 8] = "JOINT_MITER";
    JOINT_TYPE[JOINT_TYPE["JOINT_ROUND"] = 12] = "JOINT_ROUND";
    JOINT_TYPE[JOINT_TYPE["JOINT_CAP_BUTT"] = 16] = "JOINT_CAP_BUTT";
    JOINT_TYPE[JOINT_TYPE["JOINT_CAP_SQUARE"] = 18] = "JOINT_CAP_SQUARE";
    JOINT_TYPE[JOINT_TYPE["JOINT_CAP_ROUND"] = 20] = "JOINT_CAP_ROUND";
    JOINT_TYPE[JOINT_TYPE["FILL_EXPAND"] = 24] = "FILL_EXPAND";
    JOINT_TYPE[JOINT_TYPE["CAP_BUTT"] = 32] = "CAP_BUTT";
    JOINT_TYPE[JOINT_TYPE["CAP_SQUARE"] = 64] = "CAP_SQUARE";
    JOINT_TYPE[JOINT_TYPE["CAP_ROUND"] = 96] = "CAP_ROUND";
    JOINT_TYPE[JOINT_TYPE["CAP_BUTT2"] = 128] = "CAP_BUTT2";
})(exports.JOINT_TYPE || (exports.JOINT_TYPE = {}));
var stridePoints = 2;
var strideFloats = 3;
function updateBuffer(object, needEarcut, segmentNum) {
    var _a;
    if (needEarcut === void 0) { needEarcut = false; }
    var _b = object.parsedStyle, lineCap = _b.lineCap, lineJoin = _b.lineJoin;
    var _c = object.parsedStyle, defX = _c.defX, defY = _c.defY;
    var _d = object.parsedStyle, markerStart = _d.markerStart, markerEnd = _d.markerEnd, markerStartOffset = _d.markerStartOffset, markerEndOffset = _d.markerEndOffset;
    var points = [];
    var triangles = [];
    if (object.nodeName === gLite.Shape.POLYLINE || object.nodeName === gLite.Shape.POLYGON) {
        var polylineControlPoints = object.parsedStyle.points
            .points;
        var length_1 = polylineControlPoints.length;
        var startOffsetX_1 = 0;
        var startOffsetY_1 = 0;
        var endOffsetX_1 = 0;
        var endOffsetY_1 = 0;
        var rad = 0;
        var x = void 0;
        var y = void 0;
        if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {
            x = polylineControlPoints[1][0] - polylineControlPoints[0][0];
            y = polylineControlPoints[1][1] - polylineControlPoints[0][1];
            rad = Math.atan2(y, x);
            startOffsetX_1 = Math.cos(rad) * (markerStartOffset || 0);
            startOffsetY_1 = Math.sin(rad) * (markerStartOffset || 0);
        }
        if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {
            x =
                polylineControlPoints[length_1 - 2][0] -
                    polylineControlPoints[length_1 - 1][0];
            y =
                polylineControlPoints[length_1 - 2][1] -
                    polylineControlPoints[length_1 - 1][1];
            rad = Math.atan2(y, x);
            endOffsetX_1 = Math.cos(rad) * (markerEndOffset || 0);
            endOffsetY_1 = Math.sin(rad) * (markerEndOffset || 0);
        }
        points[0] = polylineControlPoints.reduce(function (prev, cur, i) {
            var offsetX = 0;
            var offsetY = 0;
            if (i === 0) {
                offsetX = startOffsetX_1;
                offsetY = startOffsetY_1;
            }
            else if (i === length_1 - 1) {
                offsetX = endOffsetX_1;
                offsetY = endOffsetY_1;
            }
            prev.push(cur[0] - defX + offsetX, cur[1] - defY + offsetY);
            return prev;
        }, []);
        // close polygon, dealing with extra joint
        if (object.nodeName === gLite.Shape.POLYGON) {
            if (needEarcut) {
                // use earcut for triangulation
                triangles = earcut(points[0], [], 2);
                return {
                    pointsBuffer: points[0],
                    travelBuffer: [],
                    triangles: triangles,
                    instancedCount: Math.round(points[0].length / stridePoints),
                };
            }
            else {
                points[0].push(points[0][0], points[0][1]);
                (_a = points[0]).push.apply(_a, tslib.__spreadArray([], tslib.__read(addTailSegment(points[0][0], points[0][1], points[0][2], points[0][3])), false));
            }
        }
    }
    else if (object.nodeName === gLite.Shape.PATH ||
        object.nodeName === gLite.Shape.CIRCLE ||
        object.nodeName === gLite.Shape.ELLIPSE ||
        object.nodeName === gLite.Shape.RECT) {
        var path = void 0;
        if (object.nodeName !== gLite.Shape.PATH) {
            path = gLite.parsePath(gLite.convertToPath(object, glMatrix.mat4.identity(glMatrix.mat4.create())));
            defX = path.rect.x;
            defY = path.rect.y;
            // support negative width/height of Rect
            if (object.nodeName === gLite.Shape.RECT) {
                var _e = object.parsedStyle, width = _e.width, height = _e.height;
                if (width < 0) {
                    defX += path.rect.width;
                }
                if (height < 0) {
                    defY += path.rect.height;
                }
            }
        }
        else {
            path = object.parsedStyle.path;
        }
        var absolutePath_1 = path.absolutePath, segments_1 = path.segments;
        var startOffsetX_2 = 0;
        var startOffsetY_2 = 0;
        var endOffsetX_2 = 0;
        var endOffsetY_2 = 0;
        var rad = 0;
        var x = void 0;
        var y = void 0;
        if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {
            var _f = tslib.__read(markerStart.parentNode.getStartTangent(), 2), p1 = _f[0], p2 = _f[1];
            x = p1[0] - p2[0];
            y = p1[1] - p2[1];
            rad = Math.atan2(y, x);
            startOffsetX_2 = Math.cos(rad) * (markerStartOffset || 0);
            startOffsetY_2 = Math.sin(rad) * (markerStartOffset || 0);
        }
        if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {
            var _g = tslib.__read(markerEnd.parentNode.getEndTangent(), 2), p1 = _g[0], p2 = _g[1];
            x = p1[0] - p2[0];
            y = p1[1] - p2[1];
            rad = Math.atan2(y, x);
            endOffsetX_2 = Math.cos(rad) * (markerEndOffset || 0);
            endOffsetY_2 = Math.sin(rad) * (markerEndOffset || 0);
        }
        var startPointIndex_1 = -1;
        var mCommandsNum_1 = -1;
        absolutePath_1.forEach(function (_a, i) {
            var _b;
            var _c = tslib.__read(_a), command = _c[0], params = _c.slice(1);
            var nextSegment = absolutePath_1[i + 1];
            var useStartOffset = i === 0 && (startOffsetX_2 !== 0 || startOffsetY_2 !== 0);
            var useEndOffset = (i === absolutePath_1.length - 1 ||
                (nextSegment &&
                    (nextSegment[0] === 'M' || nextSegment[0] === 'Z'))) &&
                endOffsetX_2 !== 0 &&
                endOffsetY_2 !== 0;
            if (command === 'M') {
                mCommandsNum_1++;
                points[mCommandsNum_1] = [];
                startPointIndex_1 = points[mCommandsNum_1].length;
                if (useStartOffset) {
                    points[mCommandsNum_1].push(params[0] - defX + startOffsetX_2, params[1] - defY + startOffsetY_2, params[0] - defX, params[1] - defY);
                }
                else {
                    points[mCommandsNum_1].push(params[0] - defX, params[1] - defY);
                }
            }
            else if (command === 'L') {
                if (useEndOffset) {
                    points[mCommandsNum_1].push(params[0] - defX + endOffsetX_2, params[1] - defY + endOffsetY_2);
                }
                else {
                    points[mCommandsNum_1].push(params[0] - defX, params[1] - defY);
                }
            }
            else if (command === 'Q') {
                quadCurveTo(params[0] - defX, params[1] - defY, params[2] - defX, params[3] - defY, points[mCommandsNum_1], segmentNum);
                if (useEndOffset) {
                    points[mCommandsNum_1].push(params[2] - defX + endOffsetX_2, params[3] - defY + endOffsetY_2);
                }
            }
            else if (command === 'A') {
                // convert Arc to Cubic
                var _d = tslib.__read(segments_1[i].prePoint, 2), px1 = _d[0], py1 = _d[1];
                var args = util.arcToCubic(px1, py1, params[0], params[1], params[2], params[3], params[4], params[5], params[6], undefined);
                // fixArc
                for (var i_1 = 0; i_1 < args.length; i_1 += 6) {
                    bezierCurveTo(args[i_1] - defX, args[i_1 + 1] - defY, args[i_1 + 2] - defX, args[i_1 + 3] - defY, args[i_1 + 4] - defX, args[i_1 + 5] - defY, points[mCommandsNum_1], segmentNum);
                }
                if (useEndOffset) {
                    points[mCommandsNum_1].push(params[5] - defX + endOffsetX_2, params[6] - defY + endOffsetY_2);
                }
            }
            else if (command === 'C') {
                bezierCurveTo(params[0] - defX, params[1] - defY, params[2] - defX, params[3] - defY, params[4] - defX, params[5] - defY, points[mCommandsNum_1], segmentNum);
                if (useEndOffset) {
                    points[mCommandsNum_1].push(params[4] - defX + endOffsetX_2, params[5] - defY + endOffsetY_2);
                }
            }
            else if (command === 'Z' &&
                (object.nodeName === gLite.Shape.PATH || object.nodeName === gLite.Shape.RECT)) {
                var epsilon = 0.0001;
                // skip if already closed
                if (Math.abs(points[mCommandsNum_1][points[mCommandsNum_1].length - 2] -
                    points[mCommandsNum_1][startPointIndex_1]) > epsilon ||
                    Math.abs(points[mCommandsNum_1][points[mCommandsNum_1].length - 1] -
                        points[mCommandsNum_1][startPointIndex_1 + 1]) > epsilon) {
                    points[mCommandsNum_1].push(points[mCommandsNum_1][startPointIndex_1], points[mCommandsNum_1][startPointIndex_1 + 1]);
                }
                (_b = points[mCommandsNum_1]).push.apply(_b, tslib.__spreadArray([], tslib.__read(addTailSegment(points[mCommandsNum_1][startPointIndex_1], points[mCommandsNum_1][startPointIndex_1 + 1], points[mCommandsNum_1][startPointIndex_1 + 2], points[mCommandsNum_1][startPointIndex_1 + 3])), false));
            }
        });
        if (needEarcut) {
            var pointsBuffer = points.reduce(function (prev, cur) {
                prev.push.apply(prev, tslib.__spreadArray([], tslib.__read(cur), false));
                return prev;
            }, []);
            // use earcut for triangulation
            triangles = earcut(pointsBuffer, [], 2);
            return {
                pointsBuffer: pointsBuffer,
                travelBuffer: [],
                triangles: triangles,
                instancedCount: Math.round(pointsBuffer.length / stridePoints),
            };
        }
    }
    var jointType = getJointType(lineJoin);
    var capType = getCapType(lineCap);
    var endJoint = capType;
    if (capType === exports.JOINT_TYPE.CAP_ROUND) {
        endJoint = exports.JOINT_TYPE.JOINT_CAP_ROUND;
    }
    if (capType === exports.JOINT_TYPE.CAP_BUTT) {
        endJoint = exports.JOINT_TYPE.JOINT_CAP_BUTT;
    }
    if (capType === exports.JOINT_TYPE.CAP_SQUARE) {
        endJoint = exports.JOINT_TYPE.JOINT_CAP_SQUARE;
    }
    var j = (Math.round(0 / stridePoints) + 2) * strideFloats;
    return points
        .map(function (points) {
        // const needDash = !isNil(lineDash);
        var dist = 0;
        var pointsBuffer = [];
        var travelBuffer = [];
        for (var i = 0; i < points.length; i += stridePoints) {
            // calc travel
            // if (needDash) {
            if (i > 1) {
                dist += Math.sqrt(Math.pow(points[i] - points[i - 2], 2) +
                    Math.pow(points[i + 1] - points[i + 1 - 2], 2));
            }
            travelBuffer.push(dist);
            // } else {
            //   travelBuffer.push(0);
            // }
            pointsBuffer[j++] = points[i];
            pointsBuffer[j++] = points[i + 1];
            pointsBuffer[j] = jointType;
            if (i == 0 && capType !== exports.JOINT_TYPE.CAP_ROUND) {
                pointsBuffer[j] += capType;
            }
            if (i + stridePoints * 2 >= points.length) {
                pointsBuffer[j] += endJoint - jointType;
            }
            else if (i + stridePoints >= points.length) {
                pointsBuffer[j] = 0;
            }
            j++;
        }
        pointsBuffer[j++] = points[points.length - 4];
        pointsBuffer[j++] = points[points.length - 3];
        pointsBuffer[j++] = 0;
        pointsBuffer[0] = points[0];
        pointsBuffer[1] = points[1];
        pointsBuffer[2] = 0;
        pointsBuffer[3] = points[2];
        pointsBuffer[4] = points[3];
        pointsBuffer[5] = capType === exports.JOINT_TYPE.CAP_ROUND ? capType : 0;
        var instancedCount = Math.round(points.length / stridePoints);
        return {
            pointsBuffer: pointsBuffer,
            travelBuffer: travelBuffer,
            triangles: triangles,
            instancedCount: instancedCount,
        };
    })
        .reduce(function (prev, cur) {
        var _a, _b;
        (_a = prev.pointsBuffer).push.apply(_a, tslib.__spreadArray([], tslib.__read(cur.pointsBuffer), false));
        (_b = prev.travelBuffer).push.apply(_b, tslib.__spreadArray([], tslib.__read(cur.travelBuffer), false));
        prev.instancedCount += cur.instancedCount;
        return prev;
    }, {
        pointsBuffer: [],
        travelBuffer: [],
        triangles: triangles,
        instancedCount: 0,
    });
}
function getJointType(lineJoin) {
    var joint;
    switch (lineJoin) {
        case 'bevel':
            joint = exports.JOINT_TYPE.JOINT_BEVEL;
            break;
        case 'round':
            joint = exports.JOINT_TYPE.JOINT_ROUND;
            break;
        default:
            joint = exports.JOINT_TYPE.JOINT_MITER;
            break;
    }
    return joint;
}
function getCapType(lineCap) {
    var cap;
    switch (lineCap) {
        case 'square':
            cap = exports.JOINT_TYPE.CAP_SQUARE;
            break;
        case 'round':
            cap = exports.JOINT_TYPE.CAP_ROUND;
            break;
        default:
            cap = exports.JOINT_TYPE.CAP_BUTT;
            break;
    }
    return cap;
}
function addTailSegment(x1, y1, x2, y2) {
    if (x2 === void 0) { x2 = x1; }
    if (y2 === void 0) { y2 = y1; }
    var vec = [x2 - x1, y2 - y1];
    var length = 0.01;
    return [x1 + vec[0] * length, y1 + vec[1] * length];
}

var meshFrag = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n\nout vec4 outputColor;\n\nvoid main(){\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n  #ifdef USE_MAP\n  #ifdef USE_PATTERN\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #else\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #endif\n#endif\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n    outputColor = u_Color;\n\n    outputColor.a = outputColor.a * u_Opacity * u_FillOpacity;\n  }\n}"; // eslint-disable-line

var meshVert = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec2 a_Position;\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n  #ifdef VIEWPORT_ORIGIN_TL\n    v_Uv.y = 1.0 - v_Uv.y;\n  #endif\n#endif\n\n  gl_Position = project(vec4(a_Position, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n}"; // eslint-disable-line

var SEGMENT_NUM = 12;
var InstancedFillMesh = /** @class */ (function (_super) {
    tslib.__extends(InstancedFillMesh, _super);
    function InstancedFillMesh(renderHelper, texturePool, lightPool, object) {
        var _this = _super.call(this, renderHelper, texturePool, lightPool, object) || this;
        _this.renderHelper = renderHelper;
        _this.texturePool = texturePool;
        _this.lightPool = lightPool;
        _this.trianglesHash = [[], []];
        _this.trianglesHash = _this.calcSegmentNum(object);
        return _this;
    }
    InstancedFillMesh.prototype.calcSegmentNum = function (object) {
        var _a = updateBuffer(object, true, SEGMENT_NUM), triangles = _a.triangles, pointsBuffer = _a.pointsBuffer;
        return [triangles, pointsBuffer];
    };
    InstancedFillMesh.prototype.compareTrianglesHash = function (hash) {
        var _a = tslib.__read(this.trianglesHash, 2), triangles = _a[0], points = _a[1];
        var _b = tslib.__read(hash, 2), t = _b[0], p = _b[1];
        if (triangles.length !== t.length || points.length !== p.length) {
            return false;
        }
        if (triangles.some(function (n, i) { return n !== t[i]; }) ||
            points.some(function (n, i) { return n !== p[i]; })) {
            return false;
        }
        return true;
    };
    InstancedFillMesh.prototype.shouldMerge = function (object, index) {
        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);
        if (!shouldMerge) {
            return false;
        }
        var trianglesHash = this.calcSegmentNum(object);
        return this.compareTrianglesHash(trianglesHash);
    };
    InstancedFillMesh.prototype.createGeometry = function (objects) {
        // use default common attributes
        _super.prototype.createGeometry.call(this, objects);
        var indices = [];
        var pointsBuffer = [];
        var uvsBuffer = [];
        objects.forEach(function (object, i) {
            // use triangles for Polygon
            var _a = updateBuffer(object, true, SEGMENT_NUM), triangles = _a.triangles, pBuffer = _a.pointsBuffer;
            var halfExtents = object.getGeometryBounds().halfExtents;
            var uvBuffer = pBuffer.map(function (x, i) { return x / halfExtents[i % 2] / 2; });
            pointsBuffer.push.apply(pointsBuffer, tslib.__spreadArray([], tslib.__read(pBuffer), false));
            uvsBuffer.push.apply(uvsBuffer, tslib.__spreadArray([], tslib.__read(uvBuffer), false));
            indices.push.apply(indices, tslib.__spreadArray([], tslib.__read(triangles.map(function (n) { return n + (i * pBuffer.length) / 2; })), false));
        });
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.POSITION,
            byteStride: 4 * 2,
            frequency: exports.VertexBufferFrequency.PerVertex,
            attributes: [
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.POSITION,
                },
            ],
            data: new Float32Array(pointsBuffer),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.UV,
            byteStride: 4 * 2,
            frequency: exports.VertexBufferFrequency.PerVertex,
            attributes: [
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.UV,
                },
            ],
            data: new Float32Array(uvsBuffer),
        });
        this.geometry.vertexCount = indices.length / objects.length;
        this.geometry.setIndexBuffer(new Uint32Array(indices));
    };
    InstancedFillMesh.prototype.createMaterial = function (objects) {
        this.material.vertexShader = meshVert;
        this.material.fragmentShader = meshFrag;
        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), { INSTANCED: true });
    };
    InstancedFillMesh.prototype.updateAttribute = function (objects, startIndex, name, value) {
        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);
        this.updateBatchedAttribute(objects, startIndex, name, value);
    };
    return InstancedFillMesh;
}(Instanced));

var frag$3 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n\nout vec4 outputColor;\n\nvoid main() {\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n  #ifdef USE_MAP\n  #ifdef USE_PATTERN\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #else\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #endif\n#endif\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n\n    // TODO: pointer-events: non-transparent-pixel\n    // if (u_Color.x == 0.0 && u_Color.y == 0.0 && u_Color.z == 0.0) {\n    //   discard;\n    // }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n    outputColor = u_Color;\n    outputColor.a = outputColor.a * u_Opacity;\n  }\n}"; // eslint-disable-line

var vert$2 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec4 a_Size;\n\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\n\nbool isPerspectiveMatrix(mat4 m) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n\n  vec2 offset = (a_Uv - u_Anchor.xy) * a_Size.xy;\n\n  bool isPerspective = isPerspectiveMatrix(u_ProjectionMatrix);\n\n  bool isBillboard = a_Size.w > 0.5;\n  if (isBillboard) {\n    vec4 mvPosition = u_ViewMatrix * u_ModelMatrix * vec4(0.0, 0.0, u_ZIndex, 1.0);\nvec2 scale;\nscale.x = length(vec3(u_ModelMatrix[0][0], u_ModelMatrix[0][1], u_ModelMatrix[0][2]));\nscale.y = length(vec3(u_ModelMatrix[1][0], u_ModelMatrix[1][1], u_ModelMatrix[1][2]));\n\n// if (sizeAttenuation < 0.5) {\n// bool isPerspective = isPerspectiveMatrix( u_ProjectionMatrix );\n// if ( isPerspective ) scale *= - mvPosition.z;\n// }\n\nvec2 alignedPosition = offset * scale;\n\nfloat rotation = 0.0;\nvec2 rotatedPosition;\nrotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\nrotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\n\nmvPosition.xy += rotatedPosition;\n\ngl_Position = u_ProjectionMatrix * mvPosition;\n  } else {\n    gl_Position = project(vec4(offset, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n  }\n\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n  #ifdef VIEWPORT_ORIGIN_TL\n    v_Uv.y = 1.0 - v_Uv.y;\n  #endif\n#endif\n\n}"; // eslint-disable-line

var ImageMesh = /** @class */ (function (_super) {
    tslib.__extends(ImageMesh, _super);
    function ImageMesh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageMesh.prototype.shouldMerge = function (object, index) {
        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);
        if (!shouldMerge) {
            return false;
        }
        if (this.instance.parsedStyle.img !== object.parsedStyle.img) {
            return false;
        }
        return true;
    };
    ImageMesh.prototype.createMaterial = function (objects) {
        var instance = objects[0];
        var img = instance.parsedStyle.img;
        this.material.defines = tslib.__assign({}, this.material.defines);
        this.material.vertexShader = vert$2;
        this.material.fragmentShader = frag$3;
        var map = this.texturePool.getOrCreateTexture(this.context.device, img);
        this.material.setUniforms({
            u_Map: map,
        });
    };
    ImageMesh.prototype.createGeometry = function (objects) {
        // use default common attributes
        _super.prototype.createGeometry.call(this, objects);
        var instanced = [];
        objects.forEach(function (object, i) {
            var image = object;
            var _a = image.parsedStyle, width = _a.width, height = _a.height, z = _a.z, isBillboard = _a.isBillboard;
            instanced.push(width, height, z, isBillboard ? 1 : 0);
        });
        this.geometry.setIndexBuffer(new Uint32Array([0, 2, 1, 0, 3, 2]));
        this.geometry.vertexCount = 6;
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.POSITION,
            byteStride: 4 * 4,
            frequency: exports.VertexBufferFrequency.PerInstance,
            attributes: [
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.POSITION,
                },
            ],
            data: new Float32Array(instanced),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: exports.VertexAttributeBufferIndex.UV,
            byteStride: 4 * 2,
            frequency: exports.VertexBufferFrequency.PerVertex,
            attributes: [
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.UV,
                },
            ],
            data: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        });
    };
    ImageMesh.prototype.updateAttribute = function (objects, startIndex, name, value) {
        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);
        this.updateBatchedAttribute(objects, startIndex, name, value);
        if (name === 'width' ||
            name === 'height' ||
            name === 'z' ||
            name === 'isBillboard') {
            var packed_1 = [];
            objects.forEach(function (object) {
                var image = object;
                var _a = image.parsedStyle, width = _a.width, height = _a.height, z = _a.z, isBillboard = _a.isBillboard;
                packed_1.push(width, height, z, isBillboard ? 1 : 0);
            });
            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.POSITION, exports.VertexAttributeLocation.POSITION, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));
        }
        else if (name === 'img') {
            var map = this.texturePool.getOrCreateTexture(this.context.device, value);
            this.material.setUniforms({
                u_Map: map,
            });
        }
    };
    return ImageMesh;
}(Instanced));

var frag$2 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\nlayout(std140) uniform ub_ObjectParams {\n  vec2 u_SDFMapSize;\n  float u_FontSize;\n  float u_GammaScale;\n  float u_StrokeBlur;\n  float u_HasStroke;\n};\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n\nuniform sampler2D u_SDFMap;\n\n#define SDF_PX 8.0\n\nin float v_GammaScale;\n\nout vec4 outputColor;\n\nvoid main() {\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n\n  float dist = texture(SAMPLER_2D(u_SDFMap), v_Uv).a;\n\n  float EDGE_GAMMA = 0.105 / u_DevicePixelRatio;\n  float fontScale = u_FontSize / 24.0;\n  highp float gamma = EDGE_GAMMA / (fontScale * u_GammaScale);\n  lowp vec4 color = u_Color;\n  lowp float buff = (256.0 - 64.0) / 256.0;\n  float opacity = u_FillOpacity;\n  if (u_HasStroke > 0.5 && u_StrokeWidth > 0.0) {\n    color = u_StrokeColor;\n    gamma = (u_StrokeBlur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_GammaScale);\n    buff = (6.0 - u_StrokeWidth / fontScale / 2.0) / SDF_PX;\n    opacity = u_StrokeOpacity;\n  }\n\n  highp float gamma_scaled = gamma * v_GammaScale;\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n\n  opacity *= alpha * u_Opacity;\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n\n    if (opacity < 0.001) {\n      discard;\n    }\n\n    outputColor = color;\n    outputColor.a *= opacity;\n  }\n}"; // eslint-disable-line

var vert$1 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\n\nlayout(std140) uniform ub_ObjectParams {\n  vec2 u_SDFMapSize;\n  float u_FontSize;\n  float u_GammaScale;\n  float u_StrokeBlur;\n  float u_HasStroke;\n};\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = TEX) in vec2 a_Tex;\nlayout(location = OFFSET) in vec2 a_Offset;\n\nout vec2 v_Uv;\nout float v_GammaScale;\n\nbool isPerspectiveMatrix(mat4 m) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n\n  v_Uv = a_Tex / u_SDFMapSize;\n  float fontScale = u_FontSize / 24.;\n\n  bool isBillboard = a_StylePacked2.y > 0.5;\n  float sizeAttenuation = a_StylePacked2.z;\n  vec2 bufferOffset = vec2(0.7, 2.0);\n  vec2 offset = a_Offset * fontScale + bufferOffset;\n\n  if (isBillboard) {\n    vec4 mvPosition = u_ViewMatrix * u_ModelMatrix * vec4(0.0, 0.0, u_ZIndex, 1.0);\nvec2 scale;\nscale.x = length(vec3(u_ModelMatrix[0][0], u_ModelMatrix[0][1], u_ModelMatrix[0][2]));\nscale.y = length(vec3(u_ModelMatrix[1][0], u_ModelMatrix[1][1], u_ModelMatrix[1][2]));\n\n// if (sizeAttenuation < 0.5) {\n// bool isPerspective = isPerspectiveMatrix( u_ProjectionMatrix );\n// if ( isPerspective ) scale *= - mvPosition.z;\n// }\n\nvec2 alignedPosition = offset * scale;\n\nfloat rotation = 0.0;\nvec2 rotatedPosition;\nrotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\nrotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\n\nmvPosition.xy += rotatedPosition;\n\ngl_Position = u_ProjectionMatrix * mvPosition;\n    v_GammaScale = 1.0;\n  } else {\n    gl_Position = project(vec4((a_Offset) * fontScale + bufferOffset, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n    v_GammaScale = gl_Position.w;\n  }\n}"; // eslint-disable-line

// borrow from mapbox/src/symbol
function createImage(image, _a, channels, data) {
    var width = _a.width, height = _a.height;
    if (!data) {
        data = new Uint8Array(width * height * channels);
    }
    else if (data.length !== width * height * channels) {
        throw new RangeError('mismatched image size');
    }
    image.width = width;
    image.height = height;
    image.data = data;
    return image;
}
function resizeImage(image, _a, channels) {
    var width = _a.width, height = _a.height;
    if (width === image.width && height === image.height) {
        return;
    }
    var newImage = createImage({}, { width: width, height: height }, channels);
    copyImage(image, newImage, { x: 0, y: 0 }, { x: 0, y: 0 }, {
        width: Math.min(image.width, width),
        height: Math.min(image.height, height),
    }, channels);
    image.width = width;
    image.height = height;
    image.data = newImage.data;
}
function copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {
    if (size.width === 0 || size.height === 0) {
        return dstImg;
    }
    if (size.width > srcImg.width ||
        size.height > srcImg.height ||
        srcPt.x > srcImg.width - size.width ||
        srcPt.y > srcImg.height - size.height) {
        throw new RangeError('out of range source coordinates for image copy');
    }
    if (size.width > dstImg.width ||
        size.height > dstImg.height ||
        dstPt.x > dstImg.width - size.width ||
        dstPt.y > dstImg.height - size.height) {
        throw new RangeError('out of range destination coordinates for image copy');
    }
    var srcData = srcImg.data;
    var dstData = dstImg.data;
    for (var y = 0; y < size.height; y++) {
        var srcOffset = ((srcPt.y + y) * srcImg.width + srcPt.x) * channels;
        var dstOffset = ((dstPt.y + y) * dstImg.width + dstPt.x) * channels;
        for (var i = 0; i < size.width * channels; i++) {
            dstData[dstOffset + i] = srcData[srcOffset + i];
        }
    }
    return dstImg;
}
var AlphaImage = /** @class */ (function () {
    function AlphaImage(size, data) {
        createImage(this, size, 1, data);
    }
    AlphaImage.prototype.resize = function (size) {
        resizeImage(this, size, 1);
    };
    AlphaImage.prototype.clone = function () {
        return new AlphaImage({ width: this.width, height: this.height }, new Uint8Array(this.data));
    };
    AlphaImage.copy = function (srcImg, dstImg, srcPt, dstPt, size) {
        copyImage(srcImg, dstImg, srcPt, dstPt, size, 1);
    };
    return AlphaImage;
}());

// borrow from https://github.com/mapbox/potpack/blob/master/index.mjs
// @see https://github.com/antvis/g/issues/836
function potpack(boxes) {
    var e_1, _a, e_2, _b;
    // calculate total box area and maximum box width
    var area = 0;
    var maxWidth = 0;
    try {
        for (var boxes_1 = tslib.__values(boxes), boxes_1_1 = boxes_1.next(); !boxes_1_1.done; boxes_1_1 = boxes_1.next()) {
            var box = boxes_1_1.value;
            area += box.w * box.h;
            maxWidth = Math.max(maxWidth, box.w);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (boxes_1_1 && !boxes_1_1.done && (_a = boxes_1.return)) _a.call(boxes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // sort the boxes for insertion by height, descending
    boxes.sort(function (a, b) { return b.h - a.h; });
    // aim for a squarish resulting container,
    // slightly adjusted for sub-100% space utilization
    var startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
    // start with a single empty space, unbounded at the bottom
    var spaces = [{ x: 0, y: 0, w: startWidth, h: Infinity }];
    var width = 0;
    var height = 0;
    try {
        for (var boxes_2 = tslib.__values(boxes), boxes_2_1 = boxes_2.next(); !boxes_2_1.done; boxes_2_1 = boxes_2.next()) {
            var box = boxes_2_1.value;
            // look through spaces backwards so that we check smaller spaces first
            for (var i = spaces.length - 1; i >= 0; i--) {
                var space = spaces[i];
                // look for empty spaces that can accommodate the current box
                if (box.w > space.w || box.h > space.h)
                    continue;
                // found the space; add the box to its top-left corner
                // |-------|-------|
                // |  box  |       |
                // |_______|       |
                // |         space |
                // |_______________|
                box.x = space.x;
                box.y = space.y;
                height = Math.max(height, box.y + box.h);
                width = Math.max(width, box.x + box.w);
                if (box.w === space.w && box.h === space.h) {
                    // space matches the box exactly; remove it
                    var last = spaces.pop();
                    if (i < spaces.length)
                        spaces[i] = last;
                }
                else if (box.h === space.h) {
                    // space matches the box height; update it accordingly
                    // |-------|---------------|
                    // |  box  | updated space |
                    // |_______|_______________|
                    space.x += box.w;
                    space.w -= box.w;
                }
                else if (box.w === space.w) {
                    // space matches the box width; update it accordingly
                    // |---------------|
                    // |      box      |
                    // |_______________|
                    // | updated space |
                    // |_______________|
                    space.y += box.h;
                    space.h -= box.h;
                }
                else {
                    // otherwise the box splits the space into two spaces
                    // |-------|-----------|
                    // |  box  | new space |
                    // |_______|___________|
                    // | updated space     |
                    // |___________________|
                    spaces.push({
                        x: space.x + box.w,
                        y: space.y,
                        w: space.w - box.w,
                        h: box.h,
                    });
                    space.y += box.h;
                    space.h -= box.h;
                }
                break;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (boxes_2_1 && !boxes_2_1.done && (_b = boxes_2.return)) _b.call(boxes_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return {
        w: width,
        h: height,
        fill: area / (width * height) || 0, // space utilization
    };
}
var padding = 1;
/**
 * Merge SDFs into a large squared atlas with `potpack`,
 * because on WebGL1 context, all textures are resized to a power of two to produce the best quality.
 *
 * @see https://doc.babylonjs.com/advanced_topics/webGL2#power-of-two-textures
 */
var GlyphAtlas = /** @class */ (function () {
    function GlyphAtlas(stacks) {
        var positions = {};
        var bins = [];
        for (var stack in stacks) {
            var glyphs = stacks[stack];
            // @ts-ignore
            var stackPositions = (positions[stack] = {});
            for (var id in glyphs) {
                var src = glyphs[+id];
                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0)
                    continue;
                var bin = {
                    x: 0,
                    y: 0,
                    w: src.bitmap.width + 2 * padding,
                    h: src.bitmap.height + 2 * padding,
                };
                bins.push(bin);
                // @ts-ignore
                stackPositions[id] = { rect: bin, metrics: src.metrics };
            }
        }
        var _a = potpack(bins), w = _a.w, h = _a.h;
        var image = new AlphaImage({ width: w || 1, height: h || 1 });
        for (var stack in stacks) {
            var glyphs = stacks[stack];
            for (var id in glyphs) {
                var src = glyphs[+id];
                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0)
                    continue;
                // @ts-ignore
                var bin = positions[stack][id].rect;
                AlphaImage.copy(src.bitmap, image, { x: 0, y: 0 }, { x: bin.x + padding, y: bin.y + padding }, src.bitmap);
            }
        }
        this.image = image;
        this.positions = positions;
    }
    return GlyphAtlas;
}());

var BASE_FONT_WIDTH = 24;
var BASE_FONT_BUFFER = 3;
var fontSize = BASE_FONT_WIDTH; // Font size in pixels
var buffer = BASE_FONT_BUFFER; // Whitespace buffer around a glyph in pixels
var radius = 8; // How many pixels around the glyph shape to use for encoding distance
var cutoff = 0.25; // How much of the radius (relative) is used for the inside part the glyph
function getDefaultCharacterSet() {
    var charSet = [];
    for (var i = 32; i < 128; i++) {
        charSet.push(String.fromCharCode(i));
    }
    return charSet;
}
/**
 * TODO: use one atlas for all fontstacks, each fontstack has one texture now
 */
var GlyphManager = /** @class */ (function () {
    function GlyphManager() {
        this.sdfGeneratorCache = {};
        this.textMetricsCache = {};
        this.glyphMap = {};
    }
    GlyphManager.prototype.getMap = function () {
        return this.glyphMap;
    };
    GlyphManager.prototype.getAtlas = function () {
        return this.glyphAtlas;
    };
    GlyphManager.prototype.getAtlasTexture = function () {
        return this.glyphAtlasTexture;
    };
    GlyphManager.prototype.layout = function (lines, fontStack, lineHeight, textAlign, letterSpacing, offsetX, offsetY) {
        var _this = this;
        var positionedGlyphs = [];
        var x = offsetX;
        var y = offsetY;
        var justify = textAlign === 'right' || textAlign === 'end'
            ? 1
            : textAlign === 'left' || textAlign === 'start'
                ? 0
                : 0.5;
        lines.forEach(function (line) {
            var lineStartIndex = positionedGlyphs.length;
            Array.from(line).forEach(function (char) {
                // fontStack
                var positions = _this.glyphMap[fontStack];
                var charCode = char.charCodeAt(0);
                var glyph = positions && positions[charCode];
                if (glyph) {
                    positionedGlyphs.push({
                        glyph: charCode,
                        x: x,
                        y: y,
                        scale: 1,
                        fontStack: fontStack,
                    });
                    x += glyph.metrics.advance + letterSpacing;
                }
            });
            var lineWidth = x - letterSpacing;
            for (var i = lineStartIndex; i < positionedGlyphs.length; i++) {
                positionedGlyphs[i].x = positionedGlyphs[i].x - justify * lineWidth;
            }
            x = 0;
            y += lineHeight;
        });
        return positionedGlyphs;
    };
    GlyphManager.prototype.generateAtlas = function (canvas, fontStack, fontFamily, fontWeight, fontStyle, text, device) {
        var _this = this;
        if (fontStack === void 0) { fontStack = ''; }
        if (fontStyle === void 0) { fontStyle = ''; }
        var newChars = [];
        if (!this.glyphMap[fontStack]) {
            newChars = getDefaultCharacterSet();
        }
        var existedChars = Object.keys(this.glyphMap[fontStack] || {});
        Array.from(new Set(text.split(''))).forEach(function (char) {
            if (existedChars.indexOf(char.charCodeAt(0).toString()) === -1) {
                newChars.push(char);
            }
        });
        if (newChars.length) {
            var glyphMap = newChars
                .map(function (char) {
                return _this.generateSDF(canvas, fontStack, fontFamily, fontWeight, fontStyle, char);
            })
                .reduce(function (prev, cur) {
                // @ts-ignore
                prev[cur.id] = cur;
                return prev;
            }, {});
            this.glyphMap[fontStack] = tslib.__assign(tslib.__assign({}, this.glyphMap[fontStack]), glyphMap);
            this.glyphAtlas = new GlyphAtlas(this.glyphMap);
            var _a = this.glyphAtlas.image, atlasWidth = _a.width, atlasHeight = _a.height, data = _a.data;
            if (this.glyphAtlasTexture) {
                this.glyphAtlasTexture.destroy();
            }
            this.glyphAtlasTexture = device.createTexture(tslib.__assign(tslib.__assign({}, makeTextureDescriptor2D(exports.Format.ALPHA, atlasWidth, atlasHeight, 1)), { pixelStore: {
                    unpackFlipY: false,
                    unpackAlignment: 1,
                }, immutable: false }));
            this.glyphAtlasTexture.setImageData([data], 0);
        }
    };
    GlyphManager.prototype.generateSDF = function (canvas, fontStack, fontFamily, fontWeight, fontStyle, char) {
        if (fontStack === void 0) { fontStack = ''; }
        var charCode = char.charCodeAt(0);
        var sdfGenerator = this.sdfGeneratorCache[fontStack];
        if (!sdfGenerator) {
            // 创建 SDF
            sdfGenerator = this.sdfGeneratorCache[fontStack] =
                // TODO: use OffscreenCanvas in TextService
                new TinySDF({
                    canvas: canvas,
                    fontSize: fontSize,
                    fontFamily: fontFamily,
                    fontWeight: fontWeight,
                    fontStyle: fontStyle,
                    buffer: buffer,
                    radius: radius,
                    cutoff: cutoff,
                });
        }
        if (!this.textMetricsCache[fontStack]) {
            this.textMetricsCache[fontStack] = {};
        }
        if (!this.textMetricsCache[fontStack][char]) {
            // 使用 mapbox/tiny-sdf 中的 context
            // @see https://stackoverflow.com/questions/46126565/how-to-get-font-glyphs-metrics-details-in-javascript
            this.textMetricsCache[fontStack][char] =
                // @ts-ignore
                sdfGenerator.ctx.measureText(char).width;
        }
        // use sdf 2.x @see https://github.com/mapbox/tiny-sdf
        var _a = sdfGenerator.draw(char), data = _a.data, width = _a.width, height = _a.height, glyphWidth = _a.glyphWidth, glyphHeight = _a.glyphHeight, glyphLeft = _a.glyphLeft, glyphTop = _a.glyphTop, glyphAdvance = _a.glyphAdvance;
        return {
            id: charCode,
            // 在 canvas 中绘制字符，使用 Uint8Array 存储 30*30 sdf 数据
            bitmap: new AlphaImage({
                width: width,
                height: height,
            }, data),
            metrics: {
                width: glyphWidth,
                height: glyphHeight,
                left: glyphLeft,
                top: glyphTop - BASE_FONT_WIDTH + BASE_FONT_BUFFER,
                advance: glyphAdvance,
            },
        };
    };
    return GlyphManager;
}());

/**
 * Create the quads used for rendering a text label.
 */
function getGlyphQuads(positionedGlyphs, positions) {
    var quads = [];
    for (var k = 0; k < positionedGlyphs.length; k++) {
        var positionedGlyph = positionedGlyphs[k];
        var glyphPositions = positions[positionedGlyph.fontStack];
        var glyph = glyphPositions && glyphPositions[positionedGlyph.glyph];
        if (!glyph)
            continue;
        var rect = glyph.rect;
        if (!rect)
            continue;
        // The rects have an addditional buffer that is not included in their size.
        var glyphPadding = 1.0;
        // const glyphPadding = 0.0;
        var rectBuffer = BASE_FONT_BUFFER + glyphPadding;
        var halfAdvance = (glyph.metrics.advance * positionedGlyph.scale) / 2;
        var glyphOffset = [0, 0];
        var builtInOffset = [positionedGlyph.x + halfAdvance, positionedGlyph.y];
        var x1 = (glyph.metrics.left - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];
        var y1 = (-glyph.metrics.top - rectBuffer) * positionedGlyph.scale + builtInOffset[1];
        var x2 = x1 + rect.w * positionedGlyph.scale;
        var y2 = y1 + rect.h * positionedGlyph.scale;
        var tl = { x: x1, y: y1 };
        var tr = { x: x2, y: y1 };
        var bl = { x: x1, y: y2 };
        var br = { x: x2, y: y2 };
        quads.push({ tl: tl, tr: tr, bl: bl, br: br, tex: rect, glyphOffset: glyphOffset });
    }
    return quads;
}

var TextVertexAttributeBufferIndex;
(function (TextVertexAttributeBufferIndex) {
    TextVertexAttributeBufferIndex[TextVertexAttributeBufferIndex["INSTANCED"] = 5] = "INSTANCED";
    TextVertexAttributeBufferIndex[TextVertexAttributeBufferIndex["TEX"] = 6] = "TEX";
})(TextVertexAttributeBufferIndex || (TextVertexAttributeBufferIndex = {}));
var TextVertexAttributeLocation;
(function (TextVertexAttributeLocation) {
    TextVertexAttributeLocation[TextVertexAttributeLocation["TEX"] = 12] = "TEX";
    TextVertexAttributeLocation[TextVertexAttributeLocation["OFFSET"] = 13] = "OFFSET";
})(TextVertexAttributeLocation || (TextVertexAttributeLocation = {}));
exports.TextUniform = void 0;
(function (TextUniform) {
    TextUniform["SDF_MAP"] = "u_SDFMap";
    TextUniform["SDF_MAP_SIZE"] = "u_SDFMapSize";
    TextUniform["FONT_SIZE"] = "u_FontSize";
    TextUniform["GAMMA_SCALE"] = "u_GammaScale";
    TextUniform["STROKE_BLUR"] = "u_StrokeBlur";
    TextUniform["HAS_STROKE"] = "u_HasStroke";
})(exports.TextUniform || (exports.TextUniform = {}));
var TextMesh = /** @class */ (function (_super) {
    tslib.__extends(TextMesh, _super);
    function TextMesh(renderHelper, texturePool, lightPool, object) {
        var _this = _super.call(this, renderHelper, texturePool, lightPool, object) || this;
        _this.renderHelper = renderHelper;
        _this.texturePool = texturePool;
        _this.lightPool = lightPool;
        _this.glyphManager = new GlyphManager();
        _this.packedBufferObjectMap = new WeakMap();
        _this.tmpMat4 = glMatrix.mat4.create();
        _this.fontHash = _this.calcFontHash(object);
        return _this;
    }
    TextMesh.prototype.calcFontHash = function (object) {
        var instancedAttributes = [
            'fontSize',
            'fontFamily',
            'fontWeight',
            'textBaseline',
            'letterSpacing',
        ];
        return (object.parsedStyle.metrics.font +
            instancedAttributes.reduce(function (prev, cur) {
                return prev + object.parsedStyle[cur];
            }, ''));
    };
    TextMesh.prototype.shouldMerge = function (object, index) {
        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);
        if (!shouldMerge) {
            return false;
        }
        if (this.index !== index) {
            return false;
        }
        return this.fontHash === this.calcFontHash(object);
    };
    TextMesh.prototype.createGeometry = function (objects) {
        var _this = this;
        var object = this.instance;
        var _a = object.parsedStyle, textBaseline = _a.textBaseline, fontSize = _a.fontSize, letterSpacing = _a.letterSpacing;
        // scale current font size to base(24)
        var fontScale = BASE_FONT_WIDTH / fontSize;
        var indices = [];
        var uvOffsets = [];
        var packed = [];
        var indicesOff = 0;
        objects.forEach(function (object) {
            var _a = object.parsedStyle, metrics = _a.metrics, dx = _a.dx, dy = _a.dy;
            var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight;
            // account for dx & dy
            var offsetX = dx || 0;
            var offsetY = dy || 0;
            var linePositionY = 0;
            // handle vertical text baseline
            if (textBaseline === 'middle') {
                linePositionY = -height / 2;
            }
            else if (textBaseline === 'bottom') {
                linePositionY = -height;
            }
            else if (textBaseline === 'top' || textBaseline === 'hanging') {
                linePositionY = 0;
            }
            else if (textBaseline === 'alphabetic') {
                linePositionY = -height + lineHeight * 0.25;
                if (!gLite.runtime.enableCSSParsing) {
                    linePositionY = -height;
                }
                // linePositionY = -height + fontProperties.ascent;
            }
            else if (textBaseline === 'ideographic') {
                linePositionY = -height;
            }
            var glyphAtlas = _this.glyphManager.getAtlas();
            var _b = _this.buildTextBuffers({
                object: object,
                lines: lines,
                fontStack: font,
                lineHeight: fontScale * lineHeight,
                offsetX: fontScale * offsetX,
                offsetY: fontScale * (linePositionY + offsetY),
                letterSpacing: fontScale * letterSpacing,
                glyphAtlas: glyphAtlas,
                indicesOffset: indicesOff,
            }), indicesOffset = _b.indicesOffset, indexBuffer = _b.indexBuffer, charUVOffsetBuffer = _b.charUVOffsetBuffer, charPackedBuffer = _b.charPackedBuffer;
            indicesOff = indicesOffset;
            var start = packed.length;
            packed.push.apply(packed, tslib.__spreadArray([], tslib.__read(charPackedBuffer), false));
            var end = packed.length;
            _this.packedBufferObjectMap.set(object, [start, end]);
            uvOffsets.push.apply(uvOffsets, tslib.__spreadArray([], tslib.__read(charUVOffsetBuffer), false));
            indices.push.apply(indices, tslib.__spreadArray([], tslib.__read(indexBuffer), false));
        });
        this.geometry.vertexCount = indices.length;
        this.geometry.setIndexBuffer(new Uint32Array(indices));
        this.geometry.setVertexBuffer({
            bufferIndex: TextVertexAttributeBufferIndex.INSTANCED,
            byteStride: 4 * (4 * 4 + 4 + 4 + 4 + 4),
            frequency: exports.VertexBufferFrequency.PerVertex,
            attributes: [
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 0,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX0,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 4,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX1,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 8,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX2,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 12,
                    location: exports.VertexAttributeLocation.MODEL_MATRIX3,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 16,
                    location: exports.VertexAttributeLocation.PACKED_COLOR,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 20,
                    location: exports.VertexAttributeLocation.PACKED_STYLE1,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 24,
                    location: exports.VertexAttributeLocation.PACKED_STYLE2,
                },
                {
                    format: exports.Format.F32_RGBA,
                    bufferByteOffset: 4 * 28,
                    location: exports.VertexAttributeLocation.PICKING_COLOR,
                },
            ],
            data: new Float32Array(packed),
        });
        this.geometry.setVertexBuffer({
            bufferIndex: TextVertexAttributeBufferIndex.TEX,
            byteStride: 4 * (2 + 2),
            frequency: exports.VertexBufferFrequency.PerVertex,
            attributes: [
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 0,
                    location: TextVertexAttributeLocation.TEX,
                },
                {
                    format: exports.Format.F32_RG,
                    bufferByteOffset: 4 * 2,
                    location: TextVertexAttributeLocation.OFFSET,
                },
            ],
            data: new Float32Array(uvOffsets),
        });
    };
    TextMesh.prototype.createMaterial = function (objects) {
        var _a;
        this.material.vertexShader = vert$1;
        this.material.fragmentShader = frag$2;
        this.material.cullMode = exports.CullMode.Back;
        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(TextVertexAttributeLocation));
        var object = this.instance;
        var _b = object.parsedStyle, fontSize = _b.fontSize, _c = _b.fontFamily, fontFamily = _c === void 0 ? '' : _c, _d = _b.fontWeight, fontWeight = _d === void 0 ? '' : _d, fontStyle = _b.fontStyle, metrics = _b.metrics;
        var font = metrics.font;
        var allText = objects.map(function (object) { return object.parsedStyle.text; }).join('');
        this.glyphManager.generateAtlas(this.texturePool.context.config.offscreenCanvas, font, fontFamily, fontWeight.toString(), fontStyle, allText, this.context.device);
        var glyphAtlasTexture = this.glyphManager.getAtlasTexture();
        var glyphAtlas = this.glyphManager.getAtlas();
        this.context.device.setResourceName(glyphAtlasTexture, 'TextSDF Texture');
        var _e = glyphAtlas.image, atlasWidth = _e.width, atlasHeight = _e.height;
        this.material.setUniforms((_a = {},
            _a[exports.TextUniform.SDF_MAP] = glyphAtlasTexture,
            _a[exports.TextUniform.SDF_MAP_SIZE] = [atlasWidth, atlasHeight],
            _a[exports.TextUniform.FONT_SIZE] = fontSize,
            _a[exports.TextUniform.GAMMA_SCALE] = 1,
            _a[exports.TextUniform.STROKE_BLUR] = 0.2,
            _a[exports.TextUniform.HAS_STROKE] = this.index,
            _a));
    };
    TextMesh.prototype.changeRenderOrder = function (object, renderOrder) {
        var vertice = this.geometry.vertices[TextVertexAttributeBufferIndex.INSTANCED];
        var byteStride = this.geometry.inputLayoutDescriptor.vertexBufferDescriptors[TextVertexAttributeBufferIndex.INSTANCED].byteStride;
        var bytes = byteStride / 4;
        var _a = tslib.__read(this.packedBufferObjectMap.get(object), 2), start = _a[0], end = _a[1];
        var sliced = vertice.slice(start, end);
        for (var i = 0; i < end - start; i += bytes) {
            sliced[i + bytes - 1] = renderOrder * RENDER_ORDER_SCALE;
        }
        this.geometry.updateVertexBuffer(TextVertexAttributeBufferIndex.INSTANCED, exports.VertexAttributeLocation.MODEL_MATRIX0, start / bytes, new Uint8Array(sliced.buffer));
    };
    TextMesh.prototype.updateAttribute = function (objects, startIndex, name, value) {
        var _this = this;
        if (name === 'text' ||
            name === 'fontFamily' ||
            name === 'fontSize' ||
            name === 'fontWeight' ||
            name === 'fontStyle' ||
            name === 'fontVariant' ||
            name === 'textBaseline' ||
            name === 'letterSpacing' ||
            name === 'wordWrapWidth' ||
            name === 'lineHeight' ||
            name === 'wordWrap' ||
            name === 'textAlign' ||
            name === 'dx' ||
            name === 'dy') {
            this.material.programDirty = true;
            this.material.geometryDirty = true;
            // need re-upload SDF texture
            this.material.textureDirty = true;
        }
        else if (name === 'modelMatrix' ||
            name === 'fill' ||
            name === 'fillOpacity' ||
            name === 'stroke' ||
            name === 'strokeOpacity' ||
            name === 'opacity' ||
            name === 'lineWidth' ||
            name === 'visibility' ||
            name === 'pointerEvents' ||
            name === 'isBillboard') {
            var vertice_1 = this.geometry.vertices[TextVertexAttributeBufferIndex.INSTANCED];
            var byteStride = this.geometry.inputLayoutDescriptor.vertexBufferDescriptors[TextVertexAttributeBufferIndex.INSTANCED].byteStride;
            var bytes_1 = byteStride / 4;
            objects.forEach(function (object) {
                var _a;
                var _b = object.parsedStyle, fill = _b.fill, stroke = _b.stroke, opacity = _b.opacity, fillOpacity = _b.fillOpacity, strokeOpacity = _b.strokeOpacity, lineWidth = _b.lineWidth, visibility = _b.visibility, isBillboard = _b.isBillboard, sizeAttenuation = _b.sizeAttenuation;
                var fillColor = [0, 0, 0, 0];
                if (gLite.isCSSRGB(fill)) {
                    fillColor = [
                        Number(fill.r),
                        Number(fill.g),
                        Number(fill.b),
                        Number(fill.alpha) * 255,
                    ];
                }
                var strokeColor = [0, 0, 0, 0];
                if (gLite.isCSSRGB(stroke)) {
                    strokeColor = [
                        Number(stroke.r),
                        Number(stroke.g),
                        Number(stroke.b),
                        Number(stroke.alpha) * 255,
                    ];
                }
                var encodedPickingColor = (object.isInteractive() &&
                    (
                    // @ts-ignore
                    (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];
                var modelMatrix = glMatrix.mat4.copy(_this.tmpMat4, object.getWorldTransform());
                var _c = tslib.__read(_this.packedBufferObjectMap.get(object), 2), start = _c[0], end = _c[1];
                var sliced = vertice_1.slice(start, end);
                for (var i = 0; i < end - start; i += bytes_1) {
                    if (name === 'modelMatrix') {
                        sliced[i + 0] = modelMatrix[0];
                        sliced[i + 1] = modelMatrix[1];
                        sliced[i + 2] = modelMatrix[2];
                        sliced[i + 3] = modelMatrix[3];
                        sliced[i + 4] = modelMatrix[4];
                        sliced[i + 5] = modelMatrix[5];
                        sliced[i + 6] = modelMatrix[6];
                        sliced[i + 7] = modelMatrix[7];
                        sliced[i + 8] = modelMatrix[8];
                        sliced[i + 9] = modelMatrix[9];
                        sliced[i + 10] = modelMatrix[10];
                        sliced[i + 11] = modelMatrix[11];
                        sliced[i + 12] = modelMatrix[12];
                        sliced[i + 13] = modelMatrix[13];
                        sliced[i + 14] = modelMatrix[14];
                        sliced[i + 15] = modelMatrix[15];
                    }
                    else if (name === 'fill') {
                        sliced[i + 16] = packUint8ToFloat(fillColor[0], fillColor[1]);
                        sliced[i + 17] = packUint8ToFloat(fillColor[2], fillColor[3]);
                    }
                    else if (name === 'stroke') {
                        sliced[i + 18] = packUint8ToFloat(strokeColor[0], strokeColor[1]);
                        sliced[i + 19] = packUint8ToFloat(strokeColor[2], strokeColor[3]);
                    }
                    sliced[i + 20] = opacity;
                    sliced[i + 21] = fillOpacity;
                    sliced[i + 22] = strokeOpacity;
                    sliced[i + 23] = lineWidth;
                    sliced[i + 24] = visibility === 'visible' ? 1 : 0;
                    sliced[i + 25] = isBillboard ? 1 : 0;
                    sliced[i + 26] = sizeAttenuation ? 1 : 0;
                    sliced[i + 27] = 0;
                    sliced[i + 28] = encodedPickingColor[0];
                    sliced[i + 29] = encodedPickingColor[1];
                    sliced[i + 30] = encodedPickingColor[2];
                    // sliced[i + 31] = object.sortable.renderOrder * RENDER_ORDER_SCALE;
                }
                _this.geometry.updateVertexBuffer(TextVertexAttributeBufferIndex.INSTANCED, exports.VertexAttributeLocation.MODEL_MATRIX0, start / bytes_1, new Uint8Array(sliced.buffer));
            });
        }
    };
    TextMesh.prototype.buildTextBuffers = function (_a) {
        var _b;
        var object = _a.object, lines = _a.lines, fontStack = _a.fontStack, lineHeight = _a.lineHeight, letterSpacing = _a.letterSpacing, offsetX = _a.offsetX, offsetY = _a.offsetY, glyphAtlas = _a.glyphAtlas, indicesOffset = _a.indicesOffset;
        var _c = object.parsedStyle, textAlign = _c.textAlign, fill = _c.fill, stroke = _c.stroke, opacity = _c.opacity, fillOpacity = _c.fillOpacity, strokeOpacity = _c.strokeOpacity, lineWidth = _c.lineWidth, visibility = _c.visibility, isBillboard = _c.isBillboard, sizeAttenuation = _c.sizeAttenuation;
        var fillColor = [0, 0, 0, 0];
        if (gLite.isCSSRGB(fill)) {
            fillColor = [
                Number(fill.r),
                Number(fill.g),
                Number(fill.b),
                Number(fill.alpha) * 255,
            ];
        }
        var strokeColor = [0, 0, 0, 0];
        if (gLite.isCSSRGB(stroke)) {
            strokeColor = [
                Number(stroke.r),
                Number(stroke.g),
                Number(stroke.b),
                Number(stroke.alpha) * 255,
            ];
        }
        var encodedPickingColor = (object.isInteractive() &&
            (
            // @ts-ignore
            (_b = object.renderable3D) === null || _b === void 0 ? void 0 : _b.encodedPickingColor)) || [0, 0, 0];
        var modelMatrix = glMatrix.mat4.copy(this.tmpMat4, object.getWorldTransform());
        var charPackedBuffer = [];
        var charUVOffsetBuffer = [];
        var indexBuffer = [];
        var i = indicesOffset;
        var positionedGlyphs = this.glyphManager.layout(lines, fontStack, lineHeight, textAlign, letterSpacing, offsetX, offsetY);
        // 计算每个独立字符相对于锚点的位置信息
        var glyphQuads = getGlyphQuads(positionedGlyphs, glyphAtlas.positions);
        glyphQuads.forEach(function (quad) {
            // rollup will use `concat`
            var temp = [];
            temp.push.apply(temp, tslib.__spreadArray([], tslib.__read(modelMatrix), false));
            var packed = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(temp), false), [
                packUint8ToFloat(fillColor[0], fillColor[1]),
                packUint8ToFloat(fillColor[2], fillColor[3]),
                packUint8ToFloat(strokeColor[0], strokeColor[1]),
                packUint8ToFloat(strokeColor[2], strokeColor[3]),
                opacity,
                fillOpacity,
                strokeOpacity,
                lineWidth,
                visibility === 'visible' ? 1 : 0,
                isBillboard ? 1 : 0,
                sizeAttenuation ? 1 : 0,
                0
            ], false), tslib.__read(encodedPickingColor), false), [
                object.sortable.renderOrder * RENDER_ORDER_SCALE,
            ], false);
            // Can't use instanced here since the total number of each Text can be different.
            charPackedBuffer.push.apply(charPackedBuffer, tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(packed), false), tslib.__read(packed), false), tslib.__read(packed), false), tslib.__read(packed), false));
            // interleaved uv & offsets
            charUVOffsetBuffer.push(quad.tex.x, quad.tex.y, quad.tl.x, quad.tl.y);
            charUVOffsetBuffer.push(quad.tex.x + quad.tex.w, quad.tex.y, quad.tr.x, quad.tr.y);
            charUVOffsetBuffer.push(quad.tex.x + quad.tex.w, quad.tex.y + quad.tex.h, quad.br.x, quad.br.y);
            charUVOffsetBuffer.push(quad.tex.x, quad.tex.y + quad.tex.h, quad.bl.x, quad.bl.y);
            indexBuffer.push(0 + i, 2 + i, 1 + i);
            indexBuffer.push(2 + i, 0 + i, 3 + i);
            i += 4;
        });
        return {
            indexBuffer: indexBuffer,
            charUVOffsetBuffer: charUVOffsetBuffer,
            charPackedBuffer: charPackedBuffer,
            indicesOffset: i,
        };
    };
    return TextMesh;
}(Instanced));

var MeshMesh = /** @class */ (function (_super) {
    tslib.__extends(MeshMesh, _super);
    function MeshMesh() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.lightReceived = true;
        return _this;
    }
    MeshMesh.prototype.shouldMerge = function (object, index) {
        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);
        if (!shouldMerge) {
            return false;
        }
        if (this.instance.nodeName === gLite.Shape.MESH) {
            if (this.instance.parsedStyle.material !== object.parsedStyle.material ||
                this.instance.parsedStyle.geometry !== object.parsedStyle.geometry) {
                return false;
            }
        }
        return true;
    };
    MeshMesh.prototype.updateAttribute = function (objects, startIndex, name, value) {
        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);
        this.updateBatchedAttribute(objects, startIndex, name, value);
    };
    MeshMesh.prototype.createMaterial = function (objects) {
        var material = this.instance.parsedStyle.material;
        this.material = material;
        this.observeMaterialChanged();
    };
    MeshMesh.prototype.createGeometry = function (objects) {
        var geometry = this.instance.parsedStyle.geometry;
        this.geometry = geometry;
        // use default common attributes
        _super.prototype.createGeometry.call(this, objects);
        this.geometry.build(objects);
        // TODO: clear dirty listener
        this.observeGeometryChanged();
    };
    return MeshMesh;
}(Instanced));

/**
 * Use 2 meshes:
 * * SDF to draw fill & simple stroke if needed.
 * * InstancedPathMesh to draw stroke separately.
 */
var CircleRenderer = /** @class */ (function (_super) {
    tslib.__extends(CircleRenderer, _super);
    function CircleRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [SDFMesh, InstancedPathMesh];
        return _this;
    }
    CircleRenderer.prototype.shouldSubmitRenderInst = function (object, index) {
        if (index === 0) {
            var fill = object.parsedStyle.fill;
            if (fill.isNone) {
                return false;
            }
        }
        if (index === 1) {
            return this.needDrawStrokeSeparately(object);
        }
        return true;
    };
    /**
     * need an additional mesh to draw stroke:
     * 1. strokeOpacity < 1
     * 2. lineDash used
     * 3. stroke is not 'none'
     */
    CircleRenderer.prototype.needDrawStrokeSeparately = function (object) {
        var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke, lineDash = _a.lineDash, lineWidth = _a.lineWidth, strokeOpacity = _a.strokeOpacity;
        var hasFill = fill && !fill.isNone;
        var hasStroke = stroke && !stroke.isNone;
        var hasDash = lineDash &&
            lineDash.length &&
            lineDash.every(function (item) { return item !== 0; });
        return (!hasFill || (hasStroke && lineWidth > 0 && (strokeOpacity < 1 || hasDash)));
    };
    return CircleRenderer;
}(Batch));

/**
 * Use the following perf enhancements:
 * * Downgrading the "simple" Path / Polyline to {@link InstancedLineMesh}, e.g. 'M 0 0 L 100 0'
 * * Merge the Path into {@link InstancedPathMesh} which contains only one curve command, e.g 'M 0 0 Q 10 10 100 100'
 * @see https://github.com/antvis/G/issues/1113
 */
var PathRenderer = /** @class */ (function (_super) {
    tslib.__extends(PathRenderer, _super);
    function PathRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [InstancedFillMesh, InstancedLineMesh, InstancedPathMesh];
        return _this;
    }
    PathRenderer.prototype.shouldSubmitRenderInst = function (object, index) {
        var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, lineWidth = _a.lineWidth;
        var hasStroke = stroke && !stroke.isNone;
        var isLine = InstancedLineMesh.isLine(object);
        object.renderable.proxyNodeName = isLine ? gLite.Shape.LINE : null;
        // Polyline don't need fill
        if (index === 0 &&
            (object.nodeName === gLite.Shape.POLYLINE || fill.isNone)) {
            return false;
        }
        // use Line for simple Path
        if (index === 1) {
            return isLine;
        }
        if (index === 2) {
            if (isLine ||
                strokeOpacity === 0 ||
                opacity === 0 ||
                lineWidth === 0 ||
                !hasStroke) {
                return false;
            }
            return true;
        }
        return true;
    };
    return PathRenderer;
}(Batch));

/** @class */ ((function (_super) {
    tslib.__extends(GroupRenderer, _super);
    function GroupRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [];
        return _this;
    }
    GroupRenderer.prototype.shouldSubmitRenderInst = function (object, index) {
        return true;
    };
    return GroupRenderer;
})(Batch));

var ImageRenderer = /** @class */ (function (_super) {
    tslib.__extends(ImageRenderer, _super);
    function ImageRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [ImageMesh];
        return _this;
    }
    ImageRenderer.prototype.shouldSubmitRenderInst = function (object, index) {
        return true;
    };
    return ImageRenderer;
}(Batch));

var TextRenderer = /** @class */ (function (_super) {
    tslib.__extends(TextRenderer, _super);
    function TextRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * one for fill, one for stroke
         */
        _this.meshes = [TextMesh, TextMesh];
        return _this;
    }
    TextRenderer.prototype.shouldSubmitRenderInst = function (object, index) {
        var _a = object.parsedStyle, stroke = _a.stroke, lineWidth = _a.lineWidth;
        var hasStroke = !!(stroke && !stroke.isNone && lineWidth);
        if (!hasStroke && index === 0) {
            // skip rendering stroke
            return false;
        }
        return true;
    };
    TextRenderer.prototype.beforeUploadUBO = function (renderInst, mesh, index) {
        var _a;
        mesh.material.setUniforms((_a = {},
            _a[exports.TextUniform.HAS_STROKE] = 1 - mesh.index,
            _a));
    };
    return TextRenderer;
}(Batch));

/**
 * use instanced for each segment
 * @see https://blog.scottlogic.com/2019/11/18/drawing-lines-with-webgl.html
 *
 * support dash array
 * TODO: joint & cap
 */
var LineRenderer = /** @class */ (function (_super) {
    tslib.__extends(LineRenderer, _super);
    function LineRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [InstancedLineMesh];
        return _this;
    }
    LineRenderer.prototype.shouldSubmitRenderInst = function (object, index) {
        return true;
    };
    return LineRenderer;
}(Batch));

var MeshRenderer = /** @class */ (function (_super) {
    tslib.__extends(MeshRenderer, _super);
    function MeshRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [MeshMesh];
        return _this;
    }
    return MeshRenderer;
}(Batch));

/**
 * Use 2 meshes:
 * * For simple Rect with fill & simple stroke, we use SDFMesh to draw which has a better performance.
 * * FillMesh & LineMesh to draw rounded rect with different radius.
 */
var RectRenderer = /** @class */ (function (_super) {
    tslib.__extends(RectRenderer, _super);
    function RectRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [SDFMesh, InstancedFillMesh, InstancedPathMesh];
        return _this;
    }
    RectRenderer.prototype.shouldSubmitRenderInst = function (object, index) {
        var radius = object.parsedStyle.radius;
        var hasDifferentRadius = radius && radius.length && radius.some(function (r) { return r !== radius[0]; });
        if (index === 0) {
            var fill = object.parsedStyle.fill;
            if (fill.isNone || hasDifferentRadius) {
                return false;
            }
        }
        if (index === 1) {
            return hasDifferentRadius;
        }
        if (index === 2) {
            return hasDifferentRadius
                ? hasDifferentRadius
                : this.needDrawStrokeSeparately(object);
        }
        return true;
    };
    /**
     * need an additional mesh to draw stroke:
     * 1. strokeOpacity < 1
     * 2. lineDash used
     * 3. stroke is not 'none'
     */
    RectRenderer.prototype.needDrawStrokeSeparately = function (object) {
        var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke, lineDash = _a.lineDash, lineWidth = _a.lineWidth, strokeOpacity = _a.strokeOpacity;
        var hasFill = fill && !fill.isNone;
        var hasStroke = stroke && !stroke.isNone;
        var hasDash = lineDash && lineDash.length && lineDash.every(function (item) { return item !== 0; });
        return (!hasFill || (hasStroke && lineWidth > 0 && (strokeOpacity < 1 || hasDash)));
    };
    return RectRenderer;
}(Batch));

var stencilRefCounter = 1;
var BatchManager = /** @class */ (function () {
    function BatchManager(renderHelper, rendererFactory, texturePool, lightPool) {
        this.renderHelper = renderHelper;
        this.rendererFactory = rendererFactory;
        this.texturePool = texturePool;
        this.lightPool = lightPool;
        /**
         * draw calls
         */
        this.meshes = [];
        /**
         * update patches which can be merged before rendering
         */
        this.pendingUpdatePatches = {};
        this.stencilRefCache = {};
    }
    BatchManager.prototype.render = function (list, isPicking) {
        var _this = this;
        if (isPicking === void 0) { isPicking = false; }
        if (!isPicking) {
            this.updatePendingPatches();
        }
        this.meshes.forEach(function (mesh) {
            // init rendering service, create geometry & material
            mesh.init(_this.context);
            var objects = mesh.objects;
            if (mesh.clipPathTarget) {
                objects = [mesh.clipPath];
            }
            // new render instance
            var renderInst = _this.renderHelper.renderInstManager.newRenderInst();
            renderInst.setAllowSkippingIfPipelineNotReady(false);
            mesh.applyRenderInst(renderInst, objects);
            _this.renderHelper.renderInstManager.submitRenderInst(renderInst, list);
            // console.log('submit: ', mesh);
            if (!isPicking) {
                // finish rendering...
                mesh.objects.forEach(function (object) {
                    object.renderable.dirty = false;
                });
            }
        });
    };
    /**
     * get called in RenderGraphPlugin
     */
    BatchManager.prototype.attach = function (context) {
        this.context = context;
    };
    BatchManager.prototype.add = function (object) {
        var _this = this;
        // @ts-ignore
        var renderable3D = object.renderable3D;
        if (renderable3D && !renderable3D.meshes.length) {
            var renderer_1 = this.rendererFactory[object.nodeName];
            if (renderer_1) {
                renderer_1.meshes.forEach(function (meshTag, i) {
                    renderable3D.meshes[i] = undefined;
                    var shouldSubmit = renderer_1.shouldSubmitRenderInst(object, i);
                    if (shouldSubmit) {
                        var existedMesh = _this.meshes.find(function (mesh) {
                            return meshTag === mesh.constructor &&
                                mesh.index === i &&
                                mesh.objects.length < mesh.maxInstances &&
                                mesh.shouldMerge(object, i);
                        });
                        if (!existedMesh ||
                            existedMesh.key !== object.parsedStyle.batchKey) {
                            existedMesh = new meshTag(_this.renderHelper, _this.texturePool, _this.lightPool, object);
                            existedMesh.renderer = renderer_1;
                            existedMesh.index = i;
                            _this.meshes.push(existedMesh);
                            if (object.parsedStyle.batchKey) {
                                existedMesh.key = object.parsedStyle.batchKey;
                            }
                        }
                        if (existedMesh) {
                            existedMesh.objects.push(object);
                            renderable3D.meshes[i] = existedMesh;
                            existedMesh.geometryDirty = true;
                        }
                    }
                });
            }
        }
    };
    BatchManager.prototype.remove = function (object) {
        var _this = this;
        // @ts-ignore
        var renderable3D = object.renderable3D;
        if (renderable3D) {
            renderable3D.meshes.forEach(function (mesh) {
                if (mesh) {
                    // remove from mesh
                    var index = mesh.objects.indexOf(object);
                    if (index > -1) {
                        mesh.objects.splice(index, 1);
                        mesh.geometryDirty = true;
                    }
                    if (mesh.objects.length === 0) {
                        _this.meshes.splice(_this.meshes.indexOf(mesh), 1);
                    }
                }
            });
            renderable3D.meshes = [];
        }
    };
    BatchManager.prototype.updateAttribute = function (object, attributeName, newValue, immediately) {
        var _this = this;
        if (immediately === void 0) { immediately = false; }
        var renderable3D = object.renderable3D;
        var renderer = this.rendererFactory[object.nodeName];
        if (renderer) {
            renderer.meshes.forEach(function (meshCtor, i) {
                var shouldSubmit = renderer.shouldSubmitRenderInst(object, i);
                var existedMesh = renderable3D.meshes.find(function (mesh) { return mesh && mesh.index === i && mesh.constructor === meshCtor; });
                // is this mesh already rendered in current displayobject?
                if (shouldSubmit !== !!existedMesh) {
                    if (existedMesh) {
                        // remove from mesh
                        existedMesh.objects.splice(existedMesh.objects.indexOf(object), 1);
                        existedMesh.geometryDirty = true;
                        if (existedMesh.objects.length === 0) {
                            _this.meshes.splice(_this.meshes.indexOf(existedMesh), 1);
                        }
                        renderable3D.meshes[renderable3D.meshes.indexOf(existedMesh)] =
                            undefined;
                    }
                    if (shouldSubmit) {
                        // clear first
                        existedMesh = _this.meshes.find(function (mesh) {
                            return meshCtor === mesh.constructor &&
                                mesh.index === i &&
                                mesh.objects.length < mesh.maxInstances &&
                                mesh.shouldMerge(object, i);
                        });
                        if (!existedMesh) {
                            // @ts-ignore
                            existedMesh = new meshCtor(_this.renderHelper, _this.texturePool, _this.lightPool, object);
                            existedMesh.renderer = renderer;
                            existedMesh.index = i;
                            existedMesh.init(_this.context);
                            _this.meshes.push(existedMesh);
                        }
                        else {
                            existedMesh.geometryDirty = true;
                        }
                        if (existedMesh) {
                            existedMesh.objects.push(object);
                            renderable3D.meshes[i] = existedMesh;
                        }
                    }
                }
                if (shouldSubmit && existedMesh) {
                    if (existedMesh.inited && !existedMesh.geometryDirty) {
                        var shouldMerge = existedMesh.shouldMerge(object, i);
                        if (shouldMerge) {
                            var objectIdx = existedMesh.objects.indexOf(object);
                            if (immediately) {
                                object.parsedStyle[attributeName] = newValue;
                                existedMesh.updateAttribute([object], objectIdx, attributeName, newValue);
                            }
                            else {
                                var patchKey = existedMesh.id + attributeName;
                                if (!_this.pendingUpdatePatches[patchKey]) {
                                    _this.pendingUpdatePatches[patchKey] = {
                                        instance: existedMesh,
                                        objectIndices: [],
                                        name: attributeName,
                                        value: newValue,
                                    };
                                }
                                if (_this.pendingUpdatePatches[patchKey].objectIndices.indexOf(objectIdx) === -1) {
                                    _this.pendingUpdatePatches[patchKey].objectIndices.push(objectIdx);
                                }
                            }
                        }
                        else {
                            _this.remove(object);
                            _this.add(object);
                        }
                    }
                    else {
                        _this.remove(object);
                        _this.add(object);
                    }
                }
            });
        }
    };
    BatchManager.prototype.changeRenderOrder = function (object, renderOrder) {
        // @ts-ignore
        var renderable3D = object.renderable3D;
        if (renderable3D && renderable3D.meshes.length) {
            renderable3D.meshes.forEach(function (mesh) {
                if (mesh && mesh.inited && !mesh.geometryDirty) {
                    var shouldSubmit = mesh.renderer.shouldSubmitRenderInst(object, mesh.index);
                    if (shouldSubmit && mesh.inited) {
                        mesh.changeRenderOrder(object, renderOrder);
                    }
                }
            });
        }
    };
    BatchManager.prototype.getStencilRef = function (object) {
        if (!this.stencilRefCache[object.entity]) {
            this.stencilRefCache[object.entity] = stencilRefCounter++;
        }
        return this.stencilRefCache[object.entity];
    };
    BatchManager.prototype.updatePendingPatches = function () {
        var _this = this;
        // merge update patches to reduce `setSubData` calls
        Object.keys(this.pendingUpdatePatches).forEach(function (patchKey) {
            var _a = _this.pendingUpdatePatches[patchKey], instance = _a.instance, objectIndices = _a.objectIndices, name = _a.name, value = _a.value;
            objectIndices.sort(function (a, b) { return a - b; });
            var updatePatches = [];
            objectIndices.forEach(function (i) {
                var lastUpdateBatch = updatePatches[updatePatches.length - 1];
                if (!lastUpdateBatch ||
                    i !== lastUpdateBatch[lastUpdateBatch.length - 1] + 1) {
                    updatePatches.push([i]);
                }
                else {
                    lastUpdateBatch.push(i);
                }
            });
            updatePatches.forEach(function (indices) {
                instance.updateAttribute(instance.objects.slice(indices[0], indices[0] + indices.length), indices[0], name, value);
            });
        });
        this.pendingUpdatePatches = {};
    };
    return BatchManager;
}());

var TexturePool = /** @class */ (function () {
    function TexturePool(context) {
        this.context = context;
        this.textureCache = {};
    }
    TexturePool.prototype.getOrCreateTexture = function (device, src, descriptor, successCallback) {
        var _this = this;
        // use Image URL or src as cache key
        // @ts-ignore
        var id = typeof src === 'string' ? src : src.src || '';
        var texture;
        if (!id || !this.textureCache[id]) {
            texture = device.createTexture(tslib.__assign({ pixelFormat: exports.Format.U8_RGBA_NORM, width: 1, height: 1, depth: 1, numLevels: 1, dimension: exports.TextureDimension.n2D, usage: exports.TextureUsage.Sampled, pixelStore: {
                    unpackFlipY: false,
                }, immutable: false }, descriptor));
            if (id) {
                this.textureCache[id] = texture;
            }
            if (!util.isString(src)) {
                texture.setImageData(src);
                texture.emit(exports.TextureEvent.LOADED);
                this.context.renderingService.dirtify();
            }
            else {
                // @see https://github.com/antvis/g/issues/938
                var createImage = this.context.config.createImage;
                var image_1;
                if (createImage) {
                    image_1 = createImage(src);
                }
                else if (gLite.isBrowser) {
                    image_1 = new window.Image();
                }
                if (image_1) {
                    image_1.onload = function () {
                        var onSuccess = function (bitmap) {
                            _this.textureCache[id].setImageData(bitmap);
                            _this.textureCache[id].emit(exports.TextureEvent.LOADED);
                            _this.context.renderingService.dirtify();
                            if (successCallback) {
                                successCallback(_this.textureCache[id]);
                            }
                        };
                        if (gLite.runtime.globalThis.createImageBitmap) {
                            gLite.runtime.globalThis
                                .createImageBitmap(image_1)
                                .then(function (bitmap) { return onSuccess(bitmap); })
                                .catch(function () {
                                // Unhandled Rejection (InvalidStateError):
                                // Failed to execute 'createImageBitmap' on 'Window':
                                // The image element contains an SVG image without intrinsic dimensions,
                                // and no resize options or crop region are specified.
                                onSuccess(image_1);
                            });
                        }
                        else {
                            onSuccess(image_1);
                        }
                    };
                    image_1.onerror = function () { };
                    image_1.crossOrigin = 'Anonymous';
                    image_1.src = src;
                }
            }
        }
        else {
            texture = this.textureCache[id];
            texture.emit(exports.TextureEvent.LOADED);
        }
        return texture;
    };
    TexturePool.prototype.getOrCreateCanvas = function () {
        return gLite.runtime.offscreenCanvasCreator.getOrCreateCanvas(this.context.config.offscreenCanvas);
    };
    TexturePool.prototype.getOrCreateGradient = function (params) {
        var instance = params.instance, gradients = params.gradients;
        var halfExtents = instance.getGeometryBounds().halfExtents;
        var width = halfExtents[0] * 2 || 1;
        var height = halfExtents[1] * 2 || 1;
        var offscreenCanvas = this.context.config.offscreenCanvas;
        var canvas = gLite.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        var context = gLite.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        canvas.width = width;
        canvas.height = height;
        // @ts-ignore
        var imagePool = this.context.imagePool;
        gradients.forEach(function (g) {
            var gradient = imagePool.getOrCreateGradient(tslib.__assign(tslib.__assign({ type: g.type }, g.value), { width: width, height: height }), context);
            // used as canvas' ID
            // @ts-ignore
            // canvas.src = key;
            context.fillStyle = gradient;
            context.fillRect(0, 0, width, height);
        });
    };
    TexturePool.prototype.getOrCreatePattern = function (pattern, instance, callback) {
        var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;
        var halfExtents = instance.getGeometryBounds().halfExtents;
        var width = halfExtents[0] * 2 || 1;
        var height = halfExtents[1] * 2 || 1;
        var offscreenCanvas = this.context.config.offscreenCanvas;
        var canvas = gLite.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        var context = gLite.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        canvas.width = width;
        canvas.height = height;
        var src;
        // Image URL
        if (util.isString(image)) {
            // @ts-ignore
            src = this.context.imagePool.getImageSync(image, callback);
        }
        else {
            src = image;
        }
        var canvasPattern = src && context.createPattern(src, repetition);
        // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasPattern/setTransform
        if (transform) {
            var mat = gLite.parsedTransformToMat4(gLite.parseTransform(transform), new gLite.DisplayObject({}));
            canvasPattern.setTransform({
                a: mat[0],
                b: mat[1],
                c: mat[4],
                d: mat[5],
                e: mat[12],
                f: mat[13],
            });
        }
        context.fillStyle = canvasPattern;
        context.fillRect(0, 0, width, height);
    };
    TexturePool.prototype.destroy = function () {
        for (var key in this.textureCache) {
            this.textureCache[key].destroy();
        }
        this.textureCache = {};
    };
    return TexturePool;
}());

var vert = "#define GLSLIFY 1\nlayout(location = 0) in vec2 a_Position;\n\nout vec2 v_TexCoord;\n\nvoid main() {\n  v_TexCoord = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n\n  #ifdef VIEWPORT_ORIGIN_TL\n    v_TexCoord.y = 1.0 - v_TexCoord.y;\n  #endif\n}"; // eslint-disable-line

var frag$1 = "#define GLSLIFY 1\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nout vec4 outputColor;\n\nvoid main() {\n  outputColor = texture(SAMPLER_2D(u_Texture), v_TexCoord);\n}"; // eslint-disable-line

var CopyProgram = /** @class */ (function (_super) {
    tslib.__extends(CopyProgram, _super);
    function CopyProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = vert;
        _this.frag = frag$1;
        _this.features = {};
        return _this;
    }
    return CopyProgram;
}(DeviceProgram));
// interface RenderInput {
//   backbufferWidth: number;
//   backbufferHeight: number;
// }
// const textureMapping = nArray(1, () => new TextureMapping());
// let geometry: Geometry;
// let inputState: InputState;
// let inputLayout: InputLayout;
// export function useCopyPass(
//   // builder: RGGraphBuilder,
//   renderHelper: RenderHelper,
//   // renderInput: RenderInput,
//   // mainColorTargetID: number,
// ): void {
//   // const mainColorResolveTextureID = builder.resolveRenderTarget(mainColorTargetID);
//   // pass.attachResolveTexture(mainColorResolveTextureID);
//   const renderInst = renderHelper.renderInstManager.newRenderInst();
//   renderInst.setUniformBuffer(renderHelper.uniformBuffer);
//   renderInst.setAllowSkippingIfPipelineNotReady(false);
//   renderInst.setMegaStateFlags(fullscreenMegaState);
//   renderInst.setBindingLayouts([{ numUniformBuffers: 0, numSamplers: 1 }]);
//   renderInst.drawPrimitives(3);
//   const copyProgram = new CopyProgram();
//   const program = renderHelper.renderCache.createProgram(copyProgram);
//   renderInst.setProgram(program);
//   if (!geometry) {
//     geometry = new Geometry();
//     geometry.device = renderHelper.getDevice();
//     geometry.setVertexBuffer({
//       bufferIndex: 0,
//       byteStride: 4 * 2,
//       frequency: VertexBufferFrequency.PerVertex,
//       attributes: [
//         {
//           format: Format.F32_RG,
//           bufferByteOffset: 4 * 0,
//           location: 0,
//         },
//       ],
//       // rendering a fullscreen triangle instead of quad
//       // @see https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/
//       data: new Float32Array([-4, -4, 4, -4, 0, 4]),
//     });
//     geometry.vertexCount = 3;
//     inputLayout = renderHelper.getCache().createInputLayout(geometry.inputLayoutDescriptor);
//     inputState = renderHelper.getDevice().createInputState(
//       inputLayout,
//       geometry.vertexBuffers.map((buffer) => ({
//         buffer,
//         byteOffset: 0,
//       })),
//       null,
//       program,
//     );
//   }
//   // textureMapping[0].texture = scope.getResolveTextureForID(mainColorResolveTextureID);
//   // renderInst.setSamplerBindingsFromTextureMappings(textureMapping);
//   renderInst.setInputLayoutAndState(inputLayout, inputState);
//   renderInst.drawPrimitives(3);
// }

var frag = "#define GLSLIFY 1\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nout vec4 outputColor;\n\nfloat MonochromeNTSC(vec3 t_Color) {\n  // NTSC primaries.\n  return dot(t_Color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 FXAA(PD_SAMPLER_2D(t_Texture), in vec2 t_PixelCenter, in vec2 t_InvResolution) {\n  // FXAA v2, based on implementations:\n  // http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/\n  // https://github.com/mitsuhiko/webgl-meincraft\n\n  float lumaMM = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy).rgb);\n\n  #if 1\n    vec2 t_PixelTopLeft = t_PixelCenter.xy - t_InvResolution.xy * 0.5;\n    float lumaNW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy)             .rgb);\n    float lumaNE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy + vec2(1.0, 0.0)).rgb);\n    float lumaSW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy + vec2(0.0, 1.0)).rgb);\n    float lumaSE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy + vec2(1.0, 1.0)).rgb);\n  #else\n    // We're at the pixel center -- pixel edges are 0.5 units away.\n    // NOTE(jstpierre): mitsuhiko's port seems to get this wrong?\n    vec2 t_PixelSize = t_InvResolution.xy * 0.5;\n\n    float lumaNW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2(-1.0, -1.0)).rgb);\n    float lumaNE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2( 1.0, -1.0)).rgb);\n    float lumaSW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2(-1.0,  1.0)).rgb);\n    float lumaSE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2( 1.0,  1.0)).rgb);\n  #endif\n\n  vec2 dir; \n  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n  dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n  const float FXAA_REDUCE_MIN = 1.0/128.0;\n  const float FXAA_REDUCE_MUL = 1.0/8.0;\n  const float FXAA_SPAN_MAX = 8.0;\n\n  float dirReduce = max(\n      (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n      FXAA_REDUCE_MIN);\n\n  float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n  dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * u_InvResolution.xy;\n\n  float lumaMin = min(lumaMM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n  float lumaMax = max(lumaMM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n  vec4 rgbA = (1.0/2.0) * (\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (1.0/3.0 - 0.5)) +\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (2.0/3.0 - 0.5)));\n  vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (0.0/3.0 - 0.5)) +\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (3.0/3.0 - 0.5)));\n  float lumaB = MonochromeNTSC(rgbB.rgb);\n\n  vec4 rgbOutput = ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n  return rgbOutput;\n}\n\nvoid main() {\n  outputColor = FXAA(PP_SAMPLER_2D(u_Texture), v_TexCoord.xy, u_InvResolution.xy);\n}"; // eslint-disable-line

var FXAAProgram = /** @class */ (function (_super) {
    tslib.__extends(FXAAProgram, _super);
    function FXAAProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.features = {};
        _this.both = "\nlayout(std140) uniform ub_Params {\n    vec4 u_Misc[1];\n};\n#define u_InvResolution (u_Misc[0].xy)\n";
        _this.vert = vert;
        _this.frag = frag;
        return _this;
    }
    return FXAAProgram;
}(DeviceProgram));
var textureMapping = nArray(1, function () { return new TextureMapping(); });
var geometry;
var inputState;
var inputLayout;
function pushFXAAPass(builder, renderHelper, renderInput, mainColorTargetID) {
    builder.pushPass(function (pass) {
        pass.setDebugName('FXAA');
        pass.attachRenderTargetID(exports.RGAttachmentSlot.Color0, mainColorTargetID);
        var mainColorResolveTextureID = builder.resolveRenderTarget(mainColorTargetID);
        pass.attachResolveTexture(mainColorResolveTextureID);
        var renderInst = renderHelper.renderInstManager.newRenderInst();
        renderInst.setUniformBuffer(renderHelper.uniformBuffer);
        renderInst.setAllowSkippingIfPipelineNotReady(false);
        renderInst.setMegaStateFlags(fullscreenMegaState);
        renderInst.setBindingLayouts([{ numUniformBuffers: 1, numSamplers: 1 }]);
        renderInst.drawPrimitives(3);
        // since gl_VertexID is not available in GLSL 100, we need to use a geometry
        var offs = renderInst.allocateUniformBuffer(0, 4);
        var d = renderInst.mapUniformBufferF32(0);
        fillVec4(d, offs, 1.0 / renderInput.backbufferWidth, 1.0 / renderInput.backbufferHeight);
        var fxaaProgram = new FXAAProgram();
        var program = renderHelper.renderCache.createProgram(fxaaProgram);
        renderInst.setProgram(program);
        if (!geometry) {
            geometry = new BufferGeometry(renderHelper.getDevice());
            geometry.setVertexBuffer({
                bufferIndex: 0,
                byteStride: 4 * 2,
                frequency: exports.VertexBufferFrequency.PerVertex,
                attributes: [
                    {
                        format: exports.Format.F32_RG,
                        bufferByteOffset: 4 * 0,
                        location: 0,
                    },
                ],
                // rendering a fullscreen triangle instead of quad
                // @see https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/
                // data: new Float32Array([-4, -4, 4, -4, 0, 4]),
                data: new Float32Array([-1, -3, -1, 1, 3, -1]),
            });
            geometry.vertexCount = 3;
            inputLayout = renderHelper
                .getCache()
                .createInputLayout(geometry.inputLayoutDescriptor);
            inputState = renderHelper.getDevice().createInputState(inputLayout, geometry.vertexBuffers.map(function (buffer) { return ({
                buffer: buffer,
                byteOffset: 0,
            }); }), null, program);
        }
        pass.exec(function (passRenderer, scope) {
            textureMapping[0].texture = scope.getResolveTextureForID(mainColorResolveTextureID);
            renderInst.setSamplerBindingsFromTextureMappings(textureMapping);
            renderInst.setInputLayoutAndState(inputLayout, inputState);
            renderInst.drawOnPass(renderHelper.renderCache, passRenderer);
        });
    });
}

var Plugin = /** @class */ (function (_super) {
    tslib.__extends(Plugin, _super);
    function Plugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'device-renderer';
        _this.parameters = {
            /**
             * ToneMapping is a renderer-level parameter, it will affect all materials.
             * @see https://threejs.org/docs/#api/en/renderers/WebGLRenderer.toneMapping
             */
            toneMapping: exports.ToneMapping.NONE,
            toneMappingExposure: 1,
        };
        return _this;
    }
    Plugin.prototype.init = function (runtime) {
        var _a;
        runtime.geometryUpdaterFactory[gLite.Shape.MESH] = new MeshUpdater();
        var renderHelper = new RenderHelper(this.parameters);
        var lightPool = new LightPool();
        var texturePool = new TexturePool(this.context);
        var pickingIdGenerator = new PickingIdGenerator();
        var circleRenderer = new CircleRenderer();
        var pathRenderer = new PathRenderer();
        var rendererFactory = (_a = {},
            _a[gLite.Shape.CIRCLE] = circleRenderer,
            _a[gLite.Shape.ELLIPSE] = circleRenderer,
            _a[gLite.Shape.POLYLINE] = pathRenderer,
            _a[gLite.Shape.PATH] = pathRenderer,
            _a[gLite.Shape.POLYGON] = pathRenderer,
            _a[gLite.Shape.RECT] = new RectRenderer(),
            _a[gLite.Shape.IMAGE] = new ImageRenderer(),
            _a[gLite.Shape.LINE] = new LineRenderer(),
            _a[gLite.Shape.TEXT] = new TextRenderer(),
            _a[gLite.Shape.MESH] = new MeshRenderer(),
            _a[gLite.Shape.GROUP] = undefined,
            _a[gLite.Shape.HTML] = undefined,
            _a);
        var batchManager = new BatchManager(renderHelper, rendererFactory, texturePool, lightPool);
        var renderGraphPlugin = new RenderGraphPlugin(renderHelper, lightPool, texturePool, batchManager);
        this.addRenderingPlugin(renderGraphPlugin);
        this.addRenderingPlugin(new PickingPlugin(renderHelper, renderGraphPlugin, pickingIdGenerator, batchManager));
    };
    Plugin.prototype.destroy = function (runtime) {
        delete runtime.geometryUpdaterFactory[gLite.Shape.MESH];
    };
    Plugin.prototype.getRenderGraphPlugin = function () {
        return this.plugins[0];
    };
    Plugin.prototype.getDevice = function () {
        return this.getRenderGraphPlugin().getDevice();
    };
    Plugin.prototype.loadTexture = function (src, descriptor, successCallback) {
        return this.getRenderGraphPlugin().loadTexture(src, descriptor, successCallback);
    };
    Plugin.prototype.toDataURL = function (options) {
        return this.getRenderGraphPlugin().toDataURL(options);
    };
    Plugin.prototype.setParameters = function (parameters) {
        this.parameters = tslib.__assign(tslib.__assign({}, this.parameters), parameters);
    };
    return Plugin;
}(gLite.AbstractRendererPlugin));

exports.Batch = Batch;
exports.BufferGeometry = BufferGeometry;
exports.CopyProgram = CopyProgram;
exports.DeviceProgram = DeviceProgram;
exports.DynamicUniformBuffer = DynamicUniformBuffer;
exports.FILL_TEXTURE_MAPPING = FILL_TEXTURE_MAPPING;
exports.Fog = Fog;
exports.HashMap = HashMap;
exports.ImageMesh = ImageMesh;
exports.Instanced = Instanced;
exports.InstancedFillMesh = InstancedFillMesh;
exports.InstancedLineMesh = InstancedLineMesh;
exports.InstancedPathMesh = InstancedPathMesh;
exports.IsDepthReversed = IsDepthReversed;
exports.Light = Light;
exports.Material = Material;
exports.Mesh = Mesh;
exports.MeshMesh = MeshMesh;
exports.OpaqueBlack = OpaqueBlack;
exports.OpaqueWhite = OpaqueWhite;
exports.Plugin = Plugin;
exports.RenderCache = RenderCache;
exports.RenderGraphPlugin = RenderGraphPlugin;
exports.RenderHelper = RenderHelper;
exports.RenderInst = RenderInst;
exports.RenderInstList = RenderInstList;
exports.RenderInstManager = RenderInstManager;
exports.Renderable3D = Renderable3D;
exports.SDFMesh = SDFMesh;
exports.ShaderMaterial = ShaderMaterial;
exports.SingleSampledTexture = SingleSampledTexture;
exports.TemporalTexture = TemporalTexture;
exports.TextMesh = TextMesh;
exports.TextureMapping = TextureMapping;
exports.TexturePool = TexturePool;
exports.TinySDF = TinySDF;
exports.TransparentBlack = TransparentBlack;
exports.TransparentWhite = TransparentWhite;
exports.UNIFORM_SETTERS = UNIFORM_SETTERS;
exports.align = align;
exports.alignNonPowerOfTwo = alignNonPowerOfTwo;
exports.arrayCopy = arrayCopy;
exports.arrayEqual = arrayEqual;
exports.assert = assert;
exports.assertExists = assertExists;
exports.bezierCurveTo = bezierCurveTo;
exports.bindingLayoutDescriptorCopy = bindingLayoutDescriptorCopy;
exports.bindingLayoutDescriptorEqual = bindingLayoutDescriptorEqual;
exports.bindingLayoutSamplerDescriptorCopy = bindingLayoutSamplerDescriptorCopy;
exports.bindingsDescriptorCopy = bindingsDescriptorCopy;
exports.bindingsDescriptorEquals = bindingsDescriptorEquals;
exports.bisectRight = bisectRight;
exports.bufferBindingCopy = bufferBindingCopy;
exports.colorCopy = colorCopy;
exports.colorEqual = colorEqual;
exports.colorNewCopy = colorNewCopy;
exports.colorNewFromRGBA = colorNewFromRGBA;
exports.compareDefines = compareDefines;
exports.compareDepthValues = compareDepthValues;
exports.copyAttachmentState = copyAttachmentState;
exports.copyAttachmentStateFromSimple = copyAttachmentStateFromSimple;
exports.copyMegaState = copyMegaState;
exports.defaultBindingLayoutSamplerDescriptor = defaultBindingLayoutSamplerDescriptor;
exports.defaultMegaState = defaultMegaState;
exports.definedProps = definedProps;
exports.enumToObject = enumToObject;
exports.fallbackUndefined = fallbackUndefined;
exports.fillArray = fillArray;
exports.fillColor = fillColor;
exports.fillMatrix4x4 = fillMatrix4x4;
exports.fillVec3v = fillVec3v;
exports.fillVec4 = fillVec4;
exports.fillVec4v = fillVec4v;
exports.fullscreenMegaState = fullscreenMegaState;
exports.getAttributeLocations = getAttributeLocations;
exports.getDefines = getDefines;
exports.getFormatByteSize = getFormatByteSize;
exports.getFormatCompByteSize = getFormatCompByteSize;
exports.getFormatCompFlags = getFormatCompFlags;
exports.getFormatCompFlagsComponentCount = getFormatCompFlagsComponentCount;
exports.getFormatComponentCount = getFormatComponentCount;
exports.getFormatFlags = getFormatFlags;
exports.getFormatSamplerKind = getFormatSamplerKind;
exports.getFormatTypeFlags = getFormatTypeFlags;
exports.getFormatTypeFlagsByteSize = getFormatTypeFlagsByteSize;
exports.getSortKeyDepth = getSortKeyDepth;
exports.getSortKeyLayer = getSortKeyLayer;
exports.getSystemEndianness = getSystemEndianness;
exports.getUniformSetter = getUniformSetter;
exports.getUniforms = getUniforms;
exports.hashCodeNumberFinish = hashCodeNumberFinish;
exports.hashCodeNumberUpdate = hashCodeNumberUpdate;
exports.inputLayoutBufferDescriptorCopy = inputLayoutBufferDescriptorCopy;
exports.inputLayoutBufferDescriptorEquals = inputLayoutBufferDescriptorEquals;
exports.inputLayoutDescriptorCopy = inputLayoutDescriptorCopy;
exports.inputLayoutDescriptorEquals = inputLayoutDescriptorEquals;
exports.isPowerOfTwo = isPowerOfTwo;
exports.leftPad = leftPad;
exports.makeAttachmentClearDescriptor = makeAttachmentClearDescriptor;
exports.makeBackbufferDescSimple = makeBackbufferDescSimple;
exports.makeDataBuffer = makeDataBuffer;
exports.makeDepthKey = makeDepthKey;
exports.makeFormat = makeFormat;
exports.makeMegaState = makeMegaState;
exports.makeSortKey = makeSortKey;
exports.makeSortKeyOpaque = makeSortKeyOpaque;
exports.makeSortKeyTranslucent = makeSortKeyTranslucent;
exports.makeTextureDescriptor2D = makeTextureDescriptor2D;
exports.nArray = nArray;
exports.nullHashFunc = nullHashFunc;
exports.nullify = nullify;
exports.opaqueBlackFullClearRenderPassDescriptor = opaqueBlackFullClearRenderPassDescriptor;
exports.opaqueWhiteFullClearRenderPassDescriptor = opaqueWhiteFullClearRenderPassDescriptor;
exports.parseUniformName = parseUniformName;
exports.prependLineNo = prependLineNo;
exports.preprocessProgramObj_GLSL = preprocessProgramObj_GLSL;
exports.preprocessProgram_GLSL = preprocessProgram_GLSL;
exports.preprocessShader_GLSL = preprocessShader_GLSL;
exports.projectionMatrixConvertClipSpaceNearZ = projectionMatrixConvertClipSpaceNearZ;
exports.pushFXAAPass = pushFXAAPass;
exports.quadCurveTo = quadCurveTo;
exports.range = range;
exports.renderInstCompareNone = renderInstCompareNone;
exports.renderInstCompareSortKey = renderInstCompareSortKey;
exports.renderPipelineDescriptorCopy = renderPipelineDescriptorCopy;
exports.renderPipelineDescriptorEquals = renderPipelineDescriptorEquals;
exports.reverseDepthForClearValue = reverseDepthForClearValue;
exports.reverseDepthForCompareMode = reverseDepthForCompareMode;
exports.reverseDepthForDepthOffset = reverseDepthForDepthOffset;
exports.reverseDepthForOrthographicProjectionMatrix = reverseDepthForOrthographicProjectionMatrix;
exports.reverseDepthForPerspectiveProjectionMatrix = reverseDepthForPerspectiveProjectionMatrix;
exports.samplerBindingCopy = samplerBindingCopy;
exports.samplerBindingNew = samplerBindingNew;
exports.samplerDescriptorEquals = samplerDescriptorEquals;
exports.segmentInstanceGeometry = segmentInstanceGeometry;
exports.setAttachmentStateSimple = setAttachmentStateSimple;
exports.setBackbufferDescSimple = setBackbufferDescSimple;
exports.setBitFlagEnabled = setBitFlagEnabled;
exports.setFormatComponentCount = setFormatComponentCount;
exports.setFormatFlags = setFormatFlags;
exports.setMegaStateFlags = setMegaStateFlags;
exports.setSortKeyBias = setSortKeyBias;
exports.setSortKeyDepth = setSortKeyDepth;
exports.setSortKeyDepthKey = setSortKeyDepthKey;
exports.setSortKeyLayer = setSortKeyLayer;
exports.setSortKeyOpaqueDepth = setSortKeyOpaqueDepth;
exports.setSortKeyProgramKey = setSortKeyProgramKey;
exports.setSortKeyTranslucentDepth = setSortKeyTranslucentDepth;
exports.spliceBisectRight = spliceBisectRight;
exports.standardFullClearRenderPassDescriptor = standardFullClearRenderPassDescriptor;
exports.updateBuffer = updateBuffer;
exports.vertexAttributeDescriptorCopy = vertexAttributeDescriptorCopy;
exports.vertexAttributeDescriptorEquals = vertexAttributeDescriptorEquals;
//# sourceMappingURL=index.js.map
