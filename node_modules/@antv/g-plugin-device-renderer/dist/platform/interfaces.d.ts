import type { EventEmitter } from 'eventemitter3';
import type { Format } from './format';
export declare enum ResourceType {
    Buffer = 0,
    Texture = 1,
    RenderTarget = 2,
    Sampler = 3,
    Program = 4,
    Bindings = 5,
    InputLayout = 6,
    InputState = 7,
    RenderPipeline = 8,
    ComputePipeline = 9,
    Readback = 10,
    QueryPool = 11
}
export interface Disposable {
    destroy: () => void;
}
export interface ResourceBase extends Disposable, EventEmitter {
    id: number;
    name?: string;
}
export interface Buffer extends ResourceBase {
    type: ResourceType.Buffer;
    setSubData: (dstByteOffset: number, src: Uint8Array, srcByteOffset?: number, byteLength?: number) => void;
}
export interface Texture extends ResourceBase {
    type: ResourceType.Texture;
    setImageData: (data: TexImageSource | ArrayBufferView[], firstMipLevel?: number) => void;
}
export interface RenderTarget extends ResourceBase {
    type: ResourceType.RenderTarget;
}
export interface Sampler extends ResourceBase {
    type: ResourceType.Sampler;
}
export interface Program extends ResourceBase {
    type: ResourceType.Program;
}
export interface Bindings extends ResourceBase {
    type: ResourceType.Bindings;
}
export interface InputLayout extends ResourceBase {
    type: ResourceType.InputLayout;
}
export interface InputState extends ResourceBase {
    type: ResourceType.InputState;
}
export interface RenderPipeline extends ResourceBase {
    type: ResourceType.RenderPipeline;
}
export interface QueryPool extends ResourceBase {
    type: ResourceType.QueryPool;
    queryResultOcclusion: (dstOffs: number) => boolean | null;
}
export interface Readback extends ResourceBase {
    type: ResourceType.Readback;
    readTexture: (t: Texture, x: number, y: number, width: number, height: number, dst: ArrayBufferView, dstOffset?: number, length?: number) => Promise<ArrayBufferView>;
    readTextureSync: (t: Texture, x: number, y: number, width: number, height: number, dst: ArrayBufferView, dstOffset?: number, length?: number) => ArrayBufferView;
    readBuffer: (b: Buffer, srcByteOffset?: number, dst?: ArrayBufferView, dstOffset?: number, length?: number) => Promise<ArrayBufferView>;
}
export interface ComputePipeline extends ResourceBase {
    type: ResourceType.ComputePipeline;
}
export type Resource = Buffer | Texture | RenderTarget | Sampler | Program | Bindings | InputLayout | InputState | RenderPipeline | ComputePipeline | Readback;
export declare enum CompareMode {
    Never = 512,
    Less = 513,
    Equal = 514,
    LessEqual = 515,
    Greater = 516,
    NotEqual = 517,
    GreaterEqual = 518,
    Always = 519
}
export declare enum FrontFaceMode {
    CCW = 2305,
    CW = 2304
}
export declare enum CullMode {
    None = 0,
    Front = 1,
    Back = 2,
    FrontAndBack = 3
}
export declare enum BlendFactor {
    Zero = 0,
    One = 1,
    Src = 768,
    OneMinusSrc = 769,
    Dst = 774,
    OneMinusDst = 775,
    SrcAlpha = 770,
    OneMinusSrcAlpha = 771,
    DstAlpha = 772,
    OneMinusDstAlpha = 773
}
export declare enum BlendMode {
    Add = 32774,
    Subtract = 32778,
    ReverseSubtract = 32779
}
export declare enum WrapMode {
    Clamp = 0,
    Repeat = 1,
    Mirror = 2
}
export declare enum TexFilterMode {
    Point = 0,
    Bilinear = 1
}
export declare enum MipFilterMode {
    NoMip = 0,
    Nearest = 1,
    Linear = 2
}
export declare enum PrimitiveTopology {
    Points = 0,
    Triangles = 1,
    TriangleStrip = 2,
    Lines = 3,
    LineStrip = 4
}
/**
 * @see https://www.w3.org/TR/webgpu/#GPUBufferDescriptor
 */
export interface BufferDescriptor {
    viewOrSize: ArrayBufferView | number;
    usage: BufferUsage;
    hint?: BufferFrequencyHint;
}
/**
 * @see https://www.w3.org/TR/webgpu/#buffer-usage
 */
export declare enum BufferUsage {
    MAP_READ = 1,
    MAP_WRITE = 2,
    COPY_SRC = 4,
    COPY_DST = 8,
    INDEX = 16,
    VERTEX = 32,
    UNIFORM = 64,
    STORAGE = 128,
    INDIRECT = 256,
    QUERY_RESOLVE = 512
}
export declare enum BufferFrequencyHint {
    Static = 1,
    Dynamic = 2
}
export declare enum VertexBufferFrequency {
    PerVertex = 1,
    PerInstance = 2
}
export declare enum TextureEvent {
    LOADED = "loaded"
}
export declare enum TextureDimension {
    n2D = 0,
    n2DArray = 1,
    n3D = 2,
    Cube = 3
}
export declare enum TextureUsage {
    Sampled = 1,
    RenderTarget = 2
}
export declare enum ChannelWriteMask {
    None = 0,
    Red = 1,
    Green = 2,
    Blue = 4,
    Alpha = 8,
    RGB = 7,
    AllChannels = 15
}
export declare enum StencilOp {
    Keep = 7680,
    Zero = 0,
    Replace = 7681,
    Invert = 5386,
    IncrementClamp = 7682,
    DecrementClamp = 7683,
    IncrementWrap = 34055,
    DecrementWrap = 34056
}
export interface VertexBufferDescriptor {
    buffer: Buffer;
    byteOffset: number;
}
export type IndexBufferDescriptor = VertexBufferDescriptor;
export interface VertexAttributeDescriptor {
    location: number;
    format: Format;
    bufferIndex: number;
    bufferByteOffset: number;
    byteStride?: number;
    divisor?: number;
}
export interface InputLayoutBufferDescriptor {
    byteStride: number;
    frequency: VertexBufferFrequency;
}
export interface TextureDescriptor {
    dimension: TextureDimension;
    pixelFormat: Format;
    width: number;
    height: number;
    depth: number;
    numLevels: number;
    usage: TextureUsage;
    immutable?: boolean;
    pixelStore?: Partial<{
        packAlignment: number;
        unpackAlignment: number;
        unpackFlipY: boolean;
    }>;
}
export declare function makeTextureDescriptor2D(pixelFormat: Format, width: number, height: number, numLevels: number): TextureDescriptor;
export interface SamplerDescriptor {
    wrapS: WrapMode;
    wrapT: WrapMode;
    wrapQ?: WrapMode;
    minFilter: TexFilterMode;
    magFilter: TexFilterMode;
    mipFilter: MipFilterMode;
    minLOD?: number;
    maxLOD?: number;
    maxAnisotropy?: number;
    compareMode?: CompareMode;
}
export interface RenderTargetDescriptor {
    pixelFormat: Format;
    width: number;
    height: number;
    sampleCount: number;
    texture?: Texture;
}
export interface BufferBinding {
    buffer: Buffer;
    wordCount: number;
}
export interface SamplerBinding {
    texture: Texture | null;
    sampler: Sampler | null;
    lateBinding: string | null;
}
export declare enum SamplerFormatKind {
    Float = 0,
    Uint = 1,
    Sint = 2,
    Depth = 3
}
export type BufferBindingType = 'uniform' | 'storage' | 'read-only-storage';
export interface BindingLayoutSamplerDescriptor {
    dimension: TextureDimension;
    formatKind: SamplerFormatKind;
    comparison?: boolean;
}
export interface BindingLayoutStorageDescriptor {
    type: BufferBindingType;
}
export interface BindingLayoutDescriptor {
    numUniformBuffers?: number;
    numSamplers?: number;
    storageEntries?: BindingLayoutStorageDescriptor[];
    samplerEntries?: BindingLayoutSamplerDescriptor[];
}
export interface BindingsDescriptor {
    bindingLayout: BindingLayoutDescriptor;
    pipeline?: RenderPipeline | ComputePipeline;
    uniformBufferBindings?: BufferBinding[];
    samplerBindings?: SamplerBinding[];
    storageBufferBindings?: BufferBinding[];
}
export interface ProgramDescriptorSimple {
    vert?: string;
    frag?: string;
    preprocessedVert?: string;
    preprocessedFrag?: string;
    preprocessedCompute?: string;
}
export interface ProgramDescriptor extends ProgramDescriptorSimple {
    ensurePreprocessed: (vendorInfo: VendorInfo) => void;
    associate: (device: Device, program: Program) => void;
}
export interface InputLayoutDescriptor {
    vertexBufferDescriptors: (InputLayoutBufferDescriptor | null)[];
    vertexAttributeDescriptors: VertexAttributeDescriptor[];
    indexBufferFormat: Format | null;
}
export interface ChannelBlendState {
    blendMode: BlendMode;
    blendSrcFactor: BlendFactor;
    blendDstFactor: BlendFactor;
}
export interface AttachmentState {
    channelWriteMask: ChannelWriteMask;
    rgbBlendState: ChannelBlendState;
    alphaBlendState: ChannelBlendState;
}
export interface MegaStateDescriptor {
    attachmentsState: AttachmentState[];
    blendConstant: Color;
    depthCompare: CompareMode;
    depthWrite: boolean;
    stencilCompare: CompareMode;
    stencilWrite: boolean;
    stencilPassOp: StencilOp;
    stencilRef: number;
    cullMode: CullMode;
    frontFace: FrontFaceMode;
    polygonOffset: boolean;
}
export interface PipelineDescriptor {
    bindingLayouts: BindingLayoutDescriptor[];
    inputLayout: InputLayout | null;
    program: Program;
}
export interface RenderPipelineDescriptor extends PipelineDescriptor {
    topology: PrimitiveTopology;
    megaStateDescriptor: MegaStateDescriptor;
    colorAttachmentFormats: (Format | null)[];
    depthStencilAttachmentFormat: Format | null;
    sampleCount: number;
}
export type ComputePipelineDescriptor = PipelineDescriptor;
export interface Color {
    r: number;
    g: number;
    b: number;
    a: number;
}
export interface RenderPassDescriptor {
    colorAttachment: (RenderTarget | null)[];
    colorAttachmentLevel: number[];
    colorClearColor: (Color | 'load')[];
    colorResolveTo: (Texture | null)[];
    colorResolveToLevel: number[];
    colorStore: boolean[];
    depthStencilAttachment: RenderTarget | null;
    depthStencilResolveTo: Texture | null;
    depthStencilStore: boolean;
    depthClearValue: number | 'load';
    stencilClearValue: number | 'load';
    occlusionQueryPool: QueryPool | null;
}
export interface DeviceLimits {
    uniformBufferWordAlignment: number;
    uniformBufferMaxPageWordSize: number;
    readonly supportedSampleCounts: number[];
}
export interface DebugGroup {
    name: string;
    drawCallCount: number;
    textureBindCount: number;
    bufferUploadCount: number;
    triangleCount: number;
}
export declare enum ViewportOrigin {
    LowerLeft = 0,
    UpperLeft = 1
}
export declare enum ClipSpaceNearZ {
    NegativeOne = 0,
    Zero = 1
}
export interface VendorInfo {
    readonly platformString: string;
    readonly glslVersion: string;
    readonly explicitBindingLocations: boolean;
    readonly separateSamplerTextures: boolean;
    readonly viewportOrigin: ViewportOrigin;
    readonly clipSpaceNearZ: ClipSpaceNearZ;
    readonly supportMRT: boolean;
}
export type PlatformFramebuffer = WebGLFramebuffer;
export interface SwapChain {
    configureSwapChain: (width: number, height: number, platformFramebuffer?: PlatformFramebuffer) => void;
    getDevice: () => Device;
    getCanvas: () => HTMLCanvasElement | OffscreenCanvas;
    getOnscreenTexture: () => Texture;
}
export interface RenderPass {
    setViewport: (x: number, y: number, w: number, h: number) => void;
    setScissor: (x: number, y: number, w: number, h: number) => void;
    setPipeline: (pipeline: RenderPipeline) => void;
    setBindings: (bindingLayoutIndex: number, bindings: Bindings, dynamicByteOffsets: number[]) => void;
    setInputState: (inputState: InputState | null) => void;
    setStencilRef: (value: number) => void;
    draw: (vertexCount: number, firstVertex: number) => void;
    drawIndexed: (indexCount: number, firstIndex: number) => void;
    drawIndexedInstanced: (indexCount: number, firstIndex: number, instanceCount: number) => void;
    beginOcclusionQuery: (dstOffs: number) => void;
    endOcclusionQuery: (dstOffs: number) => void;
    beginDebugGroup: (name: string) => void;
    endDebugGroup: () => void;
}
export interface ComputePass {
    setPipeline: (pipeline: ComputePipeline) => void;
    setBindings: (bindingLayoutIndex: number, bindings: Bindings, dynamicByteOffsets: number[]) => void;
    /**
     * @see https://www.w3.org/TR/webgpu/#compute-pass-encoder-dispatch
     */
    dispatch: (x: number, y?: number, z?: number) => void;
    beginDebugGroup: (name: string) => void;
    endDebugGroup: () => void;
}
export declare enum QueryPoolType {
    OcclusionConservative = 0
}
/**
 * Device represents a "virtual GPU"
 * @see https://www.w3.org/TR/webgpu/#gpu-device
 *
 * Support following backends:
 * * webgl1 CanvasWebGLRenderingContext
 * * WebGL2 CanvasWebGL2RenderingContext
 * * WebGPU GPUDevice
 *
 * A bit about the design of this API; all resources are "opaque", meaning you cannot look at the
 * implementation details or underlying fields of the resources, and most objects cannot have their
 * creation parameters modified after they are created. So, while buffers and textures can have their
 * contents changed through data upload passes, they cannot be resized after creation. Create a new object
 * and destroy the old one if you wish to "resize" it.
 */
export interface Device {
    /**
     * @see https://www.w3.org/TR/webgpu/#dom-gpudevice-createbuffer
     */
    createBuffer: (descriptor: BufferDescriptor) => Buffer;
    createTexture: (descriptor: TextureDescriptor) => Texture;
    createSampler: (descriptor: SamplerDescriptor) => Sampler;
    createRenderTarget: (descriptor: RenderTargetDescriptor) => RenderTarget;
    createRenderTargetFromTexture: (texture: Texture) => RenderTarget;
    createProgram: (program: ProgramDescriptor) => Program;
    createProgramSimple: (program: ProgramDescriptorSimple) => Program;
    createBindings: (bindingsDescriptor: BindingsDescriptor) => Bindings;
    createInputLayout: (inputLayoutDescriptor: InputLayoutDescriptor) => InputLayout;
    createInputState: (inputLayout: InputLayout, buffers: (VertexBufferDescriptor | null)[], indexBuffer: IndexBufferDescriptor | null, program?: Program) => InputState;
    createRenderPipeline: (descriptor: RenderPipelineDescriptor) => RenderPipeline;
    createComputePipeline: (descriptor: ComputePipelineDescriptor) => ComputePipeline;
    createReadback: () => Readback;
    createQueryPool: (type: QueryPoolType, elemCount: number) => QueryPool;
    createRenderPass: (renderPassDescriptor: RenderPassDescriptor) => RenderPass;
    createComputePass: () => ComputePass;
    beginFrame(): void;
    endFrame(): void;
    submitPass: (pass: RenderPass | ComputePass) => void;
    pipelineQueryReady: (o: RenderPipeline) => boolean;
    pipelineForceReady: (o: RenderPipeline) => void;
    copySubTexture2D: (dst: Texture, dstX: number, dstY: number, src: Texture, srcX: number, srcY: number) => void;
    queryLimits: () => DeviceLimits;
    queryTextureFormatSupported: (format: Format, width: number, height: number) => boolean;
    queryPlatformAvailable: () => boolean;
    queryVendorInfo: () => VendorInfo;
    queryRenderPass: (o: RenderPass) => Readonly<RenderPassDescriptor>;
    queryRenderTarget: (o: RenderTarget) => Readonly<RenderTargetDescriptor>;
    setResourceName: (o: Resource, s: string) => void;
    setResourceLeakCheck: (o: Resource, v: boolean) => void;
    checkForLeaks: () => void;
    programPatched: (o: Program, descriptor: ProgramDescriptorSimple) => void;
    pushDebugGroup: (debugGroup: DebugGroup) => void;
    popDebugGroup: () => void;
}
