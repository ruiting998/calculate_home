import { __assign, __extends } from "tslib";
import { omit, pick, isFunction } from '@antv/util';
import EE from 'eventemitter3';
import { createShape } from './createShape';
import applyStyle from './applyStyle';
var Animator = /** @class */function (_super) {
  __extends(Animator, _super);
  function Animator(timeline) {
    var _this = _super.call(this) || this;
    _this.timeline = timeline;
    return _this;
  }
  Animator.prototype.animate = function (shape, start, end, effect) {
    this.shape = shape;
    this.start = start;
    this.end = end;
    this.effect = effect;
  };
  // 首次播放
  Animator.prototype.run = function () {
    var _a = this,
      vNode = _a.vNode,
      shape = _a.shape,
      start = _a.start,
      end = _a.end,
      effect = _a.effect,
      children = _a.children;
    var animations = [];
    if (effect) {
      var _b = effect.property,
        property = _b === void 0 ? [] : _b,
        easing = effect.easing,
        duration = effect.duration,
        delay = effect.delay,
        iterations = effect.iterations,
        clip = effect.clip,
        _c = effect.direction,
        direction = _c === void 0 ? 'normal' : _c,
        _d = effect.onFrame,
        onFrame = _d === void 0 ? function () {} : _d,
        _e = effect.onEnd,
        onEnd = _e === void 0 ? function () {} : _e;
      // shape 动画
      if (property.length && duration > 0) {
        // 应用样式
        var style = __assign(__assign({}, omit(start, property)), omit(end, property));
        applyStyle(shape, style);
        // 开始帧
        var keyframeStart = property.reduce(function (prev, cur) {
          prev[cur] = start[cur];
          return prev;
        }, {});
        // 结束帧
        var keyframeEnd = pick(end, property);
        var animation = shape.animate([keyframeStart, keyframeEnd], {
          fill: 'both',
          easing: easing,
          duration: duration,
          delay: delay,
          iterations: iterations,
          direction: direction
        });
        if (animation) {
          animation.onframe = onFrame;
          animation.onfinish = onEnd;
          // 过滤无限循环的动画
          if (iterations !== Infinity) {
            animations.push(animation);
          }
        } else {
          // 如果没有执行动画，直接应用结束样式
          applyStyle(shape, end);
        }
      } else {
        // 直接应用结束样式
        applyStyle(shape, end);
      }
      // clip 动画
      if (clip) {
        var clipConfig = isFunction(clip) ? clip(end) : clip;
        if (clipConfig) {
          var clipType = clipConfig.type,
            clipStyle = clipConfig.style,
            _f = clipConfig.property,
            clipProperty = _f === void 0 ? [] : _f,
            clipEasing = clipConfig.easing,
            clipDuration = clipConfig.duration,
            clipDelay = clipConfig.delay,
            clipIterations = clipConfig.iterations,
            clipStart = clipConfig.start,
            clipEnd = clipConfig.end,
            clipDirection = clipConfig.direction;
          if (clipProperty.length && (clipDuration || duration) > 0) {
            var clipStartStyle_1 = __assign(__assign({}, clipStyle), clipStart);
            var clipEndStyle = __assign(__assign({}, clipStyle), clipEnd);
            // 开始帧
            var clipKeyframeStart = clipProperty.reduce(function (prev, cur) {
              prev[cur] = clipStartStyle_1[cur];
              return prev;
            }, {});
            // 结束帧
            var clipKeyframeEnd = pick(clipEndStyle, clipProperty);
            var clipShape_1 = createShape(clipType, {
              style: clipStartStyle_1
            });
            shape.setAttribute('clipPath', clipShape_1);
            // g 中 clip 为全局，且如果要在 clip上加动画，需要手动加到canvas上
            shape.ownerDocument.documentElement.appendChild(clipShape_1);
            var clipAnimation = clipShape_1.animate([clipKeyframeStart, clipKeyframeEnd], {
              fill: 'both',
              easing: clipEasing || easing,
              duration: clipDuration || duration,
              delay: clipDelay || delay,
              iterations: clipIterations || iterations,
              direction: clipDirection || direction
            });
            // 过滤无限循环的动画
            if (clipAnimation) {
              var clipFinished = clipAnimation.finished;
              clipFinished.then(function () {
                // 删掉 clip
                shape.setAttribute('clipPath', null);
                clipShape_1.destroy();
              });
              if ((clipIterations || iterations) !== Infinity) {
                animations.push(clipAnimation);
              }
            } else {
              // 没有动画，直接删掉 clip
              shape.setAttribute('clipPath', null);
              clipShape_1.destroy();
            }
          }
        }
      }
    }
    if (children && children.length) {
      children.forEach(function (child) {
        if (!child) return;
        var childAnimator = child.run();
        if (childAnimator) {
          animations.push.apply(animations, childAnimator);
        }
      });
    }
    this.animations = animations;
    if (this.timeline) {
      this.timeline.push(animations);
    }
    // TODO：这段代码放这个位置感觉挺奇怪，看看是否有更合适的地方
    if (vNode) {
      var component = vNode.component;
      if (vNode && vNode.component) {
        // @ts-ignore
        component.animationWillPlay && component.animationWillPlay();
      }
    }
    this.endEmit(animations);
    return animations;
  };
  Animator.prototype.play = function () {
    var animations = this.animations;
    if (!animations || !animations.length) return;
    animations.forEach(function (d) {
      d.play();
    });
  };
  Animator.prototype.pause = function () {
    var animations = this.animations;
    if (!animations || !animations.length) return;
    animations.forEach(function (d) {
      d.pause();
    });
  };
  Animator.prototype.goTo = function (frame) {
    var animations = this.animations;
    if (!animations || !animations.length) return;
    animations.forEach(function (d) {
      d.currentTime = frame;
    });
  };
  Animator.prototype.finish = function () {
    var animations = this.animations;
    if (!animations || !animations.length) return;
    animations.forEach(function (d) {
      d.pause();
    });
  };
  Animator.prototype.endEmit = function (animations) {
    var _this = this;
    if (!animations.length) {
      this.emit('end');
      return null;
    }
    var finished = Promise.all(animations.map(function (d) {
      return d.finished;
    }));
    finished.then(function () {
      _this.emit('end');
    });
  };
  Animator.prototype.reset = function (shape) {
    this.shape = shape;
    this.start = null;
    this.end = null;
    this.effect = null;
    this.children = null;
  };
  return Animator;
}(EE);
export default Animator;