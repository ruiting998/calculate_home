import { __assign } from "tslib";
import Children from '../../children';
import { isNumber, isArray } from '@antv/util';
import getShapeAttrs from '../shape';
import { Shape, FunctionComponent, getWorkTag } from '../workTags';
import computeCSSLayout from './css-layout';
function createMeasure(style, measureText) {
  return function /* width */
  () {
    var text = style.text,
      width = style.width,
      height = style.height;
    var outputWidth = width;
    var outputHeight = height;
    if (!isNumber(width) || !isNumber(height)) {
      var _a = measureText(text, style),
        measureWidth = _a.width,
        measureHeight = _a.height;
      if (!isNumber(width)) {
        outputWidth = measureWidth;
      }
      if (!isNumber(height)) {
        outputHeight = measureHeight;
      }
    }
    return {
      width: outputWidth,
      height: outputHeight
    };
  };
}
function getChildrenLayout(nodeTree) {
  if (!nodeTree) return;
  var left = 0;
  var top = 0;
  var right = 0;
  var bottom = 0;
  var width = 0;
  var height = 0;
  nodeTree.forEach(function (node) {
    var layout = node.layout;
    if (!layout) return;
    left = Math.min(left, layout.left);
    top = Math.min(top, layout.top);
    right = Math.min(right, layout.left + layout.width);
    bottom = Math.min(bottom, layout.top + layout.height);
    width = Math.max(width, layout.width);
    height = Math.max(height, layout.height);
  });
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    width: width,
    height: height
  };
}
var NodeTree = /** @class */function () {
  function NodeTree(node) {
    var className = node.className,
      children = node.children,
      layout = node.layout;
    var nodeChildren = children && children.length ? children.map(function (child) {
      return new NodeTree(child);
    }) : undefined;
    var nodeLayout = layout ? layout : getChildrenLayout(nodeChildren);
    this.children = nodeChildren;
    this.layout = nodeLayout;
    this.className = className;
  }
  NodeTree.prototype.getElementsByClassName = function (targetClassName) {
    var result = [];
    var _a = this,
      className = _a.className,
      children = _a.children;
    if (className === targetClassName) {
      result.push(this);
    }
    if (children) {
      children.forEach(function (child) {
        result.push.apply(result, child.getElementsByClassName(targetClassName));
      });
    }
    return result;
  };
  return NodeTree;
}();
// 展开数组
function extendMap(arr, fn) {
  if (!arr) {
    return arr;
  }
  var newArray = [];
  if (!isArray(arr)) {
    var rst = fn(arr);
    if (!rst) {
      return newArray;
    }
    if (isArray(rst)) {
      newArray = newArray.concat(rst);
    } else {
      newArray.push(rst);
    }
    return newArray;
  }
  for (var i = 0; i < arr.length; i++) {
    var element = arr[i];
    if (isArray(element)) {
      newArray = newArray.concat(extendMap(element, fn));
    } else if (element) {
      var rst = fn(element);
      if (!rst) {
        continue;
      }
      if (isArray(rst)) {
        newArray = newArray.concat(rst);
      } else {
        newArray.push(rst);
      }
    }
  }
  return newArray;
}
// 主要是把function节点，全部转换成string标签节点
function renderJSXElement(element, context, updater) {
  if (!element) return element;
  var px2hd = context.px2hd,
    measureText = context.measureText;
  var type = element.type,
    props = element.props;
  var tag = getWorkTag(type);
  // 只处理 function 组件
  if (tag === FunctionComponent) {
    // @ts-ignore
    var newElement = type(element.props, context, updater);
    // return element if type is string
    return renderJSXElement(newElement, context, updater);
  }
  var className = props.className,
    _a = props.style,
    customStyle = _a === void 0 ? {} : _a,
    attrs = props.attrs,
    newChildren = props.children;
  var style = px2hd(__assign(__assign({}, customStyle), attrs));
  // 文本需要计算文本的宽高来进行flex布局
  if (type === 'text') {
    style.measure = createMeasure(style, measureText);
  }
  // render children first
  var nextChildren = newChildren ? Children.toArray(newChildren).map(function (child) {
    return renderJSXElement(child, context, updater);
  }) : [];
  return {
    type: type,
    className: className,
    children: nextChildren.filter(Boolean),
    style: style
  };
}
// 计算布局
function computeLayout(component, newChildren) {
  var context = component.context,
    updater = component.updater;
  var nodeTree = renderJSXElement(newChildren, context, updater);
  computeCSSLayout(nodeTree);
  // 构造一个 NodeTree, 方便外部使用
  return new NodeTree(nodeTree);
}
function createChildNodeTree(parent, vNodeChildren) {
  var tag = parent.tag;
  var children = extendMap(vNodeChildren, function (child) {
    var childTag = child.tag,
      childStyle = child.style,
      childChildren = child.children;
    // 如果组件的根节点不是 flex, 则该组件不需要计算 flex 布局
    if (tag !== Shape && childTag === Shape && childStyle.display !== 'flex') {
      return null;
    }
    // 如果子组件不是 shape，则布局计算时，忽略当前节点
    if (childTag !== Shape) {
      return createChildNodeTree(child, childChildren);
    }
    return createNodeTree(child);
  });
  return children;
}
// 创建组件的布局树
function createNodeTree(vNode) {
  var tag = vNode.tag,
    type = vNode.type,
    style = vNode.style,
    context = vNode.context,
    vNodeChildren = vNode.children;
  var measureText = context.measureText;
  var children = createChildNodeTree(vNode, vNodeChildren);
  // 文本需要计算文本的宽高来进行flex布局
  if (type === 'text') {
    style.measure = createMeasure(style, measureText);
  }
  return {
    tag: tag,
    type: type,
    style: style,
    children: children,
    // 保留对 vNode 的引用，用于把布局结果回填
    vNode: vNode
  };
}
function fillElementLayout(node) {
  var type = node.type,
    style = node.style,
    vNode = node.vNode,
    children = node.children,
    layout = node.layout;
  var attrs = getShapeAttrs(type, layout);
  if (style.measure) {
    delete style.measure;
  }
  // 更新布局和样式
  vNode.layout = layout;
  vNode.style = __assign(__assign({}, attrs), style);
  if (!children || !children.length) {
    return;
  }
  for (var i = 0, len = children.length; i < len; i++) {
    var child = children[i];
    fillElementLayout(child);
  }
}
function fillComponentLayout(vNode) {
  var layout = vNode.layout,
    vNodeChildren = vNode.children;
  Children.map(vNodeChildren, function (child) {
    if (!child) {
      return;
    }
    var childTag = child.tag,
      childLayout = child.layout,
      style = child.style;
    if (childTag !== Shape && layout && !childLayout) {
      child.layout = layout;
      child.style = __assign({
        width: layout.width,
        height: layout.height
      }, style);
    }
    fillComponentLayout(child);
  });
}
export { computeLayout, createNodeTree, computeCSSLayout, fillElementLayout, fillComponentLayout };