import { __assign } from "tslib";
import Children from '../../children';
import { convertToPath } from '@antv/g-lite';
import { createShape } from './createShape';
import { Shape } from '../workTags';
import findClosestShapeNode from './findClosestShapeNode';
import Animator from './animator';
import applyStyle from './applyStyle';
function findAllShapeNode(vNode) {
  var shapeNodes = [];
  Children.map(vNode, function (node) {
    if (!node) return;
    var tag = node.tag,
      type = node.type,
      children = node.children;
    if (tag === Shape && type !== 'group') {
      shapeNodes.push(node);
    }
    if (children) {
      shapeNodes.push.apply(shapeNodes, findAllShapeNode(children));
    }
  });
  return shapeNodes;
}
function morphShape(lastNode, nextNode, animator) {
  var nextProps = nextNode.props,
    nextShape = nextNode.shape,
    nextStyle = nextNode.style,
    context = nextNode.context;
  var lastShape = lastNode.shape,
    lastStyle = lastNode.style,
    lastAnimation = lastNode.animator;
  // 形变动画之前先把原 shape 销毁
  lastShape.destroy();
  var animate = nextProps.animate,
    animation = nextProps.animation;
  var animationEffect = animation ? animation.update : null;
  if (animate === false || !animationEffect) {
    return animator;
  }
  animator = animator || new Animator(context.timeline);
  // shape 形变
  var start = animationEffect.start,
    end = animationEffect.end,
    _a = animationEffect.property,
    property = _a === void 0 ? [] : _a;
  var nextParsedStyle = nextShape.parsedStyle;
  var lastParsedStyle = lastShape.parsedStyle;
  var lastPath = convertToPath(lastShape);
  var nextPath = convertToPath(nextShape);
  var startStyle = __assign(__assign(__assign({}, lastStyle), start), {
    path: lastPath
  });
  var endStyle = __assign(__assign(__assign({}, nextStyle), end), {
    path: nextPath
  });
  var pathShape = createShape('path', {
    style: __assign(__assign({}, startStyle), {
      path: ''
    })
  });
  // 形变双方都有的属性才能动画
  var animateProperty = property.filter(function (key) {
    return nextParsedStyle.hasOwnProperty(key) && lastParsedStyle.hasOwnProperty(key);
  }).concat('path');
  animator.animate(pathShape, startStyle, endStyle, __assign(__assign({}, animationEffect), {
    property: animateProperty
  }));
  var timeline = (nextNode === null || nextNode === void 0 ? void 0 : nextNode.context).timeline;
  timeline && timeline.delete(lastAnimation);
  animator.once('end', function () {
    applyStyle(nextShape, endStyle);
    pathShape.replaceWith(nextShape);
  });
  return animator;
}
function appearAnimation(vNode) {
  return Children.map(vNode, function (node) {
    if (!node) return;
    var tag = node.tag,
      shape = node.shape,
      style = node.style,
      children = node.children,
      animate = node.animate,
      props = node.props,
      animator = node.animator;
    animator.reset(shape);
    // 有叶子节点，先执行叶子节点
    animator.children = children ? createAnimation(node, children, null) : null;
    // 不需要执行动画
    if (animate === false || tag !== Shape) {
      applyStyle(shape, style);
      return animator;
    }
    var animation = props.animation;
    var animationEffect = animation ? animation.appear : null;
    if (!animationEffect) {
      // 没有动画直接应用样式
      applyStyle(shape, style);
      return animator;
    }
    var _a = animationEffect.start,
      start = _a === void 0 ? {} : _a,
      end = animationEffect.end;
    var endStyle = __assign(__assign({}, style), end);
    animator.animate(shape, start, endStyle, animationEffect);
    return animator;
  });
}
function updateAnimation(nextNode, lastNode) {
  var nextTag = nextNode.tag,
    nextType = nextNode.type,
    nextStyle = nextNode.style,
    nextChildren = nextNode.children,
    nextProps = nextNode.props,
    nextShape = nextNode.shape,
    animator = nextNode.animator,
    animate = nextNode.animate;
  var lastTag = lastNode.tag,
    lastType = lastNode.type,
    lastStyle = lastNode.style,
    lastChildren = lastNode.children,
    lastShape = lastNode.shape;
  animator.reset(nextShape);
  // 先处理叶子节点
  animator.children = createAnimation(nextNode, nextChildren, lastChildren);
  var animation = nextProps.animation;
  var animationEffect = animation ? animation.update : null;
  // 类型相同
  if (nextType === lastType) {
    // 清除之前的样式
    var resetStyle = lastStyle ? Object.keys(lastStyle).reduce(function (prev, cur) {
      prev[cur] = '';
      return prev;
    }, {}) : null;
    // 需要更新的样式
    var style = __assign(__assign({}, resetStyle), nextStyle);
    // 组件，直接更新
    if (nextTag !== Shape) {
      applyStyle(nextShape, style);
      return animator;
    }
    // 没有动画直接应用样式
    if (animate === false || !animationEffect) {
      applyStyle(nextShape, style);
      return animator;
    }
    var start = animationEffect.start,
      end = animationEffect.end;
    var startStyle = __assign(__assign({}, lastStyle), start);
    var endStyle = __assign(__assign({}, style), end);
    animator.animate(nextShape, startStyle, endStyle, animationEffect);
    return animator;
  }
  // 无法处理形变
  if (nextTag !== Shape || lastTag !== Shape) {
    lastShape.destroy();
    return animator;
  }
  // 从 shape 到 group
  if (nextType === 'group') {
    var shapeNodes = findAllShapeNode(nextNode.children);
    return shapeNodes.map(function (node) {
      return morphShape(lastNode, node);
    });
  }
  // 从 group 到 shape
  if (lastType === 'group') {
    var shapeNodes = findAllShapeNode(lastNode.children);
    return shapeNodes.map(function (node) {
      return morphShape(node, nextNode);
    });
  }
  // 没有动画直接应用样式
  if (animate === false || !animationEffect) {
    applyStyle(nextShape, nextStyle);
    return animator;
  }
  return morphShape(lastNode, nextNode, animator);
}
function destroyAnimation(node) {
  return Children.map(node, function (vNode) {
    if (!vNode) return null;
    var tag = vNode.tag,
      shape = vNode.shape,
      children = vNode.children,
      animate = vNode.animate,
      style = vNode.style,
      props = vNode.props,
      animator = vNode.animator,
      context = vNode.context;
    var timeline = context.timeline;
    if (shape.destroyed) {
      return null;
    }
    // 重置
    animator.reset(shape);
    // 先处理叶子节点
    var childrenAnimation = children ? Children.toArray(children).map(function (child) {
      return destroyAnimation(child);
    }).filter(Boolean) : null;
    // 不需要动画直接删除
    if (animate === false) {
      shape.destroy();
      return animator;
    }
    var animation = props.animation;
    var animationEffect = animation ? animation.leave : null;
    // 没有叶子节点的动画， 直接删除
    if (!(childrenAnimation && childrenAnimation.length) && !animationEffect) {
      shape.destroy();
      return animator;
    }
    animator.children = childrenAnimation;
    // 图形有动画
    if (animationEffect && tag === Shape) {
      var start = animationEffect.start,
        _a = animationEffect.end,
        end = _a === void 0 ? {} : _a;
      var startStyle = __assign(__assign({}, style), start);
      var endStyle = end;
      animator.animate(shape, startStyle, endStyle, animationEffect);
      timeline && timeline.delete(animator.animations);
    }
    // 动画结束后，删除图形（包括子元素动画）
    animator.once('end', function () {
      shape.destroy();
    });
    return animator;
  });
}
function createAnimator(nextNode, lastNode) {
  if (!nextNode && !lastNode) {
    return null;
  }
  // delete 动画
  if (!nextNode && lastNode) {
    return destroyAnimation(lastNode);
  }
  // 如果有 transform 则从 transform 比
  var transform = nextNode.transform;
  if (transform) {
    var closestShapeNode = findClosestShapeNode(nextNode);
    nextNode.transform = null;
    closestShapeNode.transform = transform;
  }
  if (nextNode.transform) {
    if (!lastNode) {
      return updateAnimation(nextNode, nextNode.transform);
    }
    return [updateAnimation(nextNode, nextNode.transform), destroyAnimation(lastNode)];
  }
  // appear 动画
  if (nextNode && !lastNode) {
    return appearAnimation(nextNode);
  }
  // update 动画
  return updateAnimation(nextNode, lastNode);
}
function insertShape(parent, shape, nextSibling) {
  if (nextSibling) {
    parent.insertBefore(shape, nextSibling);
  } else {
    parent.appendChild(shape);
  }
}
// 处理 children 的动画
function createAnimation(parent, nextChildren, lastChildren) {
  if (!nextChildren && !lastChildren) {
    return [];
  }
  var parentShape = parent.shape;
  // 上一个处理的元素
  var prevSibling;
  var childrenAnimator = [];
  Children.compare(nextChildren, lastChildren, function (nextNode, lastNode) {
    // shape 层才执行动画
    var animator = createAnimator(nextNode, lastNode);
    Children.map(animator, function (item) {
      if (!item) return;
      childrenAnimator.push(item);
      var shape = item.shape;
      if (!shape || shape.destroyed) return;
      var nextSibling;
      // 更新文档流
      if (!prevSibling) {
        nextSibling = parentShape.firstChild;
      } else {
        nextSibling = prevSibling.nextSibling;
      }
      if (nextSibling !== shape) {
        insertShape(parentShape, shape, nextSibling);
      }
      prevSibling = shape;
    });
  });
  return childrenAnimator;
}
export { createAnimation };