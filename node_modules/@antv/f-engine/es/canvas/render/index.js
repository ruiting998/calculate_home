import { __assign, __rest } from "tslib";
import { isBoolean, isNumber, pick } from '@antv/util';
import Component from '../../component';
import Children from '../../children';
import { createShape, updateShape } from './createShape';
import { Group } from '@antv/g-lite';
import equal from '../equal';
import { createAnimation } from './animation';
import Animator from './animator';
import { getWorkTag, ClassComponent, Shape } from '../workTags';
import { computeLayout, createNodeTree, computeCSSLayout, fillElementLayout, fillComponentLayout } from './computeLayout';
import findClosestShapeNode from './findClosestShapeNode';
function pickElement(element) {
  if (!element) return element;
  return Children.map(element, function (item) {
    if (!item) return item;
    // 只需要这几个元素就可以了
    return pick(item, ['key', 'ref', 'type', 'props']);
  });
}
function getStyle(tagType, props, context) {
  var _a = props.style,
    customStyle = _a === void 0 ? {} : _a,
    attrs = props.attrs,
    zIndex = props.zIndex;
  if (tagType === Shape) {
    return context.px2hd(__assign(__assign({}, customStyle), attrs));
  }
  if (isNumber(zIndex)) {
    return {
      zIndex: zIndex
    };
  }
  return {};
}
// vnode 上的 context 做父子节点的 context 传递
function readVNodeContext(vNodeType, parentContext) {
  // @ts-ignore
  var contextInjecter = vNodeType.contextInjecter;
  if (!contextInjecter) {
    return parentContext;
  }
  // copy parentContext
  return __assign({}, parentContext);
}
// component 上的 context 是实际使用的 context
function readComponentContext(vNodeType, vNodeContext) {
  // @ts-ignore
  var contextType = vNodeType.contextType;
  if (!contextType) {
    return vNodeContext;
  }
  var _currentValue = contextType._currentValue;
  if (!_currentValue) {
    return vNodeContext;
  }
  return _currentValue;
}
function createVNode(parent, vNode) {
  var canvas = parent.canvas,
    parentContext = parent.context,
    updater = parent.updater,
    parentAnimate = parent.animate;
  var ref = vNode.ref,
    type = vNode.type,
    originProps = vNode.props;
  var animate = originProps.animate,
    transformFrom = originProps.transformFrom,
    props = __rest(originProps, ["animate", "transformFrom"]);
  var tag = getWorkTag(type);
  var context = readVNodeContext(type, parentContext);
  var animator = new Animator(context.timeline);
  var style = getStyle(tag, props, context);
  animator.vNode = vNode;
  vNode.parent = parent;
  vNode.tag = tag;
  vNode.style = style;
  vNode.context = context;
  vNode.updater = updater;
  vNode.canvas = canvas;
  vNode.animate = isBoolean(animate) ? animate : parentAnimate;
  vNode.animator = animator;
  // shape 标签
  if (tag === Shape) {
    var shape = createShape(type, __assign(__assign({}, props), {
      style: style
    }));
    if (ref) {
      ref.current = shape;
    }
    // @ts-ignore
    shape._vNode = vNode; // shape 保留 vNode 的引用
    vNode.shape = shape;
  } else {
    var componentContext_1 = readComponentContext(type, context);
    // 组件
    var component = void 0;
    if (tag === ClassComponent) {
      // @ts-ignore
      component = new type(props, componentContext_1, updater);
    } else {
      component = new Component(props, componentContext_1, updater);
      component.render = function () {
        // @ts-ignore
        return type(this.props, componentContext_1, updater);
      };
    }
    var group = new Group();
    component.container = group;
    // 设置ref
    if (ref) {
      ref.current = component;
    }
    component.context = componentContext_1;
    component.updater = updater;
    component.animator = animator;
    component._vNode = vNode;
    vNode.shape = group;
    vNode.component = component;
  }
  if (transformFrom && transformFrom.current) {
    var transformVNode = transformFrom.current._vNode;
    vNode.transform = findClosestShapeNode(transformVNode);
    if (vNode.transform) {
      vNode.transform.parent.children = null;
    }
  }
  return vNode;
}
function updateVNode(parent, nextNode, lastNode) {
  var canvas = parent.canvas,
    context = parent.context,
    updater = parent.updater,
    parentAnimate = parent.animate;
  var tag = lastNode.tag,
    animator = lastNode.animator,
    component = lastNode.component,
    shape = lastNode.shape,
    children = lastNode.children,
    lastProps = lastNode.props;
  var type = nextNode.type,
    props = nextNode.props;
  var animate = props.animate;
  animator.vNode = nextNode;
  nextNode.parent = parent;
  nextNode.tag = tag;
  nextNode.canvas = canvas;
  nextNode.context = readVNodeContext(type, context);
  nextNode.updater = updater;
  nextNode.component = component;
  nextNode.shape = updateShape(shape, props, lastProps);
  nextNode.parent = parent;
  nextNode.children = children;
  nextNode.animate = isBoolean(animate) ? animate : parentAnimate;
  nextNode.animator = animator;
  nextNode.style = getStyle(tag, props, context);
  // 更新 component
  if (component) {
    component._vNode = nextNode;
  } else {
    // 说明是 shape 标签
    // @ts-ignore
    shape._vNode = nextNode;
  }
  return nextNode;
}
function createElement(parent, element) {
  return Children.map(element, function (el) {
    if (!el) return el;
    return createVNode(parent, el);
  });
}
function destroyElement(vNode) {
  Children.map(vNode, function (node) {
    if (!node) return;
    var component = node.component,
      children = node.children;
    if (component) {
      component.willUnmount();
      destroyElement(children);
      component.didUnmount();
      component.destroy();
    } else {
      destroyElement(children);
    }
  });
}
function updateElement(parent, nextElement, lastElement) {
  var nextType = nextElement.type,
    nextProps = nextElement.props;
  var lastType = lastElement.type,
    lastProps = lastElement.props;
  if (nextType === lastType) {
    var nextVNode_1 = updateVNode(parent, nextElement, lastElement);
    // props 无变化 和 context 都无变化
    if (equal(nextProps, lastProps) && parent.context === lastElement.context) {
      return null;
    }
    return nextVNode_1;
  }
  var nextVNode = createVNode(parent, nextElement);
  destroyElement(lastElement);
  return nextVNode;
}
function diffElement(parent, nextElement, lastElement) {
  if (!nextElement && !lastElement) {
    return null;
  }
  // 删除
  if (!nextElement && lastElement) {
    destroyElement(lastElement);
    return null;
  }
  // 新建
  if (nextElement && !lastElement) {
    return createElement(parent, nextElement);
  }
  // 更新
  return updateElement(parent, nextElement, lastElement);
}
function renderComponentNodes(componentNodes) {
  if (!componentNodes || !componentNodes.length) {
    return;
  }
  // 1. shouldUpdate & willReceiveProps
  var shouldProcessChildren = componentNodes.filter(function (node) {
    var type = node.type,
      component = node.component,
      props = node.props,
      context = node.context,
      layout = node.layout;
    // 更新组件 layout
    component.layout = layout;
    // 新创建的 component
    if (!component.isMounted) return true;
    // 不需要更新
    if (component.shouldUpdate(props) === false) {
      return false;
    }
    var componentContext = readComponentContext(type, context);
    component.willReceiveProps(props, componentContext);
    component.props = props;
    component.context = context;
    return true;
  });
  if (!shouldProcessChildren.length) {
    return;
  }
  // 2. willMount / willUpdate
  shouldProcessChildren.forEach(function (child) {
    var component = child.component;
    if (!component.isMounted) {
      component.willMount();
    } else {
      component.willUpdate();
    }
  });
  // 3. render
  shouldProcessChildren.forEach(function (child) {
    var canvas = child.canvas,
      component = child.component,
      children = child.children;
    var newChildren = canvas.toRawChildren(component.render());
    renderChildren(child, newChildren, children);
    if (!component.isMounted) {
      component.didMount();
      component.isMounted = true;
    } else {
      component.didUpdate();
    }
  });
}
function renderVNode(vNode, nextChildren, lastChildren) {
  var component = vNode.component;
  // 不修改原始对象，这里重新 pick 一次，
  var newChildren = pickElement(nextChildren);
  // 设置新的 children
  vNode.children = newChildren;
  // 如果是组件，需要同时更新组件的 children
  // 等同于 vNode.tag === ClassComponent || vNode.tag === FunctionComponent
  if (component) {
    component.children = newChildren;
  }
  var componentNodeChildren = [];
  Children.compare(newChildren, lastChildren, function (next, last) {
    var element = diffElement(vNode, next, last);
    Children.map(element, function (child) {
      if (!child) return;
      var tag = child.tag,
        childProps = child.props,
        childLastChildren = child.children;
      var childrenNode = [];
      if (tag === Shape) {
        childrenNode = renderVNode(child, childProps.children, childLastChildren);
      } else {
        childrenNode = [child];
      }
      componentNodeChildren = componentNodeChildren.concat(childrenNode);
    });
  });
  return componentNodeChildren;
}
function renderChildren(parent, nextChildren, lastChildren) {
  // 返回的都是 classComponent 的节点
  var componentNodeChildren = renderVNode(parent, nextChildren, lastChildren);
  // 计算 flex 布局
  var nodeTree = createNodeTree(parent);
  computeCSSLayout(nodeTree);
  fillElementLayout(nodeTree);
  fillComponentLayout(parent);
  var newChildren = parent.children;
  if (!componentNodeChildren.length) {
    return newChildren;
  }
  renderComponentNodes(componentNodeChildren);
  return newChildren;
}
function render(vNode) {
  var lastChildren = vNode.children,
    props = vNode.props;
  var nextChildren = props.children;
  // render 节点
  var children = renderChildren(vNode, nextChildren, lastChildren);
  // 创建动画
  var childrenAnimation = createAnimation(vNode, children, lastChildren);
  // 执行动画
  if (childrenAnimation.length) {
    childrenAnimation.forEach(function (animator) {
      animator.run();
    });
  }
}
// setState 触发的更新
function updateComponents(components) {
  if (!components.length) return;
  components.forEach(function (component) {
    var vNode = component._vNode,
      lastChildren = component.children,
      props = component.props,
      animator = component.animator;
    // 是否需要更新
    if (component.shouldUpdate(props) === false) {
      return false;
    }
    component.willUpdate();
    var canvas = vNode.canvas,
      context = vNode.context;
    var newChildren = canvas.toRawChildren(component.render());
    var nextChildren = renderChildren(vNode, newChildren, lastChildren);
    // 更新 children
    component.children = nextChildren;
    vNode.children = nextChildren;
    // 创建动画
    var childrenAnimation = createAnimation(vNode, nextChildren, lastChildren);
    if (childrenAnimation.length) {
      animator.children = childrenAnimation;
    }
    // 执行动画
    animator.run();
    var timeline = context.timeline;
    if (timeline) {
      timeline.push(animator.animations);
      timeline.play.animationWillPlay();
    }
    component.didUpdate();
  });
}
export { render, renderChildren, updateComponents, computeLayout, destroyElement };