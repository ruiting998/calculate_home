import { __assign, __awaiter, __generator } from "tslib";
import { isFunction } from '@antv/util';
import equal from './equal';
import { Text, Canvas as GCanvas, runtime } from '@antv/g-lite';
import { createMobileCanvasElement } from '@antv/g-mobile-canvas-element';
import { Renderer as CanvasRenderer } from '@antv/g-mobile-canvas';
import { createUpdater } from '../component/updater';
import EE from 'eventemitter3';
import Theme from './theme';
import { px2hd as defaultPx2hd, checkCSSRule, batch2hd } from './util';
import Gesture from '../gesture';
import { render, updateComponents, destroyElement } from './render';
import { ClassComponent } from './workTags';
// 添加动画模块
import '@antv/g-web-animations-api';
function measureText(container, px2hd, theme) {
  return function (text, font) {
    var _a = font || {},
      _b = _a.fontSize,
      fontSize = _b === void 0 ? theme.fontSize : _b,
      _c = _a.fontFamily,
      fontFamily = _c === void 0 ? theme.fontFamily : _c,
      _d = _a.fontWeight,
      fontWeight = _d === void 0 ? theme.fontWeight : _d,
      _e = _a.fontVariant,
      fontVariant = _e === void 0 ? theme.fontVariant : _e,
      _f = _a.fontStyle,
      fontStyle = _f === void 0 ? theme.fontStyle : _f,
      _g = _a.textAlign,
      textAlign = _g === void 0 ? theme.textAlign : _g,
      _h = _a.textBaseline,
      textBaseline = _h === void 0 ? theme.textBaseline : _h,
      _j = _a.lineWidth,
      lineWidth = _j === void 0 ? 1 : _j;
    var style = {
      x: 0,
      y: 0,
      fontSize: px2hd(fontSize),
      fontFamily: fontFamily,
      fontStyle: fontStyle,
      fontWeight: fontWeight,
      fontVariant: fontVariant,
      text: text,
      textAlign: textAlign,
      textBaseline: textBaseline,
      lineWidth: lineWidth,
      visibility: 'hidden'
    };
    var result = checkCSSRule('text', style);
    var shape = new Text({
      style: result
    });
    container.appendChild(shape);
    var _k = shape.getBBox(),
      width = _k.width,
      height = _k.height;
    shape.remove();
    return {
      width: width,
      height: height
    };
  };
}
function computeLayout(style) {
  var left = style.left,
    top = style.top,
    width = style.width,
    height = style.height,
    padding = style.padding;
  var paddingTop = padding[0],
    paddingRight = padding[1],
    paddingBottom = padding[2],
    paddingLeft = padding[3];
  return {
    left: left + paddingLeft,
    top: top + paddingTop,
    width: width - paddingLeft - paddingRight,
    height: height - paddingTop - paddingBottom
  };
}
// 顶层Canvas标签
var Canvas = /** @class */function () {
  function Canvas(props) {
    var context = props.context,
      _a = props.renderer,
      renderer = _a === void 0 ? new CanvasRenderer() : _a,
      width = props.width,
      height = props.height,
      customTheme = props.theme,
      customPx2hd = props.px2hd,
      customPixelRatio = props.pixelRatio,
      landscape = props.landscape,
      rendererContainer = props.container,
      // style: customStyle,
      _b = props.animate,
      // style: customStyle,
      animate = _b === void 0 ? true : _b,
      createImage = props.createImage,
      requestAnimationFrame = props.requestAnimationFrame,
      cancelAnimationFrame = props.cancelAnimationFrame;
    var px2hd = isFunction(customPx2hd) ? batch2hd(customPx2hd) : defaultPx2hd;
    // 初始化主题
    var theme = px2hd(__assign(__assign({}, Theme), customTheme));
    var pixelRatio = theme.pixelRatio,
      fontSize = theme.fontSize,
      fontFamily = theme.fontFamily;
    var devicePixelRatio = customPixelRatio ? customPixelRatio : pixelRatio;
    // 组件更新器
    var updater = createUpdater(this);
    var canvasElement = createMobileCanvasElement(context);
    var canvas = new GCanvas({
      container: rendererContainer,
      canvas: canvasElement,
      devicePixelRatio: devicePixelRatio,
      renderer: renderer,
      width: width,
      height: height,
      supportsTouchEvents: true,
      // https://caniuse.com/?search=PointerEvent ios 13 以下不支持 Pointer
      supportsPointerEvents: runtime.globalThis.PointerEvent ? true : false,
      // 允许在canvas外部触发
      alwaysTriggerPointerEventOnCanvas: true,
      createImage: createImage,
      requestAnimationFrame: requestAnimationFrame,
      cancelAnimationFrame: cancelAnimationFrame,
      useNativeClickEvent: true
    });
    var container = canvas.getRoot();
    var _c = canvas.getConfig(),
      canvasWidth = _c.width,
      canvasHeight = _c.height;
    // 设置默认的全局样式
    container.setAttribute('fontSize', fontSize);
    container.setAttribute('fontFamily', fontFamily);
    var gesture = new Gesture(container);
    // 供全局使用的一些变量
    var componentContext = {
      ctx: context,
      root: this,
      canvas: canvas,
      px2hd: px2hd,
      theme: theme,
      gesture: gesture,
      measureText: measureText(container, px2hd, theme),
      timeline: null
    };
    var vNode = {
      key: undefined,
      tag: ClassComponent,
      // style: layout,
      // @ts-ignore
      type: Canvas,
      props: props,
      shape: container,
      animate: animate,
      // @ts-ignore
      component: this,
      canvas: this,
      context: componentContext,
      updater: updater
    };
    this._ee = new EE();
    this.props = props;
    this.context = componentContext;
    this.updater = updater;
    this.gesture = gesture;
    this.theme = theme;
    this.canvas = canvas;
    this.container = container;
    this.el = canvasElement;
    this.vNode = vNode;
    // todo: 横屏事件逻辑
    this.landscape = landscape;
    this.updateLayout(__assign(__assign({}, props), {
      width: canvasWidth,
      height: canvasHeight
    }));
  }
  Canvas.prototype.updateComponents = function (components) {
    updateComponents(components);
  };
  Canvas.prototype.update = function (nextProps) {
    return __awaiter(this, void 0, void 0, function () {
      var _a, props, vNode, _b, animate;
      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            _a = this, props = _a.props, vNode = _a.vNode;
            if (equal(nextProps, props)) {
              return [2 /*return*/];
            }

            _b = props.animate, animate = _b === void 0 ? true : _b;
            this.props = nextProps;
            vNode.props = nextProps;
            vNode.animate = animate;
            return [4 /*yield*/, this.render()];
          case 1:
            _c.sent();
            return [2 /*return*/];
        }
      });
    });
  };

  Canvas.prototype.render = function () {
    return __awaiter(this, void 0, void 0, function () {
      var _a, canvas, vNode;
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this, canvas = _a.canvas, vNode = _a.vNode;
            return [4 /*yield*/, canvas.ready];
          case 1:
            _b.sent();
            render(vNode);
            return [2 /*return*/];
        }
      });
    });
  };

  Canvas.prototype.emit = function (type, event) {
    this._ee.emit(type, event);
  };
  Canvas.prototype.on = function (type, listener) {
    this._ee.on(type, listener);
  };
  Canvas.prototype.off = function (type, listener) {
    this._ee.off(type, listener);
  };
  Canvas.prototype.getCanvasEl = function () {
    return this.el;
  };
  Canvas.prototype.resize = function (width, height) {
    return __awaiter(this, void 0, void 0, function () {
      var canvas;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            canvas = this.canvas;
            canvas.resize(width, height);
            this.updateLayout(__assign(__assign({}, this.props), {
              width: width,
              height: height
            }));
            return [4 /*yield*/, this.render()];
          case 1:
            _a.sent();
            return [2 /*return*/];
        }
      });
    });
  };

  Canvas.prototype.toDataURL = function (type, encoderOptions) {
    return __awaiter(this, void 0, void 0, function () {
      var canvas;
      return __generator(this, function (_a) {
        canvas = this.canvas;
        return [2 /*return*/, new Promise(function (resolve) {
          canvas.addEventListener('rerender', function () {
            canvas.getContextService().toDataURL({
              type: type,
              encoderOptions: encoderOptions
            }).then(resolve);
          }, {
            once: true
          });
        })];
      });
    });
  };
  Canvas.prototype.updateLayout = function (props) {
    var width = props.width,
      height = props.height;
    var _a = this.context,
      px2hd = _a.px2hd,
      theme = _a.theme;
    var style = px2hd(__assign({
      left: 0,
      top: 0,
      width: width,
      height: height,
      padding: theme.padding
    }, props.style));
    var layout = computeLayout(style);
    var left = layout.left,
      top = layout.top;
    // 设置 container 的位置
    this.container.setAttribute('x', left);
    this.container.setAttribute('y', top);
    this.context = __assign(__assign({}, this.context), {
      left: left,
      top: top,
      width: layout.width,
      height: layout.height
    });
    this.vNode = __assign(__assign({}, this.vNode), {
      style: layout,
      context: this.context
    });
  };
  Canvas.prototype.toRawChildren = function (children) {
    return children;
  };
  Canvas.prototype.destroy = function () {
    var _a = this,
      canvas = _a.canvas,
      children = _a.children,
      el = _a.el;
    destroyElement(children);
    // 需要清理 canvas 画布内容，否则会导致 spa 应用 ios 下 canvas 白屏
    // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12
    // https://github.com/antvis/F2/issues/630
    el.width = 0;
    el.height = 0;
    this.props = null;
    this.context = null;
    this.updater = null;
    this.theme = null;
    this.canvas = null;
    this.container = null;
    this.el = null;
    this.vNode = null;
    // 销毁也需要等 ready
    canvas.ready.then(function () {
      canvas.destroy();
    });
  };
  return Canvas;
}();
export default Canvas;