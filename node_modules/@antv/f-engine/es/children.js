import { __assign } from "tslib";
import { isArray, isNil } from '@antv/util';
function cloneElement(element, props) {
  if (!element) return element;
  return __assign(__assign({}, element), {
    props: __assign(__assign({}, element.props), props)
  });
}
function map(children, fn) {
  if (!children) {
    return fn(children);
  }
  if (isArray(children)) {
    return children.map(function (child) {
      return map(child, fn);
    });
  }
  return fn(children);
}
function compareArray(nextElements, lastElements, callback) {
  var keyed = {};
  var nextLength = nextElements.length;
  var lastLength = lastElements.length;
  for (var i = 0, len = lastLength; i < len; i++) {
    var element = lastElements[i];
    if (element && !isNil(element.key)) {
      var key = element.key;
      keyed[key] = element;
    }
  }
  var result = [];
  // 比较元素
  for (var i = 0, len = nextLength; i < len; i++) {
    var element = nextElements[i];
    if (!element) {
      continue;
    }
    var key = element.key;
    var lastElement = void 0;
    // 有key值定义
    if (!isNil(element.key)) {
      lastElement = keyed[key];
      if (lastElement) delete keyed[key];
    } else {
      // 取相同位置的元素
      lastElement = lastElements[i];
    }
    // 没有直接返回
    if (!lastElement) {
      result.push(compare(element, null, callback));
      continue;
    }
    // 如果 lastElement 已经被处理过, next 处理成新增
    if (lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed) {
      result.push(compare(element, null, callback));
      continue;
    }
    // 标记 element 已经被处理过
    lastElement.__processed = true;
    result.push(compare(element, lastElement, callback));
  }
  // 处理 lastElements 里面还未被处理的元素
  for (var i = 0, len = lastLength; i < len; i++) {
    var lastElement = lastElements[i];
    if (!lastElement) {
      continue;
    }
    if (!(lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed)) {
      result.push(compare(null, lastElement, callback));
    } else {
      delete lastElement.__processed;
    }
  }
  return result;
}
// 比较2棵树
function compare(nextElement, lastElement, callback) {
  // 有一个为空
  if (!nextElement || !lastElement) {
    return callback(nextElement, lastElement);
  }
  if (isArray(nextElement) || isArray(lastElement)) {
    var nextElementArray = isArray(nextElement) ? nextElement : [nextElement];
    var lastElementArray = isArray(lastElement) ? lastElement : [lastElement];
    return compareArray(nextElementArray, lastElementArray, callback);
  }
  return callback(nextElement, lastElement);
}
function toArray(element) {
  if (!element) {
    return element;
  }
  if (!isArray(element)) {
    return [element];
  }
  var newArray = [];
  for (var i = 0, len = element.length; i < len; i++) {
    var item = element[i];
    if (isArray(item)) {
      newArray = newArray.concat(toArray(item));
    } else {
      newArray.push(item);
    }
  }
  return newArray;
}
var Children = {
  cloneElement: cloneElement,
  map: map,
  toArray: toArray,
  compare: compare
};
export default Children;