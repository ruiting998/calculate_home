import { __extends } from "tslib";
import { Path, deg2rad } from '@antv/g-lite';
import { isNumberEqual, isNil } from '@antv/util';
import { polarToCartesian } from './util/util';
function computeArcSweep(startAngle, endAngle, anticlockwise) {
  // 顺时针方向
  if (!anticlockwise) {
    if (endAngle >= startAngle) {
      return endAngle - startAngle <= Math.PI ? 0 : 1;
    }
    return endAngle - startAngle <= -Math.PI ? 0 : 1;
  }
  // 逆时针方向
  if (endAngle >= startAngle) {
    return endAngle - startAngle <= Math.PI ? 1 : 0;
  }
  return endAngle - startAngle <= -Math.PI ? 1 : 0;
}
var Arc = /** @class */function (_super) {
  __extends(Arc, _super);
  function Arc(config) {
    var _this = _super.call(this, config) || this;
    _this.updatePath();
    return _this;
  }
  Arc.prototype.setAttribute = function (name, value, force) {
    _super.prototype.setAttribute.call(this, name, value, force);
    if (['cx', 'cy', 'startAngle', 'endAngle', 'r', 'anticlockwise'].indexOf(name) > -1) {
      this.updatePath();
    }
  };
  Arc.prototype.updatePath = function () {
    var _a = this.parsedStyle,
      _b = _a.cx,
      cx = _b === void 0 ? 0 : _b,
      _c = _a.cy,
      cy = _c === void 0 ? 0 : _c,
      startAngle = _a.startAngle,
      endAngle = _a.endAngle,
      r = _a.r,
      anticlockwise = _a.anticlockwise;
    if (isNil(startAngle) || isNil(endAngle) || startAngle === endAngle || isNil(r) || r <= 0) {
      return;
    }
    var path = this.createPath(cx, cy, deg2rad(startAngle), deg2rad(endAngle), r, anticlockwise);
    _super.prototype.setAttribute.call(this, 'path', path);
  };
  Arc.prototype.createPath = function (x, y, startAngle, endAngle, r, anticlockwise) {
    var start = polarToCartesian(x, y, r, startAngle);
    var end = polarToCartesian(x, y, r, endAngle);
    var angle = Math.abs(endAngle - startAngle);
    if (angle >= Math.PI * 2 || isNumberEqual(angle, Math.PI * 2)) {
      var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
      return [['M', start.x, start.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, middlePoint.x, middlePoint.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, start.x, start.y], ['Z']];
    }
    var arcSweep = computeArcSweep(startAngle, endAngle, anticlockwise);
    return [['M', start.x, start.y], ['A', r, r, 0, arcSweep, anticlockwise ? 0 : 1, end.x, end.y]];
  };
  return Arc;
}(Path);
export { Arc };