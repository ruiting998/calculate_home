import { __extends } from "tslib";
import { Path } from '@antv/g-lite';
var SYMBOLS = {
  circle: function circle(x, y, r) {
    return [['M', x - r, y], ['A', r, r, 0, 1, 0, x + r, y], ['A', r, r, 0, 1, 0, x - r, y]];
  },
  square: function square(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
  },
  arrow: function arrow(x, y, r) {
    return [['M', x - r, y + 2 * r / Math.sqrt(3)], ['L', x + r, y + 2 * r / Math.sqrt(3)], ['L', x, y - 2 * r / Math.sqrt(3)], ['Z']];
  }
};
var Marker = /** @class */function (_super) {
  __extends(Marker, _super);
  function Marker(config) {
    var _this = _super.call(this, config) || this;
    _this.updatePath();
    return _this;
  }
  Marker.prototype.setAttribute = function (name, value, force) {
    _super.prototype.setAttribute.call(this, name, value, force);
    if (['x', 'y', 'symbol', 'radius'].indexOf(name) > -1) {
      this.updatePath();
    }
  };
  Marker.prototype.updatePath = function () {
    var _a = this.parsedStyle,
      _b = _a.x,
      x = _b === void 0 ? 0 : _b,
      _c = _a.y,
      y = _c === void 0 ? 0 : _c;
    var _d = this.attributes,
      radius = _d.radius,
      symbol = _d.symbol;
    if (!symbol) return;
    var method = SYMBOLS[symbol];
    if (!method) return;
    var path = method(x, y, radius);
    _super.prototype.setAttribute.call(this, 'path', path);
  };
  return Marker;
}(Path);
export { Marker };