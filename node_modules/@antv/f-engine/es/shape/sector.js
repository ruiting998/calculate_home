import { __extends } from "tslib";
import { Path, deg2rad } from '@antv/g-lite';
import { polarToCartesian } from './util/util';
import { isNumberEqual, isNil } from '@antv/util';
var PI = Math.PI;
var PI2 = PI * 2;
var mathSin = Math.sin;
var mathCos = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
// const mathAbs = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax = Math.max;
var mathMin = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e) {
    return;
  }
  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
  return [x0 + t * dx10, y0 + t * dy10];
}
// Compute perpendicular offset line of length rc.
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d2 = dx * dx + dy * dy;
  var r = radius - cr;
  var s = x11 * y10 - x10 * y11;
  var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d2 - s * s));
  var cx0 = (s * dy - dx * d) / d2;
  var cy0 = (-s * dx - dy * d) / d2;
  var cx1 = (s * dy + dx * d) / d2;
  var cy1 = (-s * dx + dy * d) / d2;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  // Pick the closer of the two intersection points
  // TODO: Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function computeArcSweep(startAngle, endAngle, clockwise) {
  if (clockwise === void 0) {
    clockwise = true;
  }
  if (!clockwise) {
    var replaceAngle = endAngle;
    endAngle = startAngle;
    startAngle = replaceAngle;
  }
  endAngle = endAngle - startAngle < 0 ? endAngle + PI2 : endAngle;
  return Math.abs(endAngle - startAngle) % PI2 <= PI ? 0 : 1;
}
var Sector = /** @class */function (_super) {
  __extends(Sector, _super);
  function Sector(config) {
    var _this = _super.call(this, config) || this;
    _this.updatePath();
    return _this;
  }
  Sector.prototype.setAttribute = function (name, value, force) {
    _super.prototype.setAttribute.call(this, name, value, force);
    if (['startAngle', 'endAngle', 'r', 'r0', 'radius', 'cx', 'cy'].indexOf(name) > -1) {
      this.updatePath();
    }
  };
  Sector.prototype.updatePath = function () {
    var _a = this.parsedStyle,
      cx = _a.cx,
      cy = _a.cy,
      startAngle = _a.startAngle,
      endAngle = _a.endAngle,
      r = _a.r,
      r0 = _a.r0,
      radius = _a.radius,
      _b = _a.anticlockwise,
      anticlockwise = _b === void 0 ? false : _b;
    if (isNil(startAngle) || isNil(endAngle) || startAngle === endAngle || isNil(r) || r <= 0) {
      return;
    }
    var path = this.createPath(cx, cy, deg2rad(startAngle), deg2rad(endAngle), r, r0 ? r0 : 0, radius ? radius : [0, 0, 0, 0], anticlockwise);
    _super.prototype.setAttribute.call(this, 'path', path);
  };
  Sector.prototype.createPath = function (x, y, startAngle, endAngle, r, r0, borderRadius, anticlockwise) {
    var start = polarToCartesian(x, y, r, startAngle);
    var end = polarToCartesian(x, y, r, endAngle);
    var innerStart = polarToCartesian(x, y, r0, startAngle);
    var innerEnd = polarToCartesian(x, y, r0, endAngle);
    var clockwise = !anticlockwise;
    var angle = clockwise ? endAngle - startAngle : startAngle - endAngle;
    // 整圆
    if (Math.abs(angle) >= PI2 || isNumberEqual(Math.abs(angle), PI2)) {
      // 整个圆是分割成两个圆
      var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
      var innerMiddlePoint = polarToCartesian(x, y, r0, startAngle + Math.PI);
      var circlePathCommands = [['M', start.x, start.y], ['A', r, r, 0, 1, clockwise ? 1 : 0, middlePoint.x, middlePoint.y], ['A', r, r, 0, 1, clockwise ? 1 : 0, end.x, end.y]];
      if (r0 > 0) {
        circlePathCommands.push(['M', innerStart.x, innerStart.y]);
        circlePathCommands.push(['A', r0, r0, 0, 1, clockwise ? 0 : 1, innerMiddlePoint.x, innerMiddlePoint.y]);
        circlePathCommands.push(['A', r0, r0, 0, 1, clockwise ? 0 : 1, innerEnd.x, innerEnd.y]);
      }
      circlePathCommands.push(['M', start.x, start.y]);
      circlePathCommands.push(['Z']);
      return circlePathCommands;
    }
    var xrs = r * mathCos(startAngle);
    var yrs = r * mathSin(startAngle);
    var xire = r0 * mathCos(endAngle);
    var yire = r0 * mathSin(endAngle);
    var xre = r * mathCos(endAngle);
    var yre = r * mathSin(endAngle);
    var xirs = r0 * mathCos(startAngle);
    var yirs = r0 * mathSin(startAngle);
    // 顺时针反向，同 radius
    var outStartRadius = borderRadius[0],
      outEndRadius = borderRadius[1],
      innerEndRadius = borderRadius[2],
      innerStartRadius = borderRadius[3];
    var halfRadius = (r - r0) / 2;
    var outStartBorderRadius = mathMin(halfRadius, outStartRadius);
    var outEndBorderRadius = mathMin(halfRadius, outEndRadius);
    var innerEndBorderRadius = mathMin(halfRadius, innerEndRadius);
    var innerStartBorderRadius = mathMin(halfRadius, innerStartRadius);
    var outBorderRadiusMax = mathMax(outStartBorderRadius, outEndBorderRadius);
    var innerBorderRadiusMax = mathMax(innerEndBorderRadius, innerStartBorderRadius);
    var limitedOutBorderRadiusMax = outBorderRadiusMax;
    var limitedInnerBorderRadiusMax = innerBorderRadiusMax;
    // draw corner radius
    if (outBorderRadiusMax > e || innerBorderRadiusMax > e) {
      // restrict the max value of corner radius
      if (angle < PI) {
        var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
        if (it_1) {
          var x0 = xrs - it_1[0];
          var y0 = yrs - it_1[1];
          var x1 = xre - it_1[0];
          var y1 = yre - it_1[1];
          var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
          var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
          limitedOutBorderRadiusMax = mathMin(outBorderRadiusMax, (r - b) / (a + 1));
          limitedInnerBorderRadiusMax = mathMin(innerBorderRadiusMax, (r0 - b) / (a - 1));
        }
      }
    }
    var arcSweep = computeArcSweep(startAngle, endAngle, clockwise);
    var sectorPathCommands = [];
    if (limitedOutBorderRadiusMax > e) {
      var crStart = mathMin(outStartRadius, limitedOutBorderRadiusMax);
      var crEnd = mathMin(outEndRadius, limitedOutBorderRadiusMax);
      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, r, crStart, clockwise);
      var ct1 = computeCornerTangents(xre, yre, xire, yire, r, crEnd, clockwise);
      sectorPathCommands.push(['M', x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
      // Have the corners merged?
      if (limitedOutBorderRadiusMax < outBorderRadiusMax && crStart === crEnd) {
        var outStartBorderRadiusStartAngle = mathATan2(ct0.cy + ct0.y0, ct0.cx + ct0.x0);
        var outStartBorderRadiusEndAngle = mathATan2(ct1.cy + ct1.y0, ct1.cx + ct1.x0);
        sectorPathCommands.push(['A', limitedOutBorderRadiusMax, limitedOutBorderRadiusMax, 0, computeArcSweep(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, !clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
      } else {
        // draw the two corners and the ring
        if (crStart > 0) {
          var outStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
          var outStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
          var outStartBorderRadiusEndPoint = polarToCartesian(x, y, r, outStartBorderRadiusEndAngle);
          sectorPathCommands.push(['A', crStart, crStart, 0, computeArcSweep(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, outStartBorderRadiusEndPoint.x, outStartBorderRadiusEndPoint.y]);
        }
        var outRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
        var outRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
        var outRadiusEndPoint = polarToCartesian(x, y, r, outRadiusEndAngle);
        sectorPathCommands.push(['A', r, r, 1, computeArcSweep(outRadiusStartAngle, outRadiusEndAngle, clockwise), clockwise ? 1 : 0, outRadiusEndPoint.x, outRadiusEndPoint.y]);
        if (crEnd > 0) {
          var outEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
          var outEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
          sectorPathCommands.push(['A', crEnd, crEnd, 0, computeArcSweep(outEndBorderRadiusStartAngle, outEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        }
      }
    } else {
      sectorPathCommands.push(['M', start.x, start.y]);
      sectorPathCommands.push(['A', r, r, 0, arcSweep, clockwise ? 1 : 0, end.x, end.y]);
    }
    // no inner ring, is a circular sector
    if (r0 < e) {
      sectorPathCommands.push(['L', innerEnd.x, innerEnd.y]);
    } else if (limitedInnerBorderRadiusMax > e) {
      var crStart = mathMin(innerStartRadius, limitedInnerBorderRadiusMax);
      var crEnd = mathMin(innerEndRadius, limitedInnerBorderRadiusMax);
      var ct0 = computeCornerTangents(0, 0, xire, yire, r0, -crEnd, clockwise);
      var ct1 = computeCornerTangents(xirs, yirs, 0, 0, r0, -crStart, clockwise);
      sectorPathCommands.push(['L', x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
      // Have the corners merged?
      if (limitedInnerBorderRadiusMax < innerBorderRadiusMax && crStart === crEnd) {
        var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
        var innerStartBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
        sectorPathCommands.push(['A', limitedInnerBorderRadiusMax, limitedInnerBorderRadiusMax, 0, computeArcSweep(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle), 1, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
      } else {
        // draw the two corners and the ring
        if (crEnd > 0) {
          var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
          var innerStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
          sectorPathCommands.push(['A', crEnd, crEnd, 0, computeArcSweep(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct0.cx + ct0.x1, y + ct0.cy + ct0.y1]);
        }
        var innerRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
        var innerRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
        var innerRadiusEndPoint = polarToCartesian(x, y, r0, innerRadiusEndAngle);
        sectorPathCommands.push(['A', r0, r0, 0, computeArcSweep(innerRadiusEndAngle, innerRadiusStartAngle, clockwise), clockwise ? 0 : 1, innerRadiusEndPoint.x, innerRadiusEndPoint.y]);
        if (crStart > 0) {
          var innerEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
          var innerEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
          sectorPathCommands.push(['A', crStart, crStart, 0, computeArcSweep(innerEndBorderRadiusStartAngle, innerEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        }
      }
    }
    // the inner ring is just a circular arc
    else {
      sectorPathCommands.push(['L', innerEnd.x, innerEnd.y]);
      sectorPathCommands.push(['A', r0, r0, 0, arcSweep, clockwise ? 0 : 1, innerStart.x, innerStart.y]);
    }
    sectorPathCommands.push(['Z']);
    return sectorPathCommands;
  };
  return Sector;
}(Path);
export { Sector };