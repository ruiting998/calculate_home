(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FEngine = {}));
}(this, (function (exports) { 'use strict';

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var objectWithoutPropertiesLoose = createCommonjsModule(function (module) {
	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}
	module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var objectWithoutProperties = createCommonjsModule(function (module) {
	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};
	  var target = objectWithoutPropertiesLoose(source, excluded);
	  var key, i;
	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }
	  return target;
	}
	module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _objectWithoutProperties = /*@__PURE__*/getDefaultExportFromCjs(objectWithoutProperties);

	var _typeof_1 = createCommonjsModule(function (module) {
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
	}
	module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _typeof = /*@__PURE__*/getDefaultExportFromCjs(_typeof_1);

	var toPrimitive = createCommonjsModule(function (module) {
	var _typeof = _typeof_1["default"];
	function _toPrimitive(input, hint) {
	  if (_typeof(input) !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (_typeof(res) !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var toPropertyKey = createCommonjsModule(function (module) {
	var _typeof = _typeof_1["default"];

	function _toPropertyKey(arg) {
	  var key = toPrimitive(arg, "string");
	  return _typeof(key) === "symbol" ? key : String(key);
	}
	module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var defineProperty = createCommonjsModule(function (module) {
	function _defineProperty(obj, key, value) {
	  key = toPropertyKey(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var objectSpread2 = createCommonjsModule(function (module) {
	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);
	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    })), keys.push.apply(keys, symbols);
	  }
	  return keys;
	}
	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
	      defineProperty(target, key, source[key]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    });
	  }
	  return target;
	}
	module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _objectSpread = /*@__PURE__*/getDefaultExportFromCjs(objectSpread2);

	/**
	 * Common utilities
	 * @module glMatrix
	 */
	// Configuration Constants
	var EPSILON = 0.000001;
	var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
	if (!Math.hypot) Math.hypot = function () {
	  var y = 0,
	      i = arguments.length;

	  while (i--) {
	    y += arguments[i] * arguments[i];
	  }

	  return Math.sqrt(y);
	};

	/**
	 * 3x3 Matrix
	 * @module mat3
	 */

	/**
	 * Creates a new identity mat3
	 *
	 * @returns {mat3} a new 3x3 matrix
	 */

	function create() {
	  var out = new ARRAY_TYPE(9);

	  if (ARRAY_TYPE != Float32Array) {
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	  }

	  out[0] = 1;
	  out[4] = 1;
	  out[8] = 1;
	  return out;
	}
	/**
	 * Copies the upper-left 3x3 values into the given mat3.
	 *
	 * @param {mat3} out the receiving 3x3 matrix
	 * @param {ReadonlyMat4} a   the source 4x4 matrix
	 * @returns {mat3} out
	 */

	function fromMat4(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[4];
	  out[4] = a[5];
	  out[5] = a[6];
	  out[6] = a[8];
	  out[7] = a[9];
	  out[8] = a[10];
	  return out;
	}
	/**
	 * Create a new mat3 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m10 Component in column 1, row 0 position (index 3)
	 * @param {Number} m11 Component in column 1, row 1 position (index 4)
	 * @param {Number} m12 Component in column 1, row 2 position (index 5)
	 * @param {Number} m20 Component in column 2, row 0 position (index 6)
	 * @param {Number} m21 Component in column 2, row 1 position (index 7)
	 * @param {Number} m22 Component in column 2, row 2 position (index 8)
	 * @returns {mat3} A new mat3
	 */

	function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
	  var out = new ARRAY_TYPE(9);
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m02;
	  out[3] = m10;
	  out[4] = m11;
	  out[5] = m12;
	  out[6] = m20;
	  out[7] = m21;
	  out[8] = m22;
	  return out;
	}

	/**
	 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
	 * @module mat4
	 */

	/**
	 * Creates a new identity mat4
	 *
	 * @returns {mat4} a new 4x4 matrix
	 */

	function create$1() {
	  var out = new ARRAY_TYPE(16);

	  if (ARRAY_TYPE != Float32Array) {
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	  }

	  out[0] = 1;
	  out[5] = 1;
	  out[10] = 1;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {ReadonlyMat4} a matrix to clone
	 * @returns {mat4} a new 4x4 matrix
	 */

	function clone(a) {
	  var out = new ARRAY_TYPE(16);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  out[6] = a[6];
	  out[7] = a[7];
	  out[8] = a[8];
	  out[9] = a[9];
	  out[10] = a[10];
	  out[11] = a[11];
	  out[12] = a[12];
	  out[13] = a[13];
	  out[14] = a[14];
	  out[15] = a[15];
	  return out;
	}
	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the source matrix
	 * @returns {mat4} out
	 */

	function copy(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  out[6] = a[6];
	  out[7] = a[7];
	  out[8] = a[8];
	  out[9] = a[9];
	  out[10] = a[10];
	  out[11] = a[11];
	  out[12] = a[12];
	  out[13] = a[13];
	  out[14] = a[14];
	  out[15] = a[15];
	  return out;
	}
	/**
	 * Create a new mat4 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m03 Component in column 0, row 3 position (index 3)
	 * @param {Number} m10 Component in column 1, row 0 position (index 4)
	 * @param {Number} m11 Component in column 1, row 1 position (index 5)
	 * @param {Number} m12 Component in column 1, row 2 position (index 6)
	 * @param {Number} m13 Component in column 1, row 3 position (index 7)
	 * @param {Number} m20 Component in column 2, row 0 position (index 8)
	 * @param {Number} m21 Component in column 2, row 1 position (index 9)
	 * @param {Number} m22 Component in column 2, row 2 position (index 10)
	 * @param {Number} m23 Component in column 2, row 3 position (index 11)
	 * @param {Number} m30 Component in column 3, row 0 position (index 12)
	 * @param {Number} m31 Component in column 3, row 1 position (index 13)
	 * @param {Number} m32 Component in column 3, row 2 position (index 14)
	 * @param {Number} m33 Component in column 3, row 3 position (index 15)
	 * @returns {mat4} A new mat4
	 */

	function fromValues$1(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	  var out = new ARRAY_TYPE(16);
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m02;
	  out[3] = m03;
	  out[4] = m10;
	  out[5] = m11;
	  out[6] = m12;
	  out[7] = m13;
	  out[8] = m20;
	  out[9] = m21;
	  out[10] = m22;
	  out[11] = m23;
	  out[12] = m30;
	  out[13] = m31;
	  out[14] = m32;
	  out[15] = m33;
	  return out;
	}
	/**
	 * Set the components of a mat4 to the given values
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m03 Component in column 0, row 3 position (index 3)
	 * @param {Number} m10 Component in column 1, row 0 position (index 4)
	 * @param {Number} m11 Component in column 1, row 1 position (index 5)
	 * @param {Number} m12 Component in column 1, row 2 position (index 6)
	 * @param {Number} m13 Component in column 1, row 3 position (index 7)
	 * @param {Number} m20 Component in column 2, row 0 position (index 8)
	 * @param {Number} m21 Component in column 2, row 1 position (index 9)
	 * @param {Number} m22 Component in column 2, row 2 position (index 10)
	 * @param {Number} m23 Component in column 2, row 3 position (index 11)
	 * @param {Number} m30 Component in column 3, row 0 position (index 12)
	 * @param {Number} m31 Component in column 3, row 1 position (index 13)
	 * @param {Number} m32 Component in column 3, row 2 position (index 14)
	 * @param {Number} m33 Component in column 3, row 3 position (index 15)
	 * @returns {mat4} out
	 */

	function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m02;
	  out[3] = m03;
	  out[4] = m10;
	  out[5] = m11;
	  out[6] = m12;
	  out[7] = m13;
	  out[8] = m20;
	  out[9] = m21;
	  out[10] = m22;
	  out[11] = m23;
	  out[12] = m30;
	  out[13] = m31;
	  out[14] = m32;
	  out[15] = m33;
	  return out;
	}
	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */

	function identity(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = 1;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 1;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Transpose the values of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the source matrix
	 * @returns {mat4} out
	 */

	function transpose(out, a) {
	  // If we are transposing ourselves we can skip a few steps but have to cache some values
	  if (out === a) {
	    var a01 = a[1],
	        a02 = a[2],
	        a03 = a[3];
	    var a12 = a[6],
	        a13 = a[7];
	    var a23 = a[11];
	    out[1] = a[4];
	    out[2] = a[8];
	    out[3] = a[12];
	    out[4] = a01;
	    out[6] = a[9];
	    out[7] = a[13];
	    out[8] = a02;
	    out[9] = a12;
	    out[11] = a[14];
	    out[12] = a03;
	    out[13] = a13;
	    out[14] = a23;
	  } else {
	    out[0] = a[0];
	    out[1] = a[4];
	    out[2] = a[8];
	    out[3] = a[12];
	    out[4] = a[1];
	    out[5] = a[5];
	    out[6] = a[9];
	    out[7] = a[13];
	    out[8] = a[2];
	    out[9] = a[6];
	    out[10] = a[10];
	    out[11] = a[14];
	    out[12] = a[3];
	    out[13] = a[7];
	    out[14] = a[11];
	    out[15] = a[15];
	  }

	  return out;
	}
	/**
	 * Inverts a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the source matrix
	 * @returns {mat4} out
	 */

	function invert(out, a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];
	  var b00 = a00 * a11 - a01 * a10;
	  var b01 = a00 * a12 - a02 * a10;
	  var b02 = a00 * a13 - a03 * a10;
	  var b03 = a01 * a12 - a02 * a11;
	  var b04 = a01 * a13 - a03 * a11;
	  var b05 = a02 * a13 - a03 * a12;
	  var b06 = a20 * a31 - a21 * a30;
	  var b07 = a20 * a32 - a22 * a30;
	  var b08 = a20 * a33 - a23 * a30;
	  var b09 = a21 * a32 - a22 * a31;
	  var b10 = a21 * a33 - a23 * a31;
	  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

	  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	  if (!det) {
	    return null;
	  }

	  det = 1.0 / det;
	  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	  return out;
	}
	/**
	 * Calculates the adjugate of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the source matrix
	 * @returns {mat4} out
	 */

	function adjoint(out, a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];
	  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
	  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
	  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
	  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
	  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
	  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
	  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
	  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
	  return out;
	}
	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {ReadonlyMat4} a the source matrix
	 * @returns {Number} determinant of a
	 */

	function determinant(a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];
	  var b00 = a00 * a11 - a01 * a10;
	  var b01 = a00 * a12 - a02 * a10;
	  var b02 = a00 * a13 - a03 * a10;
	  var b03 = a01 * a12 - a02 * a11;
	  var b04 = a01 * a13 - a03 * a11;
	  var b05 = a02 * a13 - a03 * a12;
	  var b06 = a20 * a31 - a21 * a30;
	  var b07 = a20 * a32 - a22 * a30;
	  var b08 = a20 * a33 - a23 * a30;
	  var b09 = a21 * a32 - a22 * a31;
	  var b10 = a21 * a33 - a23 * a31;
	  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

	  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	}
	/**
	 * Multiplies two mat4s
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the first operand
	 * @param {ReadonlyMat4} b the second operand
	 * @returns {mat4} out
	 */

	function multiply(out, a, b) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15]; // Cache only the current line of the second matrix

	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3];
	  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = b[4];
	  b1 = b[5];
	  b2 = b[6];
	  b3 = b[7];
	  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = b[8];
	  b1 = b[9];
	  b2 = b[10];
	  b3 = b[11];
	  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = b[12];
	  b1 = b[13];
	  b2 = b[14];
	  b3 = b[15];
	  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  return out;
	}
	/**
	 * Translate a mat4 by the given vector
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the matrix to translate
	 * @param {ReadonlyVec3} v vector to translate by
	 * @returns {mat4} out
	 */

	function translate(out, a, v) {
	  var x = v[0],
	      y = v[1],
	      z = v[2];
	  var a00, a01, a02, a03;
	  var a10, a11, a12, a13;
	  var a20, a21, a22, a23;

	  if (a === out) {
	    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	  } else {
	    a00 = a[0];
	    a01 = a[1];
	    a02 = a[2];
	    a03 = a[3];
	    a10 = a[4];
	    a11 = a[5];
	    a12 = a[6];
	    a13 = a[7];
	    a20 = a[8];
	    a21 = a[9];
	    a22 = a[10];
	    a23 = a[11];
	    out[0] = a00;
	    out[1] = a01;
	    out[2] = a02;
	    out[3] = a03;
	    out[4] = a10;
	    out[5] = a11;
	    out[6] = a12;
	    out[7] = a13;
	    out[8] = a20;
	    out[9] = a21;
	    out[10] = a22;
	    out[11] = a23;
	    out[12] = a00 * x + a10 * y + a20 * z + a[12];
	    out[13] = a01 * x + a11 * y + a21 * z + a[13];
	    out[14] = a02 * x + a12 * y + a22 * z + a[14];
	    out[15] = a03 * x + a13 * y + a23 * z + a[15];
	  }

	  return out;
	}
	/**
	 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the matrix to scale
	 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/

	function scale(out, a, v) {
	  var x = v[0],
	      y = v[1],
	      z = v[2];
	  out[0] = a[0] * x;
	  out[1] = a[1] * x;
	  out[2] = a[2] * x;
	  out[3] = a[3] * x;
	  out[4] = a[4] * y;
	  out[5] = a[5] * y;
	  out[6] = a[6] * y;
	  out[7] = a[7] * y;
	  out[8] = a[8] * z;
	  out[9] = a[9] * z;
	  out[10] = a[10] * z;
	  out[11] = a[11] * z;
	  out[12] = a[12];
	  out[13] = a[13];
	  out[14] = a[14];
	  out[15] = a[15];
	  return out;
	}
	/**
	 * Rotates a mat4 by the given angle around the given axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {ReadonlyVec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */

	function rotate(out, a, rad, axis) {
	  var x = axis[0],
	      y = axis[1],
	      z = axis[2];
	  var len = Math.hypot(x, y, z);
	  var s, c, t;
	  var a00, a01, a02, a03;
	  var a10, a11, a12, a13;
	  var a20, a21, a22, a23;
	  var b00, b01, b02;
	  var b10, b11, b12;
	  var b20, b21, b22;

	  if (len < EPSILON) {
	    return null;
	  }

	  len = 1 / len;
	  x *= len;
	  y *= len;
	  z *= len;
	  s = Math.sin(rad);
	  c = Math.cos(rad);
	  t = 1 - c;
	  a00 = a[0];
	  a01 = a[1];
	  a02 = a[2];
	  a03 = a[3];
	  a10 = a[4];
	  a11 = a[5];
	  a12 = a[6];
	  a13 = a[7];
	  a20 = a[8];
	  a21 = a[9];
	  a22 = a[10];
	  a23 = a[11]; // Construct the elements of the rotation matrix

	  b00 = x * x * t + c;
	  b01 = y * x * t + z * s;
	  b02 = z * x * t - y * s;
	  b10 = x * y * t - z * s;
	  b11 = y * y * t + c;
	  b12 = z * y * t + x * s;
	  b20 = x * z * t + y * s;
	  b21 = y * z * t - x * s;
	  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

	  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged last row
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  }

	  return out;
	}
	/**
	 * Rotates a matrix by the given angle around the X axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */

	function rotateX(out, a, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  var a10 = a[4];
	  var a11 = a[5];
	  var a12 = a[6];
	  var a13 = a[7];
	  var a20 = a[8];
	  var a21 = a[9];
	  var a22 = a[10];
	  var a23 = a[11];

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged rows
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  } // Perform axis-specific matrix multiplication


	  out[4] = a10 * c + a20 * s;
	  out[5] = a11 * c + a21 * s;
	  out[6] = a12 * c + a22 * s;
	  out[7] = a13 * c + a23 * s;
	  out[8] = a20 * c - a10 * s;
	  out[9] = a21 * c - a11 * s;
	  out[10] = a22 * c - a12 * s;
	  out[11] = a23 * c - a13 * s;
	  return out;
	}
	/**
	 * Rotates a matrix by the given angle around the Y axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */

	function rotateY(out, a, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  var a00 = a[0];
	  var a01 = a[1];
	  var a02 = a[2];
	  var a03 = a[3];
	  var a20 = a[8];
	  var a21 = a[9];
	  var a22 = a[10];
	  var a23 = a[11];

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged rows
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  } // Perform axis-specific matrix multiplication


	  out[0] = a00 * c - a20 * s;
	  out[1] = a01 * c - a21 * s;
	  out[2] = a02 * c - a22 * s;
	  out[3] = a03 * c - a23 * s;
	  out[8] = a00 * s + a20 * c;
	  out[9] = a01 * s + a21 * c;
	  out[10] = a02 * s + a22 * c;
	  out[11] = a03 * s + a23 * c;
	  return out;
	}
	/**
	 * Rotates a matrix by the given angle around the Z axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */

	function rotateZ(out, a, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  var a00 = a[0];
	  var a01 = a[1];
	  var a02 = a[2];
	  var a03 = a[3];
	  var a10 = a[4];
	  var a11 = a[5];
	  var a12 = a[6];
	  var a13 = a[7];

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged last row
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  } // Perform axis-specific matrix multiplication


	  out[0] = a00 * c + a10 * s;
	  out[1] = a01 * c + a11 * s;
	  out[2] = a02 * c + a12 * s;
	  out[3] = a03 * c + a13 * s;
	  out[4] = a10 * c - a00 * s;
	  out[5] = a11 * c - a01 * s;
	  out[6] = a12 * c - a02 * s;
	  out[7] = a13 * c - a03 * s;
	  return out;
	}
	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {ReadonlyVec3} v Translation vector
	 * @returns {mat4} out
	 */

	function fromTranslation(out, v) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = 1;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 1;
	  out[11] = 0;
	  out[12] = v[0];
	  out[13] = v[1];
	  out[14] = v[2];
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.scale(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {ReadonlyVec3} v Scaling vector
	 * @returns {mat4} out
	 */

	function fromScaling(out, v) {
	  out[0] = v[0];
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = v[1];
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = v[2];
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a matrix from a given angle around a given axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotate(dest, dest, rad, axis);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {ReadonlyVec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */

	function fromRotation(out, rad, axis) {
	  var x = axis[0],
	      y = axis[1],
	      z = axis[2];
	  var len = Math.hypot(x, y, z);
	  var s, c, t;

	  if (len < EPSILON) {
	    return null;
	  }

	  len = 1 / len;
	  x *= len;
	  y *= len;
	  z *= len;
	  s = Math.sin(rad);
	  c = Math.cos(rad);
	  t = 1 - c; // Perform rotation-specific matrix multiplication

	  out[0] = x * x * t + c;
	  out[1] = y * x * t + z * s;
	  out[2] = z * x * t - y * s;
	  out[3] = 0;
	  out[4] = x * y * t - z * s;
	  out[5] = y * y * t + c;
	  out[6] = z * y * t + x * s;
	  out[7] = 0;
	  out[8] = x * z * t + y * s;
	  out[9] = y * z * t - x * s;
	  out[10] = z * z * t + c;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a matrix from the given angle around the X axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateX(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */

	function fromXRotation(out, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = c;
	  out[6] = s;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = -s;
	  out[10] = c;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a matrix from the given angle around the Y axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateY(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */

	function fromYRotation(out, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

	  out[0] = c;
	  out[1] = 0;
	  out[2] = -s;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = 1;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = s;
	  out[9] = 0;
	  out[10] = c;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a matrix from the given angle around the Z axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateZ(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */

	function fromZRotation(out, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

	  out[0] = c;
	  out[1] = s;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = -s;
	  out[5] = c;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 1;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     let quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {ReadonlyVec3} v Translation vector
	 * @returns {mat4} out
	 */

	function fromRotationTranslation(out, q, v) {
	  // Quaternion math
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;
	  var xx = x * x2;
	  var xy = x * y2;
	  var xz = x * z2;
	  var yy = y * y2;
	  var yz = y * z2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;
	  out[0] = 1 - (yy + zz);
	  out[1] = xy + wz;
	  out[2] = xz - wy;
	  out[3] = 0;
	  out[4] = xy - wz;
	  out[5] = 1 - (xx + zz);
	  out[6] = yz + wx;
	  out[7] = 0;
	  out[8] = xz + wy;
	  out[9] = yz - wx;
	  out[10] = 1 - (xx + yy);
	  out[11] = 0;
	  out[12] = v[0];
	  out[13] = v[1];
	  out[14] = v[2];
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a new mat4 from a dual quat.
	 *
	 * @param {mat4} out Matrix
	 * @param {ReadonlyQuat2} a Dual Quaternion
	 * @returns {mat4} mat4 receiving operation result
	 */

	function fromQuat2(out, a) {
	  var translation = new ARRAY_TYPE(3);
	  var bx = -a[0],
	      by = -a[1],
	      bz = -a[2],
	      bw = a[3],
	      ax = a[4],
	      ay = a[5],
	      az = a[6],
	      aw = a[7];
	  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

	  if (magnitude > 0) {
	    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
	    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
	    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
	  } else {
	    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
	    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
	    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
	  }

	  fromRotationTranslation(out, a, translation);
	  return out;
	}
	/**
	 * Returns the translation vector component of a transformation
	 *  matrix. If a matrix is built with fromRotationTranslation,
	 *  the returned vector will be the same as the translation vector
	 *  originally supplied.
	 * @param  {vec3} out Vector to receive translation component
	 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
	 * @return {vec3} out
	 */

	function getTranslation(out, mat) {
	  out[0] = mat[12];
	  out[1] = mat[13];
	  out[2] = mat[14];
	  return out;
	}
	/**
	 * Returns the scaling factor component of a transformation
	 *  matrix. If a matrix is built with fromRotationTranslationScale
	 *  with a normalized Quaternion paramter, the returned vector will be
	 *  the same as the scaling vector
	 *  originally supplied.
	 * @param  {vec3} out Vector to receive scaling factor component
	 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
	 * @return {vec3} out
	 */

	function getScaling(out, mat) {
	  var m11 = mat[0];
	  var m12 = mat[1];
	  var m13 = mat[2];
	  var m21 = mat[4];
	  var m22 = mat[5];
	  var m23 = mat[6];
	  var m31 = mat[8];
	  var m32 = mat[9];
	  var m33 = mat[10];
	  out[0] = Math.hypot(m11, m12, m13);
	  out[1] = Math.hypot(m21, m22, m23);
	  out[2] = Math.hypot(m31, m32, m33);
	  return out;
	}
	/**
	 * Returns a quaternion representing the rotational component
	 *  of a transformation matrix. If a matrix is built with
	 *  fromRotationTranslation, the returned quaternion will be the
	 *  same as the quaternion originally supplied.
	 * @param {quat} out Quaternion to receive the rotation component
	 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
	 * @return {quat} out
	 */

	function getRotation(out, mat) {
	  var scaling = new ARRAY_TYPE(3);
	  getScaling(scaling, mat);
	  var is1 = 1 / scaling[0];
	  var is2 = 1 / scaling[1];
	  var is3 = 1 / scaling[2];
	  var sm11 = mat[0] * is1;
	  var sm12 = mat[1] * is2;
	  var sm13 = mat[2] * is3;
	  var sm21 = mat[4] * is1;
	  var sm22 = mat[5] * is2;
	  var sm23 = mat[6] * is3;
	  var sm31 = mat[8] * is1;
	  var sm32 = mat[9] * is2;
	  var sm33 = mat[10] * is3;
	  var trace = sm11 + sm22 + sm33;
	  var S = 0;

	  if (trace > 0) {
	    S = Math.sqrt(trace + 1.0) * 2;
	    out[3] = 0.25 * S;
	    out[0] = (sm23 - sm32) / S;
	    out[1] = (sm31 - sm13) / S;
	    out[2] = (sm12 - sm21) / S;
	  } else if (sm11 > sm22 && sm11 > sm33) {
	    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
	    out[3] = (sm23 - sm32) / S;
	    out[0] = 0.25 * S;
	    out[1] = (sm12 + sm21) / S;
	    out[2] = (sm31 + sm13) / S;
	  } else if (sm22 > sm33) {
	    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
	    out[3] = (sm31 - sm13) / S;
	    out[0] = (sm12 + sm21) / S;
	    out[1] = 0.25 * S;
	    out[2] = (sm23 + sm32) / S;
	  } else {
	    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
	    out[3] = (sm12 - sm21) / S;
	    out[0] = (sm31 + sm13) / S;
	    out[1] = (sm23 + sm32) / S;
	    out[2] = 0.25 * S;
	  }

	  return out;
	}
	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     let quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {ReadonlyVec3} v Translation vector
	 * @param {ReadonlyVec3} s Scaling vector
	 * @returns {mat4} out
	 */

	function fromRotationTranslationScale(out, q, v, s) {
	  // Quaternion math
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;
	  var xx = x * x2;
	  var xy = x * y2;
	  var xz = x * z2;
	  var yy = y * y2;
	  var yz = y * z2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;
	  var sx = s[0];
	  var sy = s[1];
	  var sz = s[2];
	  out[0] = (1 - (yy + zz)) * sx;
	  out[1] = (xy + wz) * sx;
	  out[2] = (xz - wy) * sx;
	  out[3] = 0;
	  out[4] = (xy - wz) * sy;
	  out[5] = (1 - (xx + zz)) * sy;
	  out[6] = (yz + wx) * sy;
	  out[7] = 0;
	  out[8] = (xz + wy) * sz;
	  out[9] = (yz - wx) * sz;
	  out[10] = (1 - (xx + yy)) * sz;
	  out[11] = 0;
	  out[12] = v[0];
	  out[13] = v[1];
	  out[14] = v[2];
	  out[15] = 1;
	  return out;
	}
	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     mat4.translate(dest, origin);
	 *     let quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *     mat4.translate(dest, negativeOrigin);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {ReadonlyVec3} v Translation vector
	 * @param {ReadonlyVec3} s Scaling vector
	 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
	 * @returns {mat4} out
	 */

	function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
	  // Quaternion math
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;
	  var xx = x * x2;
	  var xy = x * y2;
	  var xz = x * z2;
	  var yy = y * y2;
	  var yz = y * z2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;
	  var sx = s[0];
	  var sy = s[1];
	  var sz = s[2];
	  var ox = o[0];
	  var oy = o[1];
	  var oz = o[2];
	  var out0 = (1 - (yy + zz)) * sx;
	  var out1 = (xy + wz) * sx;
	  var out2 = (xz - wy) * sx;
	  var out4 = (xy - wz) * sy;
	  var out5 = (1 - (xx + zz)) * sy;
	  var out6 = (yz + wx) * sy;
	  var out8 = (xz + wy) * sz;
	  var out9 = (yz - wx) * sz;
	  var out10 = (1 - (xx + yy)) * sz;
	  out[0] = out0;
	  out[1] = out1;
	  out[2] = out2;
	  out[3] = 0;
	  out[4] = out4;
	  out[5] = out5;
	  out[6] = out6;
	  out[7] = 0;
	  out[8] = out8;
	  out[9] = out9;
	  out[10] = out10;
	  out[11] = 0;
	  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
	  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
	  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
	  out[15] = 1;
	  return out;
	}
	/**
	 * Calculates a 4x4 matrix from the given quaternion
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {ReadonlyQuat} q Quaternion to create matrix from
	 *
	 * @returns {mat4} out
	 */

	function fromQuat(out, q) {
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;
	  var xx = x * x2;
	  var yx = y * x2;
	  var yy = y * y2;
	  var zx = z * x2;
	  var zy = z * y2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;
	  out[0] = 1 - yy - zz;
	  out[1] = yx + wz;
	  out[2] = zx - wy;
	  out[3] = 0;
	  out[4] = yx - wz;
	  out[5] = 1 - xx - zz;
	  out[6] = zy + wx;
	  out[7] = 0;
	  out[8] = zx + wy;
	  out[9] = zy - wx;
	  out[10] = 1 - xx - yy;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */

	function frustum(out, left, right, bottom, top, near, far) {
	  var rl = 1 / (right - left);
	  var tb = 1 / (top - bottom);
	  var nf = 1 / (near - far);
	  out[0] = near * 2 * rl;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = near * 2 * tb;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = (right + left) * rl;
	  out[9] = (top + bottom) * tb;
	  out[10] = (far + near) * nf;
	  out[11] = -1;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = far * near * 2 * nf;
	  out[15] = 0;
	  return out;
	}
	/**
	 * Generates a perspective projection matrix with the given bounds.
	 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
	 * which matches WebGL/OpenGL's clip volume.
	 * Passing null/undefined/no value for far will generate infinite projection matrix.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum, can be null or Infinity
	 * @returns {mat4} out
	 */

	function perspectiveNO(out, fovy, aspect, near, far) {
	  var f = 1.0 / Math.tan(fovy / 2),
	      nf;
	  out[0] = f / aspect;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = f;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[11] = -1;
	  out[12] = 0;
	  out[13] = 0;
	  out[15] = 0;

	  if (far != null && far !== Infinity) {
	    nf = 1 / (near - far);
	    out[10] = (far + near) * nf;
	    out[14] = 2 * far * near * nf;
	  } else {
	    out[10] = -1;
	    out[14] = -2 * near;
	  }

	  return out;
	}
	/**
	 * Alias for {@link mat4.perspectiveNO}
	 * @function
	 */

	var perspective = perspectiveNO;
	/**
	 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
	 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
	 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
	 * Passing null/undefined/no value for far will generate infinite projection matrix.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum, can be null or Infinity
	 * @returns {mat4} out
	 */

	function perspectiveZO(out, fovy, aspect, near, far) {
	  var f = 1.0 / Math.tan(fovy / 2),
	      nf;
	  out[0] = f / aspect;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = f;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[11] = -1;
	  out[12] = 0;
	  out[13] = 0;
	  out[15] = 0;

	  if (far != null && far !== Infinity) {
	    nf = 1 / (near - far);
	    out[10] = far * nf;
	    out[14] = far * near * nf;
	  } else {
	    out[10] = -1;
	    out[14] = -near;
	  }

	  return out;
	}
	/**
	 * Generates a perspective projection matrix with the given field of view.
	 * This is primarily useful for generating projection matrices to be used
	 * with the still experiemental WebVR API.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */

	function perspectiveFromFieldOfView(out, fov, near, far) {
	  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
	  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
	  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
	  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
	  var xScale = 2.0 / (leftTan + rightTan);
	  var yScale = 2.0 / (upTan + downTan);
	  out[0] = xScale;
	  out[1] = 0.0;
	  out[2] = 0.0;
	  out[3] = 0.0;
	  out[4] = 0.0;
	  out[5] = yScale;
	  out[6] = 0.0;
	  out[7] = 0.0;
	  out[8] = -((leftTan - rightTan) * xScale * 0.5);
	  out[9] = (upTan - downTan) * yScale * 0.5;
	  out[10] = far / (near - far);
	  out[11] = -1.0;
	  out[12] = 0.0;
	  out[13] = 0.0;
	  out[14] = far * near / (near - far);
	  out[15] = 0.0;
	  return out;
	}
	/**
	 * Generates a orthogonal projection matrix with the given bounds.
	 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
	 * which matches WebGL/OpenGL's clip volume.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */

	function orthoNO(out, left, right, bottom, top, near, far) {
	  var lr = 1 / (left - right);
	  var bt = 1 / (bottom - top);
	  var nf = 1 / (near - far);
	  out[0] = -2 * lr;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = -2 * bt;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 2 * nf;
	  out[11] = 0;
	  out[12] = (left + right) * lr;
	  out[13] = (top + bottom) * bt;
	  out[14] = (far + near) * nf;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Alias for {@link mat4.orthoNO}
	 * @function
	 */

	var ortho = orthoNO;
	/**
	 * Generates a orthogonal projection matrix with the given bounds.
	 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
	 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */

	function orthoZO(out, left, right, bottom, top, near, far) {
	  var lr = 1 / (left - right);
	  var bt = 1 / (bottom - top);
	  var nf = 1 / (near - far);
	  out[0] = -2 * lr;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = -2 * bt;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = nf;
	  out[11] = 0;
	  out[12] = (left + right) * lr;
	  out[13] = (top + bottom) * bt;
	  out[14] = near * nf;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis.
	 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {ReadonlyVec3} eye Position of the viewer
	 * @param {ReadonlyVec3} center Point the viewer is looking at
	 * @param {ReadonlyVec3} up vec3 pointing up
	 * @returns {mat4} out
	 */

	function lookAt(out, eye, center, up) {
	  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
	  var eyex = eye[0];
	  var eyey = eye[1];
	  var eyez = eye[2];
	  var upx = up[0];
	  var upy = up[1];
	  var upz = up[2];
	  var centerx = center[0];
	  var centery = center[1];
	  var centerz = center[2];

	  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
	    return identity(out);
	  }

	  z0 = eyex - centerx;
	  z1 = eyey - centery;
	  z2 = eyez - centerz;
	  len = 1 / Math.hypot(z0, z1, z2);
	  z0 *= len;
	  z1 *= len;
	  z2 *= len;
	  x0 = upy * z2 - upz * z1;
	  x1 = upz * z0 - upx * z2;
	  x2 = upx * z1 - upy * z0;
	  len = Math.hypot(x0, x1, x2);

	  if (!len) {
	    x0 = 0;
	    x1 = 0;
	    x2 = 0;
	  } else {
	    len = 1 / len;
	    x0 *= len;
	    x1 *= len;
	    x2 *= len;
	  }

	  y0 = z1 * x2 - z2 * x1;
	  y1 = z2 * x0 - z0 * x2;
	  y2 = z0 * x1 - z1 * x0;
	  len = Math.hypot(y0, y1, y2);

	  if (!len) {
	    y0 = 0;
	    y1 = 0;
	    y2 = 0;
	  } else {
	    len = 1 / len;
	    y0 *= len;
	    y1 *= len;
	    y2 *= len;
	  }

	  out[0] = x0;
	  out[1] = y0;
	  out[2] = z0;
	  out[3] = 0;
	  out[4] = x1;
	  out[5] = y1;
	  out[6] = z1;
	  out[7] = 0;
	  out[8] = x2;
	  out[9] = y2;
	  out[10] = z2;
	  out[11] = 0;
	  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	  out[15] = 1;
	  return out;
	}
	/**
	 * Generates a matrix that makes something look at something else.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {ReadonlyVec3} eye Position of the viewer
	 * @param {ReadonlyVec3} center Point the viewer is looking at
	 * @param {ReadonlyVec3} up vec3 pointing up
	 * @returns {mat4} out
	 */

	function targetTo(out, eye, target, up) {
	  var eyex = eye[0],
	      eyey = eye[1],
	      eyez = eye[2],
	      upx = up[0],
	      upy = up[1],
	      upz = up[2];
	  var z0 = eyex - target[0],
	      z1 = eyey - target[1],
	      z2 = eyez - target[2];
	  var len = z0 * z0 + z1 * z1 + z2 * z2;

	  if (len > 0) {
	    len = 1 / Math.sqrt(len);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;
	  }

	  var x0 = upy * z2 - upz * z1,
	      x1 = upz * z0 - upx * z2,
	      x2 = upx * z1 - upy * z0;
	  len = x0 * x0 + x1 * x1 + x2 * x2;

	  if (len > 0) {
	    len = 1 / Math.sqrt(len);
	    x0 *= len;
	    x1 *= len;
	    x2 *= len;
	  }

	  out[0] = x0;
	  out[1] = x1;
	  out[2] = x2;
	  out[3] = 0;
	  out[4] = z1 * x2 - z2 * x1;
	  out[5] = z2 * x0 - z0 * x2;
	  out[6] = z0 * x1 - z1 * x0;
	  out[7] = 0;
	  out[8] = z0;
	  out[9] = z1;
	  out[10] = z2;
	  out[11] = 0;
	  out[12] = eyex;
	  out[13] = eyey;
	  out[14] = eyez;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {ReadonlyMat4} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */

	function str(a) {
	  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
	}
	/**
	 * Returns Frobenius norm of a mat4
	 *
	 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */

	function frob(a) {
	  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
	}
	/**
	 * Adds two mat4's
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the first operand
	 * @param {ReadonlyMat4} b the second operand
	 * @returns {mat4} out
	 */

	function add(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  out[3] = a[3] + b[3];
	  out[4] = a[4] + b[4];
	  out[5] = a[5] + b[5];
	  out[6] = a[6] + b[6];
	  out[7] = a[7] + b[7];
	  out[8] = a[8] + b[8];
	  out[9] = a[9] + b[9];
	  out[10] = a[10] + b[10];
	  out[11] = a[11] + b[11];
	  out[12] = a[12] + b[12];
	  out[13] = a[13] + b[13];
	  out[14] = a[14] + b[14];
	  out[15] = a[15] + b[15];
	  return out;
	}
	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the first operand
	 * @param {ReadonlyMat4} b the second operand
	 * @returns {mat4} out
	 */

	function subtract(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  out[3] = a[3] - b[3];
	  out[4] = a[4] - b[4];
	  out[5] = a[5] - b[5];
	  out[6] = a[6] - b[6];
	  out[7] = a[7] - b[7];
	  out[8] = a[8] - b[8];
	  out[9] = a[9] - b[9];
	  out[10] = a[10] - b[10];
	  out[11] = a[11] - b[11];
	  out[12] = a[12] - b[12];
	  out[13] = a[13] - b[13];
	  out[14] = a[14] - b[14];
	  out[15] = a[15] - b[15];
	  return out;
	}
	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {ReadonlyMat4} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat4} out
	 */

	function multiplyScalar(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  out[3] = a[3] * b;
	  out[4] = a[4] * b;
	  out[5] = a[5] * b;
	  out[6] = a[6] * b;
	  out[7] = a[7] * b;
	  out[8] = a[8] * b;
	  out[9] = a[9] * b;
	  out[10] = a[10] * b;
	  out[11] = a[11] * b;
	  out[12] = a[12] * b;
	  out[13] = a[13] * b;
	  out[14] = a[14] * b;
	  out[15] = a[15] * b;
	  return out;
	}
	/**
	 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat4} out the receiving vector
	 * @param {ReadonlyMat4} a the first operand
	 * @param {ReadonlyMat4} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat4} out
	 */

	function multiplyScalarAndAdd(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  out[2] = a[2] + b[2] * scale;
	  out[3] = a[3] + b[3] * scale;
	  out[4] = a[4] + b[4] * scale;
	  out[5] = a[5] + b[5] * scale;
	  out[6] = a[6] + b[6] * scale;
	  out[7] = a[7] + b[7] * scale;
	  out[8] = a[8] + b[8] * scale;
	  out[9] = a[9] + b[9] * scale;
	  out[10] = a[10] + b[10] * scale;
	  out[11] = a[11] + b[11] * scale;
	  out[12] = a[12] + b[12] * scale;
	  out[13] = a[13] + b[13] * scale;
	  out[14] = a[14] + b[14] * scale;
	  out[15] = a[15] + b[15] * scale;
	  return out;
	}
	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {ReadonlyMat4} a The first matrix.
	 * @param {ReadonlyMat4} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */

	function exactEquals(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
	}
	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {ReadonlyMat4} a The first matrix.
	 * @param {ReadonlyMat4} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */

	function equals(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var a4 = a[4],
	      a5 = a[5],
	      a6 = a[6],
	      a7 = a[7];
	  var a8 = a[8],
	      a9 = a[9],
	      a10 = a[10],
	      a11 = a[11];
	  var a12 = a[12],
	      a13 = a[13],
	      a14 = a[14],
	      a15 = a[15];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3];
	  var b4 = b[4],
	      b5 = b[5],
	      b6 = b[6],
	      b7 = b[7];
	  var b8 = b[8],
	      b9 = b[9],
	      b10 = b[10],
	      b11 = b[11];
	  var b12 = b[12],
	      b13 = b[13],
	      b14 = b[14],
	      b15 = b[15];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
	}
	/**
	 * Alias for {@link mat4.multiply}
	 * @function
	 */

	var mul = multiply;
	/**
	 * Alias for {@link mat4.subtract}
	 * @function
	 */

	var sub = subtract;

	var mat4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		clone: clone,
		copy: copy,
		fromValues: fromValues$1,
		set: set,
		identity: identity,
		transpose: transpose,
		invert: invert,
		adjoint: adjoint,
		determinant: determinant,
		multiply: multiply,
		translate: translate,
		scale: scale,
		rotate: rotate,
		rotateX: rotateX,
		rotateY: rotateY,
		rotateZ: rotateZ,
		fromTranslation: fromTranslation,
		fromScaling: fromScaling,
		fromRotation: fromRotation,
		fromXRotation: fromXRotation,
		fromYRotation: fromYRotation,
		fromZRotation: fromZRotation,
		fromRotationTranslation: fromRotationTranslation,
		fromQuat2: fromQuat2,
		getTranslation: getTranslation,
		getScaling: getScaling,
		getRotation: getRotation,
		fromRotationTranslationScale: fromRotationTranslationScale,
		fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
		fromQuat: fromQuat,
		frustum: frustum,
		perspectiveNO: perspectiveNO,
		perspective: perspective,
		perspectiveZO: perspectiveZO,
		perspectiveFromFieldOfView: perspectiveFromFieldOfView,
		orthoNO: orthoNO,
		ortho: ortho,
		orthoZO: orthoZO,
		lookAt: lookAt,
		targetTo: targetTo,
		str: str,
		frob: frob,
		add: add,
		subtract: subtract,
		multiplyScalar: multiplyScalar,
		multiplyScalarAndAdd: multiplyScalarAndAdd,
		exactEquals: exactEquals,
		equals: equals,
		mul: mul,
		sub: sub
	});

	/**
	 * 3 Dimensional Vector
	 * @module vec3
	 */

	/**
	 * Creates a new, empty vec3
	 *
	 * @returns {vec3} a new 3D vector
	 */

	function create$2() {
	  var out = new ARRAY_TYPE(3);

	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	  }

	  return out;
	}
	/**
	 * Creates a new vec3 initialized with values from an existing vector
	 *
	 * @param {ReadonlyVec3} a vector to clone
	 * @returns {vec3} a new 3D vector
	 */

	function clone$1(a) {
	  var out = new ARRAY_TYPE(3);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  return out;
	}
	/**
	 * Calculates the length of a vec3
	 *
	 * @param {ReadonlyVec3} a vector to calculate length of
	 * @returns {Number} length of a
	 */

	function length(a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  return Math.hypot(x, y, z);
	}
	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} a new 3D vector
	 */

	function fromValues$2(x, y, z) {
	  var out = new ARRAY_TYPE(3);
	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  return out;
	}
	/**
	 * Copy the values from one vec3 to another
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the source vector
	 * @returns {vec3} out
	 */

	function copy$1(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  return out;
	}
	/**
	 * Set the components of a vec3 to the given values
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} out
	 */

	function set$1(out, x, y, z) {
	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  return out;
	}
	/**
	 * Adds two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the first operand
	 * @param {ReadonlyVec3} b the second operand
	 * @returns {vec3} out
	 */

	function add$1(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  return out;
	}
	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the first operand
	 * @param {ReadonlyVec3} b the second operand
	 * @returns {vec3} out
	 */

	function subtract$1(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  return out;
	}
	/**
	 * Multiplies two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the first operand
	 * @param {ReadonlyVec3} b the second operand
	 * @returns {vec3} out
	 */

	function multiply$1(out, a, b) {
	  out[0] = a[0] * b[0];
	  out[1] = a[1] * b[1];
	  out[2] = a[2] * b[2];
	  return out;
	}
	/**
	 * Scales a vec3 by a scalar number
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec3} out
	 */

	function scale$1(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  return out;
	}
	/**
	 * Normalize a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a vector to normalize
	 * @returns {vec3} out
	 */

	function normalize(out, a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  var len = x * x + y * y + z * z;

	  if (len > 0) {
	    //TODO: evaluate use of glm_invsqrt here?
	    len = 1 / Math.sqrt(len);
	  }

	  out[0] = a[0] * len;
	  out[1] = a[1] * len;
	  out[2] = a[2] * len;
	  return out;
	}
	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {ReadonlyVec3} a the first operand
	 * @param {ReadonlyVec3} b the second operand
	 * @returns {Number} dot product of a and b
	 */

	function dot(a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}
	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the first operand
	 * @param {ReadonlyVec3} b the second operand
	 * @returns {vec3} out
	 */

	function cross(out, a, b) {
	  var ax = a[0],
	      ay = a[1],
	      az = a[2];
	  var bx = b[0],
	      by = b[1],
	      bz = b[2];
	  out[0] = ay * bz - az * by;
	  out[1] = az * bx - ax * bz;
	  out[2] = ax * by - ay * bx;
	  return out;
	}
	/**
	 * Performs a linear interpolation between two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the first operand
	 * @param {ReadonlyVec3} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {vec3} out
	 */

	function lerp(out, a, b, t) {
	  var ax = a[0];
	  var ay = a[1];
	  var az = a[2];
	  out[0] = ax + t * (b[0] - ax);
	  out[1] = ay + t * (b[1] - ay);
	  out[2] = az + t * (b[2] - az);
	  return out;
	}
	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the vector to transform
	 * @param {ReadonlyMat4} m matrix to transform with
	 * @returns {vec3} out
	 */

	function transformMat4(out, a, m) {
	  var x = a[0],
	      y = a[1],
	      z = a[2];
	  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
	  w = w || 1.0;
	  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
	  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
	  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
	  return out;
	}
	/**
	 * Transforms the vec3 with a mat3.
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the vector to transform
	 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
	 * @returns {vec3} out
	 */

	function transformMat3(out, a, m) {
	  var x = a[0],
	      y = a[1],
	      z = a[2];
	  out[0] = x * m[0] + y * m[3] + z * m[6];
	  out[1] = x * m[1] + y * m[4] + z * m[7];
	  out[2] = x * m[2] + y * m[5] + z * m[8];
	  return out;
	}
	/**
	 * Transforms the vec3 with a quat
	 * Can also be used for dual quaternions. (Multiply it with the real part)
	 *
	 * @param {vec3} out the receiving vector
	 * @param {ReadonlyVec3} a the vector to transform
	 * @param {ReadonlyQuat} q quaternion to transform with
	 * @returns {vec3} out
	 */

	function transformQuat(out, a, q) {
	  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
	  var qx = q[0],
	      qy = q[1],
	      qz = q[2],
	      qw = q[3];
	  var x = a[0],
	      y = a[1],
	      z = a[2]; // var qvec = [qx, qy, qz];
	  // var uv = vec3.cross([], qvec, a);

	  var uvx = qy * z - qz * y,
	      uvy = qz * x - qx * z,
	      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

	  var uuvx = qy * uvz - qz * uvy,
	      uuvy = qz * uvx - qx * uvz,
	      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

	  var w2 = qw * 2;
	  uvx *= w2;
	  uvy *= w2;
	  uvz *= w2; // vec3.scale(uuv, uuv, 2);

	  uuvx *= 2;
	  uuvy *= 2;
	  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

	  out[0] = x + uvx + uuvx;
	  out[1] = y + uvy + uuvy;
	  out[2] = z + uvz + uuvz;
	  return out;
	}
	/**
	 * Returns whether or not the vectors have approximately the same elements in the same position.
	 *
	 * @param {ReadonlyVec3} a The first vector.
	 * @param {ReadonlyVec3} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */

	function equals$1(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
	}
	/**
	 * Alias for {@link vec3.length}
	 * @function
	 */

	var len = length;
	/**
	 * Perform some operation over an array of vec3s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */

	var forEach = function () {
	  var vec = create$2();
	  return function (a, stride, offset, count, fn, arg) {
	    var i, l;

	    if (!stride) {
	      stride = 3;
	    }

	    if (!offset) {
	      offset = 0;
	    }

	    if (count) {
	      l = Math.min(count * stride + offset, a.length);
	    } else {
	      l = a.length;
	    }

	    for (i = offset; i < l; i += stride) {
	      vec[0] = a[i];
	      vec[1] = a[i + 1];
	      vec[2] = a[i + 2];
	      fn(vec, vec, arg);
	      a[i] = vec[0];
	      a[i + 1] = vec[1];
	      a[i + 2] = vec[2];
	    }

	    return a;
	  };
	}();

	/**
	 * 4 Dimensional Vector
	 * @module vec4
	 */

	/**
	 * Creates a new, empty vec4
	 *
	 * @returns {vec4} a new 4D vector
	 */

	function create$3() {
	  var out = new ARRAY_TYPE(4);

	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	  }

	  return out;
	}
	/**
	 * Creates a new vec4 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} a new 4D vector
	 */

	function fromValues$3(x, y, z, w) {
	  var out = new ARRAY_TYPE(4);
	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  out[3] = w;
	  return out;
	}
	/**
	 * Copy the values from one vec4 to another
	 *
	 * @param {vec4} out the receiving vector
	 * @param {ReadonlyVec4} a the source vector
	 * @returns {vec4} out
	 */

	function copy$2(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}
	/**
	 * Normalize a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {ReadonlyVec4} a vector to normalize
	 * @returns {vec4} out
	 */

	function normalize$1(out, a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  var w = a[3];
	  var len = x * x + y * y + z * z + w * w;

	  if (len > 0) {
	    len = 1 / Math.sqrt(len);
	  }

	  out[0] = x * len;
	  out[1] = y * len;
	  out[2] = z * len;
	  out[3] = w * len;
	  return out;
	}
	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {vec4} out the receiving vector
	 * @param {ReadonlyVec4} a the vector to transform
	 * @param {ReadonlyMat4} m matrix to transform with
	 * @returns {vec4} out
	 */

	function transformMat4$1(out, a, m) {
	  var x = a[0],
	      y = a[1],
	      z = a[2],
	      w = a[3];
	  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	  return out;
	}
	/**
	 * Perform some operation over an array of vec4s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */

	var forEach$1 = function () {
	  var vec = create$3();
	  return function (a, stride, offset, count, fn, arg) {
	    var i, l;

	    if (!stride) {
	      stride = 4;
	    }

	    if (!offset) {
	      offset = 0;
	    }

	    if (count) {
	      l = Math.min(count * stride + offset, a.length);
	    } else {
	      l = a.length;
	    }

	    for (i = offset; i < l; i += stride) {
	      vec[0] = a[i];
	      vec[1] = a[i + 1];
	      vec[2] = a[i + 2];
	      vec[3] = a[i + 3];
	      fn(vec, vec, arg);
	      a[i] = vec[0];
	      a[i + 1] = vec[1];
	      a[i + 2] = vec[2];
	      a[i + 3] = vec[3];
	    }

	    return a;
	  };
	}();

	/**
	 * Quaternion
	 * @module quat
	 */

	/**
	 * Creates a new identity quat
	 *
	 * @returns {quat} a new quaternion
	 */

	function create$4() {
	  var out = new ARRAY_TYPE(4);

	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	  }

	  out[3] = 1;
	  return out;
	}
	/**
	 * Sets a quat from the given angle and rotation axis,
	 * then returns it.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyVec3} axis the axis around which to rotate
	 * @param {Number} rad the angle in radians
	 * @returns {quat} out
	 **/

	function setAxisAngle(out, axis, rad) {
	  rad = rad * 0.5;
	  var s = Math.sin(rad);
	  out[0] = s * axis[0];
	  out[1] = s * axis[1];
	  out[2] = s * axis[2];
	  out[3] = Math.cos(rad);
	  return out;
	}
	/**
	 * Multiplies two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyQuat} a the first operand
	 * @param {ReadonlyQuat} b the second operand
	 * @returns {quat} out
	 */

	function multiply$2(out, a, b) {
	  var ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];
	  var bx = b[0],
	      by = b[1],
	      bz = b[2],
	      bw = b[3];
	  out[0] = ax * bw + aw * bx + ay * bz - az * by;
	  out[1] = ay * bw + aw * by + az * bx - ax * bz;
	  out[2] = az * bw + aw * bz + ax * by - ay * bx;
	  out[3] = aw * bw - ax * bx - ay * by - az * bz;
	  return out;
	}
	/**
	 * Performs a spherical linear interpolation between two quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyQuat} a the first operand
	 * @param {ReadonlyQuat} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {quat} out
	 */

	function slerp(out, a, b, t) {
	  // benchmarks:
	  //    http://jsperf.com/quaternion-slerp-implementations
	  var ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];
	  var bx = b[0],
	      by = b[1],
	      bz = b[2],
	      bw = b[3];
	  var omega, cosom, sinom, scale0, scale1; // calc cosine

	  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

	  if (cosom < 0.0) {
	    cosom = -cosom;
	    bx = -bx;
	    by = -by;
	    bz = -bz;
	    bw = -bw;
	  } // calculate coefficients


	  if (1.0 - cosom > EPSILON) {
	    // standard case (slerp)
	    omega = Math.acos(cosom);
	    sinom = Math.sin(omega);
	    scale0 = Math.sin((1.0 - t) * omega) / sinom;
	    scale1 = Math.sin(t * omega) / sinom;
	  } else {
	    // "from" and "to" quaternions are very close
	    //  ... so we can do a linear interpolation
	    scale0 = 1.0 - t;
	    scale1 = t;
	  } // calculate final values


	  out[0] = scale0 * ax + scale1 * bx;
	  out[1] = scale0 * ay + scale1 * by;
	  out[2] = scale0 * az + scale1 * bz;
	  out[3] = scale0 * aw + scale1 * bw;
	  return out;
	}
	/**
	 * Calculates the inverse of a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyQuat} a quat to calculate inverse of
	 * @returns {quat} out
	 */

	function invert$1(out, a) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
	  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

	  out[0] = -a0 * invDot;
	  out[1] = -a1 * invDot;
	  out[2] = -a2 * invDot;
	  out[3] = a3 * invDot;
	  return out;
	}
	/**
	 * Creates a quaternion from the given 3x3 rotation matrix.
	 *
	 * NOTE: The resultant quaternion is not normalized, so you should be sure
	 * to renormalize the quaternion yourself where necessary.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyMat3} m rotation matrix
	 * @returns {quat} out
	 * @function
	 */

	function fromMat3(out, m) {
	  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
	  // article "Quaternion Calculus and Fast Animation".
	  var fTrace = m[0] + m[4] + m[8];
	  var fRoot;

	  if (fTrace > 0.0) {
	    // |w| > 1/2, may as well choose w > 1/2
	    fRoot = Math.sqrt(fTrace + 1.0); // 2w

	    out[3] = 0.5 * fRoot;
	    fRoot = 0.5 / fRoot; // 1/(4w)

	    out[0] = (m[5] - m[7]) * fRoot;
	    out[1] = (m[6] - m[2]) * fRoot;
	    out[2] = (m[1] - m[3]) * fRoot;
	  } else {
	    // |w| <= 1/2
	    var i = 0;
	    if (m[4] > m[0]) i = 1;
	    if (m[8] > m[i * 3 + i]) i = 2;
	    var j = (i + 1) % 3;
	    var k = (i + 2) % 3;
	    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
	    out[i] = 0.5 * fRoot;
	    fRoot = 0.5 / fRoot;
	    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
	    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
	    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
	  }

	  return out;
	}
	/**
	 * Creates a quaternion from the given euler angle x, y, z.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {x} Angle to rotate around X axis in degrees.
	 * @param {y} Angle to rotate around Y axis in degrees.
	 * @param {z} Angle to rotate around Z axis in degrees.
	 * @returns {quat} out
	 * @function
	 */

	function fromEuler(out, x, y, z) {
	  var halfToRad = 0.5 * Math.PI / 180.0;
	  x *= halfToRad;
	  y *= halfToRad;
	  z *= halfToRad;
	  var sx = Math.sin(x);
	  var cx = Math.cos(x);
	  var sy = Math.sin(y);
	  var cy = Math.cos(y);
	  var sz = Math.sin(z);
	  var cz = Math.cos(z);
	  out[0] = sx * cy * cz - cx * sy * sz;
	  out[1] = cx * sy * cz + sx * cy * sz;
	  out[2] = cx * cy * sz - sx * sy * cz;
	  out[3] = cx * cy * cz + sx * sy * sz;
	  return out;
	}
	/**
	 * Creates a new quat initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} a new quaternion
	 * @function
	 */

	var fromValues$4 = fromValues$3;
	/**
	 * Copy the values from one quat to another
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyQuat} a the source quaternion
	 * @returns {quat} out
	 * @function
	 */

	var copy$3 = copy$2;
	/**
	 * Alias for {@link quat.multiply}
	 * @function
	 */

	var mul$1 = multiply$2;
	/**
	 * Normalize a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyQuat} a quaternion to normalize
	 * @returns {quat} out
	 * @function
	 */

	var normalize$2 = normalize$1;
	/**
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {quat} out the receiving quaternion.
	 * @param {ReadonlyVec3} a the initial vector
	 * @param {ReadonlyVec3} b the destination vector
	 * @returns {quat} out
	 */

	var rotationTo = function () {
	  var tmpvec3 = create$2();
	  var xUnitVec3 = fromValues$2(1, 0, 0);
	  var yUnitVec3 = fromValues$2(0, 1, 0);
	  return function (out, a, b) {
	    var dot$1 = dot(a, b);

	    if (dot$1 < -0.999999) {
	      cross(tmpvec3, xUnitVec3, a);
	      if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
	      normalize(tmpvec3, tmpvec3);
	      setAxisAngle(out, tmpvec3, Math.PI);
	      return out;
	    } else if (dot$1 > 0.999999) {
	      out[0] = 0;
	      out[1] = 0;
	      out[2] = 0;
	      out[3] = 1;
	      return out;
	    } else {
	      cross(tmpvec3, a, b);
	      out[0] = tmpvec3[0];
	      out[1] = tmpvec3[1];
	      out[2] = tmpvec3[2];
	      out[3] = 1 + dot$1;
	      return normalize$2(out, out);
	    }
	  };
	}();
	/**
	 * Performs a spherical linear interpolation with two control points
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {ReadonlyQuat} a the first operand
	 * @param {ReadonlyQuat} b the second operand
	 * @param {ReadonlyQuat} c the third operand
	 * @param {ReadonlyQuat} d the fourth operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {quat} out
	 */

	var sqlerp = function () {
	  var temp1 = create$4();
	  var temp2 = create$4();
	  return function (out, a, b, c, d, t) {
	    slerp(temp1, a, d, t);
	    slerp(temp2, b, c, t);
	    slerp(out, temp1, temp2, 2 * t * (1 - t));
	    return out;
	  };
	}();
	/**
	 * Sets the specified quaternion with values corresponding to the given
	 * axes. Each axis is a vec3 and is expected to be unit length and
	 * perpendicular to all other specified axes.
	 *
	 * @param {ReadonlyVec3} view  the vector representing the viewing direction
	 * @param {ReadonlyVec3} right the vector representing the local "right" direction
	 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
	 * @returns {quat} out
	 */

	var setAxes = function () {
	  var matr = create();
	  return function (out, view, right, up) {
	    matr[0] = right[0];
	    matr[3] = right[1];
	    matr[6] = right[2];
	    matr[1] = up[0];
	    matr[4] = up[1];
	    matr[7] = up[2];
	    matr[2] = -view[0];
	    matr[5] = -view[1];
	    matr[8] = -view[2];
	    return normalize$2(out, fromMat3(out, matr));
	  };
	}();

	/**
	 * 2 Dimensional Vector
	 * @module vec2
	 */

	/**
	 * Creates a new, empty vec2
	 *
	 * @returns {vec2} a new 2D vector
	 */

	function create$5() {
	  var out = new ARRAY_TYPE(2);

	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	  }

	  return out;
	}
	/**
	 * Creates a new vec2 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} a new 2D vector
	 */

	function fromValues$5(x, y) {
	  var out = new ARRAY_TYPE(2);
	  out[0] = x;
	  out[1] = y;
	  return out;
	}
	/**
	 * Copy the values from one vec2 to another
	 *
	 * @param {vec2} out the receiving vector
	 * @param {ReadonlyVec2} a the source vector
	 * @returns {vec2} out
	 */

	function copy$4(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  return out;
	}
	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {ReadonlyVec2} a the first operand
	 * @param {ReadonlyVec2} b the second operand
	 * @returns {vec2} out
	 */

	function add$2(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  return out;
	}
	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {ReadonlyVec2} a the first operand
	 * @param {ReadonlyVec2} b the second operand
	 * @returns {vec2} out
	 */

	function subtract$2(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  return out;
	}
	/**
	 * Returns the minimum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {ReadonlyVec2} a the first operand
	 * @param {ReadonlyVec2} b the second operand
	 * @returns {vec2} out
	 */

	function min(out, a, b) {
	  out[0] = Math.min(a[0], b[0]);
	  out[1] = Math.min(a[1], b[1]);
	  return out;
	}
	/**
	 * Returns the maximum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {ReadonlyVec2} a the first operand
	 * @param {ReadonlyVec2} b the second operand
	 * @returns {vec2} out
	 */

	function max(out, a, b) {
	  out[0] = Math.max(a[0], b[0]);
	  out[1] = Math.max(a[1], b[1]);
	  return out;
	}
	/**
	 * Scales a vec2 by a scalar number
	 *
	 * @param {vec2} out the receiving vector
	 * @param {ReadonlyVec2} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec2} out
	 */

	function scale$2(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  return out;
	}
	/**
	 * Calculates the euclidian distance between two vec2's
	 *
	 * @param {ReadonlyVec2} a the first operand
	 * @param {ReadonlyVec2} b the second operand
	 * @returns {Number} distance between a and b
	 */

	function distance(a, b) {
	  var x = b[0] - a[0],
	      y = b[1] - a[1];
	  return Math.hypot(x, y);
	}
	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {ReadonlyVec2} a vector to normalize
	 * @returns {vec2} out
	 */

	function normalize$3(out, a) {
	  var x = a[0],
	      y = a[1];
	  var len = x * x + y * y;

	  if (len > 0) {
	    //TODO: evaluate use of glm_invsqrt here?
	    len = 1 / Math.sqrt(len);
	  }

	  out[0] = a[0] * len;
	  out[1] = a[1] * len;
	  return out;
	}
	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {ReadonlyVec2} a the first operand
	 * @param {ReadonlyVec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */

	function dot$1(a, b) {
	  return a[0] * b[0] + a[1] * b[1];
	}
	/**
	 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
	 *
	 * @param {ReadonlyVec2} a The first vector.
	 * @param {ReadonlyVec2} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */

	function exactEquals$1(a, b) {
	  return a[0] === b[0] && a[1] === b[1];
	}
	/**
	 * Alias for {@link vec2.subtract}
	 * @function
	 */

	var sub$1 = subtract$2;
	/**
	 * Perform some operation over an array of vec2s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */

	var forEach$2 = function () {
	  var vec = create$5();
	  return function (a, stride, offset, count, fn, arg) {
	    var i, l;

	    if (!stride) {
	      stride = 2;
	    }

	    if (!offset) {
	      offset = 0;
	    }

	    if (count) {
	      l = Math.min(count * stride + offset, a.length);
	    } else {
	      l = a.length;
	    }

	    for (i = offset; i < l; i += stride) {
	      vec[0] = a[i];
	      vec[1] = a[i + 1];
	      fn(vec, vec, arg);
	      a[i] = vec[0];
	      a[i + 1] = vec[1];
	    }

	    return a;
	  };
	}();

	function clonePath(path) {
	    return path.map(function (x) { return (Array.isArray(x) ? [].concat(x) : x); });
	}

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise, SuppressedError, Symbol */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    if (typeof b !== "function" && b !== null)
	        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	}

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spreadArray(to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	}

	var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	var paramsParser = {
	    x1: 0,
	    y1: 0,
	    x2: 0,
	    y2: 0,
	    x: 0,
	    y: 0,
	    qx: null,
	    qy: null,
	};

	function fixArc(pathArray, allPathCommands, i) {
	    if (pathArray[i].length > 7) {
	        pathArray[i].shift();
	        var pi = pathArray[i];
	        // const ni = i + 1;
	        var ni = i;
	        while (pi.length) {
	            // if created multiple C:s, their original seg is saved
	            allPathCommands[i] = 'A';
	            // @ts-ignore
	            pathArray.splice((ni += 1), 0, ['C'].concat(pi.splice(0, 6)));
	        }
	        pathArray.splice(i, 1);
	    }
	}

	var paramsCount = {
	    a: 7,
	    c: 6,
	    h: 1,
	    l: 2,
	    m: 2,
	    r: 4,
	    q: 4,
	    s: 4,
	    t: 2,
	    v: 1,
	    z: 0,
	};

	/**
	 * Iterates an array to check if it's an actual `PathArray`.
	 */
	function isPathArray(path) {
	    return (Array.isArray(path) &&
	        path.every(function (seg) {
	            var lk = seg[0].toLowerCase();
	            return paramsCount[lk] === seg.length - 1 && 'achlmqstvz'.includes(lk);
	        }));
	}

	/**
	 * Iterates an array to check if it's a `PathArray`
	 * with all absolute values.
	 */
	function isAbsoluteArray(path) {
	    return (isPathArray(path) &&
	        // @ts-ignore -- `isPathArray` also checks if it's `Array`
	        path.every(function (_a) {
	            var x = _a[0];
	            return x === x.toUpperCase();
	        }));
	}

	/**
	 * Iterates an array to check if it's a `PathArray`
	 * with all segments are in non-shorthand notation
	 * with absolute values.
	 */
	function isNormalizedArray(path) {
	    return isAbsoluteArray(path) && path.every(function (_a) {
	        var pc = _a[0];
	        return 'ACLMQZ'.includes(pc);
	    });
	}

	/**
	 * Breaks the parsing of a pathString once a segment is finalized.
	 */
	function finalizeSegment(path) {
	    var pathCommand = path.pathValue[path.segmentStart];
	    var LK = pathCommand.toLowerCase();
	    var data = path.data;
	    while (data.length >= paramsCount[LK]) {
	        // overloaded `moveTo`
	        // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts
	        if (LK === 'm' && data.length > 2) {
	            // @ts-ignore
	            path.segments.push([pathCommand].concat(data.splice(0, 2)));
	            LK = 'l';
	            pathCommand = pathCommand === 'm' ? 'l' : 'L';
	        }
	        else {
	            // @ts-ignore
	            path.segments.push([pathCommand].concat(data.splice(0, paramsCount[LK])));
	        }
	        if (!paramsCount[LK]) {
	            break;
	        }
	    }
	}

	/**
	 * Validates an A (arc-to) specific path command value.
	 * Usually a `large-arc-flag` or `sweep-flag`.
	 */
	function scanFlag(path) {
	    var index = path.index, pathValue = path.pathValue;
	    var code = pathValue.charCodeAt(index);
	    if (code === 0x30 /* 0 */) {
	        path.param = 0;
	        path.index += 1;
	        return;
	    }
	    if (code === 0x31 /* 1 */) {
	        path.param = 1;
	        path.index += 1;
	        return;
	    }
	    path.err = "[path-util]: invalid Arc flag \"" + pathValue[index] + "\", expecting 0 or 1 at index " + index;
	}

	/**
	 * Checks if the character is or belongs to a number.
	 * [0-9]|+|-|.
	 */
	function isDigitStart(code) {
	    return ((code >= 48 && code <= 57) /* 0..9 */ || code === 0x2b /* + */ || code === 0x2d /* - */ || code === 0x2e); /* . */
	}
	function isDigit(code) {
	    return code >= 48 && code <= 57; // 0..9
	}

	/**
	 * Validates every character of the path string,
	 * every path command, negative numbers or floating point numbers.
	 */
	function scanParam(path) {
	    var max = path.max, pathValue = path.pathValue, start = path.index;
	    var index = start;
	    var zeroFirst = false;
	    var hasCeiling = false;
	    var hasDecimal = false;
	    var hasDot = false;
	    var ch;
	    if (index >= max) {
	        // path.err = 'SvgPath: missed param (at pos ' + index + ')';
	        path.err = "[path-util]: Invalid path value at index " + index + ", \"pathValue\" is missing param";
	        return;
	    }
	    ch = pathValue.charCodeAt(index);
	    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
	        index += 1;
	        // ch = (index < max) ? pathValue.charCodeAt(index) : 0;
	        ch = pathValue.charCodeAt(index);
	    }
	    // This logic is shamelessly borrowed from Esprima
	    // https://github.com/ariya/esprimas
	    if (!isDigit(ch) && ch !== 0x2e /* . */) {
	        // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';
	        path.err = "[path-util]: Invalid path value at index " + index + ", \"" + pathValue[index] + "\" is not a number";
	        return;
	    }
	    if (ch !== 0x2e /* . */) {
	        zeroFirst = ch === 0x30 /* 0 */;
	        index += 1;
	        ch = pathValue.charCodeAt(index);
	        if (zeroFirst && index < max) {
	            // decimal number starts with '0' such as '09' is illegal.
	            if (ch && isDigit(ch)) {
	                // path.err = 'SvgPath: numbers started with `0` such as `09`
	                // are illegal (at pos ' + start + ')';
	                path.err = "[path-util]: Invalid path value at index " + start + ", \"" + pathValue[start] + "\" illegal number";
	                return;
	            }
	        }
	        while (index < max && isDigit(pathValue.charCodeAt(index))) {
	            index += 1;
	            hasCeiling = true;
	        }
	        ch = pathValue.charCodeAt(index);
	    }
	    if (ch === 0x2e /* . */) {
	        hasDot = true;
	        index += 1;
	        while (isDigit(pathValue.charCodeAt(index))) {
	            index += 1;
	            hasDecimal = true;
	        }
	        ch = pathValue.charCodeAt(index);
	    }
	    if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {
	        if (hasDot && !hasCeiling && !hasDecimal) {
	            path.err = "[path-util]: Invalid path value at index " + index + ", \"" + pathValue[index] + "\" invalid float exponent";
	            return;
	        }
	        index += 1;
	        ch = pathValue.charCodeAt(index);
	        if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
	            index += 1;
	        }
	        if (index < max && isDigit(pathValue.charCodeAt(index))) {
	            while (index < max && isDigit(pathValue.charCodeAt(index))) {
	                index += 1;
	            }
	        }
	        else {
	            path.err = "[path-util]: Invalid path value at index " + index + ", \"" + pathValue[index] + "\" invalid integer exponent";
	            return;
	        }
	    }
	    path.index = index;
	    path.param = +path.pathValue.slice(start, index);
	}

	/**
	 * Checks if the character is a space.
	 */
	function isSpace(ch) {
	    var specialSpaces = [
	        0x1680, 0x180e, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202f,
	        0x205f, 0x3000, 0xfeff,
	    ];
	    /* istanbul ignore next */
	    return (ch === 0x0a ||
	        ch === 0x0d ||
	        ch === 0x2028 ||
	        ch === 0x2029 || // Line terminators
	        // White spaces
	        ch === 0x20 ||
	        ch === 0x09 ||
	        ch === 0x0b ||
	        ch === 0x0c ||
	        ch === 0xa0 ||
	        (ch >= 0x1680 && specialSpaces.includes(ch)));
	}

	/**
	 * Points the parser to the next character in the
	 * path string every time it encounters any kind of
	 * space character.
	 */
	function skipSpaces(path) {
	    var pathValue = path.pathValue, max = path.max;
	    while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {
	        path.index += 1;
	    }
	}

	/**
	 * Checks if the character is a path command.
	 */
	function isPathCommand(code) {
	    // eslint-disable-next-line no-bitwise -- Impossible to satisfy
	    switch (code | 0x20) {
	        case 0x6d /* m */:
	        case 0x7a /* z */:
	        case 0x6c /* l */:
	        case 0x68 /* h */:
	        case 0x76 /* v */:
	        case 0x63 /* c */:
	        case 0x73 /* s */:
	        case 0x71 /* q */:
	        case 0x74 /* t */:
	        case 0x61 /* a */:
	            // case 0x72/* r */:
	            return true;
	        default:
	            return false;
	    }
	}

	/**
	 * Checks if the character is an A (arc-to) path command.
	 */
	function isArcCommand(code) {
	    return (code | 0x20) === 0x61;
	}

	/**
	 * Scans every character in the path string to determine
	 * where a segment starts and where it ends.
	 */
	function scanSegment(path) {
	    var max = path.max, pathValue = path.pathValue, index = path.index;
	    var cmdCode = pathValue.charCodeAt(index);
	    var reqParams = paramsCount[pathValue[index].toLowerCase()];
	    path.segmentStart = index;
	    if (!isPathCommand(cmdCode)) {
	        path.err = "[path-util]: Invalid path value \"" + pathValue[index] + "\" is not a path command";
	        return;
	    }
	    path.index += 1;
	    skipSpaces(path);
	    path.data = [];
	    if (!reqParams) {
	        // Z
	        finalizeSegment(path);
	        return;
	    }
	    for (;;) {
	        for (var i = reqParams; i > 0; i -= 1) {
	            if (isArcCommand(cmdCode) && (i === 3 || i === 4))
	                scanFlag(path);
	            else
	                scanParam(path);
	            if (path.err.length) {
	                return;
	            }
	            path.data.push(path.param);
	            skipSpaces(path);
	            // after ',' param is mandatory
	            if (path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */) {
	                path.index += 1;
	                skipSpaces(path);
	            }
	        }
	        if (path.index >= path.max) {
	            break;
	        }
	        // Stop on next segment
	        if (!isDigitStart(pathValue.charCodeAt(path.index))) {
	            break;
	        }
	    }
	    finalizeSegment(path);
	}

	/**
	 * The `PathParser` is used by the `parsePathString` static method
	 * to generate a `pathArray`.
	 */
	var PathParser = /** @class */ (function () {
	    function PathParser(pathString) {
	        this.pathValue = pathString;
	        // @ts-ignore
	        this.segments = [];
	        this.max = pathString.length;
	        this.index = 0;
	        this.param = 0.0;
	        this.segmentStart = 0;
	        this.data = [];
	        this.err = '';
	    }
	    return PathParser;
	}());

	/**
	 * Parses a path string value and returns an array
	 * of segments we like to call `pathArray`.
	 */
	function parsePathString(pathInput) {
	    if (isPathArray(pathInput)) {
	        return clonePath(pathInput);
	    }
	    var path = new PathParser(pathInput);
	    skipSpaces(path);
	    while (path.index < path.max && !path.err.length) {
	        scanSegment(path);
	    }
	    return path.err ? path.err : path.segments;
	}

	function path2Absolute(pathInput) {
	    if (isAbsoluteArray(pathInput)) {
	        return clonePath(pathInput);
	    }
	    var path = parsePathString(pathInput);
	    // if (!path || !path.length) {
	    //   return [['M', 0, 0]];
	    // }
	    var x = 0;
	    var y = 0;
	    var mx = 0;
	    var my = 0;
	    // @ts-ignore
	    return path.map(function (segment) {
	        var values = segment.slice(1).map(Number);
	        var pathCommand = segment[0];
	        var absCommand = pathCommand.toUpperCase();
	        if (pathCommand === 'M') {
	            x = values[0], y = values[1];
	            mx = x;
	            my = y;
	            return ['M', x, y];
	        }
	        var absoluteSegment;
	        if (pathCommand !== absCommand) {
	            switch (absCommand) {
	                case 'A':
	                    absoluteSegment = [
	                        absCommand,
	                        values[0],
	                        values[1],
	                        values[2],
	                        values[3],
	                        values[4],
	                        values[5] + x,
	                        values[6] + y,
	                    ];
	                    break;
	                case 'V':
	                    absoluteSegment = [absCommand, values[0] + y];
	                    break;
	                case 'H':
	                    absoluteSegment = [absCommand, values[0] + x];
	                    break;
	                default: {
	                    // use brakets for `eslint: no-case-declaration`
	                    // https://stackoverflow.com/a/50753272/803358
	                    var absValues = values.map(function (n, j) { return n + (j % 2 ? y : x); });
	                    // for n, l, c, s, q, t
	                    // @ts-ignore
	                    absoluteSegment = [absCommand].concat(absValues);
	                }
	            }
	        }
	        else {
	            // @ts-ignore
	            absoluteSegment = [absCommand].concat(values);
	        }
	        var segLength = absoluteSegment.length;
	        switch (absCommand) {
	            case 'Z':
	                x = mx;
	                y = my;
	                break;
	            case 'H':
	                x = absoluteSegment[1];
	                break;
	            case 'V':
	                y = absoluteSegment[1];
	                break;
	            default:
	                x = absoluteSegment[segLength - 2];
	                y = absoluteSegment[segLength - 1];
	                if (absCommand === 'M') {
	                    mx = x;
	                    my = y;
	                }
	        }
	        return absoluteSegment;
	    });
	}

	/**
	 * Normalizes a single segment of a `PathArray` object.
	 * eg. H/V -> L, T -> Q
	 */
	function normalizeSegment(segment, params) {
	    var pathCommand = segment[0];
	    var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
	    var values = segment.slice(1).map(Number);
	    var result = segment;
	    if (!'TQ'.includes(pathCommand)) {
	        // optional but good to be cautious
	        params.qx = null;
	        params.qy = null;
	    }
	    if (pathCommand === 'H') {
	        result = ['L', segment[1], py1];
	    }
	    else if (pathCommand === 'V') {
	        result = ['L', px1, segment[1]];
	    }
	    else if (pathCommand === 'S') {
	        var x1 = px1 * 2 - px2;
	        var y1 = py1 * 2 - py2;
	        params.x1 = x1;
	        params.y1 = y1;
	        result = ['C', x1, y1].concat(values);
	    }
	    else if (pathCommand === 'T') {
	        var qx = px1 * 2 - params.qx;
	        var qy = py1 * 2 - params.qy;
	        params.qx = qx;
	        params.qy = qy;
	        result = ['Q', qx, qy].concat(values);
	    }
	    else if (pathCommand === 'Q') {
	        var nqx = values[0], nqy = values[1];
	        params.qx = nqx;
	        params.qy = nqy;
	    }
	    return result;
	}

	/**
	 * @example
	 * const path = 'M0 0 H50';
	 * const normalizedPath = SVGPathCommander.normalizePath(path);
	 * // result => [['M', 0, 0], ['L', 50, 0]]
	 */
	function normalizePath(pathInput) {
	    if (isNormalizedArray(pathInput)) {
	        return clonePath(pathInput);
	    }
	    var path = path2Absolute(pathInput);
	    var params = __assign({}, paramsParser);
	    for (var i = 0; i < path.length; i += 1) {
	        // Save current path command
	        path[i] = normalizeSegment(path[i], params);
	        var segment = path[i];
	        var seglen = segment.length;
	        params.x1 = +segment[seglen - 2];
	        params.y1 = +segment[seglen - 1];
	        params.x2 = +segment[seglen - 4] || params.x1;
	        params.y2 = +segment[seglen - 3] || params.y1;
	    }
	    return path;
	}

	/**
	 * Iterates an array to check if it's a `PathArray`
	 * with all C (cubic bezier) segments.
	 *
	 * @param {string | PathArray} path the `Array` to be checked
	 * @returns {boolean} iteration result
	 */
	function isCurveArray(path) {
	    return isNormalizedArray(path) && path.every(function (_a) {
	        var pc = _a[0];
	        return 'MC'.includes(pc);
	    });
	}

	function rotateVector(x, y, rad) {
	    var X = x * Math.cos(rad) - y * Math.sin(rad);
	    var Y = x * Math.sin(rad) + y * Math.cos(rad);
	    return { x: X, y: Y };
	}

	/**
	 * Converts A (arc-to) segments to C (cubic-bezier-to).
	 *
	 * For more information of where this math came from visit:
	 * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	 */
	function arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {
	    var x1 = X1;
	    var y1 = Y1;
	    var rx = RX;
	    var ry = RY;
	    var x2 = X2;
	    var y2 = Y2;
	    // for more information of where this Math came from visit:
	    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	    var d120 = (Math.PI * 120) / 180;
	    var rad = (Math.PI / 180) * (+angle || 0);
	    /** @type {number[]} */
	    var res = [];
	    var xy;
	    var f1;
	    var f2;
	    var cx;
	    var cy;
	    if (!recursive) {
	        xy = rotateVector(x1, y1, -rad);
	        x1 = xy.x;
	        y1 = xy.y;
	        xy = rotateVector(x2, y2, -rad);
	        x2 = xy.x;
	        y2 = xy.y;
	        var x = (x1 - x2) / 2;
	        var y = (y1 - y2) / 2;
	        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
	        if (h > 1) {
	            h = Math.sqrt(h);
	            rx *= h;
	            ry *= h;
	        }
	        var rx2 = rx * rx;
	        var ry2 = ry * ry;
	        var k = (LAF === SF ? -1 : 1) *
	            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
	        cx = (k * rx * y) / ry + (x1 + x2) / 2;
	        cy = (k * -ry * x) / rx + (y1 + y2) / 2;
	        // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise
	        f1 = Math.asin(((((y1 - cy) / ry) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9));
	        // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise
	        f2 = Math.asin(((((y2 - cy) / ry) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9));
	        f1 = x1 < cx ? Math.PI - f1 : f1;
	        f2 = x2 < cx ? Math.PI - f2 : f2;
	        if (f1 < 0)
	            f1 = Math.PI * 2 + f1;
	        if (f2 < 0)
	            f2 = Math.PI * 2 + f2;
	        if (SF && f1 > f2) {
	            f1 -= Math.PI * 2;
	        }
	        if (!SF && f2 > f1) {
	            f2 -= Math.PI * 2;
	        }
	    }
	    else {
	        f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
	    }
	    var df = f2 - f1;
	    if (Math.abs(df) > d120) {
	        var f2old = f2;
	        var x2old = x2;
	        var y2old = y2;
	        f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
	        x2 = cx + rx * Math.cos(f2);
	        y2 = cy + ry * Math.sin(f2);
	        res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
	    }
	    df = f2 - f1;
	    var c1 = Math.cos(f1);
	    var s1 = Math.sin(f1);
	    var c2 = Math.cos(f2);
	    var s2 = Math.sin(f2);
	    var t = Math.tan(df / 4);
	    var hx = (4 / 3) * rx * t;
	    var hy = (4 / 3) * ry * t;
	    var m1 = [x1, y1];
	    var m2 = [x1 + hx * s1, y1 - hy * c1];
	    var m3 = [x2 + hx * s2, y2 - hy * c2];
	    var m4 = [x2, y2];
	    m2[0] = 2 * m1[0] - m2[0];
	    m2[1] = 2 * m1[1] - m2[1];
	    if (recursive) {
	        return m2.concat(m3, m4, res);
	        // return [...m2, ...m3, ...m4, ...res];
	    }
	    res = m2.concat(m3, m4, res);
	    // res = [...m2, ...m3, ...m4, ...res];
	    var newres = [];
	    for (var i = 0, ii = res.length; i < ii; i += 1) {
	        newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;
	    }
	    return newres;
	}
	// const TAU = Math.PI * 2;
	// const mapToEllipse = (
	//   { x, y }: { x: number; y: number },
	//   rx: number,
	//   ry: number,
	//   cosphi: number,
	//   sinphi: number,
	//   centerx: number,
	//   centery: number,
	// ) => {
	//   x *= rx;
	//   y *= ry;
	//   const xp = cosphi * x - sinphi * y;
	//   const yp = sinphi * x + cosphi * y;
	//   return {
	//     x: xp + centerx,
	//     y: yp + centery,
	//   };
	// };
	// const approxUnitArc = (ang1: number, ang2: number) => {
	//   // If 90 degree circular arc, use a constant
	//   // as derived from http://spencermortensen.com/articles/bezier-circle
	//   const a =
	//     ang2 === 1.5707963267948966
	//       ? 0.551915024494
	//       : ang2 === -1.5707963267948966
	//       ? -0.551915024494
	//       : (4 / 3) * Math.tan(ang2 / 4);
	//   const x1 = Math.cos(ang1);
	//   const y1 = Math.sin(ang1);
	//   const x2 = Math.cos(ang1 + ang2);
	//   const y2 = Math.sin(ang1 + ang2);
	//   return [
	//     {
	//       x: x1 - y1 * a,
	//       y: y1 + x1 * a,
	//     },
	//     {
	//       x: x2 + y2 * a,
	//       y: y2 - x2 * a,
	//     },
	//     {
	//       x: x2,
	//       y: y2,
	//     },
	//   ];
	// };
	// const vectorAngle = (ux: number, uy: number, vx: number, vy: number) => {
	//   const sign = ux * vy - uy * vx < 0 ? -1 : 1;
	//   let dot = ux * vx + uy * vy;
	//   if (dot > 1) {
	//     dot = 1;
	//   }
	//   if (dot < -1) {
	//     dot = -1;
	//   }
	//   return sign * Math.acos(dot);
	// };
	// const getArcCenter = (
	//   px: any,
	//   py: any,
	//   cx: any,
	//   cy: any,
	//   rx: number,
	//   ry: number,
	//   largeArcFlag: number,
	//   sweepFlag: number,
	//   sinphi: number,
	//   cosphi: number,
	//   pxp: number,
	//   pyp: number,
	// ) => {
	//   const rxsq = Math.pow(rx, 2);
	//   const rysq = Math.pow(ry, 2);
	//   const pxpsq = Math.pow(pxp, 2);
	//   const pypsq = Math.pow(pyp, 2);
	//   let radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
	//   if (radicant < 0) {
	//     radicant = 0;
	//   }
	//   radicant /= rxsq * pypsq + rysq * pxpsq;
	//   radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
	//   const centerxp = ((radicant * rx) / ry) * pyp;
	//   const centeryp = ((radicant * -ry) / rx) * pxp;
	//   const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
	//   const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
	//   const vx1 = (pxp - centerxp) / rx;
	//   const vy1 = (pyp - centeryp) / ry;
	//   const vx2 = (-pxp - centerxp) / rx;
	//   const vy2 = (-pyp - centeryp) / ry;
	//   const ang1 = vectorAngle(1, 0, vx1, vy1);
	//   let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
	//   if (sweepFlag === 0 && ang2 > 0) {
	//     ang2 -= TAU;
	//   }
	//   if (sweepFlag === 1 && ang2 < 0) {
	//     ang2 += TAU;
	//   }
	//   return [centerx, centery, ang1, ang2];
	// };
	// const arcToBezier = ({ px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0 }) => {
	//   const curves = [];
	//   if (rx === 0 || ry === 0) {
	//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
	//   }
	//   const sinphi = Math.sin((xAxisRotation * TAU) / 360);
	//   const cosphi = Math.cos((xAxisRotation * TAU) / 360);
	//   const pxp = (cosphi * (px - cx)) / 2 + (sinphi * (py - cy)) / 2;
	//   const pyp = (-sinphi * (px - cx)) / 2 + (cosphi * (py - cy)) / 2;
	//   if (pxp === 0 && pyp === 0) {
	//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
	//   }
	//   rx = Math.abs(rx);
	//   ry = Math.abs(ry);
	//   const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
	//   if (lambda > 1) {
	//     rx *= Math.sqrt(lambda);
	//     ry *= Math.sqrt(lambda);
	//   }
	//   let [centerx, centery, ang1, ang2] = getArcCenter(
	//     px,
	//     py,
	//     cx,
	//     cy,
	//     rx,
	//     ry,
	//     largeArcFlag,
	//     sweepFlag,
	//     sinphi,
	//     cosphi,
	//     pxp,
	//     pyp,
	//   );
	//   // If 'ang2' == 90.0000000001, then `ratio` will evaluate to
	//   // 1.0000000001. This causes `segments` to be greater than one, which is an
	//   // unecessary split, and adds extra points to the bezier curve. To alleviate
	//   // this issue, we round to 1.0 when the ratio is close to 1.0.
	//   let ratio = Math.abs(ang2) / (TAU / 4);
	//   if (Math.abs(1.0 - ratio) < 0.0000001) {
	//     ratio = 1.0;
	//   }
	//   const segments = Math.max(Math.ceil(ratio), 1);
	//   ang2 /= segments;
	//   for (let i = 0; i < segments; i++) {
	//     curves.push(approxUnitArc(ang1, ang2));
	//     ang1 += ang2;
	//   }
	//   return curves.map((curve) => {
	//     const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);
	//     const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);
	//     const { x, y } = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);
	//     return { x1, y1, x2, y2, x, y };
	//   });
	// };
	// export function arcToCubic(
	//   x1: number,
	//   y1: number,
	//   rx: number,
	//   ry: number,
	//   angle: number,
	//   LAF: number,
	//   SF: number,
	//   x2: number,
	//   y2: number,
	// ) {
	//   const curves = arcToBezier({
	//     px: x1,
	//     py: y1,
	//     cx: x2,
	//     cy: y2,
	//     rx,
	//     ry,
	//     xAxisRotation: angle,
	//     largeArcFlag: LAF,
	//     sweepFlag: SF,
	//   });
	//   return curves.reduce((prev, cur) => {
	//     const { x1, y1, x2, y2, x, y } = cur;
	//     prev.push(x1, y1, x2, y2, x, y);
	//     return prev;
	//   }, [] as number[]);
	// }

	function quadToCubic(x1, y1, qx, qy, x2, y2) {
	    var r13 = 1 / 3;
	    var r23 = 2 / 3;
	    return [
	        r13 * x1 + r23 * qx,
	        r13 * y1 + r23 * qy,
	        r13 * x2 + r23 * qx,
	        r13 * y2 + r23 * qy,
	        x2,
	        y2, // x,y
	    ];
	}

	function midPoint(a, b, t) {
	    var ax = a[0];
	    var ay = a[1];
	    var bx = b[0];
	    var by = b[1];
	    return [ax + (bx - ax) * t, ay + (by - ay) * t];
	}

	function distanceSquareRoot(a, b) {
	    return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));
	}

	/**
	 * Returns a {x,y} point at a given length, the total length and
	 * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.
	 */
	function segmentLineFactory(x1, y1, x2, y2, distance) {
	    var length = distanceSquareRoot([x1, y1], [x2, y2]);
	    var point = { x: 0, y: 0 };
	    if (typeof distance === 'number') {
	        if (distance <= 0) {
	            point = { x: x1, y: y1 };
	        }
	        else if (distance >= length) {
	            point = { x: x2, y: y2 };
	        }
	        else {
	            var _a = midPoint([x1, y1], [x2, y2], distance / length), x = _a[0], y = _a[1];
	            point = { x: x, y: y };
	        }
	    }
	    return {
	        length: length,
	        point: point,
	        min: {
	            x: Math.min(x1, x2),
	            y: Math.min(y1, y2),
	        },
	        max: {
	            x: Math.max(x1, x2),
	            y: Math.max(y1, y2),
	        },
	    };
	}

	function lineToCubic(x1, y1, x2, y2) {
	    var t = 0.5;
	    var p0 = [x1, y1];
	    var p1 = [x2, y2];
	    var p2 = midPoint(p0, p1, t);
	    var p3 = midPoint(p1, p2, t);
	    var p4 = midPoint(p2, p3, t);
	    var p5 = midPoint(p3, p4, t);
	    var p6 = midPoint(p4, p5, t);
	    // const seg1 = [...p0, ...p2, ...p4, ...p6, t];
	    // @ts-ignore
	    var cp1 = segmentLineFactory(p0[0], p0[1], p2[0], p2[1], p4[0]).point;
	    // const seg2 = [...p6, ...p5, ...p3, ...p1, 0];
	    // @ts-ignore
	    var cp2 = segmentLineFactory(p6[0], p6[1], p5[0], p5[1], p3[0]).point;
	    return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];
	}

	function segmentToCubic(segment, params) {
	    var pathCommand = segment[0];
	    var values = segment.slice(1).map(Number);
	    var x = values[0], y = values[1];
	    var args;
	    var px1 = params.x1, py1 = params.y1, px = params.x, py = params.y;
	    if (!'TQ'.includes(pathCommand)) {
	        params.qx = null;
	        params.qy = null;
	    }
	    switch (pathCommand) {
	        case 'M':
	            params.x = x;
	            params.y = y;
	            return segment;
	        case 'A':
	            args = [px1, py1].concat(values);
	            // @ts-ignore
	            return ['C'].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
	        case 'Q':
	            params.qx = x;
	            params.qy = y;
	            args = [px1, py1].concat(values);
	            // @ts-ignore
	            return ['C'].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
	        case 'L':
	            // @ts-ignore
	            return ['C'].concat(lineToCubic(px1, py1, x, y));
	        case 'Z':
	            // prevent NaN from divide 0
	            if (px1 === px && py1 === py) {
	                return ['C', px1, py1, px, py, px, py];
	            }
	            // @ts-ignore
	            return ['C'].concat(lineToCubic(px1, py1, px, py));
	    }
	    return segment;
	}

	// import { fixPath } from '../process/fix-path';
	function path2Curve(pathInput, needZCommandIndexes) {
	    if (needZCommandIndexes === void 0) { needZCommandIndexes = false; }
	    if (isCurveArray(pathInput)) {
	        var cloned = clonePath(pathInput);
	        if (needZCommandIndexes) {
	            return [cloned, []];
	        }
	        else {
	            return cloned;
	        }
	    }
	    // fixPath will remove 'Z' command
	    // const path = fixPath(normalizePath(pathInput));
	    var path = normalizePath(pathInput);
	    var params = __assign({}, paramsParser);
	    var allPathCommands = [];
	    var pathCommand = '';
	    var ii = path.length;
	    var segment;
	    var seglen;
	    var zCommandIndexes = [];
	    for (var i = 0; i < ii; i += 1) {
	        if (path[i])
	            pathCommand = path[i][0];
	        allPathCommands[i] = pathCommand;
	        var curveSegment = segmentToCubic(path[i], params);
	        path[i] = curveSegment;
	        fixArc(path, allPathCommands, i);
	        ii = path.length; // solves curveArrays ending in Z
	        // keep Z command account for lineJoin
	        // @see https://github.com/antvis/util/issues/68
	        if (pathCommand === 'Z') {
	            zCommandIndexes.push(i);
	        }
	        segment = path[i];
	        seglen = segment.length;
	        params.x1 = +segment[seglen - 2];
	        params.y1 = +segment[seglen - 1];
	        params.x2 = +segment[seglen - 4] || params.x1;
	        params.y2 = +segment[seglen - 3] || params.y1;
	    }
	    // validate
	    if (needZCommandIndexes) {
	        return [path, zCommandIndexes];
	    }
	    else {
	        return path;
	    }
	}

	// reverse CURVE based pathArray segments only
	function reverseCurve(pathArray) {
	    var rotatedCurve = pathArray
	        .slice(1)
	        .map(function (x, i, curveOnly) {
	        // @ts-ignore
	        return !i ? pathArray[0].slice(1).concat(x.slice(1)) : curveOnly[i - 1].slice(-2).concat(x.slice(1));
	    })
	        // @ts-ignore
	        .map(function (x) { return x.map(function (y, i) { return x[x.length - i - 2 * (1 - (i % 2))]; }); })
	        .reverse();
	    return [['M'].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function (x) { return ['C'].concat(x.slice(2)); }));
	}

	function angleBetween(v0, v1) {
	    var v0x = v0.x, v0y = v0.y;
	    var v1x = v1.x, v1y = v1.y;
	    var p = v0x * v1x + v0y * v1y;
	    var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
	    var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
	    var angle = sign * Math.acos(p / n);
	    return angle;
	}
	/**
	 * Returns a {x,y} point at a given length, the total length and
	 * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.
	 * @see https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js
	 */
	function getPointAtArcSegmentLength(x1, y1, RX, RY, angle, LAF, SF, x, y, t) {
	    var abs = Math.abs, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, PI = Math.PI;
	    var rx = abs(RX);
	    var ry = abs(RY);
	    var xRot = ((angle % 360) + 360) % 360;
	    var xRotRad = xRot * (PI / 180);
	    if (x1 === x && y1 === y) {
	        return { x: x1, y: y1 };
	    }
	    if (rx === 0 || ry === 0) {
	        return segmentLineFactory(x1, y1, x, y, t).point;
	    }
	    var dx = (x1 - x) / 2;
	    var dy = (y1 - y) / 2;
	    var transformedPoint = {
	        x: cos(xRotRad) * dx + sin(xRotRad) * dy,
	        y: -sin(xRotRad) * dx + cos(xRotRad) * dy,
	    };
	    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
	    if (radiiCheck > 1) {
	        rx *= sqrt(radiiCheck);
	        ry *= sqrt(radiiCheck);
	    }
	    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
	    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
	    var cRadicand = cSquareNumerator / cSquareRootDenom;
	    cRadicand = cRadicand < 0 ? 0 : cRadicand;
	    var cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
	    var transformedCenter = {
	        x: cCoef * ((rx * transformedPoint.y) / ry),
	        y: cCoef * (-(ry * transformedPoint.x) / rx),
	    };
	    var center = {
	        x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,
	        y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2,
	    };
	    var startVector = {
	        x: (transformedPoint.x - transformedCenter.x) / rx,
	        y: (transformedPoint.y - transformedCenter.y) / ry,
	    };
	    var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
	    var endVector = {
	        x: (-transformedPoint.x - transformedCenter.x) / rx,
	        y: (-transformedPoint.y - transformedCenter.y) / ry,
	    };
	    var sweepAngle = angleBetween(startVector, endVector);
	    if (!SF && sweepAngle > 0) {
	        sweepAngle -= 2 * PI;
	    }
	    else if (SF && sweepAngle < 0) {
	        sweepAngle += 2 * PI;
	    }
	    sweepAngle %= 2 * PI;
	    var alpha = startAngle + sweepAngle * t;
	    var ellipseComponentX = rx * cos(alpha);
	    var ellipseComponentY = ry * sin(alpha);
	    var point = {
	        x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
	        y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y,
	    };
	    // to be used later
	    // point.ellipticalArcStartAngle = startAngle;
	    // point.ellipticalArcEndAngle = startAngle + sweepAngle;
	    // point.ellipticalArcAngle = alpha;
	    // point.ellipticalArcCenter = center;
	    // point.resultantRx = rx;
	    // point.resultantRy = ry;
	    return point;
	}
	/**
	 * Returns a {x,y} point at a given length, the total length and
	 * the shape minimum and maximum {x,y} coordinates of an A (arc-to) segment.
	 *
	 * For better performance, it can skip calculate bbox or length in some scenario.
	 */
	function segmentArcFactory(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, distance, options) {
	    var _a;
	    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
	    var distanceIsNumber = typeof distance === 'number';
	    var x = X1;
	    var y = Y1;
	    var LENGTH = 0;
	    var prev = [x, y, LENGTH];
	    var cur = [x, y];
	    var t = 0;
	    var POINT = { x: 0, y: 0 };
	    var POINTS = [{ x: x, y: y }];
	    if (distanceIsNumber && distance <= 0) {
	        POINT = { x: x, y: y };
	    }
	    // bad perf when size > 100
	    for (var j = 0; j <= sampleSize; j += 1) {
	        t = j / sampleSize;
	        (_a = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t), x = _a.x, y = _a.y);
	        if (bbox) {
	            POINTS.push({ x: x, y: y });
	        }
	        if (length) {
	            LENGTH += distanceSquareRoot(cur, [x, y]);
	        }
	        cur = [x, y];
	        if (distanceIsNumber && LENGTH >= distance && distance > prev[2]) {
	            var dv = (LENGTH - distance) / (LENGTH - prev[2]);
	            POINT = {
	                x: cur[0] * (1 - dv) + prev[0] * dv,
	                y: cur[1] * (1 - dv) + prev[1] * dv,
	            };
	        }
	        prev = [x, y, LENGTH];
	    }
	    if (distanceIsNumber && distance >= LENGTH) {
	        POINT = { x: X2, y: Y2 };
	    }
	    return {
	        length: LENGTH,
	        point: POINT,
	        min: {
	            x: Math.min.apply(null, POINTS.map(function (n) { return n.x; })),
	            y: Math.min.apply(null, POINTS.map(function (n) { return n.y; })),
	        },
	        max: {
	            x: Math.max.apply(null, POINTS.map(function (n) { return n.x; })),
	            y: Math.max.apply(null, POINTS.map(function (n) { return n.y; })),
	        },
	    };
	}

	/**
	 * Returns a {x,y} point at a given length, the total length and
	 * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.
	 */
	function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {
	    var t1 = 1 - t;
	    return {
	        x: Math.pow(t1, 3) * x1 + 3 * Math.pow(t1, 2) * t * c1x + 3 * t1 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x2,
	        y: Math.pow(t1, 3) * y1 + 3 * Math.pow(t1, 2) * t * c1y + 3 * t1 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y2,
	    };
	}
	/**
	 * Returns the length of a C (cubic-bezier) segment
	 * or an {x,y} point at a given length.
	 */
	function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance, options) {
	    var _a;
	    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
	    var distanceIsNumber = typeof distance === 'number';
	    var x = x1;
	    var y = y1;
	    var LENGTH = 0;
	    var prev = [x, y, LENGTH];
	    var cur = [x, y];
	    var t = 0;
	    var POINT = { x: 0, y: 0 };
	    var POINTS = [{ x: x, y: y }];
	    if (distanceIsNumber && distance <= 0) {
	        POINT = { x: x, y: y };
	    }
	    // bad perf when size = 300
	    for (var j = 0; j <= sampleSize; j += 1) {
	        t = j / sampleSize;
	        (_a = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t), x = _a.x, y = _a.y);
	        if (bbox) {
	            POINTS.push({ x: x, y: y });
	        }
	        if (length) {
	            LENGTH += distanceSquareRoot(cur, [x, y]);
	        }
	        cur = [x, y];
	        if (distanceIsNumber && LENGTH >= distance && distance > prev[2]) {
	            var dv = (LENGTH - distance) / (LENGTH - prev[2]);
	            POINT = {
	                x: cur[0] * (1 - dv) + prev[0] * dv,
	                y: cur[1] * (1 - dv) + prev[1] * dv,
	            };
	        }
	        prev = [x, y, LENGTH];
	    }
	    if (distanceIsNumber && distance >= LENGTH) {
	        POINT = { x: x2, y: y2 };
	    }
	    return {
	        length: LENGTH,
	        point: POINT,
	        min: {
	            x: Math.min.apply(null, POINTS.map(function (n) { return n.x; })),
	            y: Math.min.apply(null, POINTS.map(function (n) { return n.y; })),
	        },
	        max: {
	            x: Math.max.apply(null, POINTS.map(function (n) { return n.x; })),
	            y: Math.max.apply(null, POINTS.map(function (n) { return n.y; })),
	        },
	    };
	}

	/**
	 * Returns the {x,y} coordinates of a point at a
	 * given length of a quadratic-bezier segment.
	 *
	 * @see https://github.com/substack/point-at-length
	 */
	function getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {
	    var t1 = 1 - t;
	    return {
	        x: Math.pow(t1, 2) * x1 + 2 * t1 * t * cx + Math.pow(t, 2) * x2,
	        y: Math.pow(t1, 2) * y1 + 2 * t1 * t * cy + Math.pow(t, 2) * y2,
	    };
	}
	/**
	 * Returns a {x,y} point at a given length, the total length and
	 * the minimum and maximum {x,y} coordinates of a Q (quadratic-bezier) segment.
	 */
	function segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance, options) {
	    var _a;
	    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
	    var distanceIsNumber = typeof distance === 'number';
	    var x = x1;
	    var y = y1;
	    var LENGTH = 0;
	    var prev = [x, y, LENGTH];
	    var cur = [x, y];
	    var t = 0;
	    var POINT = { x: 0, y: 0 };
	    var POINTS = [{ x: x, y: y }];
	    if (distanceIsNumber && distance <= 0) {
	        POINT = { x: x, y: y };
	    }
	    for (var j = 0; j <= sampleSize; j += 1) {
	        t = j / sampleSize;
	        (_a = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t), x = _a.x, y = _a.y);
	        if (bbox) {
	            POINTS.push({ x: x, y: y });
	        }
	        if (length) {
	            LENGTH += distanceSquareRoot(cur, [x, y]);
	        }
	        cur = [x, y];
	        if (distanceIsNumber && LENGTH >= distance && distance > prev[2]) {
	            var dv = (LENGTH - distance) / (LENGTH - prev[2]);
	            POINT = {
	                x: cur[0] * (1 - dv) + prev[0] * dv,
	                y: cur[1] * (1 - dv) + prev[1] * dv,
	            };
	        }
	        prev = [x, y, LENGTH];
	    }
	    /* istanbul ignore else */
	    if (distanceIsNumber && distance >= LENGTH) {
	        POINT = { x: x2, y: y2 };
	    }
	    return {
	        length: LENGTH,
	        point: POINT,
	        min: {
	            x: Math.min.apply(null, POINTS.map(function (n) { return n.x; })),
	            y: Math.min.apply(null, POINTS.map(function (n) { return n.y; })),
	        },
	        max: {
	            x: Math.max.apply(null, POINTS.map(function (n) { return n.x; })),
	            y: Math.max.apply(null, POINTS.map(function (n) { return n.y; })),
	        },
	    };
	}

	/**
	 * Returns a {x,y} point at a given length
	 * of a shape, the shape total length and
	 * the shape minimum and maximum {x,y} coordinates.
	 */
	function pathLengthFactory(pathInput, distance, options) {
	    var _a, _b, _c, _d, _e, _f;
	    var path = normalizePath(pathInput);
	    var distanceIsNumber = typeof distance === 'number';
	    var isM;
	    var data = [];
	    var pathCommand;
	    var x = 0;
	    var y = 0;
	    var mx = 0;
	    var my = 0;
	    var seg;
	    var MIN = [];
	    var MAX = [];
	    var length = 0;
	    var min = { x: 0, y: 0 };
	    var max = min;
	    var point = min;
	    var POINT = min;
	    var LENGTH = 0;
	    for (var i = 0, ll = path.length; i < ll; i += 1) {
	        seg = path[i];
	        pathCommand = seg[0];
	        isM = pathCommand === 'M';
	        data = !isM ? [x, y].concat(seg.slice(1)) : data;
	        // this segment is always ZERO
	        /* istanbul ignore else */
	        if (isM) {
	            // remember mx, my for Z
	            mx = seg[1], my = seg[2];
	            min = { x: mx, y: my };
	            max = min;
	            length = 0;
	            if (distanceIsNumber && distance < 0.001) {
	                POINT = min;
	            }
	        }
	        else if (pathCommand === 'L') {
	            (_a = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH), length = _a.length, min = _a.min, max = _a.max, point = _a.point);
	        }
	        else if (pathCommand === 'A') {
	            (_b = segmentArcFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], (distance || 0) - LENGTH, options || {}), length = _b.length, min = _b.min, max = _b.max, point = _b.point);
	        }
	        else if (pathCommand === 'C') {
	            (_c = segmentCubicFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], (distance || 0) - LENGTH, options || {}), length = _c.length, min = _c.min, max = _c.max, point = _c.point);
	        }
	        else if (pathCommand === 'Q') {
	            (_d = segmentQuadFactory(data[0], data[1], data[2], data[3], data[4], data[5], (distance || 0) - LENGTH, options || {}), length = _d.length, min = _d.min, max = _d.max, point = _d.point);
	        }
	        else if (pathCommand === 'Z') {
	            data = [x, y, mx, my];
	            (_e = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH), length = _e.length, min = _e.min, max = _e.max, point = _e.point);
	        }
	        if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {
	            POINT = point;
	        }
	        MAX.push(max);
	        MIN.push(min);
	        LENGTH += length;
	        _f = pathCommand !== 'Z' ? seg.slice(-2) : [mx, my], x = _f[0], y = _f[1];
	    }
	    // native `getPointAtLength` behavior when the given distance
	    // is higher than total length
	    if (distanceIsNumber && distance >= LENGTH) {
	        POINT = { x: x, y: y };
	    }
	    return {
	        length: LENGTH,
	        point: POINT,
	        min: {
	            x: Math.min.apply(null, MIN.map(function (n) { return n.x; })),
	            y: Math.min.apply(null, MIN.map(function (n) { return n.y; })),
	        },
	        max: {
	            x: Math.max.apply(null, MAX.map(function (n) { return n.x; })),
	            y: Math.max.apply(null, MAX.map(function (n) { return n.y; })),
	        },
	    };
	}

	/**
	 * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.
	 *
	 * The `normalizePath` version is lighter, faster, more efficient and more accurate
	 * with paths that are not `curveArray`.
	 */
	function getTotalLength(pathInput, options) {
	    return pathLengthFactory(pathInput, undefined, __assign(__assign({}, options), { bbox: false, length: true })).length;
	}

	function getRotations(a) {
	    var segCount = a.length;
	    var pointCount = segCount - 1;
	    return a.map(function (f, idx) {
	        return a.map(function (p, i) {
	            var oldSegIdx = idx + i;
	            var seg;
	            if (i === 0 || (a[oldSegIdx] && a[oldSegIdx][0] === 'M')) {
	                seg = a[oldSegIdx];
	                return ['M'].concat(seg.slice(-2));
	            }
	            if (oldSegIdx >= segCount)
	                oldSegIdx -= pointCount;
	            return a[oldSegIdx];
	        });
	    });
	}
	function getRotatedCurve(a, b) {
	    var segCount = a.length - 1;
	    var lineLengths = [];
	    var computedIndex = 0;
	    var sumLensSqrd = 0;
	    var rotations = getRotations(a);
	    rotations.forEach(function (r, i) {
	        a.slice(1).forEach(function (s, j) {
	            // @ts-ignore
	            sumLensSqrd += distanceSquareRoot(a[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
	        });
	        lineLengths[i] = sumLensSqrd;
	        sumLensSqrd = 0;
	    });
	    computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
	    return rotations[computedIndex];
	}

	/**
	 * Returns the area of a single cubic-bezier segment.
	 *
	 * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html
	 */
	function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x2, y2) {
	    // https://stackoverflow.com/a/15845996
	    return ((3 *
	        ((y2 - y1) * (c1x + c2x) -
	            (x2 - x1) * (c1y + c2y) +
	            c1y * (x1 - c2x) -
	            c1x * (y1 - c2y) +
	            y2 * (c2x + x1 / 3) -
	            x2 * (c2y + y1 / 3))) /
	        20);
	}
	/**
	 * Returns the area of a shape.
	 * @author Jürg Lehni & Jonathan Puckey
	 *
	 * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js
	 */
	function getPathArea(path) {
	    var x = 0;
	    var y = 0;
	    var len = 0;
	    return path2Curve(path)
	        .map(function (seg) {
	        var _a;
	        switch (seg[0]) {
	            case 'M':
	                x = seg[1], y = seg[2];
	                return 0;
	            default:
	                // @ts-ignore
	                var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x2 = _b[4], y2 = _b[5];
	                len = getCubicSegArea(x, y, c1x, c1y, c2x, c2y, x2, y2);
	                _a = seg.slice(-2), x = _a[0], y = _a[1];
	                return len;
	        }
	    })
	        .reduce(function (a, b) { return a + b; }, 0);
	}
	// export function getPathArea(pathArray: AbsoluteArray) {
	//   let x = 0;
	//   let y = 0;
	//   let mx = 0;
	//   let my = 0;
	//   let len = 0;
	//   return pathArray
	//     .map((seg) => {
	//       switch (seg[0]) {
	//         case 'M':
	//         case 'Z':
	//           mx = seg[0] === 'M' ? seg[1] : mx;
	//           my = seg[0] === 'M' ? seg[2] : my;
	//           x = mx;
	//           y = my;
	//           return 0;
	//         default:
	//           // @ts-ignore
	//           len = getCubicSegArea.apply(0, [x, y].concat(seg.slice(1)));
	//           [x, y] = seg.slice(-2) as [number, number];
	//           return len;
	//       }
	//     })
	//     .reduce((a, b) => a + b, 0);
	// }

	function getDrawDirection(pathArray) {
	    return getPathArea(pathArray) >= 0;
	}

	/**
	 * Returns [x,y] coordinates of a point at a given length of a shape.
	 */
	function getPointAtLength(pathInput, distance, options) {
	    return pathLengthFactory(pathInput, distance, __assign(__assign({}, options), { bbox: false, length: true })).point;
	}

	function splitCubic(pts, t) {
	    if (t === void 0) { t = 0.5; }
	    var p0 = pts.slice(0, 2);
	    var p1 = pts.slice(2, 4);
	    var p2 = pts.slice(4, 6);
	    var p3 = pts.slice(6, 8);
	    var p4 = midPoint(p0, p1, t);
	    var p5 = midPoint(p1, p2, t);
	    var p6 = midPoint(p2, p3, t);
	    var p7 = midPoint(p4, p5, t);
	    var p8 = midPoint(p5, p6, t);
	    var p9 = midPoint(p7, p8, t);
	    return [
	        // @ts-ignore
	        ['C'].concat(p4, p7, p9),
	        // @ts-ignore
	        ['C'].concat(p8, p6, p3),
	    ];
	}
	function getCurveArray(segments) {
	    return segments.map(function (segment, i, pathArray) {
	        // @ts-ignore
	        var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
	        // @ts-ignore
	        var curveLength = i
	            ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length
	            : 0;
	        var subsegs;
	        if (i) {
	            // must be [segment,segment]
	            subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
	        }
	        else {
	            subsegs = [segment];
	        }
	        return {
	            s: segment,
	            ss: subsegs,
	            l: curveLength,
	        };
	    });
	}
	function equalizeSegments(path1, path2, TL) {
	    var c1 = getCurveArray(path1);
	    var c2 = getCurveArray(path2);
	    var L1 = c1.length;
	    var L2 = c2.length;
	    var l1 = c1.filter(function (x) { return x.l; }).length;
	    var l2 = c2.filter(function (x) { return x.l; }).length;
	    var m1 = c1.filter(function (x) { return x.l; }).reduce(function (a, _a) {
	        var l = _a.l;
	        return a + l;
	    }, 0) / l1 || 0;
	    var m2 = c2.filter(function (x) { return x.l; }).reduce(function (a, _a) {
	        var l = _a.l;
	        return a + l;
	    }, 0) / l2 || 0;
	    var tl = TL || Math.max(L1, L2);
	    var mm = [m1, m2];
	    var dif = [tl - L1, tl - L2];
	    var canSplit = 0;
	    var result = [c1, c2].map(function (x, i) {
	        // @ts-ignore
	        return x.l === tl
	            ? x.map(function (y) { return y.s; })
	            : x
	                .map(function (y, j) {
	                canSplit = j && dif[i] && y.l >= mm[i];
	                dif[i] -= canSplit ? 1 : 0;
	                return canSplit ? y.ss : [y.s];
	            })
	                .flat();
	    });
	    return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
	}

	/**
	 * @see https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isfunction
	 */
	var isFunction = (function (value) {
	    return typeof value === 'function';
	});

	// isFinite,
	var isNil = function (value) {
	    /**
	     * isNil(null) => true
	     * isNil() => true
	     */
	    return value === null || value === undefined;
	};

	var toString = {}.toString;
	var isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };

	var isArray = (function (value) {
	    return Array.isArray ? Array.isArray(value) : isType(value, 'Array');
	});

	var isObject = (function (value) {
	    /**
	     * isObject({}) => true
	     * isObject([1, 2, 3]) => true
	     * isObject(Function) => true
	     * isObject(null) => false
	     */
	    var type = typeof value;
	    return (value !== null && type === 'object') || type === 'function';
	});

	function each(elements, func) {
	    if (!elements) {
	        return;
	    }
	    var rst;
	    if (isArray(elements)) {
	        for (var i = 0, len = elements.length; i < len; i++) {
	            rst = func(elements[i], i);
	            if (rst === false) {
	                break;
	            }
	        }
	    }
	    else if (isObject(elements)) {
	        for (var k in elements) {
	            if (elements.hasOwnProperty(k)) {
	                rst = func(elements[k], k);
	                if (rst === false) {
	                    break;
	                }
	            }
	        }
	    }
	}

	var isObjectLike = function (value) {
	    /**
	     * isObjectLike({}) => true
	     * isObjectLike([1, 2, 3]) => true
	     * isObjectLike(Function) => false
	     * isObjectLike(null) => false
	     */
	    return typeof value === 'object' && value !== null;
	};

	var isPlainObject = function (value) {
	    /**
	     * isObjectLike(new Foo) => false
	     * isObjectLike([1, 2, 3]) => false
	     * isObjectLike({ x: 0, y: 0 }) => true
	     * isObjectLike(Object.create(null)) => true
	     */
	    if (!isObjectLike(value) || !isType(value, 'Object')) {
	        return false;
	    }
	    if (Object.getPrototypeOf(value) === null) {
	        return true;
	    }
	    var proto = value;
	    while (Object.getPrototypeOf(proto) !== null) {
	        proto = Object.getPrototypeOf(proto);
	    }
	    return Object.getPrototypeOf(value) === proto;
	};

	/**
	 * @param {Array} arr The array to iterate over.
	 * @return {*} Returns the maximum value.
	 * @example
	 *
	 * max([1, 2]);
	 * // => 2
	 *
	 * max([]);
	 * // => undefined
	 *
	 * const data = new Array(1250010).fill(1).map((d,idx) => idx);
	 *
	 * max(data);
	 * // => 1250010
	 * // Math.max(...data) will encounter "Maximum call stack size exceeded" error
	 */
	var max$1 = (function (arr) {
	    if (!isArray(arr)) {
	        return undefined;
	    }
	    return arr.reduce(function (prev, curr) {
	        return Math.max(prev, curr);
	    }, arr[0]);
	});

	/**
	 * @param {Array} arr The array to iterate over.
	 * @return {*} Returns the minimum value.
	 * @example
	 *
	 * min([1, 2]);
	 * // => 1
	 *
	 * min([]);
	 * // => undefined
	 *
	 * const data = new Array(1250010).fill(1).map((d,idx) => idx);
	 *
	 * min(data);
	 * // => 1250010
	 * // Math.min(...data) will encounter "Maximum call stack size exceeded" error
	 */
	var min$1 = (function (arr) {
	    if (!isArray(arr)) {
	        return undefined;
	    }
	    return arr.reduce(function (prev, curr) {
	        return Math.min(prev, curr);
	    }, arr[0]);
	});

	var reduce = function (arr, fn, init) {
	    if (!isArray(arr) && !isPlainObject(arr)) {
	        return arr;
	    }
	    var result = init;
	    each(arr, function (data, i) {
	        result = fn(result, data, i);
	    });
	    return result;
	};

	var isString = (function (str) {
	    return isType(str, 'String');
	});

	var clamp = function (a, min, max) {
	    if (a < min) {
	        return min;
	    }
	    else if (a > max) {
	        return max;
	    }
	    return a;
	};

	/**
	 * 判断是否数字
	 * @return {Boolean} 是否数字
	 */
	var isNumber = function (value) {
	    return isType(value, 'Number');
	};

	var PRECISION = 0.00001; // numbers less than this is considered as 0
	function isNumberEqual(a, b, precision) {
	    if (precision === void 0) { precision = PRECISION; }
	    return Math.abs(a - b) < precision;
	}

	var mod = function (n, m) {
	    return ((n % m) + m) % m;
	};

	/**
	 * 是否是布尔类型
	 *
	 * @param {Object} value 测试的值
	 * @return {Boolean}
	 */
	var isBoolean = function (value) {
	    return isType(value, 'Boolean');
	};

	var isUndefined = function (value) {
	    return value === undefined;
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var pick = (function (object, keys) {
	    if (object === null || !isPlainObject(object)) {
	        return {};
	    }
	    var result = {};
	    each(keys, function (key) {
	        if (hasOwnProperty.call(object, key)) {
	            result[key] = object[key];
	        }
	    });
	    return result;
	});

	var omit = (function (obj, keys) {
	    return reduce(obj, function (r, curr, key) {
	        if (!keys.includes(key)) {
	            r[key] = curr;
	        }
	        return r;
	    }, {});
	});

	var classCallCheck = createCommonjsModule(function (module) {
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _classCallCheck = /*@__PURE__*/getDefaultExportFromCjs(classCallCheck);

	var createClass = createCommonjsModule(function (module) {
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}
	module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _createClass = /*@__PURE__*/getDefaultExportFromCjs(createClass);

	var Component = /*#__PURE__*/function () {
	  function Component(props, context, updater) {
	    _classCallCheck(this, Component);
	    this.isMounted = false;
	    // State 内部私有属性
	    this.destroyed = false;
	    this.props = props;
	    this.state = {};
	    this.context = context;
	    this.updater = updater;
	  }
	  _createClass(Component, [{
	    key: "willMount",
	    value: function willMount() {}
	  }, {
	    key: "didMount",
	    value: function didMount() {}
	  }, {
	    key: "shouldUpdate",
	    value: function shouldUpdate(_nextProps) {
	      return true;
	    }
	  }, {
	    key: "willReceiveProps",
	    value: function willReceiveProps(_props, _context) {}
	  }, {
	    key: "willUpdate",
	    value: function willUpdate() {}
	  }, {
	    key: "didUpdate",
	    value: function didUpdate() {}
	  }, {
	    key: "render",
	    value: function render() {
	      return null;
	    }
	  }, {
	    key: "willUnmount",
	    value: function willUnmount() {}
	  }, {
	    key: "didUnmount",
	    value: function didUnmount() {}
	  }, {
	    key: "setState",
	    value: function setState(partialState, callback) {
	      if (this.destroyed) {
	        return;
	      }
	      this.updater.enqueueSetState(this, partialState, callback);
	    }
	  }, {
	    key: "forceUpdate",
	    value: function forceUpdate(callback) {
	      if (this.destroyed) {
	        return;
	      }
	      this.updater.enqueueForceUpdate(this, {}, callback);
	    }
	  }, {
	    key: "setAnimate",
	    value: function setAnimate(animate) {
	      this.animate = animate;
	      this._vNode.animate = animate;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.destroyed = true;
	      this.animator = null;
	    }
	  }]);
	  return Component;
	}(); // 标识是否是组件
	// @ts-ignore
	Component.prototype.isF2Component = true;

	function cloneElement(element, props) {
	  if (!element) return element;
	  return _objectSpread(_objectSpread({}, element), {}, {
	    props: _objectSpread(_objectSpread({}, element.props), props)
	  });
	}
	function map(children, fn) {
	  if (!children) {
	    return fn(children);
	  }
	  if (isArray(children)) {
	    return children.map(function (child) {
	      return map(child, fn);
	    });
	  }
	  return fn(children);
	}
	function compareArray(nextElements, lastElements, callback) {
	  var keyed = {};
	  var nextLength = nextElements.length;
	  var lastLength = lastElements.length;
	  for (var i = 0, len = lastLength; i < len; i++) {
	    var element = lastElements[i];
	    if (element && !isNil(element.key)) {
	      var key = element.key;
	      keyed[key] = element;
	    }
	  }
	  var result = [];
	  // 比较元素
	  for (var _i = 0, _len = nextLength; _i < _len; _i++) {
	    var _lastElement;
	    var _element = nextElements[_i];
	    if (!_element) {
	      continue;
	    }
	    var _key = _element.key;
	    var lastElement = void 0;
	    // 有key值定义
	    if (!isNil(_element.key)) {
	      lastElement = keyed[_key];
	      if (lastElement) delete keyed[_key];
	    } else {
	      // 取相同位置的元素
	      lastElement = lastElements[_i];
	    }
	    // 没有直接返回
	    if (!lastElement) {
	      result.push(compare(_element, null, callback));
	      continue;
	    }
	    // 如果 lastElement 已经被处理过, next 处理成新增
	    if ((_lastElement = lastElement) === null || _lastElement === void 0 ? void 0 : _lastElement.__processed) {
	      result.push(compare(_element, null, callback));
	      continue;
	    }
	    // 标记 element 已经被处理过
	    lastElement.__processed = true;
	    result.push(compare(_element, lastElement, callback));
	  }
	  // 处理 lastElements 里面还未被处理的元素
	  for (var _i2 = 0, _len2 = lastLength; _i2 < _len2; _i2++) {
	    var _lastElement2 = lastElements[_i2];
	    if (!_lastElement2) {
	      continue;
	    }
	    if (!(_lastElement2 === null || _lastElement2 === void 0 ? void 0 : _lastElement2.__processed)) {
	      result.push(compare(null, _lastElement2, callback));
	    } else {
	      delete _lastElement2.__processed;
	    }
	  }
	  return result;
	}
	// 比较2棵树
	function compare(nextElement, lastElement, callback) {
	  // 有一个为空
	  if (!nextElement || !lastElement) {
	    return callback(nextElement, lastElement);
	  }
	  if (isArray(nextElement) || isArray(lastElement)) {
	    var nextElementArray = isArray(nextElement) ? nextElement : [nextElement];
	    var lastElementArray = isArray(lastElement) ? lastElement : [lastElement];
	    return compareArray(nextElementArray, lastElementArray, callback);
	  }
	  return callback(nextElement, lastElement);
	}
	function toArray(element) {
	  if (!element) {
	    return element;
	  }
	  if (!isArray(element)) {
	    return [element];
	  }
	  var newArray = [];
	  for (var i = 0, len = element.length; i < len; i++) {
	    var item = element[i];
	    if (isArray(item)) {
	      newArray = newArray.concat(toArray(item));
	    } else {
	      newArray.push(item);
	    }
	  }
	  return newArray;
	}
	var Children = {
	  cloneElement: cloneElement,
	  map: map,
	  toArray: toArray,
	  compare: compare
	};

	var arrayWithHoles = createCommonjsModule(function (module) {
	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}
	module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var iterableToArrayLimit = createCommonjsModule(function (module) {
	function _iterableToArrayLimit(arr, i) {
	  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
	  if (null != _i) {
	    var _s,
	      _e,
	      _x,
	      _r,
	      _arr = [],
	      _n = !0,
	      _d = !1;
	    try {
	      if (_x = (_i = _i.call(arr)).next, 0 === i) {
	        if (Object(_i) !== _i) return;
	        _n = !1;
	      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
	    } catch (err) {
	      _d = !0, _e = err;
	    } finally {
	      try {
	        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	    return _arr;
	  }
	}
	module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var arrayLikeToArray = createCommonjsModule(function (module) {
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}
	module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var unsupportedIterableToArray = createCommonjsModule(function (module) {
	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
	}
	module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var nonIterableRest = createCommonjsModule(function (module) {
	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var slicedToArray = createCommonjsModule(function (module) {
	function _slicedToArray(arr, i) {
	  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
	}
	module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _slicedToArray = /*@__PURE__*/getDefaultExportFromCjs(slicedToArray);

	var eventemitter3 = createCommonjsModule(function (module) {

	var has = Object.prototype.hasOwnProperty
	  , prefix = '~';

	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @private
	 */
	function Events() {}

	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);

	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}

	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Add a listener for a given event.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} once Specify if the listener is a one-time listener.
	 * @returns {EventEmitter}
	 * @private
	 */
	function addListener(emitter, event, fn, context, once) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('The listener must be a function');
	  }

	  var listener = new EE(fn, context || emitter, once)
	    , evt = prefix ? prefix + event : event;

	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
	  else emitter._events[evt] = [emitter._events[evt], listener];

	  return emitter;
	}

	/**
	 * Clear event by name.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} evt The Event name.
	 * @private
	 */
	function clearEvent(emitter, evt) {
	  if (--emitter._eventsCount === 0) emitter._events = new Events();
	  else delete emitter._events[evt];
	}

	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = []
	    , events
	    , name;

	  if (this._eventsCount === 0) return names;

	  for (name in (events = this._events)) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Array} The registered listeners.
	 * @public
	 */
	EventEmitter.prototype.listeners = function listeners(event) {
	  var evt = prefix ? prefix + event : event
	    , handlers = this._events[evt];

	  if (!handlers) return [];
	  if (handlers.fn) return [handlers.fn];

	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
	    ee[i] = handlers[i].fn;
	  }

	  return ee;
	};

	/**
	 * Return the number of listeners listening to a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Number} The number of listeners.
	 * @public
	 */
	EventEmitter.prototype.listenerCount = function listenerCount(event) {
	  var evt = prefix ? prefix + event : event
	    , listeners = this._events[evt];

	  if (!listeners) return 0;
	  if (listeners.fn) return 1;
	  return listeners.length;
	};

	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Add a listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  return addListener(this, event, fn, context, false);
	};

	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  return addListener(this, event, fn, context, true);
	};

	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {*} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return this;
	  if (!fn) {
	    clearEvent(this, evt);
	    return this;
	  }

	  var listeners = this._events[evt];

	  if (listeners.fn) {
	    if (
	      listeners.fn === fn &&
	      (!once || listeners.once) &&
	      (!context || listeners.context === context)
	    ) {
	      clearEvent(this, evt);
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (
	        listeners[i].fn !== fn ||
	        (once && !listeners[i].once) ||
	        (context && listeners[i].context !== context)
	      ) {
	        events.push(listeners[i]);
	      }
	    }

	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
	    else clearEvent(this, evt);
	  }

	  return this;
	};

	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {(String|Symbol)} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;

	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) clearEvent(this, evt);
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;

	//
	// Expose the module.
	//
	{
	  module.exports = EventEmitter;
	}
	});

	function define(constructor, factory, prototype) {
	  constructor.prototype = factory.prototype = prototype;
	  prototype.constructor = constructor;
	}

	function extend(parent, definition) {
	  var prototype = Object.create(parent.prototype);
	  for (var key in definition) prototype[key] = definition[key];
	  return prototype;
	}

	function Color() {}

	var darker = 0.7;
	var brighter = 1 / darker;

	var reI = "\\s*([+-]?\\d+)\\s*",
	    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
	    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
	    reHex = /^#([0-9a-f]{3,8})$/,
	    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
	    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
	    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
	    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
	    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
	    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

	var named = {
	  aliceblue: 0xf0f8ff,
	  antiquewhite: 0xfaebd7,
	  aqua: 0x00ffff,
	  aquamarine: 0x7fffd4,
	  azure: 0xf0ffff,
	  beige: 0xf5f5dc,
	  bisque: 0xffe4c4,
	  black: 0x000000,
	  blanchedalmond: 0xffebcd,
	  blue: 0x0000ff,
	  blueviolet: 0x8a2be2,
	  brown: 0xa52a2a,
	  burlywood: 0xdeb887,
	  cadetblue: 0x5f9ea0,
	  chartreuse: 0x7fff00,
	  chocolate: 0xd2691e,
	  coral: 0xff7f50,
	  cornflowerblue: 0x6495ed,
	  cornsilk: 0xfff8dc,
	  crimson: 0xdc143c,
	  cyan: 0x00ffff,
	  darkblue: 0x00008b,
	  darkcyan: 0x008b8b,
	  darkgoldenrod: 0xb8860b,
	  darkgray: 0xa9a9a9,
	  darkgreen: 0x006400,
	  darkgrey: 0xa9a9a9,
	  darkkhaki: 0xbdb76b,
	  darkmagenta: 0x8b008b,
	  darkolivegreen: 0x556b2f,
	  darkorange: 0xff8c00,
	  darkorchid: 0x9932cc,
	  darkred: 0x8b0000,
	  darksalmon: 0xe9967a,
	  darkseagreen: 0x8fbc8f,
	  darkslateblue: 0x483d8b,
	  darkslategray: 0x2f4f4f,
	  darkslategrey: 0x2f4f4f,
	  darkturquoise: 0x00ced1,
	  darkviolet: 0x9400d3,
	  deeppink: 0xff1493,
	  deepskyblue: 0x00bfff,
	  dimgray: 0x696969,
	  dimgrey: 0x696969,
	  dodgerblue: 0x1e90ff,
	  firebrick: 0xb22222,
	  floralwhite: 0xfffaf0,
	  forestgreen: 0x228b22,
	  fuchsia: 0xff00ff,
	  gainsboro: 0xdcdcdc,
	  ghostwhite: 0xf8f8ff,
	  gold: 0xffd700,
	  goldenrod: 0xdaa520,
	  gray: 0x808080,
	  green: 0x008000,
	  greenyellow: 0xadff2f,
	  grey: 0x808080,
	  honeydew: 0xf0fff0,
	  hotpink: 0xff69b4,
	  indianred: 0xcd5c5c,
	  indigo: 0x4b0082,
	  ivory: 0xfffff0,
	  khaki: 0xf0e68c,
	  lavender: 0xe6e6fa,
	  lavenderblush: 0xfff0f5,
	  lawngreen: 0x7cfc00,
	  lemonchiffon: 0xfffacd,
	  lightblue: 0xadd8e6,
	  lightcoral: 0xf08080,
	  lightcyan: 0xe0ffff,
	  lightgoldenrodyellow: 0xfafad2,
	  lightgray: 0xd3d3d3,
	  lightgreen: 0x90ee90,
	  lightgrey: 0xd3d3d3,
	  lightpink: 0xffb6c1,
	  lightsalmon: 0xffa07a,
	  lightseagreen: 0x20b2aa,
	  lightskyblue: 0x87cefa,
	  lightslategray: 0x778899,
	  lightslategrey: 0x778899,
	  lightsteelblue: 0xb0c4de,
	  lightyellow: 0xffffe0,
	  lime: 0x00ff00,
	  limegreen: 0x32cd32,
	  linen: 0xfaf0e6,
	  magenta: 0xff00ff,
	  maroon: 0x800000,
	  mediumaquamarine: 0x66cdaa,
	  mediumblue: 0x0000cd,
	  mediumorchid: 0xba55d3,
	  mediumpurple: 0x9370db,
	  mediumseagreen: 0x3cb371,
	  mediumslateblue: 0x7b68ee,
	  mediumspringgreen: 0x00fa9a,
	  mediumturquoise: 0x48d1cc,
	  mediumvioletred: 0xc71585,
	  midnightblue: 0x191970,
	  mintcream: 0xf5fffa,
	  mistyrose: 0xffe4e1,
	  moccasin: 0xffe4b5,
	  navajowhite: 0xffdead,
	  navy: 0x000080,
	  oldlace: 0xfdf5e6,
	  olive: 0x808000,
	  olivedrab: 0x6b8e23,
	  orange: 0xffa500,
	  orangered: 0xff4500,
	  orchid: 0xda70d6,
	  palegoldenrod: 0xeee8aa,
	  palegreen: 0x98fb98,
	  paleturquoise: 0xafeeee,
	  palevioletred: 0xdb7093,
	  papayawhip: 0xffefd5,
	  peachpuff: 0xffdab9,
	  peru: 0xcd853f,
	  pink: 0xffc0cb,
	  plum: 0xdda0dd,
	  powderblue: 0xb0e0e6,
	  purple: 0x800080,
	  rebeccapurple: 0x663399,
	  red: 0xff0000,
	  rosybrown: 0xbc8f8f,
	  royalblue: 0x4169e1,
	  saddlebrown: 0x8b4513,
	  salmon: 0xfa8072,
	  sandybrown: 0xf4a460,
	  seagreen: 0x2e8b57,
	  seashell: 0xfff5ee,
	  sienna: 0xa0522d,
	  silver: 0xc0c0c0,
	  skyblue: 0x87ceeb,
	  slateblue: 0x6a5acd,
	  slategray: 0x708090,
	  slategrey: 0x708090,
	  snow: 0xfffafa,
	  springgreen: 0x00ff7f,
	  steelblue: 0x4682b4,
	  tan: 0xd2b48c,
	  teal: 0x008080,
	  thistle: 0xd8bfd8,
	  tomato: 0xff6347,
	  turquoise: 0x40e0d0,
	  violet: 0xee82ee,
	  wheat: 0xf5deb3,
	  white: 0xffffff,
	  whitesmoke: 0xf5f5f5,
	  yellow: 0xffff00,
	  yellowgreen: 0x9acd32
	};

	define(Color, color, {
	  copy: function(channels) {
	    return Object.assign(new this.constructor, this, channels);
	  },
	  displayable: function() {
	    return this.rgb().displayable();
	  },
	  hex: color_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: color_formatHex,
	  formatHsl: color_formatHsl,
	  formatRgb: color_formatRgb,
	  toString: color_formatRgb
	});

	function color_formatHex() {
	  return this.rgb().formatHex();
	}

	function color_formatHsl() {
	  return hslConvert(this).formatHsl();
	}

	function color_formatRgb() {
	  return this.rgb().formatRgb();
	}

	function color(format) {
	  var m, l;
	  format = (format + "").trim().toLowerCase();
	  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
	      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
	      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
	      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
	      : null) // invalid hex
	      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
	      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	      : null;
	}

	function rgbn(n) {
	  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	}

	function rgba(r, g, b, a) {
	  if (a <= 0) r = g = b = NaN;
	  return new Rgb(r, g, b, a);
	}

	function rgbConvert(o) {
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Rgb;
	  o = o.rgb();
	  return new Rgb(o.r, o.g, o.b, o.opacity);
	}

	function rgb(r, g, b, opacity) {
	  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	}

	function Rgb(r, g, b, opacity) {
	  this.r = +r;
	  this.g = +g;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Rgb, rgb, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  rgb: function() {
	    return this;
	  },
	  displayable: function() {
	    return (-0.5 <= this.r && this.r < 255.5)
	        && (-0.5 <= this.g && this.g < 255.5)
	        && (-0.5 <= this.b && this.b < 255.5)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: rgb_formatHex,
	  formatRgb: rgb_formatRgb,
	  toString: rgb_formatRgb
	}));

	function rgb_formatHex() {
	  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
	}

	function rgb_formatRgb() {
	  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	  return (a === 1 ? "rgb(" : "rgba(")
	      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	      + (a === 1 ? ")" : ", " + a + ")");
	}

	function hex(value) {
	  value = Math.max(0, Math.min(255, Math.round(value) || 0));
	  return (value < 16 ? "0" : "") + value.toString(16);
	}

	function hsla(h, s, l, a) {
	  if (a <= 0) h = s = l = NaN;
	  else if (l <= 0 || l >= 1) h = s = NaN;
	  else if (s <= 0) h = NaN;
	  return new Hsl(h, s, l, a);
	}

	function hslConvert(o) {
	  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Hsl;
	  if (o instanceof Hsl) return o;
	  o = o.rgb();
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      h = NaN,
	      s = max - min,
	      l = (max + min) / 2;
	  if (s) {
	    if (r === max) h = (g - b) / s + (g < b) * 6;
	    else if (g === max) h = (b - r) / s + 2;
	    else h = (r - g) / s + 4;
	    s /= l < 0.5 ? max + min : 2 - max - min;
	    h *= 60;
	  } else {
	    s = l > 0 && l < 1 ? 0 : h;
	  }
	  return new Hsl(h, s, l, o.opacity);
	}

	function hsl(h, s, l, opacity) {
	  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	}

	function Hsl(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hsl, hsl, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = this.h % 360 + (this.h < 0) * 360,
	        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	        l = this.l,
	        m2 = l + (l < 0.5 ? l : 1 - l) * s,
	        m1 = 2 * l - m2;
	    return new Rgb(
	      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	      hsl2rgb(h, m1, m2),
	      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	      this.opacity
	    );
	  },
	  displayable: function() {
	    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	        && (0 <= this.l && this.l <= 1)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  formatHsl: function() {
	    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	    return (a === 1 ? "hsl(" : "hsla(")
	        + (this.h || 0) + ", "
	        + (this.s || 0) * 100 + "%, "
	        + (this.l || 0) * 100 + "%"
	        + (a === 1 ? ")" : ", " + a + ")");
	  }
	}));

	/* From FvD 13.37, CSS Color Module Level 3 */
	function hsl2rgb(h, m1, m2) {
	  return (h < 60 ? m1 + (m2 - m1) * h / 60
	      : h < 180 ? m2
	      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	      : m1) * 255;
	}

	function distance$1(x1, y1, x2, y2) {
	    var dx = x1 - x2;
	    var dy = y1 - y2;
	    return Math.sqrt(dx * dx + dy * dy);
	}
	function getBBoxByArray(xArr, yArr) {
	    var minX = Math.min.apply(Math, __spreadArray([], __read(xArr), false));
	    var minY = Math.min.apply(Math, __spreadArray([], __read(yArr), false));
	    var maxX = Math.max.apply(Math, __spreadArray([], __read(xArr), false));
	    var maxY = Math.max.apply(Math, __spreadArray([], __read(yArr), false));
	    return {
	        x: minX,
	        y: minY,
	        width: maxX - minX,
	        height: maxY - minY,
	    };
	}
	// x 的极值
	function xExtrema(rx, ry, xRotation) {
	    return Math.atan((-ry / rx) * Math.tan(xRotation));
	}
	// y 的极值
	function yExtrema(rx, ry, xRotation) {
	    return Math.atan(ry / (rx * Math.tan(xRotation)));
	}
	// 根据角度求 x 坐标
	function xAt(cx, cy, rx, ry, xRotation, angle) {
	    return (rx * Math.cos(xRotation) * Math.cos(angle) -
	        ry * Math.sin(xRotation) * Math.sin(angle) +
	        cx);
	}
	// 根据角度求 y 坐标
	function yAt(cx, cy, rx, ry, xRotation, angle) {
	    return (rx * Math.sin(xRotation) * Math.cos(angle) +
	        ry * Math.cos(xRotation) * Math.sin(angle) +
	        cy);
	}
	function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
	    var xDim = xExtrema(rx, ry, xRotation);
	    var minX = Infinity;
	    var maxX = -Infinity;
	    var xs = [startAngle, endAngle];
	    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
	        var xAngle = xDim + i;
	        if (startAngle < endAngle) {
	            if (startAngle < xAngle && xAngle < endAngle) {
	                xs.push(xAngle);
	            }
	        }
	        else {
	            if (endAngle < xAngle && xAngle < startAngle) {
	                xs.push(xAngle);
	            }
	        }
	    }
	    for (var i = 0; i < xs.length; i++) {
	        var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
	        if (x < minX) {
	            minX = x;
	        }
	        if (x > maxX) {
	            maxX = x;
	        }
	    }
	    var yDim = yExtrema(rx, ry, xRotation);
	    var minY = Infinity;
	    var maxY = -Infinity;
	    var ys = [startAngle, endAngle];
	    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
	        var yAngle = yDim + i;
	        if (startAngle < endAngle) {
	            if (startAngle < yAngle && yAngle < endAngle) {
	                ys.push(yAngle);
	            }
	        }
	        else {
	            if (endAngle < yAngle && yAngle < startAngle) {
	                ys.push(yAngle);
	            }
	        }
	    }
	    for (var i = 0; i < ys.length; i++) {
	        var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
	        if (y < minY) {
	            minY = y;
	        }
	        if (y > maxY) {
	            maxY = y;
	        }
	    }
	    return {
	        x: minX,
	        y: minY,
	        width: maxX - minX,
	        height: maxY - minY,
	    };
	}

	var EPSILON$1 = 0.0001;
	/**
	 * 使用牛顿切割法求最近的点
	 * @param {number[]} xArr      点的 x 数组
	 * @param {number[]} yArr      点的 y 数组
	 * @param {number}   x         指定的点 x
	 * @param {number}   y         指定的点 y
	 * @param {Function} tCallback 差值函数
	 */
	function nearestPoint$2(xArr, yArr, x, y, tCallback, length) {
	    var t = -1;
	    var d = Infinity;
	    var v0 = [x, y];
	    var segNum = 20;
	    if (length && length > 200) {
	        segNum = length / 10;
	    }
	    var increaseRate = 1 / segNum;
	    var interval = increaseRate / 10;
	    for (var i = 0; i <= segNum; i++) {
	        var _t = i * increaseRate;
	        var v1 = [
	            tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([_t])), false)),
	            tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([_t])), false)),
	        ];
	        var d1 = distance$1(v0[0], v0[1], v1[0], v1[1]);
	        if (d1 < d) {
	            t = _t;
	            d = d1;
	        }
	    }
	    // 提前终止
	    if (t === 0) {
	        return {
	            x: xArr[0],
	            y: yArr[0],
	        };
	    }
	    if (t === 1) {
	        var count = xArr.length;
	        return {
	            x: xArr[count - 1],
	            y: yArr[count - 1],
	        };
	    }
	    d = Infinity;
	    for (var i = 0; i < 32; i++) {
	        if (interval < EPSILON$1) {
	            break;
	        }
	        var prev = t - interval;
	        var next = t + interval;
	        var v1 = [
	            tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([prev])), false)),
	            tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([prev])), false)),
	        ];
	        var d1 = distance$1(v0[0], v0[1], v1[0], v1[1]);
	        if (prev >= 0 && d1 < d) {
	            t = prev;
	            d = d1;
	        }
	        else {
	            var v2 = [
	                tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([next])), false)),
	                tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([next])), false)),
	            ];
	            var d2 = distance$1(v0[0], v0[1], v2[0], v2[1]);
	            if (next <= 1 && d2 < d) {
	                t = next;
	                d = d2;
	            }
	            else {
	                interval *= 0.5;
	            }
	        }
	    }
	    return {
	        x: tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([t])), false)),
	        y: tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([t])), false)),
	    };
	}
	function length$4(x1, y1, x2, y2) {
	    return distance$1(x1, y1, x2, y2);
	}
	function pointAt$3(x1, y1, x2, y2, t) {
	    return {
	        x: (1 - t) * x1 + t * x2,
	        y: (1 - t) * y1 + t * y2,
	    };
	}
	function pointToLine(x1, y1, x2, y2, x, y) {
	    var d = [x2 - x1, y2 - y1];
	    // 如果端点相等，则判定点到点的距离
	    if (exactEquals$1(d, [0, 0])) {
	        return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
	    }
	    var u = [-d[1], d[0]];
	    normalize$3(u, u);
	    var a = [x - x1, y - y1];
	    return Math.abs(dot$1(a, u));
	}

	function cubicAt(p0, p1, p2, p3, t) {
	    var onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍
	    return (onet * onet * onet * p0 +
	        3 * p1 * t * onet * onet +
	        3 * p2 * t * t * onet +
	        p3 * t * t * t);
	}
	function extrema$1(p0, p1, p2, p3) {
	    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
	    var b = 6 * p0 - 12 * p1 + 6 * p2;
	    var c = 3 * p1 - 3 * p0;
	    var extremas = [];
	    var t1;
	    var t2;
	    var discSqrt;
	    if (isNumberEqual(a, 0)) {
	        if (!isNumberEqual(b, 0)) {
	            t1 = -c / b;
	            if (t1 >= 0 && t1 <= 1) {
	                extremas.push(t1);
	            }
	        }
	    }
	    else {
	        var disc = b * b - 4 * a * c;
	        if (isNumberEqual(disc, 0)) {
	            extremas.push(-b / (2 * a));
	        }
	        else if (disc > 0) {
	            discSqrt = Math.sqrt(disc);
	            t1 = (-b + discSqrt) / (2 * a);
	            t2 = (-b - discSqrt) / (2 * a);
	            if (t1 >= 0 && t1 <= 1) {
	                extremas.push(t1);
	            }
	            if (t2 >= 0 && t2 <= 1) {
	                extremas.push(t2);
	            }
	        }
	    }
	    return extremas;
	}
	function box$3(x1, y1, x2, y2, x3, y3, x4, y4) {
	    var xArr = [x1, x4];
	    var yArr = [y1, y4];
	    var xExtrema = extrema$1(x1, x2, x3, x4);
	    var yExtrema = extrema$1(y1, y2, y3, y4);
	    for (var i = 0; i < xExtrema.length; i++) {
	        xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));
	    }
	    for (var i = 0; i < yExtrema.length; i++) {
	        yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));
	    }
	    return getBBoxByArray(xArr, yArr);
	}
	function nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
	    return nearestPoint$2([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);
	}
	function pointDistance$3(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
	    var point = nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);
	    return distance$1(point.x, point.y, x0, y0);
	}
	function lengthOfSegment(points) {
	    if (points.length < 2) {
	        return 0;
	    }
	    var totalLength = 0;
	    for (var i = 0; i < points.length - 1; i++) {
	        var from = points[i];
	        var to = points[i + 1];
	        totalLength += distance$1(from[0], from[1], to[0], to[1]);
	    }
	    return totalLength;
	}
	function length$2(points) {
	    return lengthOfSegment(points);
	}

	// 差值公式
	function quadraticAt(p0, p1, p2, t) {
	    var onet = 1 - t;
	    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
	}
	// 求极值
	function extrema(p0, p1, p2) {
	    var a = p0 + p2 - 2 * p1;
	    if (isNumberEqual(a, 0)) {
	        return [0.5];
	    }
	    var rst = (p0 - p1) / a;
	    if (rst <= 1 && rst >= 0) {
	        return [rst];
	    }
	    return [];
	}
	function box(x1, y1, x2, y2, x3, y3) {
	    var xExtrema = extrema(x1, x2, x3)[0];
	    var yExtrema = extrema(y1, y2, y3)[0];
	    // 控制点不加入 box 的计算
	    var xArr = [x1, x3];
	    var yArr = [y1, y3];
	    if (xExtrema !== undefined) {
	        xArr.push(quadraticAt(x1, x2, x3, xExtrema));
	    }
	    if (yExtrema !== undefined) {
	        yArr.push(quadraticAt(y1, y2, y3, yExtrema));
	    }
	    return getBBoxByArray(xArr, yArr);
	}
	function nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0) {
	    return nearestPoint$2([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
	}
	function pointDistance(x1, y1, x2, y2, x3, y3, x0, y0) {
	    var point = nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
	    return distance$1(point.x, point.y, x0, y0);
	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var rbush = {exports: {}};

	(function (module, exports) {
	(function (global, factory) {
	module.exports = factory() ;
	}(commonjsGlobal, function () {
	function quickselect(arr, k, left, right, compare) {
	    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
	}

	function quickselectStep(arr, k, left, right, compare) {

	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            quickselectStep(arr, k, newLeft, newRight, compare);
	        }

	        var t = arr[k];
	        var i = left;
	        var j = right;

	        swap(arr, left, k);
	        if (compare(arr[right], t) > 0) { swap(arr, left, right); }

	        while (i < j) {
	            swap(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) { i++; }
	            while (compare(arr[j], t) > 0) { j--; }
	        }

	        if (compare(arr[left], t) === 0) { swap(arr, left, j); }
	        else {
	            j++;
	            swap(arr, j, right);
	        }

	        if (j <= k) { left = j + 1; }
	        if (k <= j) { right = j - 1; }
	    }
	}

	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function defaultCompare(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	var RBush = function RBush(maxEntries) {
	    if ( maxEntries === void 0 ) maxEntries = 9;

	    // max entries in a node is 9 by default; min node fill is 40% for best performance
	    this._maxEntries = Math.max(4, maxEntries);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
	    this.clear();
	};

	RBush.prototype.all = function all () {
	    return this._all(this.data, []);
	};

	RBush.prototype.search = function search (bbox) {
	    var node = this.data;
	    var result = [];

	    if (!intersects(bbox, node)) { return result; }

	    var toBBox = this.toBBox;
	    var nodesToSearch = [];

	    while (node) {
	        for (var i = 0; i < node.children.length; i++) {
	            var child = node.children[i];
	            var childBBox = node.leaf ? toBBox(child) : child;

	            if (intersects(bbox, childBBox)) {
	                if (node.leaf) { result.push(child); }
	                else if (contains(bbox, childBBox)) { this._all(child, result); }
	                else { nodesToSearch.push(child); }
	            }
	        }
	        node = nodesToSearch.pop();
	    }

	    return result;
	};

	RBush.prototype.collides = function collides (bbox) {
	    var node = this.data;

	    if (!intersects(bbox, node)) { return false; }

	    var nodesToSearch = [];
	    while (node) {
	        for (var i = 0; i < node.children.length; i++) {
	            var child = node.children[i];
	            var childBBox = node.leaf ? this.toBBox(child) : child;

	            if (intersects(bbox, childBBox)) {
	                if (node.leaf || contains(bbox, childBBox)) { return true; }
	                nodesToSearch.push(child);
	            }
	        }
	        node = nodesToSearch.pop();
	    }

	    return false;
	};

	RBush.prototype.load = function load (data) {
	    if (!(data && data.length)) { return this; }

	    if (data.length < this._minEntries) {
	        for (var i = 0; i < data.length; i++) {
	            this.insert(data[i]);
	        }
	        return this;
	    }

	    // recursively build the tree with the given data from scratch using OMT algorithm
	    var node = this._build(data.slice(), 0, data.length - 1, 0);

	    if (!this.data.children.length) {
	        // save as is if tree is empty
	        this.data = node;

	    } else if (this.data.height === node.height) {
	        // split root if trees have the same height
	        this._splitRoot(this.data, node);

	    } else {
	        if (this.data.height < node.height) {
	            // swap trees if inserted one is bigger
	            var tmpNode = this.data;
	            this.data = node;
	            node = tmpNode;
	        }

	        // insert the small tree into the large tree at appropriate level
	        this._insert(node, this.data.height - node.height - 1, true);
	    }

	    return this;
	};

	RBush.prototype.insert = function insert (item) {
	    if (item) { this._insert(item, this.data.height - 1); }
	    return this;
	};

	RBush.prototype.clear = function clear () {
	    this.data = createNode([]);
	    return this;
	};

	RBush.prototype.remove = function remove (item, equalsFn) {
	    if (!item) { return this; }

	    var node = this.data;
	    var bbox = this.toBBox(item);
	    var path = [];
	    var indexes = [];
	    var i, parent, goingUp;

	    // depth-first iterative tree traversal
	    while (node || path.length) {

	        if (!node) { // go up
	            node = path.pop();
	            parent = path[path.length - 1];
	            i = indexes.pop();
	            goingUp = true;
	        }

	        if (node.leaf) { // check current node
	            var index = findItem(item, node.children, equalsFn);

	            if (index !== -1) {
	                // item found, remove the item and condense tree upwards
	                node.children.splice(index, 1);
	                path.push(node);
	                this._condense(path);
	                return this;
	            }
	        }

	        if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
	            path.push(node);
	            indexes.push(i);
	            i = 0;
	            parent = node;
	            node = node.children[0];

	        } else if (parent) { // go right
	            i++;
	            node = parent.children[i];
	            goingUp = false;

	        } else { node = null; } // nothing found
	    }

	    return this;
	};

	RBush.prototype.toBBox = function toBBox (item) { return item; };

	RBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };
	RBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };

	RBush.prototype.toJSON = function toJSON () { return this.data; };

	RBush.prototype.fromJSON = function fromJSON (data) {
	    this.data = data;
	    return this;
	};

	RBush.prototype._all = function _all (node, result) {
	    var nodesToSearch = [];
	    while (node) {
	        if (node.leaf) { result.push.apply(result, node.children); }
	        else { nodesToSearch.push.apply(nodesToSearch, node.children); }

	        node = nodesToSearch.pop();
	    }
	    return result;
	};

	RBush.prototype._build = function _build (items, left, right, height) {

	    var N = right - left + 1;
	    var M = this._maxEntries;
	    var node;

	    if (N <= M) {
	        // reached leaf level; return leaf
	        node = createNode(items.slice(left, right + 1));
	        calcBBox(node, this.toBBox);
	        return node;
	    }

	    if (!height) {
	        // target height of the bulk-loaded tree
	        height = Math.ceil(Math.log(N) / Math.log(M));

	        // target number of root entries to maximize storage utilization
	        M = Math.ceil(N / Math.pow(M, height - 1));
	    }

	    node = createNode([]);
	    node.leaf = false;
	    node.height = height;

	    // split the items into M mostly square tiles

	    var N2 = Math.ceil(N / M);
	    var N1 = N2 * Math.ceil(Math.sqrt(M));

	    multiSelect(items, left, right, N1, this.compareMinX);

	    for (var i = left; i <= right; i += N1) {

	        var right2 = Math.min(i + N1 - 1, right);

	        multiSelect(items, i, right2, N2, this.compareMinY);

	        for (var j = i; j <= right2; j += N2) {

	            var right3 = Math.min(j + N2 - 1, right2);

	            // pack each entry recursively
	            node.children.push(this._build(items, j, right3, height - 1));
	        }
	    }

	    calcBBox(node, this.toBBox);

	    return node;
	};

	RBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {
	    while (true) {
	        path.push(node);

	        if (node.leaf || path.length - 1 === level) { break; }

	        var minArea = Infinity;
	        var minEnlargement = Infinity;
	        var targetNode = (void 0);

	        for (var i = 0; i < node.children.length; i++) {
	            var child = node.children[i];
	            var area = bboxArea(child);
	            var enlargement = enlargedArea(bbox, child) - area;

	            // choose entry with the least area enlargement
	            if (enlargement < minEnlargement) {
	                minEnlargement = enlargement;
	                minArea = area < minArea ? area : minArea;
	                targetNode = child;

	            } else if (enlargement === minEnlargement) {
	                // otherwise choose one with the smallest area
	                if (area < minArea) {
	                    minArea = area;
	                    targetNode = child;
	                }
	            }
	        }

	        node = targetNode || node.children[0];
	    }

	    return node;
	};

	RBush.prototype._insert = function _insert (item, level, isNode) {
	    var bbox = isNode ? item : this.toBBox(item);
	    var insertPath = [];

	    // find the best node for accommodating the item, saving all nodes along the path too
	    var node = this._chooseSubtree(bbox, this.data, level, insertPath);

	    // put the item into the node
	    node.children.push(item);
	    extend(node, bbox);

	    // split on node overflow; propagate upwards if necessary
	    while (level >= 0) {
	        if (insertPath[level].children.length > this._maxEntries) {
	            this._split(insertPath, level);
	            level--;
	        } else { break; }
	    }

	    // adjust bboxes along the insertion path
	    this._adjustParentBBoxes(bbox, insertPath, level);
	};

	// split overflowed node into two
	RBush.prototype._split = function _split (insertPath, level) {
	    var node = insertPath[level];
	    var M = node.children.length;
	    var m = this._minEntries;

	    this._chooseSplitAxis(node, m, M);

	    var splitIndex = this._chooseSplitIndex(node, m, M);

	    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
	    newNode.height = node.height;
	    newNode.leaf = node.leaf;

	    calcBBox(node, this.toBBox);
	    calcBBox(newNode, this.toBBox);

	    if (level) { insertPath[level - 1].children.push(newNode); }
	    else { this._splitRoot(node, newNode); }
	};

	RBush.prototype._splitRoot = function _splitRoot (node, newNode) {
	    // split root node
	    this.data = createNode([node, newNode]);
	    this.data.height = node.height + 1;
	    this.data.leaf = false;
	    calcBBox(this.data, this.toBBox);
	};

	RBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {
	    var index;
	    var minOverlap = Infinity;
	    var minArea = Infinity;

	    for (var i = m; i <= M - m; i++) {
	        var bbox1 = distBBox(node, 0, i, this.toBBox);
	        var bbox2 = distBBox(node, i, M, this.toBBox);

	        var overlap = intersectionArea(bbox1, bbox2);
	        var area = bboxArea(bbox1) + bboxArea(bbox2);

	        // choose distribution with minimum overlap
	        if (overlap < minOverlap) {
	            minOverlap = overlap;
	            index = i;

	            minArea = area < minArea ? area : minArea;

	        } else if (overlap === minOverlap) {
	            // otherwise choose distribution with minimum area
	            if (area < minArea) {
	                minArea = area;
	                index = i;
	            }
	        }
	    }

	    return index || M - m;
	};

	// sorts node children by the best axis for split
	RBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {
	    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
	    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
	    var xMargin = this._allDistMargin(node, m, M, compareMinX);
	    var yMargin = this._allDistMargin(node, m, M, compareMinY);

	    // if total distributions margin value is minimal for x, sort by minX,
	    // otherwise it's already sorted by minY
	    if (xMargin < yMargin) { node.children.sort(compareMinX); }
	};

	// total margin of all possible split distributions where each node is at least m full
	RBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {
	    node.children.sort(compare);

	    var toBBox = this.toBBox;
	    var leftBBox = distBBox(node, 0, m, toBBox);
	    var rightBBox = distBBox(node, M - m, M, toBBox);
	    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

	    for (var i = m; i < M - m; i++) {
	        var child = node.children[i];
	        extend(leftBBox, node.leaf ? toBBox(child) : child);
	        margin += bboxMargin(leftBBox);
	    }

	    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
	        var child$1 = node.children[i$1];
	        extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
	        margin += bboxMargin(rightBBox);
	    }

	    return margin;
	};

	RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {
	    // adjust bboxes along the given tree path
	    for (var i = level; i >= 0; i--) {
	        extend(path[i], bbox);
	    }
	};

	RBush.prototype._condense = function _condense (path) {
	    // go through the path, removing empty nodes and updating bboxes
	    for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {
	        if (path[i].children.length === 0) {
	            if (i > 0) {
	                siblings = path[i - 1].children;
	                siblings.splice(siblings.indexOf(path[i]), 1);

	            } else { this.clear(); }

	        } else { calcBBox(path[i], this.toBBox); }
	    }
	};

	function findItem(item, items, equalsFn) {
	    if (!equalsFn) { return items.indexOf(item); }

	    for (var i = 0; i < items.length; i++) {
	        if (equalsFn(item, items[i])) { return i; }
	    }
	    return -1;
	}

	// calculate node's bbox from bboxes of its children
	function calcBBox(node, toBBox) {
	    distBBox(node, 0, node.children.length, toBBox, node);
	}

	// min bounding rectangle of node children from k to p-1
	function distBBox(node, k, p, toBBox, destNode) {
	    if (!destNode) { destNode = createNode(null); }
	    destNode.minX = Infinity;
	    destNode.minY = Infinity;
	    destNode.maxX = -Infinity;
	    destNode.maxY = -Infinity;

	    for (var i = k; i < p; i++) {
	        var child = node.children[i];
	        extend(destNode, node.leaf ? toBBox(child) : child);
	    }

	    return destNode;
	}

	function extend(a, b) {
	    a.minX = Math.min(a.minX, b.minX);
	    a.minY = Math.min(a.minY, b.minY);
	    a.maxX = Math.max(a.maxX, b.maxX);
	    a.maxY = Math.max(a.maxY, b.maxY);
	    return a;
	}

	function compareNodeMinX(a, b) { return a.minX - b.minX; }
	function compareNodeMinY(a, b) { return a.minY - b.minY; }

	function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
	function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

	function enlargedArea(a, b) {
	    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
	           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
	}

	function intersectionArea(a, b) {
	    var minX = Math.max(a.minX, b.minX);
	    var minY = Math.max(a.minY, b.minY);
	    var maxX = Math.min(a.maxX, b.maxX);
	    var maxY = Math.min(a.maxY, b.maxY);

	    return Math.max(0, maxX - minX) *
	           Math.max(0, maxY - minY);
	}

	function contains(a, b) {
	    return a.minX <= b.minX &&
	           a.minY <= b.minY &&
	           b.maxX <= a.maxX &&
	           b.maxY <= a.maxY;
	}

	function intersects(a, b) {
	    return b.minX <= a.maxX &&
	           b.minY <= a.maxY &&
	           b.maxX >= a.minX &&
	           b.maxY >= a.minY;
	}

	function createNode(children) {
	    return {
	        children: children,
	        height: 1,
	        leaf: true,
	        minX: Infinity,
	        minY: Infinity,
	        maxX: -Infinity,
	        maxY: -Infinity
	    };
	}

	// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
	// combines selection algorithm with binary divide & conquer approach

	function multiSelect(arr, left, right, n, compare) {
	    var stack = [left, right];

	    while (stack.length) {
	        right = stack.pop();
	        left = stack.pop();

	        if (right - left <= n) { continue; }

	        var mid = left + Math.ceil((right - left) / n / 2) * n;
	        quickselect(arr, mid, left, right, compare);

	        stack.push(left, mid, mid, right);
	    }
	}

	return RBush;

	}));
	}(rbush));

	var RBush = rbush.exports;

	var Shape;
	(function (Shape) {
	    Shape["GROUP"] = "g";
	    Shape["CIRCLE"] = "circle";
	    Shape["ELLIPSE"] = "ellipse";
	    Shape["IMAGE"] = "image";
	    Shape["RECT"] = "rect";
	    Shape["LINE"] = "line";
	    Shape["POLYLINE"] = "polyline";
	    Shape["POLYGON"] = "polygon";
	    Shape["TEXT"] = "text";
	    Shape["PATH"] = "path";
	    Shape["HTML"] = "html";
	    Shape["MESH"] = "mesh";
	})(Shape || (Shape = {}));
	var ClipSpaceNearZ;
	(function (ClipSpaceNearZ) {
	    ClipSpaceNearZ[ClipSpaceNearZ["ZERO"] = 0] = "ZERO";
	    ClipSpaceNearZ[ClipSpaceNearZ["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
	})(ClipSpaceNearZ || (ClipSpaceNearZ = {}));

	var AbstractRendererPlugin = /** @class */ (function () {
	    function AbstractRendererPlugin() {
	        this.plugins = [];
	    }
	    AbstractRendererPlugin.prototype.addRenderingPlugin = function (plugin) {
	        this.plugins.push(plugin);
	        this.context.renderingPlugins.push(plugin);
	    };
	    AbstractRendererPlugin.prototype.removeAllRenderingPlugins = function () {
	        var _this = this;
	        this.plugins.forEach(function (plugin) {
	            var index = _this.context.renderingPlugins.indexOf(plugin);
	            if (index >= 0) {
	                _this.context.renderingPlugins.splice(index, 1);
	            }
	        });
	    };
	    return AbstractRendererPlugin;
	}());
	var AbstractRenderer = /** @class */ (function () {
	    function AbstractRenderer(config) {
	        this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
	        this.plugins = [];
	        this.config = __assign({ 
	            /**
	             * only dirty object will cause re-render
	             */
	            enableDirtyCheck: true, enableCulling: false, 
	            /**
	             * enable auto rendering by default
	             */
	            enableAutoRendering: true, 
	            /**
	             * enable dirty rectangle rendering by default
	             */
	            enableDirtyRectangleRendering: true, enableDirtyRectangleRenderingDebug: false }, config);
	    }
	    AbstractRenderer.prototype.registerPlugin = function (plugin) {
	        var index = this.plugins.findIndex(function (p) { return p === plugin; });
	        if (index === -1) {
	            this.plugins.push(plugin);
	        }
	    };
	    AbstractRenderer.prototype.unregisterPlugin = function (plugin) {
	        var index = this.plugins.findIndex(function (p) { return p === plugin; });
	        if (index > -1) {
	            this.plugins.splice(index, 1);
	        }
	    };
	    AbstractRenderer.prototype.getPlugins = function () {
	        return this.plugins;
	    };
	    AbstractRenderer.prototype.getPlugin = function (name) {
	        return this.plugins.find(function (plugin) { return plugin.name === name; });
	    };
	    AbstractRenderer.prototype.getConfig = function () {
	        return this.config;
	    };
	    AbstractRenderer.prototype.setConfig = function (config) {
	        Object.assign(this.config, config);
	    };
	    return AbstractRenderer;
	}());

	function copyVec3(a, b) {
	    a[0] = b[0];
	    a[1] = b[1];
	    a[2] = b[2];
	    return a;
	}
	function subVec3(o, a, b) {
	    o[0] = a[0] - b[0];
	    o[1] = a[1] - b[1];
	    o[2] = a[2] - b[2];
	    return o;
	}
	function addVec3(o, a, b) {
	    o[0] = a[0] + b[0];
	    o[1] = a[1] + b[1];
	    o[2] = a[2] + b[2];
	    return o;
	}
	function scaleVec3(o, a, b) {
	    o[0] = a[0] * b;
	    o[1] = a[1] * b;
	    o[2] = a[2] * b;
	    return o;
	}
	function maxVec3(o, a, b) {
	    o[0] = Math.max(a[0], b[0]);
	    o[1] = Math.max(a[1], b[1]);
	    o[2] = Math.max(a[2], b[2]);
	    return o;
	}
	function minVec3(o, a, b) {
	    o[0] = Math.min(a[0], b[0]);
	    o[1] = Math.min(a[1], b[1]);
	    o[2] = Math.min(a[2], b[2]);
	    return o;
	}
	function getAngle(angle) {
	    if (angle === undefined) {
	        return 0;
	    }
	    else if (angle > 360 || angle < -360) {
	        return angle % 360;
	    }
	    return angle;
	}
	function createVec3(x, y, z) {
	    if (y === void 0) { y = 0; }
	    if (z === void 0) { z = 0; }
	    if (Array.isArray(x) && x.length === 3) {
	        return clone$1(x);
	    }
	    if (isNumber(x)) {
	        return fromValues$2(x, y, z);
	    }
	    return fromValues$2(x[0], x[1] || y, x[2] || z);
	}
	function deg2rad(deg) {
	    return deg * (Math.PI / 180);
	}
	function rad2deg(rad) {
	    return rad * (180 / Math.PI);
	}
	function turn2deg(turn) {
	    return 360 * turn;
	}
	function getEulerFromQuat(out, quat) {
	    var x = quat[0];
	    var y = quat[1];
	    var z = quat[2];
	    var w = quat[3];
	    var x2 = x * x;
	    var y2 = y * y;
	    var z2 = z * z;
	    var w2 = w * w;
	    var unit = x2 + y2 + z2 + w2;
	    var test = x * w - y * z;
	    if (test > 0.499995 * unit) {
	        // TODO: Use glmatrix.EPSILON
	        // singularity at the north pole
	        out[0] = Math.PI / 2;
	        out[1] = 2 * Math.atan2(y, x);
	        out[2] = 0;
	    }
	    else if (test < -0.499995 * unit) {
	        //TODO: Use glmatrix.EPSILON
	        // singularity at the south pole
	        out[0] = -Math.PI / 2;
	        out[1] = 2 * Math.atan2(y, x);
	        out[2] = 0;
	    }
	    else {
	        out[0] = Math.asin(2 * (x * z - w * y));
	        out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));
	        out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));
	    }
	    // TODO: Return them as degrees and not as radians
	    return out;
	}
	function getEulerFromMat4(out, m) {
	    var x;
	    var z;
	    var halfPi = Math.PI * 0.5;
	    var _a = __read(getScaling(create$2(), m), 3), sx = _a[0], sy = _a[1], sz = _a[2];
	    var y = Math.asin(-m[2] / sx);
	    if (y < halfPi) {
	        if (y > -halfPi) {
	            x = Math.atan2(m[6] / sy, m[10] / sz);
	            z = Math.atan2(m[1] / sx, m[0] / sx);
	        }
	        else {
	            // Not a unique solution
	            z = 0;
	            x = -Math.atan2(m[4] / sy, m[5] / sy);
	        }
	    }
	    else {
	        // Not a unique solution
	        z = 0;
	        x = Math.atan2(m[4] / sy, m[5] / sy);
	    }
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	}
	/**
	 * @see https://github.com/toji/gl-matrix/issues/329
	 * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions
	 */
	function getEuler(out, quat) {
	    if (quat.length === 16) {
	        return getEulerFromMat4(out, quat);
	    }
	    else {
	        return getEulerFromQuat(out, quat);
	    }
	}
	function fromRotationTranslationScale$1(rotation, x, y, scaleX, scaleY) {
	    var cos = Math.cos(rotation);
	    var sin = Math.sin(rotation);
	    return fromValues(scaleX * cos, scaleY * sin, 0, -scaleX * sin, scaleY * cos, 0, x, y, 1);
	}
	function makePerspective(out, left, right, top, bottom, near, far, zero) {
	    if (zero === void 0) { zero = false; }
	    var x = (2 * near) / (right - left);
	    var y = (2 * near) / (top - bottom);
	    var a = (right + left) / (right - left);
	    var b = (top + bottom) / (top - bottom);
	    var c;
	    var d;
	    if (zero) {
	        c = -far / (far - near);
	        d = (-far * near) / (far - near);
	    }
	    else {
	        c = -(far + near) / (far - near);
	        d = (-2 * far * near) / (far - near);
	    }
	    out[0] = x;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = y;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = a;
	    out[9] = b;
	    out[10] = c;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = d;
	    out[15] = 0;
	    return out;
	}
	function decompose(mat) {
	    var row0x = mat[0];
	    var row0y = mat[1];
	    var row1x = mat[3];
	    var row1y = mat[4];
	    // decompose 3x3 matrix
	    // @see https://www.w3.org/TR/css-transforms-1/#decomposing-a-2d-matrix
	    var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
	    var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
	    // If determinant is negative, one axis was flipped.
	    var determinant = row0x * row1y - row0y * row1x;
	    if (determinant < 0) {
	        // Flip axis with minimum unit vector dot product.
	        if (row0x < row1y) {
	            scalingX = -scalingX;
	        }
	        else {
	            scalingY = -scalingY;
	        }
	    }
	    // Renormalize matrix to remove scale.
	    if (scalingX) {
	        row0x *= 1 / scalingX;
	        row0y *= 1 / scalingX;
	    }
	    if (scalingY) {
	        row1x *= 1 / scalingY;
	        row1y *= 1 / scalingY;
	    }
	    // Compute rotation and renormalize matrix.
	    var rotation = Math.atan2(row0y, row0x);
	    var angle = rad2deg(rotation);
	    return [mat[6], mat[7], scalingX, scalingY, angle];
	}
	var tmp = create$1();
	var perspectiveMatrix = create$1();
	var tmpVec4 = create$3();
	var row = [create$2(), create$2(), create$2()];
	var pdum3 = create$2();
	/*
	Input:  matrix      ; a 4x4 matrix
	Output: translation ; a 3 component vector
	        scale       ; a 3 component vector
	        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
	        perspective ; a 4 component vector
	        quaternion  ; a 4 component vector
	Returns false if the matrix cannot be decomposed, true if it can


	References:
	https://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js
	https://github.com/ChromiumWebApps/chromium/blob/master/ui/gfx/transform_util.cc
	http://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix
	*/
	function decomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {
	    //normalize, if not possible then bail out early
	    if (!normalize$4(tmp, matrix))
	        return false;
	    // perspectiveMatrix is used to solve for perspective, but it also provides
	    // an easy way to test for singularity of the upper 3x3 component.
	    copy(perspectiveMatrix, tmp);
	    perspectiveMatrix[3] = 0;
	    perspectiveMatrix[7] = 0;
	    perspectiveMatrix[11] = 0;
	    perspectiveMatrix[15] = 1;
	    // If the perspectiveMatrix is not invertible, we are also unable to
	    // decompose, so we'll bail early. Constant taken from SkMatrix44::invert.
	    if (Math.abs(determinant(perspectiveMatrix)) < 1e-8)
	        return false;
	    var a03 = tmp[3], a13 = tmp[7], a23 = tmp[11], a30 = tmp[12], a31 = tmp[13], a32 = tmp[14], a33 = tmp[15];
	    // First, isolate perspective.
	    if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
	        tmpVec4[0] = a03;
	        tmpVec4[1] = a13;
	        tmpVec4[2] = a23;
	        tmpVec4[3] = a33;
	        // Solve the equation by inverting perspectiveMatrix and multiplying
	        // rightHandSide by the inverse.
	        // resuing the perspectiveMatrix here since it's no longer needed
	        var ret = invert(perspectiveMatrix, perspectiveMatrix);
	        if (!ret)
	            return false;
	        transpose(perspectiveMatrix, perspectiveMatrix);
	        //multiply by transposed inverse perspective matrix, into perspective vec4
	        transformMat4$1(perspective, tmpVec4, perspectiveMatrix);
	    }
	    else {
	        //no perspective
	        perspective[0] = perspective[1] = perspective[2] = 0;
	        perspective[3] = 1;
	    }
	    // Next take care of translation
	    translation[0] = a30;
	    translation[1] = a31;
	    translation[2] = a32;
	    // Now get scale and shear. 'row' is a 3 element array of 3 component vectors
	    mat3from4(row, tmp);
	    // Compute X scale factor and normalize first row.
	    scale[0] = length(row[0]);
	    normalize(row[0], row[0]);
	    // Compute XY shear factor and make 2nd row orthogonal to 1st.
	    skew[0] = dot(row[0], row[1]);
	    combine(row[1], row[1], row[0], 1.0, -skew[0]);
	    // Now, compute Y scale and normalize 2nd row.
	    scale[1] = length(row[1]);
	    normalize(row[1], row[1]);
	    skew[0] /= scale[1];
	    // Compute XZ and YZ shears, orthogonalize 3rd row
	    skew[1] = dot(row[0], row[2]);
	    combine(row[2], row[2], row[0], 1.0, -skew[1]);
	    skew[2] = dot(row[1], row[2]);
	    combine(row[2], row[2], row[1], 1.0, -skew[2]);
	    // Next, get Z scale and normalize 3rd row.
	    scale[2] = length(row[2]);
	    normalize(row[2], row[2]);
	    skew[1] /= scale[2];
	    skew[2] /= scale[2];
	    // At this point, the matrix (in rows) is orthonormal.
	    // Check for a coordinate system flip.  If the determinant
	    // is -1, then negate the matrix and the scaling factors.
	    cross(pdum3, row[1], row[2]);
	    if (dot(row[0], pdum3) < 0) {
	        for (var i = 0; i < 3; i++) {
	            scale[i] *= -1;
	            row[i][0] *= -1;
	            row[i][1] *= -1;
	            row[i][2] *= -1;
	        }
	    }
	    // Now, get the rotations out
	    quaternion[0] =
	        0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
	    quaternion[1] =
	        0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
	    quaternion[2] =
	        0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
	    quaternion[3] =
	        0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
	    if (row[2][1] > row[1][2])
	        quaternion[0] = -quaternion[0];
	    if (row[0][2] > row[2][0])
	        quaternion[1] = -quaternion[1];
	    if (row[1][0] > row[0][1])
	        quaternion[2] = -quaternion[2];
	    return true;
	}
	function normalize$4(out, mat) {
	    var m44 = mat[15];
	    // Cannot normalize.
	    if (m44 === 0)
	        return false;
	    var scale = 1 / m44;
	    for (var i = 0; i < 16; i++)
	        out[i] = mat[i] * scale;
	    return true;
	}
	//gets upper-left of a 4x4 matrix into a 3x3 of vectors
	function mat3from4(out, mat4x4) {
	    out[0][0] = mat4x4[0];
	    out[0][1] = mat4x4[1];
	    out[0][2] = mat4x4[2];
	    out[1][0] = mat4x4[4];
	    out[1][1] = mat4x4[5];
	    out[1][2] = mat4x4[6];
	    out[2][0] = mat4x4[8];
	    out[2][1] = mat4x4[9];
	    out[2][2] = mat4x4[10];
	}
	function combine(out, a, b, scale1, scale2) {
	    out[0] = a[0] * scale1 + b[0] * scale2;
	    out[1] = a[1] * scale1 + b[1] * scale2;
	    out[2] = a[2] * scale1 + b[2] * scale2;
	}

	/**
	 * Axis-Aligned Bounding Box
	 * 为了便于后续 Frustum Culling，通过查找表定义 p-vertex 和 n-vertex
	 * @see https://github.com/antvis/GWebGPUEngine/issues/3
	 */
	var AABB = /** @class */ (function () {
	    function AABB() {
	        this.center = [0, 0, 0];
	        this.halfExtents = [0, 0, 0];
	        this.min = [0, 0, 0];
	        this.max = [0, 0, 0];
	    }
	    AABB.isEmpty = function (aabb) {
	        return (!aabb ||
	            (aabb.halfExtents[0] === 0 &&
	                aabb.halfExtents[1] === 0 &&
	                aabb.halfExtents[2] === 0));
	    };
	    // center: vec3 = vec3.create();
	    // halfExtents: vec3 = vec3.create();
	    // min: vec3 = vec3.create();
	    // max: vec3 = vec3.create();
	    AABB.prototype.update = function (center, halfExtents) {
	        copyVec3(this.center, center);
	        copyVec3(this.halfExtents, halfExtents);
	        subVec3(this.min, this.center, this.halfExtents);
	        addVec3(this.max, this.center, this.halfExtents);
	        // vec3.copy(this.center, center);
	        // vec3.copy(this.halfExtents, halfExtents);
	        // vec3.sub(this.min, this.center, this.halfExtents);
	        // vec3.add(this.max, this.center, this.halfExtents);
	    };
	    AABB.prototype.setMinMax = function (min, max) {
	        // vec3.add(this.center, max, min);
	        // vec3.scale(this.center, this.center, 0.5);
	        // vec3.sub(this.halfExtents, max, min);
	        // vec3.scale(this.halfExtents, this.halfExtents, 0.5);
	        // vec3.copy(this.min, min);
	        // vec3.copy(this.max, max);
	        addVec3(this.center, max, min);
	        scaleVec3(this.center, this.center, 0.5);
	        subVec3(this.halfExtents, max, min);
	        scaleVec3(this.halfExtents, this.halfExtents, 0.5);
	        copyVec3(this.min, min);
	        copyVec3(this.max, max);
	    };
	    AABB.prototype.getMin = function () {
	        return this.min;
	    };
	    AABB.prototype.getMax = function () {
	        return this.max;
	    };
	    AABB.prototype.add = function (aabb) {
	        if (AABB.isEmpty(aabb)) {
	            return;
	        }
	        if (AABB.isEmpty(this)) {
	            this.setMinMax(aabb.getMin(), aabb.getMax());
	            return;
	        }
	        var tc = this.center;
	        var tcx = tc[0];
	        var tcy = tc[1];
	        var tcz = tc[2];
	        var th = this.halfExtents;
	        var thx = th[0];
	        var thy = th[1];
	        var thz = th[2];
	        var tminx = tcx - thx;
	        var tmaxx = tcx + thx;
	        var tminy = tcy - thy;
	        var tmaxy = tcy + thy;
	        var tminz = tcz - thz;
	        var tmaxz = tcz + thz;
	        var oc = aabb.center;
	        var ocx = oc[0];
	        var ocy = oc[1];
	        var ocz = oc[2];
	        var oh = aabb.halfExtents;
	        var ohx = oh[0];
	        var ohy = oh[1];
	        var ohz = oh[2];
	        var ominx = ocx - ohx;
	        var omaxx = ocx + ohx;
	        var ominy = ocy - ohy;
	        var omaxy = ocy + ohy;
	        var ominz = ocz - ohz;
	        var omaxz = ocz + ohz;
	        if (ominx < tminx) {
	            tminx = ominx;
	        }
	        if (omaxx > tmaxx) {
	            tmaxx = omaxx;
	        }
	        if (ominy < tminy) {
	            tminy = ominy;
	        }
	        if (omaxy > tmaxy) {
	            tmaxy = omaxy;
	        }
	        if (ominz < tminz) {
	            tminz = ominz;
	        }
	        if (omaxz > tmaxz) {
	            tmaxz = omaxz;
	        }
	        tc[0] = (tminx + tmaxx) * 0.5;
	        tc[1] = (tminy + tmaxy) * 0.5;
	        tc[2] = (tminz + tmaxz) * 0.5;
	        th[0] = (tmaxx - tminx) * 0.5;
	        th[1] = (tmaxy - tminy) * 0.5;
	        th[2] = (tmaxz - tminz) * 0.5;
	        this.min[0] = tminx;
	        this.min[1] = tminy;
	        this.min[2] = tminz;
	        this.max[0] = tmaxx;
	        this.max[1] = tmaxy;
	        this.max[2] = tmaxz;
	    };
	    AABB.prototype.setFromTransformedAABB = function (aabb, m) {
	        var bc = this.center;
	        var br = this.halfExtents;
	        var ac = aabb.center;
	        var ar = aabb.halfExtents;
	        var mx0 = m[0];
	        var mx1 = m[4];
	        var mx2 = m[8];
	        var my0 = m[1];
	        var my1 = m[5];
	        var my2 = m[9];
	        var mz0 = m[2];
	        var mz1 = m[6];
	        var mz2 = m[10];
	        var mx0a = Math.abs(mx0);
	        var mx1a = Math.abs(mx1);
	        var mx2a = Math.abs(mx2);
	        var my0a = Math.abs(my0);
	        var my1a = Math.abs(my1);
	        var my2a = Math.abs(my2);
	        var mz0a = Math.abs(mz0);
	        var mz1a = Math.abs(mz1);
	        var mz2a = Math.abs(mz2);
	        bc[0] = m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
	        bc[1] = m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
	        bc[2] = m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
	        // vec3.set(
	        //   bc,
	        //   m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2],
	        //   m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2],
	        //   m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2],
	        // );
	        br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
	        br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
	        br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
	        // vec3.set(
	        //   br,
	        //   mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2],
	        //   my0a * ar[0] + my1a * ar[1] + my2a * ar[2],
	        //   mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2],
	        // );
	        // this.min = vec3.sub(this.min, bc, br);
	        // this.max = vec3.add(this.max, bc, br);
	        subVec3(this.min, bc, br);
	        addVec3(this.max, bc, br);
	    };
	    AABB.prototype.intersects = function (aabb) {
	        var aMax = this.getMax();
	        var aMin = this.getMin();
	        var bMax = aabb.getMax();
	        var bMin = aabb.getMin();
	        return (aMin[0] <= bMax[0] &&
	            aMax[0] >= bMin[0] &&
	            aMin[1] <= bMax[1] &&
	            aMax[1] >= bMin[1] &&
	            aMin[2] <= bMax[2] &&
	            aMax[2] >= bMin[2]);
	    };
	    AABB.prototype.intersection = function (aabb) {
	        if (!this.intersects(aabb)) {
	            return null;
	        }
	        var intersection = new AABB();
	        // const min = vec3.max(vec3.create(), this.getMin(), aabb.getMin());
	        // const max = vec3.min(vec3.create(), this.getMax(), aabb.getMax());
	        var min = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
	        var max = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
	        intersection.setMinMax(min, max);
	        return intersection;
	    };
	    // containsPoint(point: vec3) {
	    //   const min = this.getMin();
	    //   const max = this.getMax();
	    //   return !(
	    //     point[0] < min[0] ||
	    //     point[0] > max[0] ||
	    //     point[1] < min[1] ||
	    //     point[1] > max[1] ||
	    //     point[2] < min[2] ||
	    //     point[2] > max[2]
	    //   );
	    // }
	    /**
	     * get n-vertex
	     * @param plane plane of CullingVolume
	     */
	    AABB.prototype.getNegativeFarPoint = function (plane) {
	        if (plane.pnVertexFlag === 0x111) {
	            return copyVec3([0, 0, 0], this.min);
	            // return vec3.copy(vec3.create(), this.min);
	        }
	        else if (plane.pnVertexFlag === 0x110) {
	            return [this.min[0], this.min[1], this.max[2]];
	            // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);
	        }
	        else if (plane.pnVertexFlag === 0x101) {
	            return [this.min[0], this.max[1], this.min[2]];
	            // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);
	        }
	        else if (plane.pnVertexFlag === 0x100) {
	            return [this.min[0], this.max[1], this.max[2]];
	            // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);
	        }
	        else if (plane.pnVertexFlag === 0x011) {
	            return [this.max[0], this.min[1], this.min[2]];
	            // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);
	        }
	        else if (plane.pnVertexFlag === 0x010) {
	            return [this.max[0], this.min[1], this.max[2]];
	            // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);
	        }
	        else if (plane.pnVertexFlag === 0x001) {
	            return [this.max[0], this.max[1], this.min[2]];
	            // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);
	        }
	        else {
	            return [this.max[0], this.max[1], this.max[2]];
	            // return vec3.fromValues(this.max[0], this.max[1], this.max[2]);
	        }
	    };
	    /**
	     * get p-vertex
	     * @param plane plane of CullingVolume
	     */
	    AABB.prototype.getPositiveFarPoint = function (plane) {
	        if (plane.pnVertexFlag === 0x111) {
	            return copyVec3([0, 0, 0], this.max);
	            // return vec3.copy(vec3.create(), this.max);
	        }
	        else if (plane.pnVertexFlag === 0x110) {
	            return [this.max[0], this.max[1], this.min[2]];
	            // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);
	        }
	        else if (plane.pnVertexFlag === 0x101) {
	            return [this.max[0], this.min[1], this.max[2]];
	            // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);
	        }
	        else if (plane.pnVertexFlag === 0x100) {
	            return [this.max[0], this.min[1], this.min[2]];
	            // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);
	        }
	        else if (plane.pnVertexFlag === 0x011) {
	            return [this.min[0], this.max[1], this.max[2]];
	            // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);
	        }
	        else if (plane.pnVertexFlag === 0x010) {
	            return [this.min[0], this.max[1], this.min[2]];
	            // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);
	        }
	        else if (plane.pnVertexFlag === 0x001) {
	            return [this.min[0], this.min[1], this.max[2]];
	            // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);
	        }
	        else {
	            return [this.min[0], this.min[1], this.min[2]];
	            // return vec3.fromValues(this.min[0], this.min[1], this.min[2]);
	        }
	    };
	    return AABB;
	}());

	var Plane = /** @class */ (function () {
	    function Plane(distance, normal) {
	        this.distance = distance || 0;
	        this.normal = normal || fromValues$2(0, 1, 0);
	        this.updatePNVertexFlag();
	    }
	    Plane.prototype.updatePNVertexFlag = function () {
	        this.pnVertexFlag =
	            (Number(this.normal[0] >= 0) << 8) +
	                (Number(this.normal[1] >= 0) << 4) +
	                Number(this.normal[2] >= 0);
	    };
	    Plane.prototype.distanceToPoint = function (point) {
	        return dot(point, this.normal) - this.distance;
	    };
	    Plane.prototype.normalize = function () {
	        var invLen = 1 / len(this.normal);
	        scale$1(this.normal, this.normal, invLen);
	        this.distance *= invLen;
	    };
	    Plane.prototype.intersectsLine = function (start, end, point) {
	        var d0 = this.distanceToPoint(start);
	        var d1 = this.distanceToPoint(end);
	        var t = d0 / (d0 - d1);
	        var intersects = t >= 0 && t <= 1;
	        if (intersects && point) {
	            lerp(point, start, end, t);
	        }
	        return intersects;
	    };
	    return Plane;
	}());

	var Mask;
	(function (Mask) {
	    Mask[Mask["OUTSIDE"] = 4294967295] = "OUTSIDE";
	    Mask[Mask["INSIDE"] = 0] = "INSIDE";
	    Mask[Mask["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
	})(Mask || (Mask = {}));
	var Frustum = /** @class */ (function () {
	    function Frustum(planes) {
	        this.planes = [];
	        if (planes) {
	            this.planes = planes;
	        }
	        else {
	            for (var i = 0; i < 6; i++) {
	                this.planes.push(new Plane());
	            }
	        }
	    }
	    /**
	     * extract 6 planes from projectionMatrix
	     * @see http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf
	     */
	    Frustum.prototype.extractFromVPMatrix = function (projectionMatrix) {
	        // @ts-ignore
	        var _a = __read(projectionMatrix, 16), m0 = _a[0], m1 = _a[1], m2 = _a[2], m3 = _a[3], m4 = _a[4], m5 = _a[5], m6 = _a[6], m7 = _a[7], m8 = _a[8], m9 = _a[9], m10 = _a[10], m11 = _a[11], m12 = _a[12], m13 = _a[13], m14 = _a[14], m15 = _a[15];
	        // right
	        set$1(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
	        this.planes[0].distance = m15 - m12;
	        // left
	        set$1(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
	        this.planes[1].distance = m15 + m12;
	        // bottom
	        set$1(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
	        this.planes[2].distance = m15 + m13;
	        // top
	        set$1(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
	        this.planes[3].distance = m15 - m13;
	        // far
	        set$1(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
	        this.planes[4].distance = m15 - m14;
	        // near
	        set$1(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
	        this.planes[5].distance = m15 + m14;
	        this.planes.forEach(function (plane) {
	            plane.normalize();
	            plane.updatePNVertexFlag();
	        });
	    };
	    return Frustum;
	}());

	var Point = /** @class */ (function () {
	    function Point(x, y) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        this.x = 0;
	        this.y = 0;
	        this.x = x;
	        this.y = y;
	    }
	    Point.prototype.clone = function () {
	        return new Point(this.x, this.y);
	    };
	    Point.prototype.copyFrom = function (p) {
	        this.x = p.x;
	        this.y = p.y;
	    };
	    return Point;
	}());

	var Rectangle = /** @class */ (function () {
	    function Rectangle(x, y, width, height) {
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;
	        this.left = x;
	        this.right = x + width;
	        this.top = y;
	        this.bottom = y + height;
	    }
	    Rectangle.prototype.toJSON = function () { };
	    return Rectangle;
	}());

	var ERROR_MSG_METHOD_NOT_IMPLEMENTED = 'Method not implemented.';
	var ERROR_MSG_USE_DOCUMENT_ELEMENT = 'Use document.documentElement instead.';
	var ERROR_MSG_APPEND_DESTROYED_ELEMENT = 'Cannot append a destroyed element.';

	/**
	 * Different type of cameras, eg. simple camera used in 2D scene or
	 * advanced camera which can do actions & switch between landmarks.
	 */
	var CameraType;
	(function (CameraType) {
	    /**
	     * Performs all the rotational operations with the focal point instead of the camera position.
	     * This type of camera is useful in applications(like CAD) where 3D objects are being designed or explored.
	     * Camera cannot orbits over the north & south poles.
	     * @see http://voxelent.com/tutorial-cameras/
	     *
	     * In Three.js it's used in OrbitControls.
	     * @see https://threejs.org/docs/#examples/zh/controls/OrbitControls
	     */
	    CameraType[CameraType["ORBITING"] = 0] = "ORBITING";
	    /**
	     * It's similar to the ORBITING camera, but it allows the camera to orbit over the north or south poles.
	     *
	     * In Three.js it's used in OrbitControls.
	     * @see https://threejs.org/docs/#examples/en/controls/TrackballControls
	     */
	    CameraType[CameraType["EXPLORING"] = 1] = "EXPLORING";
	    /**
	     * Performs all the rotational operations with the camera position.
	     * It's useful in first person shooting games.
	     * Camera cannot orbits over the north & south poles.
	     *
	     * In Three.js it's used in FirstPersonControls.
	     * @see https://threejs.org/docs/#examples/en/controls/FirstPersonControls
	     */
	    CameraType[CameraType["TRACKING"] = 2] = "TRACKING";
	})(CameraType || (CameraType = {}));
	/**
	 * CameraType must be TRACKING
	 */
	var CameraTrackingMode;
	(function (CameraTrackingMode) {
	    CameraTrackingMode[CameraTrackingMode["DEFAULT"] = 0] = "DEFAULT";
	    CameraTrackingMode[CameraTrackingMode["ROTATIONAL"] = 1] = "ROTATIONAL";
	    CameraTrackingMode[CameraTrackingMode["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
	    CameraTrackingMode[CameraTrackingMode["CINEMATIC"] = 3] = "CINEMATIC";
	})(CameraTrackingMode || (CameraTrackingMode = {}));
	var CameraProjectionMode;
	(function (CameraProjectionMode) {
	    CameraProjectionMode[CameraProjectionMode["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
	    CameraProjectionMode[CameraProjectionMode["PERSPECTIVE"] = 1] = "PERSPECTIVE";
	})(CameraProjectionMode || (CameraProjectionMode = {}));
	var CameraEvent = {
	    UPDATED: 'updated',
	};

	var MIN_DISTANCE = 0.0002;
	/**
	 * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计
	 * @see https://github.com/d13g0/nucleo.js/blob/master/source/camera/Camera.js
	 *
	 * 保存相机参数，定义相机动作：
	 * 1. dolly 沿 n 轴移动
	 * 2. pan 沿 u v 轴移动
	 * 3. rotate 以方位角旋转
	 * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互
	 */
	var Camera = /** @class */ (function () {
	    function Camera() {
	        /**
	         * Clip space near Z, default to range `[-1, 1]`
	         */
	        this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
	        this.eventEmitter = new eventemitter3();
	        /**
	         * Matrix of camera
	         */
	        this.matrix = create$1();
	        /**
	         * u axis +X is right
	         * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition
	         */
	        this.right = fromValues$2(1, 0, 0);
	        /**
	         * v axis +Y is up
	         */
	        this.up = fromValues$2(0, 1, 0);
	        /**
	         * n axis +Z is inside
	         */
	        this.forward = fromValues$2(0, 0, 1);
	        /**
	         * Position of camera.
	         */
	        this.position = fromValues$2(0, 0, 1);
	        /**
	         * Position of focal point.
	         */
	        this.focalPoint = fromValues$2(0, 0, 0);
	        /**
	         * vector from focalPoint to position
	         */
	        this.distanceVector = fromValues$2(0, 0, -1);
	        /**
	         * length(focalPoint - position)
	         */
	        this.distance = 1;
	        /**
	         * @see https://en.wikipedia.org/wiki/Azimuth
	         */
	        this.azimuth = 0;
	        this.elevation = 0;
	        this.roll = 0;
	        this.relAzimuth = 0;
	        this.relElevation = 0;
	        this.relRoll = 0;
	        /**
	         * 沿 n 轴移动时，保证移动速度从快到慢
	         */
	        this.dollyingStep = 0;
	        this.maxDistance = Infinity;
	        this.minDistance = -Infinity;
	        /**
	         * zoom factor of the camera, default is 1
	         * eg. https://threejs.org/docs/#api/en/cameras/OrthographicCamera.zoom
	         */
	        this.zoom = 1;
	        /**
	         * invert the horizontal coordinate system HCS
	         */
	        this.rotateWorld = false;
	        /**
	         * 投影矩阵参数
	         */
	        /**
	         * field of view [0-360]
	         * @see http://en.wikipedia.org/wiki/Angle_of_view
	         */
	        this.fov = 30;
	        this.near = 0.1;
	        this.far = 1000;
	        this.aspect = 1;
	        this.projectionMatrix = create$1();
	        this.projectionMatrixInverse = create$1();
	        this.jitteredProjectionMatrix = undefined;
	        this.enableUpdate = true;
	        // protected following = undefined;
	        this.type = CameraType.EXPLORING;
	        this.trackingMode = CameraTrackingMode.DEFAULT;
	        this.projectionMode = CameraProjectionMode.PERSPECTIVE;
	        /**
	         * for culling use
	         */
	        this.frustum = new Frustum();
	        /**
	         * ortho matrix for Canvas2D & SVG
	         */
	        this.orthoMatrix = create$1();
	    }
	    // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
	    //   this.setType(type, trackingMode);
	    // }
	    Camera.prototype.isOrtho = function () {
	        return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
	    };
	    Camera.prototype.getProjectionMode = function () {
	        return this.projectionMode;
	    };
	    Camera.prototype.getPerspective = function () {
	        // account for TAA
	        return this.jitteredProjectionMatrix || this.projectionMatrix;
	    };
	    Camera.prototype.getPerspectiveInverse = function () {
	        return this.projectionMatrixInverse;
	    };
	    Camera.prototype.getFrustum = function () {
	        return this.frustum;
	    };
	    Camera.prototype.getPosition = function () {
	        return this.position;
	    };
	    Camera.prototype.getFocalPoint = function () {
	        return this.focalPoint;
	    };
	    Camera.prototype.getDollyingStep = function () {
	        return this.dollyingStep;
	    };
	    Camera.prototype.getNear = function () {
	        return this.near;
	    };
	    Camera.prototype.getFar = function () {
	        return this.far;
	    };
	    Camera.prototype.getZoom = function () {
	        return this.zoom;
	    };
	    Camera.prototype.getOrthoMatrix = function () {
	        return this.orthoMatrix;
	    };
	    Camera.prototype.getView = function () {
	        return this.view;
	    };
	    Camera.prototype.setEnableUpdate = function (enabled) {
	        this.enableUpdate = enabled;
	    };
	    Camera.prototype.setType = function (type, trackingMode) {
	        this.type = type;
	        if (this.type === CameraType.EXPLORING) {
	            this.setWorldRotation(true);
	        }
	        else {
	            this.setWorldRotation(false);
	        }
	        this._getAngles();
	        if (this.type === CameraType.TRACKING && trackingMode !== undefined) {
	            this.setTrackingMode(trackingMode);
	        }
	        return this;
	    };
	    Camera.prototype.setProjectionMode = function (projectionMode) {
	        this.projectionMode = projectionMode;
	        return this;
	    };
	    Camera.prototype.setTrackingMode = function (trackingMode) {
	        if (this.type !== CameraType.TRACKING) {
	            throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');
	        }
	        this.trackingMode = trackingMode;
	        return this;
	    };
	    /**
	     * If flag is true, it reverses the azimuth and elevation angles.
	     * Subsequent calls to rotate, setAzimuth, setElevation,
	     * changeAzimuth or changeElevation will cause the inverted effect.
	     * setRoll or changeRoll is not affected by this method.
	     *
	     * This inversion is useful when one wants to simulate that the world
	     * is moving, instead of the camera.
	     *
	     * By default the camera angles are not reversed.
	     * @param {Boolean} flag the boolean flag to reverse the angles.
	     */
	    Camera.prototype.setWorldRotation = function (flag) {
	        this.rotateWorld = flag;
	        this._getAngles();
	        return this;
	    };
	    /**
	     * 计算 MV 矩阵，为相机矩阵的逆矩阵
	     */
	    Camera.prototype.getViewTransform = function () {
	        return invert(create$1(), this.matrix);
	    };
	    Camera.prototype.getWorldTransform = function () {
	        return this.matrix;
	    };
	    Camera.prototype.jitterProjectionMatrix = function (x, y) {
	        var translation = fromTranslation(create$1(), [x, y, 0]);
	        this.jitteredProjectionMatrix = multiply(create$1(), translation, this.projectionMatrix);
	    };
	    Camera.prototype.clearJitterProjectionMatrix = function () {
	        this.jitteredProjectionMatrix = undefined;
	    };
	    /**
	     * 设置相机矩阵
	     */
	    Camera.prototype.setMatrix = function (matrix) {
	        this.matrix = matrix;
	        this._update();
	        return this;
	    };
	    Camera.prototype.setFov = function (fov) {
	        this.setPerspective(this.near, this.far, fov, this.aspect);
	        return this;
	    };
	    Camera.prototype.setAspect = function (aspect) {
	        this.setPerspective(this.near, this.far, this.fov, aspect);
	        return this;
	    };
	    Camera.prototype.setNear = function (near) {
	        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
	            this.setPerspective(near, this.far, this.fov, this.aspect);
	        }
	        else {
	            this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
	        }
	        return this;
	    };
	    Camera.prototype.setFar = function (far) {
	        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
	            this.setPerspective(this.near, far, this.fov, this.aspect);
	        }
	        else {
	            this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
	        }
	        return this;
	    };
	    /**
	     * Sets an offset in a larger frustum, used in PixelPicking
	     */
	    Camera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
	        this.aspect = fullWidth / fullHeight;
	        if (this.view === undefined) {
	            this.view = {
	                enabled: true,
	                fullWidth: 1,
	                fullHeight: 1,
	                offsetX: 0,
	                offsetY: 0,
	                width: 1,
	                height: 1,
	            };
	        }
	        this.view.enabled = true;
	        this.view.fullWidth = fullWidth;
	        this.view.fullHeight = fullHeight;
	        this.view.offsetX = x;
	        this.view.offsetY = y;
	        this.view.width = width;
	        this.view.height = height;
	        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
	            this.setPerspective(this.near, this.far, this.fov, this.aspect);
	        }
	        else {
	            this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
	        }
	        return this;
	    };
	    Camera.prototype.clearViewOffset = function () {
	        if (this.view !== undefined) {
	            this.view.enabled = false;
	        }
	        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
	            this.setPerspective(this.near, this.far, this.fov, this.aspect);
	        }
	        else {
	            this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
	        }
	        return this;
	    };
	    Camera.prototype.setZoom = function (zoom) {
	        this.zoom = zoom;
	        if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
	            this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
	        }
	        else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
	            this.setPerspective(this.near, this.far, this.fov, this.aspect);
	        }
	        return this;
	    };
	    /**
	     * Zoom by specified point in viewport coordinates.
	     */
	    Camera.prototype.setZoomByViewportPoint = function (zoom, viewportPoint) {
	        var _a = this.canvas.viewport2Canvas({
	            x: viewportPoint[0],
	            y: viewportPoint[1],
	        }), ox = _a.x, oy = _a.y;
	        var roll = this.roll;
	        this.rotate(0, 0, -roll);
	        this.setPosition(ox, oy);
	        this.setFocalPoint(ox, oy);
	        this.setZoom(zoom);
	        this.rotate(0, 0, roll);
	        var _b = this.canvas.viewport2Canvas({
	            x: viewportPoint[0],
	            y: viewportPoint[1],
	        }), cx = _b.x, cy = _b.y;
	        // project to rotated axis
	        var dvec = fromValues$2(cx - ox, cy - oy, 0);
	        var dx = dot(dvec, this.right) / length(this.right);
	        var dy = dot(dvec, this.up) / length(this.up);
	        this.pan(-dx, -dy);
	        return this;
	    };
	    Camera.prototype.setPerspective = function (near, far, fov, aspect) {
	        var _a;
	        this.projectionMode = CameraProjectionMode.PERSPECTIVE;
	        this.fov = fov;
	        this.near = near;
	        this.far = far;
	        this.aspect = aspect;
	        var top = (this.near * Math.tan(deg2rad(0.5 * this.fov))) / this.zoom;
	        var height = 2 * top;
	        var width = this.aspect * height;
	        var left = -0.5 * width;
	        if ((_a = this.view) === null || _a === void 0 ? void 0 : _a.enabled) {
	            var fullWidth = this.view.fullWidth;
	            var fullHeight = this.view.fullHeight;
	            left += (this.view.offsetX * width) / fullWidth;
	            top -= (this.view.offsetY * height) / fullHeight;
	            width *= this.view.width / fullWidth;
	            height *= this.view.height / fullHeight;
	        }
	        makePerspective(this.projectionMatrix, left, left + width, top, top - height, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
	        // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D
	        scale(this.projectionMatrix, this.projectionMatrix, fromValues$2(1, -1, 1));
	        invert(this.projectionMatrixInverse, this.projectionMatrix);
	        this.triggerUpdate();
	        return this;
	    };
	    Camera.prototype.setOrthographic = function (l, r, t, b, near, far) {
	        var _a;
	        this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
	        this.rright = r;
	        this.left = l;
	        this.top = t;
	        this.bottom = b;
	        this.near = near;
	        this.far = far;
	        var dx = (this.rright - this.left) / (2 * this.zoom);
	        var dy = (this.top - this.bottom) / (2 * this.zoom);
	        var cx = (this.rright + this.left) / 2;
	        var cy = (this.top + this.bottom) / 2;
	        var left = cx - dx;
	        var right = cx + dx;
	        var top = cy + dy;
	        var bottom = cy - dy;
	        if ((_a = this.view) === null || _a === void 0 ? void 0 : _a.enabled) {
	            var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
	            var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
	            left += scaleW * this.view.offsetX;
	            right = left + scaleW * this.view.width;
	            top -= scaleH * this.view.offsetY;
	            bottom = top - scaleH * this.view.height;
	        }
	        if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
	            ortho(this.projectionMatrix, left, right, bottom, top, near, far);
	        }
	        else {
	            orthoZO(this.projectionMatrix, left, right, bottom, top, near, far);
	        }
	        // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D
	        scale(this.projectionMatrix, this.projectionMatrix, fromValues$2(1, -1, 1));
	        invert(this.projectionMatrixInverse, this.projectionMatrix);
	        this._getOrthoMatrix();
	        this.triggerUpdate();
	        return this;
	    };
	    /**
	     * Move the camera in world coordinates.
	     * It will keep looking at the current focal point.
	     *
	     * support scalars or vectors.
	     * @example
	     * setPosition(1, 2, 3);
	     * setPosition([1, 2, 3]);
	     */
	    Camera.prototype.setPosition = function (x, y, z) {
	        if (y === void 0) { y = this.position[1]; }
	        if (z === void 0) { z = this.position[2]; }
	        var position = createVec3(x, y, z);
	        this._setPosition(position);
	        this.setFocalPoint(this.focalPoint);
	        this.triggerUpdate();
	        return this;
	    };
	    /**
	     * Sets the focal point of this camera in world coordinates.
	     *
	     * support scalars or vectors.
	     * @example
	     * setFocalPoint(1, 2, 3);
	     * setFocalPoint([1, 2, 3]);
	     */
	    Camera.prototype.setFocalPoint = function (x, y, z) {
	        if (y === void 0) { y = this.focalPoint[1]; }
	        if (z === void 0) { z = this.focalPoint[2]; }
	        var up = fromValues$2(0, 1, 0);
	        this.focalPoint = createVec3(x, y, z);
	        if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
	            var d = subtract$1(create$2(), this.focalPoint, this.position);
	            x = d[0];
	            y = d[1];
	            z = d[2];
	            var r = length(d);
	            var el = rad2deg(Math.asin(y / r));
	            var az = 90 + rad2deg(Math.atan2(z, x));
	            var m = create$1();
	            rotateY(m, m, deg2rad(az));
	            rotateX(m, m, deg2rad(el));
	            up = transformMat4(create$2(), [0, 1, 0], m);
	        }
	        invert(this.matrix, lookAt(create$1(), this.position, this.focalPoint, up));
	        this._getAxes();
	        this._getDistance();
	        this._getAngles();
	        this.triggerUpdate();
	        return this;
	    };
	    Camera.prototype.getDistance = function () {
	        return this.distance;
	    };
	    Camera.prototype.getDistanceVector = function () {
	        return this.distanceVector;
	    };
	    /**
	     * Moves the camera towards/from the focal point.
	     */
	    Camera.prototype.setDistance = function (d) {
	        if (this.distance === d || d < 0) {
	            return this;
	        }
	        this.distance = d;
	        if (this.distance < MIN_DISTANCE) {
	            this.distance = MIN_DISTANCE;
	        }
	        this.dollyingStep = this.distance / 100;
	        var pos = create$2();
	        d = this.distance;
	        var n = this.forward;
	        var f = this.focalPoint;
	        pos[0] = d * n[0] + f[0];
	        pos[1] = d * n[1] + f[1];
	        pos[2] = d * n[2] + f[2];
	        this._setPosition(pos);
	        this.triggerUpdate();
	        return this;
	    };
	    Camera.prototype.setMaxDistance = function (d) {
	        this.maxDistance = d;
	        return this;
	    };
	    Camera.prototype.setMinDistance = function (d) {
	        this.minDistance = d;
	        return this;
	    };
	    /**
	     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
	     * the azimuth in degrees
	     */
	    Camera.prototype.setAzimuth = function (az) {
	        this.azimuth = getAngle(az);
	        this.computeMatrix();
	        this._getAxes();
	        if (this.type === CameraType.ORBITING ||
	            this.type === CameraType.EXPLORING) {
	            this._getPosition();
	        }
	        else if (this.type === CameraType.TRACKING) {
	            this._getFocalPoint();
	        }
	        this.triggerUpdate();
	        return this;
	    };
	    Camera.prototype.getAzimuth = function () {
	        return this.azimuth;
	    };
	    /**
	     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
	     */
	    Camera.prototype.setElevation = function (el) {
	        this.elevation = getAngle(el);
	        this.computeMatrix();
	        this._getAxes();
	        if (this.type === CameraType.ORBITING ||
	            this.type === CameraType.EXPLORING) {
	            this._getPosition();
	        }
	        else if (this.type === CameraType.TRACKING) {
	            this._getFocalPoint();
	        }
	        this.triggerUpdate();
	        return this;
	    };
	    Camera.prototype.getElevation = function () {
	        return this.elevation;
	    };
	    /**
	     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
	     */
	    Camera.prototype.setRoll = function (angle) {
	        this.roll = getAngle(angle);
	        this.computeMatrix();
	        this._getAxes();
	        if (this.type === CameraType.ORBITING ||
	            this.type === CameraType.EXPLORING) {
	            this._getPosition();
	        }
	        else if (this.type === CameraType.TRACKING) {
	            this._getFocalPoint();
	        }
	        this.triggerUpdate();
	        return this;
	    };
	    Camera.prototype.getRoll = function () {
	        return this.roll;
	    };
	    /**
	     * 根据相机矩阵重新计算各种相机参数
	     */
	    Camera.prototype._update = function () {
	        this._getAxes();
	        this._getPosition();
	        this._getDistance();
	        this._getAngles();
	        this._getOrthoMatrix();
	        this.triggerUpdate();
	    };
	    /**
	     * 计算相机矩阵
	     */
	    Camera.prototype.computeMatrix = function () {
	        // 使用四元数描述 3D 旋转
	        // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html
	        var rotZ = setAxisAngle(create$4(), [0, 0, 1], deg2rad(this.roll));
	        identity(this.matrix);
	        // only consider HCS for EXPLORING and ORBITING cameras
	        var rotX = setAxisAngle(create$4(), [1, 0, 0], deg2rad(((this.rotateWorld && this.type !== CameraType.TRACKING) ||
	            this.type === CameraType.TRACKING
	            ? 1
	            : -1) * this.elevation));
	        var rotY = setAxisAngle(create$4(), [0, 1, 0], deg2rad(((this.rotateWorld && this.type !== CameraType.TRACKING) ||
	            this.type === CameraType.TRACKING
	            ? 1
	            : -1) * this.azimuth));
	        var rotQ = multiply$2(create$4(), rotY, rotX);
	        rotQ = multiply$2(create$4(), rotQ, rotZ);
	        var rotMatrix = fromQuat(create$1(), rotQ);
	        if (this.type === CameraType.ORBITING ||
	            this.type === CameraType.EXPLORING) {
	            translate(this.matrix, this.matrix, this.focalPoint);
	            multiply(this.matrix, this.matrix, rotMatrix);
	            translate(this.matrix, this.matrix, [0, 0, this.distance]);
	        }
	        else if (this.type === CameraType.TRACKING) {
	            translate(this.matrix, this.matrix, this.position);
	            multiply(this.matrix, this.matrix, rotMatrix);
	        }
	    };
	    /**
	     * Sets the camera position in the camera matrix
	     */
	    Camera.prototype._setPosition = function (x, y, z) {
	        this.position = createVec3(x, y, z);
	        var m = this.matrix;
	        m[12] = this.position[0];
	        m[13] = this.position[1];
	        m[14] = this.position[2];
	        m[15] = 1;
	        this._getOrthoMatrix();
	    };
	    /**
	     * Recalculates axes based on the current matrix
	     */
	    Camera.prototype._getAxes = function () {
	        copy$1(this.right, createVec3(transformMat4$1(create$3(), [1, 0, 0, 0], this.matrix)));
	        copy$1(this.up, createVec3(transformMat4$1(create$3(), [0, 1, 0, 0], this.matrix)));
	        copy$1(this.forward, createVec3(transformMat4$1(create$3(), [0, 0, 1, 0], this.matrix)));
	        normalize(this.right, this.right);
	        normalize(this.up, this.up);
	        normalize(this.forward, this.forward);
	    };
	    /**
	     * Recalculates euler angles based on the current state
	     */
	    Camera.prototype._getAngles = function () {
	        // Recalculates angles
	        var x = this.distanceVector[0];
	        var y = this.distanceVector[1];
	        var z = this.distanceVector[2];
	        var r = length(this.distanceVector);
	        // FAST FAIL: If there is no distance we cannot compute angles
	        if (r === 0) {
	            this.elevation = 0;
	            this.azimuth = 0;
	            return;
	        }
	        if (this.type === CameraType.TRACKING) {
	            this.elevation = rad2deg(Math.asin(y / r));
	            this.azimuth = rad2deg(Math.atan2(-x, -z));
	        }
	        else {
	            if (this.rotateWorld) {
	                this.elevation = rad2deg(Math.asin(y / r));
	                this.azimuth = rad2deg(Math.atan2(-x, -z));
	            }
	            else {
	                this.elevation = -rad2deg(Math.asin(y / r));
	                this.azimuth = -rad2deg(Math.atan2(-x, -z));
	            }
	        }
	    };
	    /**
	     * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
	     */
	    Camera.prototype._getPosition = function () {
	        copy$1(this.position, createVec3(transformMat4$1(create$3(), [0, 0, 0, 1], this.matrix)));
	        // 相机位置变化，需要重新计算视距
	        this._getDistance();
	    };
	    /**
	     * 重新计算视点，只有 TRACKING 模式视点才会发生变化
	     */
	    Camera.prototype._getFocalPoint = function () {
	        transformMat3(this.distanceVector, [0, 0, -this.distance], fromMat4(create(), this.matrix));
	        add$1(this.focalPoint, this.position, this.distanceVector);
	        // 视点变化，需要重新计算视距
	        this._getDistance();
	    };
	    /**
	     * 重新计算视距
	     */
	    Camera.prototype._getDistance = function () {
	        this.distanceVector = subtract$1(create$2(), this.focalPoint, this.position);
	        this.distance = length(this.distanceVector);
	        this.dollyingStep = this.distance / 100;
	    };
	    Camera.prototype._getOrthoMatrix = function () {
	        if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
	            return;
	        }
	        var position = this.position;
	        var rotZ = setAxisAngle(create$4(), [0, 0, 1], (-this.roll * Math.PI) / 180);
	        fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, fromValues$2((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), fromValues$2(this.zoom, this.zoom, 1), position);
	    };
	    Camera.prototype.triggerUpdate = function () {
	        if (this.enableUpdate) {
	            // update frustum
	            var viewMatrix = this.getViewTransform();
	            var vpMatrix = multiply(create$1(), this.getPerspective(), viewMatrix);
	            this.getFrustum().extractFromVPMatrix(vpMatrix);
	            this.eventEmitter.emit(CameraEvent.UPDATED);
	        }
	    };
	    Camera.prototype.rotate = function (azimuth, elevation, roll) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Camera.prototype.pan = function (tx, ty) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Camera.prototype.dolly = function (value) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Camera.prototype.createLandmark = function (name, params) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Camera.prototype.gotoLandmark = function (name, options) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Camera.prototype.cancelLandmarkAnimation = function () {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    return Camera;
	}());

	function memoize(func, resolver) {
	    if (typeof func !== 'function' ||
	        (resolver != null && typeof resolver !== 'function')) {
	        throw new TypeError('Expected a function');
	    }
	    var memoized = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var key = resolver ? resolver.apply(this, args) : args[0];
	        var cache = memoized.cache;
	        if (cache.has(key)) {
	            return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	    };
	    memoized.cache = new (memoize.Cache || Map)();
	    return memoized;
	}
	memoize.Cache = Map;

	// These units are iterated through, so be careful when adding or changing the
	// order.
	var UnitType;
	(function (UnitType) {
	    UnitType[UnitType["kUnknown"] = 0] = "kUnknown";
	    UnitType[UnitType["kNumber"] = 1] = "kNumber";
	    UnitType[UnitType["kPercentage"] = 2] = "kPercentage";
	    // Length units
	    UnitType[UnitType["kEms"] = 3] = "kEms";
	    // kExs,
	    UnitType[UnitType["kPixels"] = 4] = "kPixels";
	    // kCentimeters,
	    // kMillimeters,
	    // kInches,
	    // kPoints,
	    // kPicas,
	    // kQuarterMillimeters,
	    // https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
	    //
	    // See also IsViewportPercentageLength.
	    // kViewportWidth,
	    // kViewportHeight,
	    // kViewportInlineSize,
	    // kViewportBlockSize,
	    // kViewportMin,
	    // kViewportMax,
	    // kSmallViewportWidth,
	    // kSmallViewportHeight,
	    // kSmallViewportInlineSize,
	    // kSmallViewportBlockSize,
	    // kSmallViewportMin,
	    // kSmallViewportMax,
	    // kLargeViewportWidth,
	    // kLargeViewportHeight,
	    // kLargeViewportInlineSize,
	    // kLargeViewportBlockSize,
	    // kLargeViewportMin,
	    // kLargeViewportMax,
	    // kDynamicViewportWidth,
	    // kDynamicViewportHeight,
	    // kDynamicViewportInlineSize,
	    // kDynamicViewportBlockSize,
	    // kDynamicViewportMin,
	    // kDynamicViewportMax,
	    // https://drafts.csswg.org/css-contain-3/#container-lengths
	    //
	    // See also IsContainerPercentageLength.
	    // kContainerWidth,
	    // kContainerHeight,
	    // kContainerInlineSize,
	    // kContainerBlockSize,
	    // kContainerMin,
	    // kContainerMax,
	    UnitType[UnitType["kRems"] = 5] = "kRems";
	    // kChs,
	    // kUserUnits, // The SVG term for unitless lengths
	    // Angle units
	    UnitType[UnitType["kDegrees"] = 6] = "kDegrees";
	    UnitType[UnitType["kRadians"] = 7] = "kRadians";
	    UnitType[UnitType["kGradians"] = 8] = "kGradians";
	    UnitType[UnitType["kTurns"] = 9] = "kTurns";
	    // Time units
	    UnitType[UnitType["kMilliseconds"] = 10] = "kMilliseconds";
	    UnitType[UnitType["kSeconds"] = 11] = "kSeconds";
	    // kHertz,
	    // kKilohertz,
	    // Resolution
	    // kDotsPerPixel,
	    // kDotsPerInch,
	    // kDotsPerCentimeter,
	    // Other units
	    // kFraction,
	    UnitType[UnitType["kInteger"] = 12] = "kInteger";
	    // This value is used to handle quirky margins in reflow roots (body, td,
	    // and th) like WinIE. The basic idea is that a stylesheet can use the value
	    // __qem (for quirky em) instead of em. When the quirky value is used, if
	    // you're in quirks mode, the margin will collapse away inside a table cell.
	    // This quirk is specified in the HTML spec but our impl is different.
	    // TODO: Remove this. crbug.com/443952
	    // kQuirkyEms,
	})(UnitType || (UnitType = {}));
	var UnitCategory;
	(function (UnitCategory) {
	    UnitCategory[UnitCategory["kUNumber"] = 0] = "kUNumber";
	    UnitCategory[UnitCategory["kUPercent"] = 1] = "kUPercent";
	    UnitCategory[UnitCategory["kULength"] = 2] = "kULength";
	    UnitCategory[UnitCategory["kUAngle"] = 3] = "kUAngle";
	    UnitCategory[UnitCategory["kUTime"] = 4] = "kUTime";
	    // kUFrequency,
	    // kUResolution,
	    UnitCategory[UnitCategory["kUOther"] = 5] = "kUOther";
	})(UnitCategory || (UnitCategory = {}));
	var ValueRange;
	(function (ValueRange) {
	    ValueRange[ValueRange["kAll"] = 0] = "kAll";
	    ValueRange[ValueRange["kNonNegative"] = 1] = "kNonNegative";
	    ValueRange[ValueRange["kInteger"] = 2] = "kInteger";
	    ValueRange[ValueRange["kNonNegativeInteger"] = 3] = "kNonNegativeInteger";
	    ValueRange[ValueRange["kPositiveInteger"] = 4] = "kPositiveInteger";
	})(ValueRange || (ValueRange = {}));
	var Nested;
	(function (Nested) {
	    Nested[Nested["kYes"] = 0] = "kYes";
	    Nested[Nested["kNo"] = 1] = "kNo";
	})(Nested || (Nested = {}));
	var ParenLess;
	(function (ParenLess) {
	    ParenLess[ParenLess["kYes"] = 0] = "kYes";
	    ParenLess[ParenLess["kNo"] = 1] = "kNo";
	})(ParenLess || (ParenLess = {}));

	// This file specifies the unit strings used in CSSPrimitiveValues.
	var data = [
	    {
	        name: 'em',
	        unit_type: UnitType.kEms,
	    },
	    // {
	    //   name: 'ex',
	    //   unit_type: UnitType.kExs,
	    // },
	    {
	        name: 'px',
	        unit_type: UnitType.kPixels,
	    },
	    // {
	    //   name: "cm",
	    //   unit_type: UnitType.kCentimeters,
	    // },
	    // {
	    //   name: "mm",
	    //   unit_type: UnitType.kMillimeters,
	    // },
	    // {
	    //   name: "q",
	    //   unit_type: UnitType.kQuarterMillimeters,
	    // },
	    // {
	    //   name: "in",
	    //   unit_type: UnitType.kInches,
	    // },
	    // {
	    //   name: "pt",
	    //   unit_type: UnitType.kPoints,
	    // },
	    // {
	    //   name: "pc",
	    //   unit_type: UnitType.kPicas,
	    // },
	    {
	        name: 'deg',
	        unit_type: UnitType.kDegrees,
	    },
	    {
	        name: 'rad',
	        unit_type: UnitType.kRadians,
	    },
	    {
	        name: 'grad',
	        unit_type: UnitType.kGradians,
	    },
	    {
	        name: 'ms',
	        unit_type: UnitType.kMilliseconds,
	    },
	    {
	        name: 's',
	        unit_type: UnitType.kSeconds,
	    },
	    // {
	    //   name: "hz",
	    //   unit_type: UnitType.kHertz,
	    // },
	    // {
	    //   name: "khz",
	    //   unit_type: UnitType.kKilohertz,
	    // },
	    // {
	    //   name: "dpi",
	    //   unit_type: "kDotsPerInch",
	    // },
	    // {
	    //   name: "dpcm",
	    //   unit_type: "kDotsPerCentimeter",
	    // },
	    // {
	    //   name: "dppx",
	    //   unit_type: "kDotsPerPixel",
	    // },
	    // {
	    //   name: "x",
	    //   unit_type: "kDotsPerPixel",
	    // },
	    // {
	    //   name: "vw",
	    //   unit_type: "kViewportWidth",
	    // },
	    // {
	    //   name: "vh",
	    //   unit_type: "kViewportHeight",
	    // },
	    // {
	    //   name: "vi",
	    //   unit_type: "kViewportInlineSize",
	    // },
	    // {
	    //   name: "vb",
	    //   unit_type: "kViewportBlockSize",
	    // },
	    // {
	    //   name: "vmin",
	    //   unit_type: UnitType.kViewportMin,
	    // },
	    // {
	    //   name: "vmax",
	    //   unit_type: UnitType.kViewportMax,
	    // },
	    // {
	    //   name: "svw",
	    //   unit_type: "kSmallViewportWidth",
	    // },
	    // {
	    //   name: "svh",
	    //   unit_type: "kSmallViewportHeight",
	    // },
	    // {
	    //   name: "svi",
	    //   unit_type: "kSmallViewportInlineSize",
	    // },
	    // {
	    //   name: "svb",
	    //   unit_type: "kSmallViewportBlockSize",
	    // },
	    // {
	    //   name: "svmin",
	    //   unit_type: "kSmallViewportMin",
	    // },
	    // {
	    //   name: "svmax",
	    //   unit_type: "kSmallViewportMax",
	    // },
	    // {
	    //   name: "lvw",
	    //   unit_type: "kLargeViewportWidth",
	    // },
	    // {
	    //   name: "lvh",
	    //   unit_type: "kLargeViewportHeight",
	    // },
	    // {
	    //   name: "lvi",
	    //   unit_type: "kLargeViewportInlineSize",
	    // },
	    // {
	    //   name: "lvb",
	    //   unit_type: "kLargeViewportBlockSize",
	    // },
	    // {
	    //   name: "lvmin",
	    //   unit_type: UnitType.kLargeViewportMin,
	    // },
	    // {
	    //   name: "lvmax",
	    //   unit_type: UnitType.kLargeViewportMax,
	    // },
	    // {
	    //   name: "dvw",
	    //   unit_type: UnitType.kDynamicViewportWidth,
	    // },
	    // {
	    //   name: "dvh",
	    //   unit_type: UnitType.kDynamicViewportHeight,
	    // },
	    // {
	    //   name: "dvi",
	    //   unit_type: UnitType.kDynamicViewportInlineSize,
	    // },
	    // {
	    //   name: "dvb",
	    //   unit_type: UnitType.kDynamicViewportBlockSize,
	    // },
	    // {
	    //   name: "dvmin",
	    //   unit_type: UnitType.kDynamicViewportMin,
	    // },
	    // {
	    //   name: "dvmax",
	    //   unit_type: UnitType.kDynamicViewportMax,
	    // },
	    // {
	    //   name: "cqw",
	    //   unit_type: UnitType.kContainerWidth,
	    // },
	    // {
	    //   name: "cqh",
	    //   unit_type: UnitType.kContainerHeight,
	    // },
	    // {
	    //   name: "cqi",
	    //   unit_type: UnitType.kContainerInlineSize,
	    // },
	    // {
	    //   name: "cqb",
	    //   unit_type: UnitType.kContainerBlockSize,
	    // },
	    // {
	    //   name: "cqmin",
	    //   unit_type: UnitType.kContainerMin,
	    // },
	    // {
	    //   name: "cqmax",
	    //   unit_type: UnitType.kContainerMax,
	    // },
	    {
	        name: 'rem',
	        unit_type: UnitType.kRems,
	    },
	    // {
	    //   name: 'fr',
	    //   unit_type: UnitType.kFraction,
	    // },
	    {
	        name: 'turn',
	        unit_type: UnitType.kTurns,
	    },
	    // {
	    //   name: 'ch',
	    //   unit_type: UnitType.kChs,
	    // },
	    // {
	    //   name: '__qem',
	    //   unit_type: UnitType.kQuirkyEms,
	    // },
	];
	var CSSStyleValueType;
	(function (CSSStyleValueType) {
	    CSSStyleValueType[CSSStyleValueType["kUnknownType"] = 0] = "kUnknownType";
	    CSSStyleValueType[CSSStyleValueType["kUnparsedType"] = 1] = "kUnparsedType";
	    CSSStyleValueType[CSSStyleValueType["kKeywordType"] = 2] = "kKeywordType";
	    // Start of CSSNumericValue subclasses
	    CSSStyleValueType[CSSStyleValueType["kUnitType"] = 3] = "kUnitType";
	    CSSStyleValueType[CSSStyleValueType["kSumType"] = 4] = "kSumType";
	    CSSStyleValueType[CSSStyleValueType["kProductType"] = 5] = "kProductType";
	    CSSStyleValueType[CSSStyleValueType["kNegateType"] = 6] = "kNegateType";
	    CSSStyleValueType[CSSStyleValueType["kInvertType"] = 7] = "kInvertType";
	    CSSStyleValueType[CSSStyleValueType["kMinType"] = 8] = "kMinType";
	    CSSStyleValueType[CSSStyleValueType["kMaxType"] = 9] = "kMaxType";
	    CSSStyleValueType[CSSStyleValueType["kClampType"] = 10] = "kClampType";
	    // End of CSSNumericValue subclasses
	    CSSStyleValueType[CSSStyleValueType["kTransformType"] = 11] = "kTransformType";
	    CSSStyleValueType[CSSStyleValueType["kPositionType"] = 12] = "kPositionType";
	    CSSStyleValueType[CSSStyleValueType["kURLImageType"] = 13] = "kURLImageType";
	    CSSStyleValueType[CSSStyleValueType["kColorType"] = 14] = "kColorType";
	    CSSStyleValueType[CSSStyleValueType["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
	})(CSSStyleValueType || (CSSStyleValueType = {}));
	// function parseCSSStyleValue(propertyName: string, value: string): CSSStyleValue[] {
	//   // const propertyId = cssPropertyID(propertyName);
	//   // if (propertyId === CSSPropertyID.kInvalid) {
	//   //   return [];
	//   // }
	//   // const customPropertyName = propertyId === CSSPropertyID.kVariable ? propertyName : null;
	//   // return fromString(propertyId, customPropertyName, value);
	//   return [];
	// }
	var stringToUnitType = function (name) {
	    return data.find(function (item) { return item.name === name; }).unit_type;
	};
	var unitFromName = function (name) {
	    if (!name) {
	        return UnitType.kUnknown;
	    }
	    if (name === 'number') {
	        return UnitType.kNumber;
	    }
	    if (name === 'percent' || name === '%') {
	        return UnitType.kPercentage;
	    }
	    return stringToUnitType(name);
	};
	var unitTypeToUnitCategory = function (type) {
	    switch (type) {
	        case UnitType.kNumber:
	        case UnitType.kInteger:
	            return UnitCategory.kUNumber;
	        case UnitType.kPercentage:
	            return UnitCategory.kUPercent;
	        case UnitType.kPixels:
	            // case UnitType.kCentimeters:
	            // case UnitType.kMillimeters:
	            // case UnitType.kQuarterMillimeters:
	            // case UnitType.kInches:
	            // case UnitType.kPoints:
	            // case UnitType.kPicas:
	            // case UnitType.kUserUnits:
	            return UnitCategory.kULength;
	        case UnitType.kMilliseconds:
	        case UnitType.kSeconds:
	            return UnitCategory.kUTime;
	        case UnitType.kDegrees:
	        case UnitType.kRadians:
	        case UnitType.kGradians:
	        case UnitType.kTurns:
	            return UnitCategory.kUAngle;
	        // case UnitType.kHertz:
	        // case UnitType.kKilohertz:
	        //   return UnitCategory.kUFrequency;
	        // case UnitType.kDotsPerPixel:
	        // case UnitType.kDotsPerInch:
	        // case UnitType.kDotsPerCentimeter:
	        //   return UnitCategory.kUResolution;
	        default:
	            return UnitCategory.kUOther;
	    }
	};
	var canonicalUnitTypeForCategory = function (category) {
	    // The canonical unit type is chosen according to the way
	    // CSSPropertyParser.ValidUnit() chooses the default unit in each category
	    // (based on unitflags).
	    switch (category) {
	        case UnitCategory.kUNumber:
	            return UnitType.kNumber;
	        case UnitCategory.kULength:
	            return UnitType.kPixels;
	        case UnitCategory.kUPercent:
	            return UnitType.kPercentage;
	        // return UnitType.kUnknown; // Cannot convert between numbers and percent.
	        case UnitCategory.kUTime:
	            return UnitType.kSeconds;
	        case UnitCategory.kUAngle:
	            return UnitType.kDegrees;
	        // case UnitCategory.kUFrequency:
	        //   return UnitType.kHertz;
	        // case UnitCategory.kUResolution:
	        //   return UnitType.kDotsPerPixel;
	        default:
	            return UnitType.kUnknown;
	    }
	};
	/**
	 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/css_primitive_value.cc#353
	 */
	var conversionToCanonicalUnitsScaleFactor = function (unit_type) {
	    var factor = 1.0;
	    // FIXME: the switch can be replaced by an array of scale factors.
	    switch (unit_type) {
	        // These are "canonical" units in their respective categories.
	        case UnitType.kPixels:
	        // case UnitType.kUserUnits:
	        case UnitType.kDegrees:
	        case UnitType.kSeconds:
	            // case UnitType.kHertz:
	            break;
	        case UnitType.kMilliseconds:
	            factor = 0.001;
	            break;
	        // case UnitType.kCentimeters:
	        //   // factor = kCssPixelsPerCentimeter;
	        //   break;
	        // case UnitType.kDotsPerCentimeter:
	        //   // factor = 1 / kCssPixelsPerCentimeter;
	        //   break;
	        // case UnitType.kMillimeters:
	        //   // factor = kCssPixelsPerMillimeter;
	        //   break;
	        // case UnitType.kQuarterMillimeters:
	        //   // factor = kCssPixelsPerQuarterMillimeter;
	        //   break;
	        // case UnitType.kInches:
	        //   // factor = kCssPixelsPerInch;
	        //   break;
	        // case UnitType.kDotsPerInch:
	        //   // factor = 1 / kCssPixelsPerInch;
	        //   break;
	        // case UnitType.kPoints:
	        //   // factor = kCssPixelsPerPoint;
	        //   break;
	        // case UnitType.kPicas:
	        //   // factor = kCssPixelsPerPica;
	        //   break;
	        case UnitType.kRadians:
	            factor = 180 / Math.PI;
	            break;
	        case UnitType.kGradians:
	            factor = 0.9;
	            break;
	        case UnitType.kTurns:
	            factor = 360;
	            break;
	    }
	    return factor;
	};
	var unitTypeToString = function (type) {
	    switch (type) {
	        case UnitType.kNumber:
	        case UnitType.kInteger:
	            // case UnitType.kUserUnits:
	            return '';
	        case UnitType.kPercentage:
	            return '%';
	        case UnitType.kEms:
	            // case UnitType.kQuirkyEms:
	            return 'em';
	        // case UnitType.kExs:
	        //   return 'ex';
	        case UnitType.kRems:
	            return 'rem';
	        // case UnitType.kChs:
	        //   return 'ch';
	        case UnitType.kPixels:
	            return 'px';
	        // case UnitType.kCentimeters:
	        //   return 'cm';
	        // case UnitType.kDotsPerPixel:
	        //   return 'dppx';
	        // case UnitType.kDotsPerInch:
	        //   return 'dpi';
	        // case UnitType.kDotsPerCentimeter:
	        //   return 'dpcm';
	        // case UnitType.kMillimeters:
	        //   return 'mm';
	        // case UnitType.kQuarterMillimeters:
	        //   return 'q';
	        // case UnitType.kInches:
	        //   return 'in';
	        // case UnitType.kPoints:
	        //   return 'pt';
	        // case UnitType.kPicas:
	        //   return 'pc';
	        case UnitType.kDegrees:
	            return 'deg';
	        case UnitType.kRadians:
	            return 'rad';
	        case UnitType.kGradians:
	            return 'grad';
	        case UnitType.kMilliseconds:
	            return 'ms';
	        case UnitType.kSeconds:
	            return 's';
	        // case UnitType.kHertz:
	        //   return 'hz';
	        // case UnitType.kKilohertz:
	        //   return 'khz';
	        case UnitType.kTurns:
	            return 'turn';
	    }
	    return '';
	};
	/**
	 * CSSStyleValue is the base class for all CSS values accessible from Typed OM.
	 * Values that are not yet supported as specific types are also returned as base CSSStyleValues.
	 *
	 * Spec @see https://drafts.css-houdini.org/css-typed-om/#stylevalue-objects
	 * Docs @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleValue
	 */
	var CSSStyleValue = /** @class */ (function () {
	    function CSSStyleValue() {
	    }
	    // static parse(propertyName: string, value: string): CSSStyleValue {
	    //   return parseCSSStyleValue(propertyName, value)[0];
	    // }
	    // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
	    //   return parseCSSStyleValue(propertyName, value);
	    // }
	    CSSStyleValue.isAngle = function (unit) {
	        return (unit === UnitType.kDegrees ||
	            unit === UnitType.kRadians ||
	            unit === UnitType.kGradians ||
	            unit === UnitType.kTurns);
	    };
	    // static isViewportPercentageLength(type: UnitType) {
	    //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
	    // }
	    // static isContainerPercentageLength(type: UnitType) {
	    //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
	    // }
	    CSSStyleValue.isLength = function (type) {
	        // return (type >= UnitType.kEms && type <= UnitType.kUserUnits) || type == UnitType.kQuirkyEms;
	        return type >= UnitType.kEms && type < UnitType.kDegrees;
	    };
	    CSSStyleValue.isRelativeUnit = function (type) {
	        return (type === UnitType.kPercentage ||
	            type === UnitType.kEms ||
	            // type === UnitType.kExs ||
	            type === UnitType.kRems
	        // type === UnitType.kChs ||
	        // this.isViewportPercentageLength(type) ||
	        // this.isContainerPercentageLength(type)
	        );
	    };
	    CSSStyleValue.isTime = function (unit) {
	        return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
	    };
	    // protected abstract toCSSValue(): CSSValue;
	    CSSStyleValue.prototype.toString = function () {
	        return this.buildCSSText(Nested.kNo, ParenLess.kNo, '');
	    };
	    CSSStyleValue.prototype.isNumericValue = function () {
	        return (this.getType() >= CSSStyleValueType.kUnitType &&
	            this.getType() <= CSSStyleValueType.kClampType);
	    };
	    return CSSStyleValue;
	}());

	/**
	 * CSSColorValue is the base class used for the various CSS color interfaces.
	 *
	 * @see https://drafts.css-houdini.org/css-typed-om-1/#colorvalue-objects
	 */
	var CSSColorValue = /** @class */ (function (_super) {
	    __extends(CSSColorValue, _super);
	    function CSSColorValue(colorSpace) {
	        var _this = _super.call(this) || this;
	        _this.colorSpace = colorSpace;
	        return _this;
	    }
	    CSSColorValue.prototype.getType = function () {
	        return CSSStyleValueType.kColorType;
	    };
	    // buildCSSText(n: Nested, p: ParenLess, result: string): string {
	    //   let text = '';
	    //   if (this.colorSpace === 'rgb') {
	    //     text = `rgba(${this.channels.join(',')},${this.alpha})`;
	    //   }
	    //   return (result += text);
	    // }
	    /**
	     * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
	     */
	    CSSColorValue.prototype.to = function (colorSpace) {
	        return this;
	    };
	    return CSSColorValue;
	}(CSSStyleValue));

	var GradientType;
	(function (GradientType) {
	    GradientType[GradientType["Constant"] = 0] = "Constant";
	    GradientType[GradientType["LinearGradient"] = 1] = "LinearGradient";
	    GradientType[GradientType["RadialGradient"] = 2] = "RadialGradient";
	})(GradientType || (GradientType = {}));
	var CSSGradientValue = /** @class */ (function (_super) {
	    __extends(CSSGradientValue, _super);
	    function CSSGradientValue(type, value) {
	        var _this = _super.call(this) || this;
	        _this.type = type;
	        _this.value = value;
	        return _this;
	    }
	    CSSGradientValue.prototype.clone = function () {
	        return new CSSGradientValue(this.type, this.value);
	    };
	    CSSGradientValue.prototype.buildCSSText = function (n, p, result) {
	        return result;
	    };
	    CSSGradientValue.prototype.getType = function () {
	        return CSSStyleValueType.kColorType;
	    };
	    return CSSGradientValue;
	}(CSSStyleValue));

	/**
	 * CSSKeywordValue represents CSS Values that are specified as keywords
	 * eg. 'initial'
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSKeywordValue
	 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_keyword_value.idl
	 */
	var CSSKeywordValue = /** @class */ (function (_super) {
	    __extends(CSSKeywordValue, _super);
	    function CSSKeywordValue(value) {
	        var _this = _super.call(this) || this;
	        _this.value = value;
	        return _this;
	    }
	    CSSKeywordValue.prototype.clone = function () {
	        return new CSSKeywordValue(this.value);
	    };
	    CSSKeywordValue.prototype.getType = function () {
	        return CSSStyleValueType.kKeywordType;
	    };
	    CSSKeywordValue.prototype.buildCSSText = function (n, p, result) {
	        return result + this.value;
	    };
	    return CSSKeywordValue;
	}(CSSStyleValue));

	var camelCase = memoize(function (str) {
	    if (str === void 0) { str = ''; }
	    return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
	});
	var kebabize = function (str) {
	    return str
	        .split('')
	        .map(function (letter, idx) {
	        return letter.toUpperCase() === letter
	            ? "".concat(idx !== 0 ? '-' : '').concat(letter.toLowerCase())
	            : letter;
	    })
	        .join('');
	};

	function DCHECK(bool) {
	    if (!bool) {
	        throw new Error();
	    }
	}
	function isFunction$1(func) {
	    return typeof func === 'function';
	}
	function isSymbol(value) {
	    // @see https://github.com/lodash/lodash/blob/master/isSymbol.js
	    return typeof value === 'symbol';
	}
	var FORMAT_ATTR_MAP = {
	    d: {
	        alias: 'path',
	    },
	    strokeDasharray: {
	        alias: 'lineDash',
	    },
	    strokeWidth: {
	        alias: 'lineWidth',
	    },
	    textAnchor: {
	        alias: 'textAlign',
	    },
	    src: {
	        alias: 'img',
	    },
	};
	var formatAttributeName = memoize(function (name) {
	    var attributeName = camelCase(name);
	    var map = FORMAT_ATTR_MAP[attributeName];
	    attributeName = (map === null || map === void 0 ? void 0 : map.alias) || attributeName;
	    return attributeName;
	});

	// type CSSNumericBaseType =
	//   | 'length'
	//   | 'angle'
	//   | 'time'
	//   | 'frequency'
	//   | 'resolution'
	//   | 'flex'
	//   | 'percent';
	// https://drafts.css-houdini.org/css-typed-om/#dictdef-cssnumerictype
	// interface CSSNumericType {
	//   length: number;
	//   angle: number;
	//   time: number;
	//   frequency: number;
	//   resolution: number;
	//   flex: number;
	//   percent: number;
	//   percentHint: CSSNumericBaseType;
	// }
	var formatInfinityOrNaN = function (number, suffix) {
	    if (suffix === void 0) { suffix = ''; }
	    var result = '';
	    if (!Number.isFinite(number)) {
	        if (number > 0)
	            result = 'infinity';
	        else
	            result = '-infinity';
	    }
	    else {
	        DCHECK(Number.isNaN(number));
	        result = 'NaN';
	    }
	    return (result += suffix);
	};
	var toCanonicalUnit = function (unit) {
	    return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
	};
	/**
	 * CSSNumericValue is the base class for numeric and length typed CSS Values.
	 * @see https://drafts.css-houdini.org/css-typed-om/#numeric-objects
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue
	 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.idl
	 */
	/**
	 * Represents numeric values that can be expressed as a single number plus a
	 * unit (or a naked number or percentage).
	 * @see https://drafts.css-houdini.org/css-typed-om/#cssunitvalue
	 */
	var CSSUnitValue = /** @class */ (function (_super) {
	    __extends(CSSUnitValue, _super);
	    function CSSUnitValue(value, unitOrName) {
	        if (unitOrName === void 0) { unitOrName = UnitType.kNumber; }
	        var _this = _super.call(this) || this;
	        var unit;
	        if (typeof unitOrName === 'string') {
	            unit = unitFromName(unitOrName);
	        }
	        else {
	            unit = unitOrName;
	        }
	        _this.unit = unit;
	        _this.value = value;
	        return _this;
	    }
	    CSSUnitValue.prototype.clone = function () {
	        return new CSSUnitValue(this.value, this.unit);
	    };
	    CSSUnitValue.prototype.equals = function (other) {
	        var other_unit_value = other;
	        return (this.value === other_unit_value.value &&
	            this.unit === other_unit_value.unit);
	    };
	    CSSUnitValue.prototype.getType = function () {
	        return CSSStyleValueType.kUnitType;
	    };
	    CSSUnitValue.prototype.convertTo = function (target_unit) {
	        if (this.unit === target_unit) {
	            return new CSSUnitValue(this.value, this.unit);
	        }
	        // Instead of defining the scale factors for every unit to every other unit,
	        // we simply convert to the canonical unit and back since we already have
	        // the scale factors for canonical units.
	        var canonical_unit = toCanonicalUnit(this.unit);
	        if (canonical_unit !== toCanonicalUnit(target_unit) ||
	            canonical_unit === UnitType.kUnknown) {
	            return null;
	        }
	        var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) /
	            conversionToCanonicalUnitsScaleFactor(target_unit);
	        return new CSSUnitValue(this.value * scale_factor, target_unit);
	    };
	    CSSUnitValue.prototype.buildCSSText = function (n, p, result) {
	        var text;
	        switch (this.unit) {
	            case UnitType.kUnknown:
	                // FIXME
	                break;
	            case UnitType.kInteger:
	                text = Number(this.value).toFixed(0);
	                break;
	            case UnitType.kNumber:
	            case UnitType.kPercentage:
	            case UnitType.kEms:
	            // case UnitType.kQuirkyEms:
	            // case UnitType.kExs:
	            case UnitType.kRems:
	            // case UnitType.kChs:
	            case UnitType.kPixels:
	            // case UnitType.kCentimeters:
	            // case UnitType.kDotsPerPixel:
	            // case UnitType.kDotsPerInch:
	            // case UnitType.kDotsPerCentimeter:
	            // case UnitType.kMillimeters:
	            // case UnitType.kQuarterMillimeters:
	            // case UnitType.kInches:
	            // case UnitType.kPoints:
	            // case UnitType.kPicas:
	            // case UnitType.kUserUnits:
	            case UnitType.kDegrees:
	            case UnitType.kRadians:
	            case UnitType.kGradians:
	            case UnitType.kMilliseconds:
	            case UnitType.kSeconds:
	            // case UnitType.kHertz:
	            // case UnitType.kKilohertz:
	            case UnitType.kTurns: // case UnitType.kContainerMax: { // case UnitType.kContainerMin: // case UnitType.kContainerBlockSize: // case UnitType.kContainerInlineSize: // case UnitType.kContainerHeight: // case UnitType.kContainerWidth: // case UnitType.kDynamicViewportMax: // case UnitType.kDynamicViewportMin: // case UnitType.kDynamicViewportBlockSize: // case UnitType.kDynamicViewportInlineSize: // case UnitType.kDynamicViewportHeight: // case UnitType.kDynamicViewportWidth: // case UnitType.kLargeViewportMax: // case UnitType.kLargeViewportMin: // case UnitType.kLargeViewportBlockSize: // case UnitType.kLargeViewportInlineSize: // case UnitType.kLargeViewportHeight: // case UnitType.kLargeViewportWidth: // case UnitType.kSmallViewportMax: // case UnitType.kSmallViewportMin: // case UnitType.kSmallViewportBlockSize: // case UnitType.kSmallViewportInlineSize: // case UnitType.kSmallViewportHeight: // case UnitType.kSmallViewportWidth: // case UnitType.kViewportMax: // case UnitType.kViewportMin: // case UnitType.kViewportBlockSize: // case UnitType.kViewportInlineSize: // case UnitType.kViewportHeight: // case UnitType.kViewportWidth: // case UnitType.kFraction:
	                {
	                    var kMinInteger = -999999;
	                    var kMaxInteger = 999999;
	                    var value = this.value;
	                    var unit = unitTypeToString(this.unit);
	                    if (value < kMinInteger || value > kMaxInteger) {
	                        var unit_1 = unitTypeToString(this.unit);
	                        if (!Number.isFinite(value) || Number.isNaN(value)) {
	                            text = formatInfinityOrNaN(value, unit_1);
	                        }
	                        else {
	                            text = value + (unit_1 || '');
	                        }
	                    }
	                    else {
	                        text = "".concat(value).concat(unit);
	                    }
	                }
	        }
	        result += text;
	        return result;
	    };
	    return CSSUnitValue;
	}(CSSStyleValue));
	var Opx = new CSSUnitValue(0, 'px');
	new CSSUnitValue(1, 'px');
	var Odeg = new CSSUnitValue(0, 'deg');

	/**
	 * The CSSRGB class represents the CSS rgb()/rgba() functions.
	 *
	 * @see https://drafts.css-houdini.org/css-typed-om-1/#cssrgb
	 */
	var CSSRGB = /** @class */ (function (_super) {
	    __extends(CSSRGB, _super);
	    function CSSRGB(r, g, b, alpha, 
	    /**
	     * 'transparent' & 'none' has the same rgba data
	     */
	    isNone) {
	        if (alpha === void 0) { alpha = 1; }
	        if (isNone === void 0) { isNone = false; }
	        var _this = _super.call(this, 'rgb') || this;
	        _this.r = r;
	        _this.g = g;
	        _this.b = b;
	        _this.alpha = alpha;
	        _this.isNone = isNone;
	        return _this;
	    }
	    CSSRGB.prototype.clone = function () {
	        return new CSSRGB(this.r, this.g, this.b, this.alpha);
	    };
	    CSSRGB.prototype.buildCSSText = function (n, p, result) {
	        return result + "rgba(".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
	    };
	    return CSSRGB;
	}(CSSColorValue));

	/**
	 * CSSKeywordValue
	 */
	var unsetKeywordValue = new CSSKeywordValue('unset');
	var initialKeywordValue = new CSSKeywordValue('initial');
	var inheritKeywordValue = new CSSKeywordValue('inherit');
	var keywordCache = {
	    '': unsetKeywordValue,
	    unset: unsetKeywordValue,
	    initial: initialKeywordValue,
	    inherit: inheritKeywordValue,
	};
	var getOrCreateKeyword = function (name) {
	    if (!keywordCache[name]) {
	        keywordCache[name] = new CSSKeywordValue(name);
	    }
	    return keywordCache[name];
	};
	/**
	 * CSSColor
	 */
	var noneColor = new CSSRGB(0, 0, 0, 0, true);
	var transparentColor = new CSSRGB(0, 0, 0, 0);
	var getOrCreateRGBA = memoize(function (r, g, b, a) {
	    return new CSSRGB(r, g, b, a);
	}, function (r, g, b, a) {
	    return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
	});
	// export const getOrCreateUnitValue = memoize(
	//   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {
	//     return new CSSUnitValue(value, unitOrName);
	//   },
	//   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {
	//     return `${value}${unitOrName}`;
	//   },
	// );
	var getOrCreateUnitValue = function (value, unitOrName) {
	    if (unitOrName === void 0) { unitOrName = UnitType.kNumber; }
	    return new CSSUnitValue(value, unitOrName);
	};
	var PECENTAGE_50 = new CSSUnitValue(50, '%');

	/**
	 * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
	 */
	var Strategy;
	(function (Strategy) {
	    Strategy[Strategy["Standard"] = 0] = "Standard";
	})(Strategy || (Strategy = {}));

	var SortReason;
	(function (SortReason) {
	    SortReason[SortReason["ADDED"] = 0] = "ADDED";
	    SortReason[SortReason["REMOVED"] = 1] = "REMOVED";
	    SortReason[SortReason["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
	})(SortReason || (SortReason = {}));

	var EMPTY_PARSED_PATH = {
	    absolutePath: [],
	    hasArc: false,
	    segments: [],
	    polygons: [],
	    polylines: [],
	    curve: null,
	    totalLength: 0,
	    rect: new Rectangle(0, 0, 0, 0),
	};

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type
	 */
	var PropertySyntax;
	(function (PropertySyntax) {
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#coordinate
	     */
	    PropertySyntax["COORDINATE"] = "<coordinate>";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#color
	     */
	    PropertySyntax["COLOR"] = "<color>";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#paint
	     */
	    PropertySyntax["PAINT"] = "<paint>";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#number
	     */
	    PropertySyntax["NUMBER"] = "<number>";
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle
	     */
	    PropertySyntax["ANGLE"] = "<angle>";
	    /**
	     * <number> with range 0..1
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#opacity_value
	     */
	    PropertySyntax["OPACITY_VALUE"] = "<opacity-value>";
	    /**
	     * <number> with range 0..Infinity
	     */
	    PropertySyntax["SHADOW_BLUR"] = "<shadow-blur>";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#length
	     */
	    PropertySyntax["LENGTH"] = "<length>";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#percentage
	     */
	    PropertySyntax["PERCENTAGE"] = "<percentage>";
	    PropertySyntax["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
	    PropertySyntax["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/margin#formal_syntax
	     */
	    PropertySyntax["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#list-of-ts
	     */
	    PropertySyntax["LIST_OF_POINTS"] = "<list-of-points>";
	    PropertySyntax["PATH"] = "<path>";
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/filter#formal_syntax
	     */
	    PropertySyntax["FILTER"] = "<filter>";
	    PropertySyntax["Z_INDEX"] = "<z-index>";
	    PropertySyntax["OFFSET_DISTANCE"] = "<offset-distance>";
	    PropertySyntax["DEFINED_PATH"] = "<defined-path>";
	    PropertySyntax["MARKER"] = "<marker>";
	    PropertySyntax["TRANSFORM"] = "<transform>";
	    PropertySyntax["TRANSFORM_ORIGIN"] = "<transform-origin>";
	    PropertySyntax["TEXT"] = "<text>";
	    PropertySyntax["TEXT_TRANSFORM"] = "<text-transform>";
	})(PropertySyntax || (PropertySyntax = {}));

	/**
	 * borrow from gradient-parser, but we delete some browser compatible prefix such as `-webkit-`
	 * @see https://github.com/rafaelcaricio/gradient-parser
	 */
	function colorStopToString(colorStop) {
	    var type = colorStop.type, value = colorStop.value;
	    if (type === 'hex') {
	        return "#".concat(value);
	    }
	    else if (type === 'literal') {
	        return value;
	    }
	    else if (type === 'rgb') {
	        return "rgb(".concat(value.join(','), ")");
	    }
	    else {
	        return "rgba(".concat(value.join(','), ")");
	    }
	}
	var parseGradient$1 = (function () {
	    var tokens = {
	        linearGradient: /^(linear\-gradient)/i,
	        repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
	        radialGradient: /^(radial\-gradient)/i,
	        repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
	        /**
	         * @see https://projects.verou.me/conic-gradient/
	         */
	        conicGradient: /^(conic\-gradient)/i,
	        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
	        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
	        positionKeywords: /^(left|center|right|top|bottom)/i,
	        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
	        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
	        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
	        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
	        startCall: /^\(/,
	        endCall: /^\)/,
	        comma: /^,/,
	        hexColor: /^\#([0-9a-fA-F]+)/,
	        literalColor: /^([a-zA-Z]+)/,
	        rgbColor: /^rgb/i,
	        rgbaColor: /^rgba/i,
	        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/,
	    };
	    var input = '';
	    function error(msg) {
	        throw new Error(input + ': ' + msg);
	    }
	    function getAST() {
	        var ast = matchListDefinitions();
	        if (input.length > 0) {
	            error('Invalid input not EOF');
	        }
	        return ast;
	    }
	    function matchListDefinitions() {
	        return matchListing(matchDefinition);
	    }
	    function matchDefinition() {
	        return (matchGradient('linear-gradient', tokens.linearGradient, matchLinearOrientation) ||
	            matchGradient('repeating-linear-gradient', tokens.repeatingLinearGradient, matchLinearOrientation) ||
	            matchGradient('radial-gradient', tokens.radialGradient, matchListRadialOrientations) ||
	            matchGradient('repeating-radial-gradient', tokens.repeatingRadialGradient, matchListRadialOrientations) ||
	            matchGradient('conic-gradient', tokens.conicGradient, matchListRadialOrientations));
	    }
	    function matchGradient(gradientType, pattern, orientationMatcher) {
	        return matchCall(pattern, function (captures) {
	            var orientation = orientationMatcher();
	            if (orientation) {
	                if (!scan(tokens.comma)) {
	                    error('Missing comma before color stops');
	                }
	            }
	            return {
	                type: gradientType,
	                orientation: orientation,
	                colorStops: matchListing(matchColorStop),
	            };
	        });
	    }
	    function matchCall(pattern, callback) {
	        var captures = scan(pattern);
	        if (captures) {
	            if (!scan(tokens.startCall)) {
	                error('Missing (');
	            }
	            var result = callback(captures);
	            if (!scan(tokens.endCall)) {
	                error('Missing )');
	            }
	            return result;
	        }
	    }
	    function matchLinearOrientation() {
	        return matchSideOrCorner() || matchAngle();
	    }
	    function matchSideOrCorner() {
	        return match('directional', tokens.sideOrCorner, 1);
	    }
	    function matchAngle() {
	        return match('angular', tokens.angleValue, 1);
	    }
	    function matchListRadialOrientations() {
	        var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
	        if (radialOrientation) {
	            radialOrientations = [];
	            radialOrientations.push(radialOrientation);
	            lookaheadCache = input;
	            if (scan(tokens.comma)) {
	                radialOrientation = matchRadialOrientation();
	                if (radialOrientation) {
	                    radialOrientations.push(radialOrientation);
	                }
	                else {
	                    input = lookaheadCache;
	                }
	            }
	        }
	        return radialOrientations;
	    }
	    function matchRadialOrientation() {
	        var radialType = matchCircle() || matchEllipse();
	        if (radialType) {
	            // @ts-ignore
	            radialType.at = matchAtPosition();
	        }
	        else {
	            var extent = matchExtentKeyword();
	            if (extent) {
	                radialType = extent;
	                var positionAt = matchAtPosition();
	                if (positionAt) {
	                    // @ts-ignore
	                    radialType.at = positionAt;
	                }
	            }
	            else {
	                var defaultPosition = matchPositioning();
	                if (defaultPosition) {
	                    radialType = {
	                        type: 'default-radial',
	                        // @ts-ignore
	                        at: defaultPosition,
	                    };
	                }
	            }
	        }
	        return radialType;
	    }
	    function matchCircle() {
	        var circle = match('shape', /^(circle)/i, 0);
	        if (circle) {
	            // @ts-ignore
	            circle.style = matchLength() || matchExtentKeyword();
	        }
	        return circle;
	    }
	    function matchEllipse() {
	        var ellipse = match('shape', /^(ellipse)/i, 0);
	        if (ellipse) {
	            // @ts-ignore
	            ellipse.style = matchDistance() || matchExtentKeyword();
	        }
	        return ellipse;
	    }
	    function matchExtentKeyword() {
	        return match('extent-keyword', tokens.extentKeywords, 1);
	    }
	    function matchAtPosition() {
	        if (match('position', /^at/, 0)) {
	            var positioning = matchPositioning();
	            if (!positioning) {
	                error('Missing positioning value');
	            }
	            return positioning;
	        }
	    }
	    function matchPositioning() {
	        var location = matchCoordinates();
	        if (location.x || location.y) {
	            return {
	                type: 'position',
	                value: location,
	            };
	        }
	    }
	    function matchCoordinates() {
	        return {
	            x: matchDistance(),
	            y: matchDistance(),
	        };
	    }
	    function matchListing(matcher) {
	        var captures = matcher();
	        var result = [];
	        if (captures) {
	            result.push(captures);
	            while (scan(tokens.comma)) {
	                captures = matcher();
	                if (captures) {
	                    result.push(captures);
	                }
	                else {
	                    error('One extra comma');
	                }
	            }
	        }
	        return result;
	    }
	    function matchColorStop() {
	        var color = matchColor();
	        if (!color) {
	            error('Expected color definition');
	        }
	        color.length = matchDistance();
	        return color;
	    }
	    function matchColor() {
	        return (matchHexColor() ||
	            matchRGBAColor() ||
	            matchRGBColor() ||
	            matchLiteralColor());
	    }
	    function matchLiteralColor() {
	        return match('literal', tokens.literalColor, 0);
	    }
	    function matchHexColor() {
	        return match('hex', tokens.hexColor, 1);
	    }
	    function matchRGBColor() {
	        return matchCall(tokens.rgbColor, function () {
	            return {
	                type: 'rgb',
	                value: matchListing(matchNumber),
	            };
	        });
	    }
	    function matchRGBAColor() {
	        return matchCall(tokens.rgbaColor, function () {
	            return {
	                type: 'rgba',
	                value: matchListing(matchNumber),
	            };
	        });
	    }
	    function matchNumber() {
	        return scan(tokens.number)[1];
	    }
	    function matchDistance() {
	        return (match('%', tokens.percentageValue, 1) ||
	            matchPositionKeyword() ||
	            matchLength());
	    }
	    function matchPositionKeyword() {
	        return match('position-keyword', tokens.positionKeywords, 1);
	    }
	    function matchLength() {
	        return match('px', tokens.pixelValue, 1) || match('em', tokens.emValue, 1);
	    }
	    function match(type, pattern, captureIndex) {
	        var captures = scan(pattern);
	        if (captures) {
	            return {
	                type: type,
	                value: captures[captureIndex],
	            };
	        }
	    }
	    function scan(regexp) {
	        var blankCaptures = /^[\n\r\t\s]+/.exec(input);
	        if (blankCaptures) {
	            consume(blankCaptures[0].length);
	        }
	        var captures = regexp.exec(input);
	        if (captures) {
	            consume(captures[0].length);
	        }
	        return captures;
	    }
	    function consume(size) {
	        input = input.substring(size);
	    }
	    return function (code) {
	        input = code;
	        return getAST();
	    };
	})();
	function computeLinearGradient(width, height, angle) {
	    var rad = deg2rad(angle.value);
	    var rx = 0;
	    var ry = 0;
	    var rcx = rx + width / 2;
	    var rcy = ry + height / 2;
	    // get the length of gradient line
	    // @see https://observablehq.com/@danburzo/css-gradient-line
	    var length = Math.abs(width * Math.cos(rad)) + Math.abs(height * Math.sin(rad));
	    var x1 = rcx - (Math.cos(rad) * length) / 2;
	    var y1 = rcy - (Math.sin(rad) * length) / 2;
	    var x2 = rcx + (Math.cos(rad) * length) / 2;
	    var y2 = rcy + (Math.sin(rad) * length) / 2;
	    return { x1: x1, y1: y1, x2: x2, y2: y2 };
	}
	function computeRadialGradient(width, height, cx, cy, size) {
	    // 'px'
	    var x = cx.value;
	    var y = cy.value;
	    // TODO: 'em'
	    // '%'
	    if (cx.unit === UnitType.kPercentage) {
	        x = (cx.value / 100) * width;
	    }
	    if (cy.unit === UnitType.kPercentage) {
	        y = (cy.value / 100) * height;
	    }
	    // default to farthest-side
	    var r = Math.max(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
	    if (size) {
	        if (size instanceof CSSUnitValue) {
	            r = size.value;
	        }
	        else if (size instanceof CSSKeywordValue) {
	            // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients#example_closest-side_for_circles
	            if (size.value === 'closest-side') {
	                r = Math.min(x, width - x, y, height - y);
	            }
	            else if (size.value === 'farthest-side') {
	                r = Math.max(x, width - x, y, height - y);
	            }
	            else if (size.value === 'closest-corner') {
	                r = Math.min(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
	            }
	        }
	    }
	    return { x: x, y: y, r: r };
	}

	var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
	var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
	var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
	var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
	function spaceColorStops(colorStops) {
	    var _a, _b, _c;
	    var length = colorStops.length;
	    colorStops[length - 1].length = (_a = colorStops[length - 1].length) !== null && _a !== void 0 ? _a : {
	        type: '%',
	        value: '100',
	    };
	    if (length > 1) {
	        colorStops[0].length = (_b = colorStops[0].length) !== null && _b !== void 0 ? _b : {
	            type: '%',
	            value: '0',
	        };
	    }
	    var previousIndex = 0;
	    var previousOffset = Number(colorStops[0].length.value);
	    for (var i = 1; i < length; i++) {
	        // support '%' & 'px'
	        var offset = (_c = colorStops[i].length) === null || _c === void 0 ? void 0 : _c.value;
	        if (!isNil(offset) && !isNil(previousOffset)) {
	            for (var j = 1; j < i - previousIndex; j++)
	                colorStops[previousIndex + j].length = {
	                    type: '%',
	                    value: "".concat(previousOffset +
	                        ((Number(offset) - previousOffset) * j) / (i - previousIndex)),
	                };
	            previousIndex = i;
	            previousOffset = Number(offset);
	        }
	    }
	}
	// The position of the gradient line's starting point.
	// different from CSS side(to top) @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#values
	var SideOrCornerToDegMap = {
	    left: 270 - 90,
	    top: 0 - 90,
	    bottom: 180 - 90,
	    right: 90 - 90,
	    'left top': 315 - 90,
	    'top left': 315 - 90,
	    'left bottom': 225 - 90,
	    'bottom left': 225 - 90,
	    'right top': 45 - 90,
	    'top right': 45 - 90,
	    'right bottom': 135 - 90,
	    'bottom right': 135 - 90,
	};
	var angleToDeg = memoize(function (orientation) {
	    var angle;
	    if (orientation.type === 'angular') {
	        angle = Number(orientation.value);
	    }
	    else {
	        angle = SideOrCornerToDegMap[orientation.value] || 0;
	    }
	    return getOrCreateUnitValue(angle, 'deg');
	});
	var positonToCSSUnitValue = memoize(function (position) {
	    var cx = 50;
	    var cy = 50;
	    var unitX = '%';
	    var unitY = '%';
	    if ((position === null || position === void 0 ? void 0 : position.type) === 'position') {
	        var _a = position.value, x = _a.x, y = _a.y;
	        if ((x === null || x === void 0 ? void 0 : x.type) === 'position-keyword') {
	            if (x.value === 'left') {
	                cx = 0;
	            }
	            else if (x.value === 'center') {
	                cx = 50;
	            }
	            else if (x.value === 'right') {
	                cx = 100;
	            }
	            else if (x.value === 'top') {
	                cy = 0;
	            }
	            else if (x.value === 'bottom') {
	                cy = 100;
	            }
	        }
	        if ((y === null || y === void 0 ? void 0 : y.type) === 'position-keyword') {
	            if (y.value === 'left') {
	                cx = 0;
	            }
	            else if (y.value === 'center') {
	                cy = 50;
	            }
	            else if (y.value === 'right') {
	                cx = 100;
	            }
	            else if (y.value === 'top') {
	                cy = 0;
	            }
	            else if (y.value === 'bottom') {
	                cy = 100;
	            }
	        }
	        if ((x === null || x === void 0 ? void 0 : x.type) === 'px' || (x === null || x === void 0 ? void 0 : x.type) === '%' || (x === null || x === void 0 ? void 0 : x.type) === 'em') {
	            unitX = x === null || x === void 0 ? void 0 : x.type;
	            cx = Number(x.value);
	        }
	        if ((y === null || y === void 0 ? void 0 : y.type) === 'px' || (y === null || y === void 0 ? void 0 : y.type) === '%' || (y === null || y === void 0 ? void 0 : y.type) === 'em') {
	            unitY = y === null || y === void 0 ? void 0 : y.type;
	            cy = Number(y.value);
	        }
	    }
	    return {
	        cx: getOrCreateUnitValue(cx, unitX),
	        cy: getOrCreateUnitValue(cy, unitY),
	    };
	});
	var parseGradient = memoize(function (colorStr) {
	    var _a;
	    if (colorStr.indexOf('linear') > -1 || colorStr.indexOf('radial') > -1) {
	        var ast = parseGradient$1(colorStr);
	        return ast.map(function (_a) {
	            var type = _a.type, orientation = _a.orientation, colorStops = _a.colorStops;
	            spaceColorStops(colorStops);
	            var steps = colorStops.map(function (colorStop) {
	                // TODO: only support % for now, should calc percentage of axis length when using px/em
	                return {
	                    offset: getOrCreateUnitValue(Number(colorStop.length.value), '%'),
	                    color: colorStopToString(colorStop),
	                };
	            });
	            if (type === 'linear-gradient') {
	                return new CSSGradientValue(GradientType.LinearGradient, {
	                    angle: orientation
	                        ? angleToDeg(orientation)
	                        : Odeg,
	                    steps: steps,
	                });
	            }
	            else if (type === 'radial-gradient') {
	                if (!orientation) {
	                    orientation = [
	                        {
	                            type: 'shape',
	                            value: 'circle',
	                        },
	                    ];
	                }
	                if (orientation[0].type === 'shape' &&
	                    orientation[0].value === 'circle') {
	                    var _b = positonToCSSUnitValue(orientation[0].at), cx = _b.cx, cy = _b.cy;
	                    var size = void 0;
	                    if (orientation[0].style) {
	                        var _c = orientation[0].style, type_1 = _c.type, value = _c.value;
	                        if (type_1 === 'extent-keyword') {
	                            size = getOrCreateKeyword(value);
	                        }
	                        else {
	                            size = getOrCreateUnitValue(value, type_1);
	                        }
	                    }
	                    return new CSSGradientValue(GradientType.RadialGradient, {
	                        cx: cx,
	                        cy: cy,
	                        size: size,
	                        steps: steps,
	                    });
	                }
	                // TODO: support ellipse shape
	                // TODO: repeating-linear-gradient & repeating-radial-gradient
	                // } else if (type === 'repeating-linear-gradient') {
	                // } else if (type === 'repeating-radial-gradient') {
	            }
	        });
	    }
	    // legacy format, should be deprecated later
	    var type = colorStr[0];
	    if (colorStr[1] === '(' || colorStr[2] === '(') {
	        if (type === 'l') {
	            var arr = regexLG.exec(colorStr);
	            if (arr) {
	                var steps = ((_a = arr[2].match(regexColorStop)) === null || _a === void 0 ? void 0 : _a.map(function (stop) { return stop.split(':'); })) || [];
	                return [
	                    new CSSGradientValue(GradientType.LinearGradient, {
	                        angle: getOrCreateUnitValue(parseFloat(arr[1]), 'deg'),
	                        steps: steps.map(function (_a) {
	                            var _b = __read(_a, 2), offset = _b[0], color = _b[1];
	                            return ({
	                                offset: getOrCreateUnitValue(Number(offset) * 100, '%'),
	                                color: color,
	                            });
	                        }),
	                    }),
	                ];
	            }
	        }
	        else if (type === 'r') {
	            var parsedRadialGradient = parseRadialGradient(colorStr);
	            if (parsedRadialGradient) {
	                if (isString(parsedRadialGradient)) {
	                    colorStr = parsedRadialGradient;
	                }
	                else {
	                    return [
	                        new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient),
	                    ];
	                }
	            }
	        }
	        else if (type === 'p') {
	            return parsePattern(colorStr);
	        }
	    }
	});
	function parseRadialGradient(gradientStr) {
	    var _a;
	    var arr = regexRG.exec(gradientStr);
	    if (arr) {
	        var steps = ((_a = arr[4].match(regexColorStop)) === null || _a === void 0 ? void 0 : _a.map(function (stop) { return stop.split(':'); })) || [];
	        return {
	            cx: getOrCreateUnitValue(50, '%'),
	            cy: getOrCreateUnitValue(50, '%'),
	            steps: steps.map(function (_a) {
	                var _b = __read(_a, 2), offset = _b[0], color = _b[1];
	                return ({
	                    offset: getOrCreateUnitValue(Number(offset) * 100, '%'),
	                    color: color,
	                });
	            }),
	        };
	    }
	    return null;
	}
	function parsePattern(patternStr) {
	    var arr = regexPR.exec(patternStr);
	    if (arr) {
	        var repetition = arr[1];
	        var src = arr[2];
	        switch (repetition) {
	            case 'a':
	                repetition = 'repeat';
	                break;
	            case 'x':
	                repetition = 'repeat-x';
	                break;
	            case 'y':
	                repetition = 'repeat-y';
	                break;
	            case 'n':
	                repetition = 'no-repeat';
	                break;
	            default:
	                repetition = 'no-repeat';
	        }
	        return {
	            image: src,
	            // @ts-ignore
	            repetition: repetition,
	        };
	    }
	    return null;
	}
	function isPattern(object) {
	    return object && !!object.image;
	}
	function isCSSRGB(object) {
	    return (object &&
	        !isNil(object.r) &&
	        !isNil(object.g) &&
	        !isNil(object.b));
	}
	/**
	 * @see https://github.com/WebKit/WebKit/blob/main/Source/WebCore/css/parser/CSSParser.cpp#L97
	 */
	var parseColor = memoize(function (colorStr) {
	    if (isPattern(colorStr)) {
	        return __assign({ repetition: 'repeat' }, colorStr);
	    }
	    if (isNil(colorStr)) {
	        colorStr = '';
	    }
	    if (colorStr === 'transparent') {
	        // transparent black
	        return transparentColor;
	    }
	    else if (colorStr === 'currentColor') {
	        // @see https://github.com/adobe-webplatform/Snap.svg/issues/526
	        colorStr = 'black';
	    }
	    // support CSS gradient syntax
	    var g = parseGradient(colorStr);
	    if (g) {
	        return g;
	    }
	    // constants
	    var color$1 = color(colorStr);
	    var rgba = [0, 0, 0, 0];
	    if (color$1 !== null) {
	        rgba[0] = color$1.r || 0;
	        rgba[1] = color$1.g || 0;
	        rgba[2] = color$1.b || 0;
	        rgba[3] = color$1.opacity;
	    }
	    // return new CSSRGB(...rgba);
	    return getOrCreateRGBA.apply(void 0, __spreadArray([], __read(rgba), false));
	});
	function mergeColors(left, right) {
	    // only support constant value, exclude gradient & pattern
	    if (!isCSSRGB(left) || !isCSSRGB(right)) {
	        return;
	    }
	    return [
	        [Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)],
	        [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)],
	        function (color) {
	            var rgba = color.slice();
	            if (rgba[3]) {
	                for (var i = 0; i < 3; i++)
	                    rgba[i] = Math.round(clamp(rgba[i], 0, 255));
	            }
	            rgba[3] = clamp(rgba[3], 0, 1);
	            return "rgba(".concat(rgba.join(','), ")");
	        },
	    ];
	}

	function parseDimension(unitRegExp, string) {
	    if (isNil(string)) {
	        return getOrCreateUnitValue(0, 'px');
	    }
	    string = "".concat(string).trim().toLowerCase();
	    if (isFinite(Number(string))) {
	        if ('px'.search(unitRegExp) >= 0) {
	            return getOrCreateUnitValue(Number(string), 'px');
	        }
	        else if ('deg'.search(unitRegExp) >= 0) {
	            return getOrCreateUnitValue(Number(string), 'deg');
	        }
	    }
	    var matchedUnits = [];
	    string = string.replace(unitRegExp, function (match) {
	        matchedUnits.push(match);
	        return 'U' + match;
	    });
	    var taggedUnitRegExp = 'U(' + unitRegExp.source + ')';
	    return matchedUnits.map(function (unit) {
	        return getOrCreateUnitValue(Number(string
	            .replace(new RegExp('U' + unit, 'g'), '')
	            .replace(new RegExp(taggedUnitRegExp, 'g'), '*0')), unit);
	    })[0];
	}
	/**
	 * <length>
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length
	 * length with only absolute unit, eg. 1px
	 */
	var parseLength = memoize(function (css) {
	    return parseDimension(new RegExp('px', 'g'), css);
	});
	/**
	 * <percentage>
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage
	 */
	memoize(function (css) {
	    return parseDimension(new RegExp('%', 'g'), css);
	});
	/**
	 * length with absolute or relative unit,
	 * eg. 1px, 0.7em, 50%, calc(100% - 200px);
	 *
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length-percentage
	 */
	// export const parseLengthOrPercentage = memoize((css: string): CSSUnitValue => {
	//   if (isNumber(css) || isFinite(Number(css))) {
	//     return getOrCreateUnitValue(Number(css), 'px');
	//   }
	//   return parseDimension(new RegExp('px|%|em|rem', 'g'), css) as CSSUnitValue;
	// });
	var parseLengthOrPercentage = function (css) {
	    if (isNumber(css) || isFinite(Number(css))) {
	        // Number(css) is NaN
	        return getOrCreateUnitValue(Number(css) || 0, 'px');
	        // return Number(css);
	    }
	    return parseDimension(new RegExp('px|%|em|rem', 'g'), css);
	};
	var parseAngle = memoize(function (css) {
	    return parseDimension(new RegExp('deg|rad|grad|turn', 'g'), css);
	});
	/**
	 * merge CSSUnitValue
	 *
	 * @example
	 * 10px + 20px = 30px
	 * 10deg + 10rad
	 * 10% + 20% = 30%
	 */
	function mergeDimensions(left, right, target, nonNegative, index) {
	    if (index === void 0) { index = 0; }
	    var unit = '';
	    var leftValue = left.value || 0;
	    var rightValue = right.value || 0;
	    var canonicalUnit = toCanonicalUnit(left.unit);
	    var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
	    var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
	    if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
	        leftValue = leftCanonicalUnitValue.value;
	        rightValue = rightCanonicalUnitValue.value;
	        unit = unitTypeToString(left.unit);
	    }
	    else {
	        // format '%' to 'px'
	        if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
	            leftValue = convertPercentUnit(left, index, target);
	            rightValue = convertPercentUnit(right, index, target);
	            unit = 'px';
	        }
	    }
	    // // format 'rad' 'turn' to 'deg'
	    // if (CSSUnitValue.isAngle(left.unit) || CSSUnitValue.isAngle(right.unit)) {
	    //   leftValue = convertAngleUnit(left);
	    //   rightValue = convertAngleUnit(right);
	    //   unit = 'deg';
	    // }
	    return [
	        leftValue,
	        rightValue,
	        function (value) {
	            if (nonNegative) {
	                value = Math.max(value, 0);
	            }
	            return value + unit;
	        },
	    ];
	}
	function convertAngleUnit(value) {
	    var deg = 0;
	    if (value.unit === UnitType.kDegrees) {
	        deg = value.value;
	    }
	    else if (value.unit === UnitType.kRadians) {
	        deg = rad2deg(Number(value.value));
	    }
	    else if (value.unit === UnitType.kTurns) {
	        deg = turn2deg(Number(value.value));
	    }
	    return deg;
	}
	function parseDimensionArrayFormat(string, size) {
	    var parsed;
	    if (Array.isArray(string)) {
	        // [1, '2px', 3]
	        parsed = string.map(function (segment) { return Number(segment); });
	    }
	    else if (isString(string)) {
	        parsed = string.split(' ').map(function (segment) { return Number(segment); });
	    }
	    else if (isNumber(string)) {
	        parsed = [string];
	    }
	    if (size === 2) {
	        if (parsed.length === 1) {
	            return [parsed[0], parsed[0]];
	        }
	        else {
	            return [parsed[0], parsed[1]];
	        }
	    }
	    else {
	        if (parsed.length === 1) {
	            return [parsed[0], parsed[0], parsed[0], parsed[0]];
	        }
	        else if (parsed.length === 2) {
	            return [parsed[0], parsed[1], parsed[0], parsed[1]];
	        }
	        else if (parsed.length === 3) {
	            return [parsed[0], parsed[1], parsed[2], parsed[1]];
	        }
	        else {
	            return [parsed[0], parsed[1], parsed[2], parsed[3]];
	        }
	    }
	}
	function parseDimensionArray(string) {
	    if (isString(string)) {
	        // "1px 2px 3px"
	        return string.split(' ').map(function (segment) { return parseLengthOrPercentage(segment); });
	    }
	    else {
	        // [1, '2px', 3]
	        return string.map(function (segment) { return parseLengthOrPercentage(segment.toString()); });
	    }
	}
	// export function mergeDimensionList(
	//   left: CSSUnitValue[],
	//   right: CSSUnitValue[],
	//   target: IElement | null,
	// ): [number[], number[], (list: number[]) => string] | undefined {
	//   if (left.length !== right.length) {
	//     return;
	//   }
	//   const unit = left[0].unit;
	//   return [
	//     left.map((l) => l.value),
	//     right.map((l) => l.value),
	//     (values: number[]) => {
	//       return values.map((n) => new CSSUnitValue(n, unit)).join(' ');
	//     },
	//   ];
	// }
	function convertPercentUnit(valueWithUnit, vec3Index, target) {
	    if (valueWithUnit.value === 0) {
	        return 0;
	    }
	    if (valueWithUnit.unit === UnitType.kPixels) {
	        return Number(valueWithUnit.value);
	    }
	    else if (valueWithUnit.unit === UnitType.kPercentage && target) {
	        var bounds = target.nodeName === Shape.GROUP
	            ? target.getLocalBounds()
	            : // : target.getGeometryBounds();
	                target.geometry.contentBounds;
	        return (valueWithUnit.value / 100) * bounds.halfExtents[vec3Index] * 2;
	    }
	    return 0;
	}

	var parseParam = function (css) {
	    return parseDimension(/deg|rad|grad|turn|px|%/g, css);
	};
	var supportedFilters = [
	    'blur',
	    'brightness',
	    'drop-shadow',
	    'contrast',
	    'grayscale',
	    'sepia',
	    'saturate',
	    'hue-rotate',
	    'invert',
	];
	function parseFilter(filterStr) {
	    if (filterStr === void 0) { filterStr = ''; }
	    filterStr = filterStr.toLowerCase().trim();
	    if (filterStr === 'none') {
	        return [];
	    }
	    var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
	    var result = [];
	    var match;
	    var prevLastIndex = 0;
	    while ((match = filterRegExp.exec(filterStr))) {
	        if (match.index !== prevLastIndex) {
	            return [];
	        }
	        prevLastIndex = match.index + match[0].length;
	        if (supportedFilters.indexOf(match[1]) > -1) {
	            result.push({
	                name: match[1],
	                params: match[2].split(' ').map(function (p) { return parseParam(p) || parseColor(p); }),
	            });
	        }
	        if (filterRegExp.lastIndex === filterStr.length) {
	            return result;
	        }
	    }
	    return [];
	}

	function numberToString(x) {
	    // scale(0.00000001) -> scale(0)
	    // return x.toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
	    return x.toString();
	}
	/**
	 * parse string or number to CSSUnitValue(numeric)
	 *
	 * eg.
	 * * 0 -> CSSUnitValue(0)
	 * * '2' -> CSSUnitValue(2)
	 */
	var parseNumber = memoize(function (string) {
	    if (typeof string === 'number') {
	        return getOrCreateUnitValue(string);
	    }
	    if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
	        return getOrCreateUnitValue(Number(string));
	    }
	    else {
	        return getOrCreateUnitValue(0);
	    }
	});
	/**
	 * separate string to array
	 * eg.
	 * * [0.5, 0.5] -> [CSSUnitValue, CSSUnitValue]
	 */
	memoize(function (string) {
	    if (isString(string)) {
	        return string.split(' ').map(parseNumber);
	    }
	    else {
	        return string.map(parseNumber);
	    }
	});
	function mergeNumbers(left, right) {
	    return [left, right, numberToString];
	}
	function clampedMergeNumbers(min, max) {
	    return function (left, right) { return [
	        left,
	        right,
	        function (x) { return numberToString(clamp(x, min, max)); },
	    ]; };
	}
	function mergeNumberLists(left, right) {
	    if (left.length !== right.length) {
	        return;
	    }
	    return [
	        left,
	        right,
	        function (numberList) {
	            return numberList;
	        },
	    ];
	}

	function getOrCalculatePathTotalLength(path) {
	    if (path.parsedStyle.path.totalLength === 0) {
	        path.parsedStyle.path.totalLength = getTotalLength(path.parsedStyle.path.absolutePath);
	    }
	    return path.parsedStyle.path.totalLength;
	}
	function hasArcOrBezier(path) {
	    var hasArc = false;
	    var count = path.length;
	    for (var i = 0; i < count; i++) {
	        var params = path[i];
	        var cmd = params[0];
	        if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {
	            hasArc = true;
	            break;
	        }
	    }
	    return hasArc;
	}
	function extractPolygons(pathArray) {
	    var polygons = [];
	    var polylines = [];
	    var points = []; // 防止第一个命令不是 'M'
	    for (var i = 0; i < pathArray.length; i++) {
	        var params = pathArray[i];
	        var cmd = params[0];
	        if (cmd === 'M') {
	            // 遇到 'M' 判定是否是新数组，新数组中没有点
	            if (points.length) {
	                // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形
	                polylines.push(points);
	                points = []; // 创建新的点
	            }
	            points.push([params[1], params[2]]);
	        }
	        else if (cmd === 'Z') {
	            if (points.length) {
	                // 存在点
	                polygons.push(points);
	                points = []; // 开始新的点集合
	            }
	            // 如果不存在点，同时 'Z'，则说明是错误，不处理
	        }
	        else {
	            points.push([params[1], params[2]]);
	        }
	    }
	    // 说明 points 未放入 polygons 或者 polyline
	    // 仅当只有一个 M，没有 Z 时会发生这种情况
	    if (points.length > 0) {
	        polylines.push(points);
	    }
	    return {
	        polygons: polygons,
	        polylines: polylines,
	    };
	}
	function isSamePoint(point1, point2) {
	    return point1[0] === point2[0] && point1[1] === point2[1];
	}
	function getPathBBox(segments, lineWidth) {
	    var xArr = [];
	    var yArr = [];
	    var segmentsWithAngle = [];
	    for (var i = 0; i < segments.length; i++) {
	        var segment = segments[i];
	        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
	        var box$1 = void 0;
	        switch (segment.command) {
	            case 'Q':
	                box$1 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
	                break;
	            case 'C':
	                box$1 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
	                break;
	            case 'A':
	                var arcParams = segment.arcParams;
	                box$1 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
	                break;
	            default:
	                xArr.push(currentPoint[0]);
	                yArr.push(currentPoint[1]);
	                break;
	        }
	        if (box$1) {
	            segment.box = box$1;
	            xArr.push(box$1.x, box$1.x + box$1.width);
	            yArr.push(box$1.y, box$1.y + box$1.height);
	        }
	        if (lineWidth &&
	            (segment.command === 'L' || segment.command === 'M') &&
	            segment.prePoint &&
	            segment.nextPoint) {
	            segmentsWithAngle.push(segment);
	        }
	    }
	    // bbox calculation should ignore NaN for path attribute
	    // ref: https://github.com/antvis/g/issues/210
	    // ref: https://github.com/antvis/G2/issues/3109
	    xArr = xArr.filter(function (item) { return !Number.isNaN(item) && item !== Infinity && item !== -Infinity; });
	    yArr = yArr.filter(function (item) { return !Number.isNaN(item) && item !== Infinity && item !== -Infinity; });
	    var minX = min$1(xArr);
	    var minY = min$1(yArr);
	    var maxX = max$1(xArr);
	    var maxY = max$1(yArr);
	    if (segmentsWithAngle.length === 0) {
	        return {
	            x: minX,
	            y: minY,
	            width: maxX - minX,
	            height: maxY - minY,
	        };
	    }
	    for (var i = 0; i < segmentsWithAngle.length; i++) {
	        var segment = segmentsWithAngle[i];
	        var currentPoint = segment.currentPoint;
	        var extra = void 0;
	        if (currentPoint[0] === minX) {
	            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
	            minX = minX - extra.xExtra;
	        }
	        else if (currentPoint[0] === maxX) {
	            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
	            maxX = maxX + extra.xExtra;
	        }
	        if (currentPoint[1] === minY) {
	            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
	            minY = minY - extra.yExtra;
	        }
	        else if (currentPoint[1] === maxY) {
	            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
	            maxY = maxY + extra.yExtra;
	        }
	    }
	    return {
	        x: minX,
	        y: minY,
	        width: maxX - minX,
	        height: maxY - minY,
	    };
	}
	function getExtraFromSegmentWithAngle(segment, lineWidth) {
	    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
	    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) +
	        Math.pow(currentPoint[1] - prePoint[1], 2);
	    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) +
	        Math.pow(currentPoint[1] - nextPoint[1], 2);
	    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) +
	        Math.pow(prePoint[1] - nextPoint[1], 2);
	    // 以 currentPoint 为顶点的夹角
	    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) /
	        (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
	    // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度
	    // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等
	    if (!currentAngle ||
	        Math.sin(currentAngle) === 0 ||
	        isNumberEqual(currentAngle, 0)) {
	        return {
	            xExtra: 0,
	            yExtra: 0,
	        };
	    }
	    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
	    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
	    // 将夹角转为锐角
	    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
	    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
	    // 这里不考虑在水平和垂直方向的投影，直接使用最大差值
	    // 由于上层统一加减了二分之一线宽，这里需要进行弥补
	    var extra = {
	        // 水平方向投影
	        xExtra: Math.cos(currentAngle / 2 - xAngle) *
	            ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) -
	            lineWidth / 2 || 0,
	        // 垂直方向投影
	        yExtra: Math.cos(yAngle - currentAngle / 2) *
	            ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) -
	            lineWidth / 2 || 0,
	    };
	    return extra;
	}
	// 点对称
	function toSymmetry(point, center) {
	    return [
	        center[0] + (center[0] - point[0]),
	        center[1] + (center[1] - point[1]),
	    ];
	}
	var angleBetween$1 = function (v0, v1) {
	    var p = v0.x * v1.x + v0.y * v1.y;
	    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) *
	        (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
	    var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
	    var angle = sign * Math.acos(p / n);
	    return angle;
	};
	/**
	 * @see https://github.com/rveciana/svg-path-properties/blob/b6bd9a322966f6ef7a311872d80c56e3718de861/src/arc.ts#L121
	 */
	var pointOnEllipticalArc = function (p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
	    // In accordance to: http://www.w3.org/TR/SVG/implnote.html#ArcOutOfRangeParameters
	    rx = Math.abs(rx);
	    ry = Math.abs(ry);
	    xAxisRotation = mod(xAxisRotation, 360);
	    var xAxisRotationRadians = deg2rad(xAxisRotation);
	    // If the endpoints are identical, then this is equivalent to omitting the elliptical arc segment entirely.
	    if (p0.x === p1.x && p0.y === p1.y) {
	        return { x: p0.x, y: p0.y, ellipticalArcAngle: 0 }; // Check if angle is correct
	    }
	    // If rx = 0 or ry = 0 then this arc is treated as a straight line segment joining the endpoints.
	    if (rx === 0 || ry === 0) {
	        //return this.pointOnLine(p0, p1, t);
	        return { x: 0, y: 0, ellipticalArcAngle: 0 }; // Check if angle is correct
	    }
	    // Following "Conversion from endpoint to center parameterization"
	    // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter
	    // Step #1: Compute transformedPoint
	    var dx = (p0.x - p1.x) / 2;
	    var dy = (p0.y - p1.y) / 2;
	    var transformedPoint = {
	        x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
	        y: -Math.sin(xAxisRotationRadians) * dx +
	            Math.cos(xAxisRotationRadians) * dy,
	    };
	    // Ensure radii are large enough
	    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) +
	        Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
	    if (radiiCheck > 1) {
	        rx = Math.sqrt(radiiCheck) * rx;
	        ry = Math.sqrt(radiiCheck) * ry;
	    }
	    // Step #2: Compute transformedCenter
	    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) -
	        Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) -
	        Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
	    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) +
	        Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
	    var cRadicand = cSquareNumerator / cSquareRootDenom;
	    // Make sure this never drops below zero because of precision
	    cRadicand = cRadicand < 0 ? 0 : cRadicand;
	    var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
	    var transformedCenter = {
	        x: cCoef * ((rx * transformedPoint.y) / ry),
	        y: cCoef * (-(ry * transformedPoint.x) / rx),
	    };
	    // Step #3: Compute center
	    var center = {
	        x: Math.cos(xAxisRotationRadians) * transformedCenter.x -
	            Math.sin(xAxisRotationRadians) * transformedCenter.y +
	            (p0.x + p1.x) / 2,
	        y: Math.sin(xAxisRotationRadians) * transformedCenter.x +
	            Math.cos(xAxisRotationRadians) * transformedCenter.y +
	            (p0.y + p1.y) / 2,
	    };
	    // Step #4: Compute start/sweep angles
	    // Start angle of the elliptical arc prior to the stretch and rotate operations.
	    // Difference between the start and end angles
	    var startVector = {
	        x: (transformedPoint.x - transformedCenter.x) / rx,
	        y: (transformedPoint.y - transformedCenter.y) / ry,
	    };
	    var startAngle = angleBetween$1({
	        x: 1,
	        y: 0,
	    }, startVector);
	    var endVector = {
	        x: (-transformedPoint.x - transformedCenter.x) / rx,
	        y: (-transformedPoint.y - transformedCenter.y) / ry,
	    };
	    var sweepAngle = angleBetween$1(startVector, endVector);
	    if (!sweepFlag && sweepAngle > 0) {
	        sweepAngle -= 2 * Math.PI;
	    }
	    else if (sweepFlag && sweepAngle < 0) {
	        sweepAngle += 2 * Math.PI;
	    }
	    // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)
	    sweepAngle %= 2 * Math.PI;
	    // From http://www.w3.org/TR/SVG/implnote.html#ArcParameterizationAlternatives
	    var angle = startAngle + sweepAngle * t;
	    var ellipseComponentX = rx * Math.cos(angle);
	    var ellipseComponentY = ry * Math.sin(angle);
	    var point = {
	        x: Math.cos(xAxisRotationRadians) * ellipseComponentX -
	            Math.sin(xAxisRotationRadians) * ellipseComponentY +
	            center.x,
	        y: Math.sin(xAxisRotationRadians) * ellipseComponentX +
	            Math.cos(xAxisRotationRadians) * ellipseComponentY +
	            center.y,
	        ellipticalArcStartAngle: startAngle,
	        ellipticalArcEndAngle: startAngle + sweepAngle,
	        ellipticalArcAngle: angle,
	        ellipticalArcCenter: center,
	        resultantRx: rx,
	        resultantRy: ry,
	    };
	    return point;
	};
	function path2Segments(path) {
	    var segments = [];
	    var currentPoint = null; // 当前图形
	    var nextParams = null; // 下一节点的 path 参数
	    var startMovePoint = null; // 开始 M 的点，可能会有多个
	    var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引
	    var count = path.length;
	    for (var i = 0; i < count; i++) {
	        var params = path[i];
	        nextParams = path[i + 1];
	        var command = params[0];
	        // 数学定义上的参数，便于后面的计算
	        var segment = {
	            command: command,
	            prePoint: currentPoint,
	            params: params,
	            startTangent: null,
	            endTangent: null,
	            currentPoint: null,
	            nextPoint: null,
	            arcParams: null,
	            box: null,
	            cubicParams: null,
	        };
	        switch (command) {
	            case 'M':
	                startMovePoint = [params[1], params[2]];
	                lastStartMovePointIndex = i;
	                break;
	            case 'A':
	                var arcParams = getArcParams(currentPoint, params);
	                segment.arcParams = arcParams;
	                break;
	        }
	        if (command === 'Z') {
	            // 有了 Z 后，当前节点从开始 M 的点开始
	            currentPoint = startMovePoint;
	            // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点
	            nextParams = path[lastStartMovePointIndex + 1];
	        }
	        else {
	            var len = params.length;
	            currentPoint = [params[len - 2], params[len - 1]];
	        }
	        if (nextParams && nextParams[0] === 'Z') {
	            // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点
	            nextParams = path[lastStartMovePointIndex];
	            if (segments[lastStartMovePointIndex]) {
	                // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点
	                segments[lastStartMovePointIndex].prePoint = currentPoint;
	            }
	        }
	        segment.currentPoint = currentPoint;
	        // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点
	        if (segments[lastStartMovePointIndex] &&
	            isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
	            segments[lastStartMovePointIndex].prePoint = segment.prePoint;
	        }
	        var nextPoint = nextParams
	            ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]]
	            : null;
	        segment.nextPoint = nextPoint;
	        // Add startTangent and endTangent
	        var prePoint = segment.prePoint;
	        if (['L', 'H', 'V'].includes(command)) {
	            segment.startTangent = [
	                prePoint[0] - currentPoint[0],
	                prePoint[1] - currentPoint[1],
	            ];
	            segment.endTangent = [
	                currentPoint[0] - prePoint[0],
	                currentPoint[1] - prePoint[1],
	            ];
	        }
	        else if (command === 'Q') {
	            // 二次贝塞尔曲线只有一个控制点
	            var cp = [params[1], params[2]];
	            // 二次贝塞尔曲线的终点为 currentPoint
	            segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
	            segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
	        }
	        else if (command === 'T') {
	            var preSegment = segments[i - 1];
	            var cp = toSymmetry(preSegment.currentPoint, prePoint);
	            if (preSegment.command === 'Q') {
	                segment.command = 'Q';
	                segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
	                segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
	            }
	            else {
	                // @ts-ignore
	                segment.command = 'TL';
	                segment.startTangent = [
	                    prePoint[0] - currentPoint[0],
	                    prePoint[1] - currentPoint[1],
	                ];
	                segment.endTangent = [
	                    currentPoint[0] - prePoint[0],
	                    currentPoint[1] - prePoint[1],
	                ];
	            }
	        }
	        else if (command === 'C') {
	            // 三次贝塞尔曲线有两个控制点
	            var cp1 = [params[1], params[2]];
	            var cp2 = [params[3], params[4]];
	            segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
	            segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
	            // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]
	            if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
	                segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
	            }
	            if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
	                segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
	            }
	        }
	        else if (command === 'S') {
	            var preSegment = segments[i - 1];
	            var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
	            var cp2 = [params[1], params[2]];
	            if (preSegment.command === 'C') {
	                segment.command = 'C'; // 将 S 命令变换为 C 命令
	                segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
	                segment.endTangent = [
	                    currentPoint[0] - cp2[0],
	                    currentPoint[1] - cp2[1],
	                ];
	            }
	            else {
	                // @ts-ignore
	                segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令
	                segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
	                segment.endTangent = [
	                    currentPoint[0] - cp2[0],
	                    currentPoint[1] - cp2[1],
	                ];
	            }
	        }
	        else if (command === 'A') {
	            var _a = getTangentAtRatio(segment, 0), dx1 = _a.x, dy1 = _a.y;
	            var _b = getTangentAtRatio(segment, 1, false), dx2 = _b.x, dy2 = _b.y;
	            segment.startTangent = [dx1, dy1];
	            segment.endTangent = [dx2, dy2];
	        }
	        segments.push(segment);
	    }
	    return segments;
	}
	/**
	 * Use length instead of ratio
	 */
	function getTangentAtRatio(segment, ratio, sign) {
	    if (sign === void 0) { sign = true; }
	    var _a = segment.arcParams, _b = _a.rx, rx = _b === void 0 ? 0 : _b, _c = _a.ry, ry = _c === void 0 ? 0 : _c, xRotation = _a.xRotation, arcFlag = _a.arcFlag, sweepFlag = _a.sweepFlag;
	    var p1 = pointOnEllipticalArc({ x: segment.prePoint[0], y: segment.prePoint[1] }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, { x: segment.currentPoint[0], y: segment.currentPoint[1] }, ratio);
	    var p2 = pointOnEllipticalArc({ x: segment.prePoint[0], y: segment.prePoint[1] }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, { x: segment.currentPoint[0], y: segment.currentPoint[1] }, sign ? ratio + 0.005 : ratio - 0.005);
	    var xDist = p2.x - p1.x;
	    var yDist = p2.y - p1.y;
	    var dist = Math.sqrt(xDist * xDist + yDist * yDist);
	    return { x: -xDist / dist, y: -yDist / dist };
	}
	// 向量长度
	function vMag(v) {
	    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	}
	// u.v/|u||v|，计算夹角的余弦值
	function vRatio(u, v) {
	    // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1
	    return vMag(u) * vMag(v)
	        ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v))
	        : 1;
	}
	// 向量角度
	function vAngle(u, v) {
	    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	}
	function getArcParams(startPoint, params) {
	    var rx = params[1];
	    var ry = params[2];
	    var xRotation = mod(deg2rad(params[3]), Math.PI * 2);
	    var arcFlag = params[4];
	    var sweepFlag = params[5];
	    // 弧形起点坐标
	    var x1 = startPoint[0];
	    var y1 = startPoint[1];
	    // 弧形终点坐标
	    var x2 = params[6];
	    var y2 = params[7];
	    var xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 +
	        (Math.sin(xRotation) * (y1 - y2)) / 2.0;
	    var yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 +
	        (Math.cos(xRotation) * (y1 - y2)) / 2.0;
	    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	    if (lambda > 1) {
	        rx *= Math.sqrt(lambda);
	        ry *= Math.sqrt(lambda);
	    }
	    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
	    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
	    if (arcFlag === sweepFlag) {
	        f *= -1;
	    }
	    if (isNaN(f)) {
	        f = 0;
	    }
	    // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理
	    var cxp = ry ? (f * rx * yp) / ry : 0;
	    var cyp = rx ? (f * -ry * xp) / rx : 0;
	    // 椭圆圆心坐标
	    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
	    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
	    // 起始点的单位向量
	    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	    // 终止点的单位向量
	    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	    // 计算起始点和圆心的连线，与 x 轴正方向的夹角
	    var theta = vAngle([1, 0], u);
	    // 计算圆弧起始点和终止点与椭圆圆心连线的夹角
	    var dTheta = vAngle(u, v);
	    if (vRatio(u, v) <= -1) {
	        dTheta = Math.PI;
	    }
	    if (vRatio(u, v) >= 1) {
	        dTheta = 0;
	    }
	    if (sweepFlag === 0 && dTheta > 0) {
	        dTheta = dTheta - 2 * Math.PI;
	    }
	    if (sweepFlag === 1 && dTheta < 0) {
	        dTheta = dTheta + 2 * Math.PI;
	    }
	    return {
	        cx: cx,
	        cy: cy,
	        // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
	        rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
	        ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
	        startAngle: theta,
	        endAngle: theta + dTheta,
	        xRotation: xRotation,
	        arcFlag: arcFlag,
	        sweepFlag: sweepFlag,
	    };
	}
	function commandsToPathString(commands, object, transform) {
	    var _a = object.parsedStyle, _b = _a.defX, defX = _b === void 0 ? 0 : _b, _c = _a.defY, defY = _c === void 0 ? 0 : _c;
	    return commands.reduce(function (prev, cur) {
	        var path = '';
	        if (cur[0] === 'M' || cur[0] === 'L') {
	            var p = fromValues$2(cur[1] - defX, cur[2] - defY, 0);
	            if (transform) {
	                transformMat4(p, p, transform);
	            }
	            path = "".concat(cur[0]).concat(p[0], ",").concat(p[1]);
	        }
	        else if (cur[0] === 'Z') {
	            path = cur[0];
	        }
	        else if (cur[0] === 'C') {
	            var p1 = fromValues$2(cur[1] - defX, cur[2] - defY, 0);
	            var p2 = fromValues$2(cur[3] - defX, cur[4] - defY, 0);
	            var p3 = fromValues$2(cur[5] - defX, cur[6] - defY, 0);
	            if (transform) {
	                transformMat4(p1, p1, transform);
	                transformMat4(p2, p2, transform);
	                transformMat4(p3, p3, transform);
	            }
	            path = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p2[0], ",").concat(p2[1], ",").concat(p3[0], ",").concat(p3[1]);
	        }
	        else if (cur[0] === 'A') {
	            var c = fromValues$2(cur[6] - defX, cur[7] - defY, 0);
	            if (transform) {
	                transformMat4(c, c, transform);
	            }
	            path = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c[0], ",").concat(c[1]);
	        }
	        else if (cur[0] === 'Q') {
	            var p1 = fromValues$2(cur[1] - defX, cur[2] - defY, 0);
	            var p2 = fromValues$2(cur[3] - defX, cur[4] - defY, 0);
	            if (transform) {
	                transformMat4(p1, p1, transform);
	                transformMat4(p2, p2, transform);
	            }
	            path = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
	        }
	        return (prev += path);
	    }, '');
	}
	function lineToCommands(x1, y1, x2, y2) {
	    return [
	        ['M', x1, y1],
	        ['L', x2, y2],
	    ];
	}
	function ellipseToCommands(rx, ry, cx, cy) {
	    var factor = ((-1 + Math.sqrt(2)) / 3) * 4;
	    var dx = rx * factor;
	    var dy = ry * factor;
	    var left = cx - rx;
	    var right = cx + rx;
	    var top = cy - ry;
	    var bottom = cy + ry;
	    return [
	        ['M', left, cy],
	        ['C', left, cy - dy, cx - dx, top, cx, top],
	        ['C', cx + dx, top, right, cy - dy, right, cy],
	        ['C', right, cy + dy, cx + dx, bottom, cx, bottom],
	        ['C', cx - dx, bottom, left, cy + dy, left, cy],
	        ['Z'],
	    ];
	}
	function polygonToCommands(points, closed) {
	    var result = points.map(function (point, i) {
	        return [i === 0 ? 'M' : 'L', point[0], point[1]];
	    });
	    if (closed) {
	        result.push(['Z']);
	    }
	    return result;
	}
	function rectToCommands(width, height, x, y, radius) {
	    // @see https://gist.github.com/danielpquinn/dd966af424030d47e476
	    if (radius) {
	        var _a = __read(radius, 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];
	        var signX = width > 0 ? 1 : -1;
	        var signY = height > 0 ? 1 : -1;
	        // sweep-flag @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths#arcs
	        var sweepFlag = signX + signY !== 0 ? 1 : 0;
	        return [
	            ['M', signX * tlr + x, y],
	            ['L', width - signX * trr + x, y],
	            trr ? ['A', trr, trr, 0, 0, sweepFlag, width + x, signY * trr + y] : null,
	            ['L', width + x, height - signY * brr + y],
	            brr
	                ? ['A', brr, brr, 0, 0, sweepFlag, width + x - signX * brr, height + y]
	                : null,
	            ['L', x + signX * blr, height + y],
	            blr
	                ? ['A', blr, blr, 0, 0, sweepFlag, x, height + y - signY * blr]
	                : null,
	            ['L', x, signY * tlr + y],
	            tlr ? ['A', tlr, tlr, 0, 0, sweepFlag, signX * tlr + x, y] : null,
	            ['Z'],
	        ].filter(function (command) { return command; });
	    }
	    return [
	        ['M', x, y],
	        ['L', x + width, y],
	        ['L', x + width, y + height],
	        ['L', x, y + height],
	        ['Z'],
	    ];
	}
	/**
	 * convert object to path, should account for:
	 * * transform & origin
	 * * anchor
	 * * lineWidth
	 */
	function convertToPath(object, transform) {
	    if (transform === void 0) { transform = object.getLocalTransform(); }
	    var commands = [];
	    switch (object.nodeName) {
	        case Shape.LINE:
	            var _a = object.parsedStyle, x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
	            commands = lineToCommands(x1, y1, x2, y2);
	            break;
	        case Shape.CIRCLE: {
	            var _b = object.parsedStyle, r = _b.r, cx = _b.cx, cy = _b.cy;
	            commands = ellipseToCommands(r, r, cx, cy);
	            break;
	        }
	        case Shape.ELLIPSE: {
	            var _c = object.parsedStyle, rx = _c.rx, ry = _c.ry, cx = _c.cx, cy = _c.cy;
	            commands = ellipseToCommands(rx, ry, cx, cy);
	            break;
	        }
	        case Shape.POLYLINE:
	        case Shape.POLYGON:
	            var points = object.parsedStyle.points;
	            commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
	            break;
	        case Shape.RECT:
	            var _d = object.parsedStyle, width_1 = _d.width, height_1 = _d.height, x = _d.x, y = _d.y, radius = _d.radius;
	            var hasRadius = radius && radius.some(function (r) { return r !== 0; });
	            commands = rectToCommands(width_1, height_1, x, y, hasRadius &&
	                radius.map(function (r) {
	                    return clamp(r, 0, Math.min(Math.abs(width_1) / 2, Math.abs(height_1) / 2));
	                }));
	            break;
	        case Shape.PATH:
	            var absolutePath = object.parsedStyle.path.absolutePath;
	            commands = __spreadArray([], __read(absolutePath), false);
	            break;
	    }
	    if (commands.length) {
	        return commandsToPathString(commands, object, transform);
	    }
	}

	var internalParsePath = function (path) {
	    // empty path
	    if (path === '' || (Array.isArray(path) && path.length === 0)) {
	        return {
	            absolutePath: [],
	            hasArc: false,
	            segments: [],
	            polygons: [],
	            polylines: [],
	            curve: null,
	            totalLength: 0,
	            rect: {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0,
	            },
	        };
	    }
	    var absolutePath;
	    try {
	        absolutePath = normalizePath(path);
	    }
	    catch (e) {
	        absolutePath = normalizePath('');
	        console.error("[g]: Invalid SVG Path definition: ".concat(path));
	    }
	    var hasArc = hasArcOrBezier(absolutePath);
	    var _a = extractPolygons(absolutePath), polygons = _a.polygons, polylines = _a.polylines;
	    // for later use
	    var segments = path2Segments(absolutePath);
	    // Only calculate bbox here since we don't need length now.
	    var _b = getPathBBox(segments, 0), x = _b.x, y = _b.y, width = _b.width, height = _b.height;
	    return {
	        absolutePath: absolutePath,
	        hasArc: hasArc,
	        segments: segments,
	        polygons: polygons,
	        polylines: polylines,
	        // curve,
	        // Delay the calculation of length.
	        totalLength: 0,
	        rect: {
	            x: Number.isFinite(x) ? x : 0,
	            y: Number.isFinite(y) ? y : 0,
	            width: Number.isFinite(width) ? width : 0,
	            height: Number.isFinite(height) ? height : 0,
	        },
	    };
	};
	var memoizedParsePath = memoize(internalParsePath);
	function parsePath(path) {
	    return (isString(path) ? memoizedParsePath(path) : internalParsePath(path));
	}
	function mergePaths(left, right, object) {
	    var curve1 = left.curve;
	    var curve2 = right.curve;
	    if (!curve1 || curve1.length === 0) {
	        // convert to curves to do morphing & picking later
	        // @see http://thednp.github.io/kute.js/svgCubicMorph.html
	        curve1 = path2Curve(left.absolutePath, false);
	        left.curve = curve1;
	    }
	    if (!curve2 || curve2.length === 0) {
	        curve2 = path2Curve(right.absolutePath, false);
	        right.curve = curve2;
	    }
	    var curves = [curve1, curve2];
	    if (curve1.length !== curve2.length) {
	        curves = equalizeSegments(curve1, curve2);
	    }
	    var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1])
	        ? reverseCurve(curves[0])
	        : clonePath(curves[0]);
	    return [
	        curve0,
	        getRotatedCurve(curves[1], curve0),
	        function (pathArray) {
	            // need converting to path string?
	            return pathArray;
	        },
	    ];
	}

	/**
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/points
	 *
	 * @example
	 * points="100,10 250,150 200,110"
	 */
	function parsePoints(pointsOrStr, object) {
	    var points;
	    if (isString(pointsOrStr)) {
	        points = pointsOrStr.split(' ').map(function (pointStr) {
	            var _a = __read(pointStr.split(','), 2), x = _a[0], y = _a[1];
	            return [Number(x), Number(y)];
	        });
	    }
	    else {
	        points = pointsOrStr;
	    }
	    var segments = [];
	    var tempLength = 0;
	    var segmentT;
	    var segmentL;
	    var totalLength = length$2(points);
	    points.forEach(function (p, i) {
	        if (points[i + 1]) {
	            segmentT = [0, 0];
	            segmentT[0] = tempLength / totalLength;
	            segmentL = length$4(p[0], p[1], points[i + 1][0], points[i + 1][1]);
	            tempLength += segmentL;
	            segmentT[1] = tempLength / totalLength;
	            segments.push(segmentT);
	        }
	    });
	    var minX = Math.min.apply(Math, __spreadArray([], __read(points.map(function (point) { return point[0]; })), false));
	    var minY = Math.min.apply(Math, __spreadArray([], __read(points.map(function (point) { return point[1]; })), false));
	    if (object) {
	        object.parsedStyle.defX = minX;
	        object.parsedStyle.defY = minY;
	    }
	    return {
	        points: points,
	        totalLength: totalLength,
	        segments: segments,
	    };
	}
	function mergePoints(left, right) {
	    return [
	        left.points,
	        right.points,
	        function (points) {
	            return points;
	        },
	    ];
	}

	var _ = null;
	function cast(pattern) {
	    return function (contents) {
	        var i = 0;
	        return pattern.map(function (x) {
	            return x === _ ? contents[i++] : x;
	        });
	    };
	}
	function id(x) {
	    return x;
	}
	// type: [argTypes, convertTo3D, convertTo2D]
	// In the argument types string, lowercase characters represent optional arguments
	var transformFunctions = {
	    // @ts-ignore
	    matrix: ['NNNNNN', [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
	    matrix3d: ['NNNNNNNNNNNNNNNN', id],
	    rotate: ['A'],
	    rotatex: ['A'],
	    rotatey: ['A'],
	    rotatez: ['A'],
	    rotate3d: ['NNNA'],
	    perspective: ['L'],
	    scale: ['Nn', cast([_, _, new CSSUnitValue(1)]), id],
	    scalex: [
	        'N',
	        cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]),
	        cast([_, new CSSUnitValue(1)]),
	    ],
	    scaley: [
	        'N',
	        cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]),
	        cast([new CSSUnitValue(1), _]),
	    ],
	    scalez: ['N', cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
	    scale3d: ['NNN', id],
	    skew: ['Aa', null, id],
	    skewx: ['A', null, cast([_, Odeg])],
	    skewy: ['A', null, cast([Odeg, _])],
	    translate: ['Tt', cast([_, _, Opx]), id],
	    translatex: ['T', cast([_, Opx, Opx]), cast([_, Opx])],
	    translatey: ['T', cast([Opx, _, Opx]), cast([Opx, _])],
	    translatez: ['L', cast([Opx, Opx, _])],
	    translate3d: ['TTL', id],
	};
	/**
	 * none
	 * scale(1) scale(1, 2)
	 * scaleX(1)
	 */
	function parseTransform(string) {
	    string = (string || 'none').toLowerCase().trim();
	    if (string === 'none') {
	        return [];
	    }
	    var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
	    var result = [];
	    var match;
	    var prevLastIndex = 0;
	    while ((match = transformRegExp.exec(string))) {
	        if (match.index !== prevLastIndex) {
	            return [];
	        }
	        prevLastIndex = match.index + match[0].length;
	        var functionName = match[1]; // scale
	        var functionData = transformFunctions[functionName]; // scale(1, 2)
	        if (!functionData) {
	            // invalid, eg. scale()
	            return [];
	        }
	        var args = match[2].split(','); // 1,2
	        var argTypes = functionData[0]; // Nn
	        if (argTypes.length < args.length) {
	            // scale(N, n)
	            return [];
	        }
	        var parsedArgs = [];
	        for (var i = 0; i < argTypes.length; i++) {
	            var arg = args[i];
	            var type = argTypes[i];
	            var parsedArg = void 0;
	            if (!arg) {
	                // @ts-ignore
	                parsedArg = {
	                    a: Odeg,
	                    n: parsedArgs[0],
	                    t: Opx,
	                }[type];
	            }
	            else {
	                // @ts-ignore
	                parsedArg = {
	                    A: function (s) {
	                        return s.trim() === '0' ? Odeg : parseAngle(s);
	                    },
	                    N: parseNumber,
	                    T: parseLengthOrPercentage,
	                    L: parseLength,
	                }[type.toUpperCase()](arg);
	            }
	            if (parsedArg === undefined) {
	                return [];
	            }
	            parsedArgs.push(parsedArg);
	        }
	        result.push({ t: functionName, d: parsedArgs }); // { t: scale, d: [1, 2] }
	        if (transformRegExp.lastIndex === string.length) {
	            return result;
	        }
	    }
	    return [];
	}
	function convertItemToMatrix(item) {
	    var x;
	    var y;
	    var z;
	    var angle;
	    switch (item.t) {
	        case 'rotatex':
	            angle = deg2rad(convertAngleUnit(item.d[0]));
	            return [
	                1,
	                0,
	                0,
	                0,
	                0,
	                Math.cos(angle),
	                Math.sin(angle),
	                0,
	                0,
	                -Math.sin(angle),
	                Math.cos(angle),
	                0,
	                0,
	                0,
	                0,
	                1,
	            ];
	        case 'rotatey':
	            angle = deg2rad(convertAngleUnit(item.d[0]));
	            return [
	                Math.cos(angle),
	                0,
	                -Math.sin(angle),
	                0,
	                0,
	                1,
	                0,
	                0,
	                Math.sin(angle),
	                0,
	                Math.cos(angle),
	                0,
	                0,
	                0,
	                0,
	                1,
	            ];
	        case 'rotate':
	        case 'rotatez':
	            angle = deg2rad(convertAngleUnit(item.d[0]));
	            return [
	                Math.cos(angle),
	                Math.sin(angle),
	                0,
	                0,
	                -Math.sin(angle),
	                Math.cos(angle),
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	            ];
	        case 'rotate3d':
	            x = item.d[0].value;
	            y = item.d[1].value;
	            z = item.d[2].value;
	            angle = deg2rad(convertAngleUnit(item.d[3]));
	            var sqrLength = x * x + y * y + z * z;
	            if (sqrLength === 0) {
	                x = 1;
	                y = 0;
	                z = 0;
	            }
	            else if (sqrLength !== 1) {
	                var length_1 = Math.sqrt(sqrLength);
	                x /= length_1;
	                y /= length_1;
	                z /= length_1;
	            }
	            var s = Math.sin(angle / 2);
	            var sc = s * Math.cos(angle / 2);
	            var sq = s * s;
	            return [
	                1 - 2 * (y * y + z * z) * sq,
	                2 * (x * y * sq + z * sc),
	                2 * (x * z * sq - y * sc),
	                0,
	                2 * (x * y * sq - z * sc),
	                1 - 2 * (x * x + z * z) * sq,
	                2 * (y * z * sq + x * sc),
	                0,
	                2 * (x * z * sq + y * sc),
	                2 * (y * z * sq - x * sc),
	                1 - 2 * (x * x + y * y) * sq,
	                0,
	                0,
	                0,
	                0,
	                1,
	            ];
	        case 'scale':
	            return [
	                item.d[0].value,
	                0,
	                0,
	                0,
	                0,
	                item.d[1].value,
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	            ];
	        case 'scalex':
	            return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	        case 'scaley':
	            return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	        case 'scalez':
	            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
	        case 'scale3d':
	            return [
	                item.d[0].value,
	                0,
	                0,
	                0,
	                0,
	                item.d[1].value,
	                0,
	                0,
	                0,
	                0,
	                item.d[2].value,
	                0,
	                0,
	                0,
	                0,
	                1,
	            ];
	        case 'skew':
	            var xAngle = deg2rad(convertAngleUnit(item.d[0]));
	            var yAngle = deg2rad(convertAngleUnit(item.d[1]));
	            return [
	                1,
	                Math.tan(yAngle),
	                0,
	                0,
	                Math.tan(xAngle),
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	            ];
	        case 'skewx':
	            angle = deg2rad(convertAngleUnit(item.d[0]));
	            return [1, 0, 0, 0, Math.tan(angle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	        case 'skewy':
	            angle = deg2rad(convertAngleUnit(item.d[0]));
	            return [1, Math.tan(angle), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	        case 'translate':
	            // TODO: pass target
	            x = convertPercentUnit(item.d[0], 0, null) || 0;
	            y = convertPercentUnit(item.d[1], 0, null) || 0;
	            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, 0, 1];
	        case 'translatex':
	            x = convertPercentUnit(item.d[0], 0, null) || 0;
	            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];
	        case 'translatey':
	            y = convertPercentUnit(item.d[0], 0, null) || 0;
	            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y, 0, 1];
	        case 'translatez':
	            z = convertPercentUnit(item.d[0], 0, null) || 0;
	            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
	        case 'translate3d':
	            x = convertPercentUnit(item.d[0], 0, null) || 0;
	            y = convertPercentUnit(item.d[1], 0, null) || 0;
	            z = convertPercentUnit(item.d[2], 0, null) || 0;
	            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];
	        case 'perspective':
	            var t = convertPercentUnit(item.d[0], 0, null) || 0;
	            var p = t ? -1 / t : 0;
	            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
	        case 'matrix':
	            return [
	                item.d[0].value,
	                item.d[1].value,
	                0,
	                0,
	                item.d[2].value,
	                item.d[3].value,
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                item.d[4].value,
	                item.d[5].value,
	                0,
	                1,
	            ];
	        case 'matrix3d':
	            return item.d.map(function (d) { return d.value; });
	    }
	}
	function multiplyMatrices(a, b) {
	    return [
	        a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3],
	        a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3],
	        a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3],
	        a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3],
	        a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7],
	        a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7],
	        a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7],
	        a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7],
	        a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11],
	        a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11],
	        a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11],
	        a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11],
	        a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15],
	        a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15],
	        a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15],
	        a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15],
	    ];
	}
	function convertToMatrix(transformList) {
	    if (transformList.length === 0) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    }
	    return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
	}
	function makeMatrixDecomposition(transformList) {
	    var translate = [0, 0, 0];
	    var scale = [1, 1, 1];
	    var skew = [0, 0, 0];
	    var perspective = [0, 0, 0, 1];
	    var quaternion = [0, 0, 0, 1];
	    decomposeMat4(
	    // @ts-ignore
	    convertToMatrix(transformList), translate, scale, skew, perspective, quaternion);
	    return [[translate, scale, skew, quaternion, perspective]];
	}
	var composeMatrix = (function () {
	    function multiply(a, b) {
	        var result = [
	            [0, 0, 0, 0],
	            [0, 0, 0, 0],
	            [0, 0, 0, 0],
	            [0, 0, 0, 0],
	        ];
	        for (var i = 0; i < 4; i++) {
	            for (var j = 0; j < 4; j++) {
	                for (var k = 0; k < 4; k++) {
	                    result[i][j] += b[i][k] * a[k][j];
	                }
	            }
	        }
	        return result;
	    }
	    function is2D(m) {
	        return (m[0][2] == 0 &&
	            m[0][3] == 0 &&
	            m[1][2] == 0 &&
	            m[1][3] == 0 &&
	            m[2][0] == 0 &&
	            m[2][1] == 0 &&
	            m[2][2] == 1 &&
	            m[2][3] == 0 &&
	            m[3][2] == 0 &&
	            m[3][3] == 1);
	    }
	    function composeMatrix(translate, scale, skew, quat, perspective) {
	        var matrix = [
	            [1, 0, 0, 0],
	            [0, 1, 0, 0],
	            [0, 0, 1, 0],
	            [0, 0, 0, 1],
	        ];
	        for (var i = 0; i < 4; i++) {
	            matrix[i][3] = perspective[i];
	        }
	        for (var i = 0; i < 3; i++) {
	            for (var j = 0; j < 3; j++) {
	                matrix[3][i] += translate[j] * matrix[j][i];
	            }
	        }
	        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
	        var rotMatrix = [
	            [1, 0, 0, 0],
	            [0, 1, 0, 0],
	            [0, 0, 1, 0],
	            [0, 0, 0, 1],
	        ];
	        rotMatrix[0][0] = 1 - 2 * (y * y + z * z);
	        rotMatrix[0][1] = 2 * (x * y - z * w);
	        rotMatrix[0][2] = 2 * (x * z + y * w);
	        rotMatrix[1][0] = 2 * (x * y + z * w);
	        rotMatrix[1][1] = 1 - 2 * (x * x + z * z);
	        rotMatrix[1][2] = 2 * (y * z - x * w);
	        rotMatrix[2][0] = 2 * (x * z - y * w);
	        rotMatrix[2][1] = 2 * (y * z + x * w);
	        rotMatrix[2][2] = 1 - 2 * (x * x + y * y);
	        matrix = multiply(matrix, rotMatrix);
	        var temp = [
	            [1, 0, 0, 0],
	            [0, 1, 0, 0],
	            [0, 0, 1, 0],
	            [0, 0, 0, 1],
	        ];
	        if (skew[2]) {
	            temp[2][1] = skew[2];
	            matrix = multiply(matrix, temp);
	        }
	        if (skew[1]) {
	            temp[2][1] = 0;
	            temp[2][0] = skew[0];
	            matrix = multiply(matrix, temp);
	        }
	        if (skew[0]) {
	            temp[2][0] = 0;
	            temp[1][0] = skew[0];
	            matrix = multiply(matrix, temp);
	        }
	        for (var i = 0; i < 3; i++) {
	            for (var j = 0; j < 3; j++) {
	                matrix[i][j] *= scale[i];
	            }
	        }
	        if (is2D(matrix)) {
	            return [
	                matrix[0][0],
	                matrix[0][1],
	                matrix[1][0],
	                matrix[1][1],
	                matrix[3][0],
	                matrix[3][1],
	            ];
	        }
	        return matrix[0].concat(matrix[1], matrix[2], matrix[3]);
	    }
	    return composeMatrix;
	})();
	function numberToLongString(x) {
	    return x.toFixed(6).replace('.000000', '');
	}
	function mergeMatrices(left, right) {
	    var leftArgs;
	    var rightArgs;
	    // @ts-ignore
	    if (left.decompositionPair !== right) {
	        // @ts-ignore
	        left.decompositionPair = right;
	        // @ts-ignore
	        leftArgs = makeMatrixDecomposition(left);
	    }
	    // @ts-ignore
	    if (right.decompositionPair !== left) {
	        // @ts-ignore
	        right.decompositionPair = left;
	        // @ts-ignore
	        rightArgs = makeMatrixDecomposition(right);
	    }
	    if (leftArgs[0] === null || rightArgs[0] === null)
	        return [
	            // @ts-ignore
	            [false],
	            // @ts-ignore
	            [true],
	            // @ts-ignore
	            function (x) {
	                return x ? right[0].d : left[0].d;
	            },
	        ];
	    leftArgs[0].push(0);
	    rightArgs[0].push(1);
	    return [
	        leftArgs,
	        rightArgs,
	        // @ts-ignore
	        function (list) {
	            // @ts-ignore
	            var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
	            var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
	            var stringifiedArgs = mat.map(numberToLongString).join(',');
	            return stringifiedArgs;
	        },
	    ];
	}
	function dot$2(v1, v2) {
	    var result = 0;
	    for (var i = 0; i < v1.length; i++) {
	        result += v1[i] * v2[i];
	    }
	    return result;
	}
	function quat(fromQ, toQ, f) {
	    var product = dot$2(fromQ, toQ);
	    product = clamp(product, -1.0, 1.0);
	    var quat = [];
	    if (product === 1.0) {
	        quat = fromQ;
	    }
	    else {
	        var theta = Math.acos(product);
	        var w = (Math.sin(f * theta) * 1) / Math.sqrt(1 - product * product);
	        for (var i = 0; i < 4; i++) {
	            quat.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
	        }
	    }
	    return quat;
	}
	// scalex/y/z -> scale
	function typeTo2D(type) {
	    return type.replace(/[xy]/, '');
	}
	// scalex/y/z -> scale3d
	function typeTo3D(type) {
	    return type.replace(/(x|y|z|3d)?$/, '3d');
	}
	var isMatrixOrPerspective = function (lt, rt) {
	    return ((lt === 'perspective' && rt === 'perspective') ||
	        ((lt === 'matrix' || lt === 'matrix3d') &&
	            (rt === 'matrix' || rt === 'matrix3d')));
	};
	function mergeTransforms(left, right, target) {
	    var flipResults = false;
	    // padding empty transform, eg. merge 'scale(10)' with 'none' -> scale(1)
	    if (!left.length || !right.length) {
	        if (!left.length) {
	            flipResults = true;
	            left = right;
	            right = [];
	        }
	        var _loop_1 = function (i) {
	            var _a = left[i], type = _a.t, args = _a.d;
	            // none -> scale(1)/translateX(0)
	            var defaultValue = type.substring(0, 5) === 'scale' ? 1 : 0;
	            right.push({
	                t: type,
	                d: args.map(function (arg) {
	                    if (typeof arg === 'number') {
	                        return getOrCreateUnitValue(defaultValue);
	                    }
	                    return getOrCreateUnitValue(defaultValue, arg.unit);
	                    //   {
	                    //     unit: arg.unit,
	                    //     value: defaultValue,
	                    //   };
	                }),
	            });
	        };
	        for (var i = 0; i < left.length; i++) {
	            _loop_1(i);
	        }
	    }
	    var leftResult = [];
	    var rightResult = [];
	    var types = [];
	    // merge matrix() with matrix3d()
	    if (left.length !== right.length) {
	        var merged = mergeMatrices(left, right);
	        // @ts-ignore
	        leftResult = [merged[0]];
	        // @ts-ignore
	        rightResult = [merged[1]];
	        types = [['matrix', [merged[2]]]];
	    }
	    else {
	        for (var i = 0; i < left.length; i++) {
	            var leftType = left[i].t;
	            var rightType = right[i].t;
	            var leftArgs = left[i].d;
	            var rightArgs = right[i].d;
	            var leftFunctionData = transformFunctions[leftType];
	            var rightFunctionData = transformFunctions[rightType];
	            var type = void 0;
	            if (isMatrixOrPerspective(leftType, rightType)) {
	                var merged = mergeMatrices([left[i]], [right[i]]);
	                // @ts-ignore
	                leftResult.push(merged[0]);
	                // @ts-ignore
	                rightResult.push(merged[1]);
	                types.push(['matrix', [merged[2]]]);
	                continue;
	            }
	            else if (leftType === rightType) {
	                type = leftType;
	            }
	            else if (leftFunctionData[2] &&
	                rightFunctionData[2] &&
	                typeTo2D(leftType) === typeTo2D(rightType)) {
	                type = typeTo2D(leftType);
	                // @ts-ignore
	                leftArgs = leftFunctionData[2](leftArgs);
	                // @ts-ignore
	                rightArgs = rightFunctionData[2](rightArgs);
	            }
	            else if (leftFunctionData[1] &&
	                rightFunctionData[1] &&
	                typeTo3D(leftType) === typeTo3D(rightType)) {
	                type = typeTo3D(leftType);
	                // @ts-ignore
	                leftArgs = leftFunctionData[1](leftArgs);
	                // @ts-ignore
	                rightArgs = rightFunctionData[1](rightArgs);
	            }
	            else {
	                var merged = mergeMatrices(left, right);
	                // @ts-ignore
	                leftResult = [merged[0]];
	                // @ts-ignore
	                rightResult = [merged[1]];
	                types = [['matrix', [merged[2]]]];
	                break;
	            }
	            var leftArgsCopy = [];
	            var rightArgsCopy = [];
	            var stringConversions = [];
	            for (var j = 0; j < leftArgs.length; j++) {
	                // const merge = leftArgs[j].unit === UnitType.kNumber ? mergeDimensions : mergeDimensions;
	                var merged = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
	                leftArgsCopy[j] = merged[0];
	                rightArgsCopy[j] = merged[1];
	                stringConversions.push(merged[2]);
	            }
	            leftResult.push(leftArgsCopy);
	            rightResult.push(rightArgsCopy);
	            types.push([type, stringConversions]);
	        }
	    }
	    if (flipResults) {
	        var tmp = leftResult;
	        leftResult = rightResult;
	        rightResult = tmp;
	    }
	    return [
	        leftResult,
	        rightResult,
	        function (list) {
	            return list
	                .map(function (args, i) {
	                var stringifiedArgs = args
	                    .map(function (arg, j) {
	                    return types[i][1][j](arg);
	                })
	                    .join(',');
	                if (types[i][0] === 'matrix' &&
	                    stringifiedArgs.split(',').length === 16) {
	                    types[i][0] = 'matrix3d';
	                }
	                if (types[i][0] === 'matrix3d' &&
	                    stringifiedArgs.split(',').length === 6) {
	                    types[i][0] = 'matrix';
	                }
	                return types[i][0] + '(' + stringifiedArgs + ')';
	            })
	                .join(' ');
	        },
	    ];
	}

	/**
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin
	 * eg. 'center' 'top left' '50px 50px'
	 */
	var parseTransformOrigin = memoize(function (value) {
	    if (isString(value)) {
	        if (value === 'text-anchor') {
	            return [getOrCreateUnitValue(0, 'px'), getOrCreateUnitValue(0, 'px')];
	        }
	        var values = value.split(' ');
	        if (values.length === 1) {
	            if (values[0] === 'top' || values[0] === 'bottom') {
	                // 'top' -> 'center top'
	                values[1] = values[0];
	                values[0] = 'center';
	            }
	            else {
	                // '50px' -> '50px center'
	                values[1] = 'center';
	            }
	        }
	        if (values.length !== 2) {
	            return null;
	        }
	        // eg. center bottom
	        return [
	            parseLengthOrPercentage(convertKeyword2Percent(values[0])),
	            parseLengthOrPercentage(convertKeyword2Percent(values[1])),
	        ];
	    }
	    else {
	        return [
	            getOrCreateUnitValue(value[0] || 0, 'px'),
	            getOrCreateUnitValue(value[1] || 0, 'px'),
	        ];
	    }
	});
	function convertKeyword2Percent(keyword) {
	    if (keyword === 'center') {
	        return '50%';
	    }
	    else if (keyword === 'left' || keyword === 'top') {
	        return '0';
	    }
	    else if (keyword === 'right' || keyword === 'bottom') {
	        return '100%';
	    }
	    return keyword;
	}

	/**
	 * Blink used them in code generation(css_properties.json5)
	 */
	var BUILT_IN_PROPERTIES = [
	    {
	        /**
	         * used in CSS Layout API
	         * eg. `display: 'flex'`
	         */
	        n: 'display',
	        k: ['none'],
	    },
	    {
	        /**
	         * range [0.0, 1.0]
	         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
	         */
	        n: 'opacity',
	        int: true,
	        inh: true,
	        d: '1',
	        syntax: PropertySyntax.OPACITY_VALUE,
	    },
	    {
	        /**
	         * inheritable, range [0.0, 1.0]
	         * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
	         * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
	         */
	        n: 'fillOpacity',
	        int: true,
	        inh: true,
	        d: '1',
	        syntax: PropertySyntax.OPACITY_VALUE,
	    },
	    {
	        /**
	         * inheritable, range [0.0, 1.0]
	         * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
	         * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
	         */
	        n: 'strokeOpacity',
	        int: true,
	        inh: true,
	        d: '1',
	        syntax: PropertySyntax.OPACITY_VALUE,
	    },
	    {
	        /**
	         * background-color is not inheritable
	         * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
	         */
	        n: 'fill',
	        int: true,
	        k: ['none'],
	        d: 'none',
	        syntax: PropertySyntax.PAINT,
	    },
	    {
	        n: 'fillRule',
	        k: ['nonzero', 'evenodd'],
	        d: 'nonzero',
	    },
	    /**
	     * default to none
	     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
	     */
	    {
	        n: 'stroke',
	        int: true,
	        k: ['none'],
	        d: 'none',
	        syntax: PropertySyntax.PAINT,
	        /**
	         * Stroke 'none' won't affect geometry but others will.
	         */
	        l: true,
	    },
	    {
	        n: 'shadowType',
	        k: ['inner', 'outer', 'both'],
	        d: 'outer',
	        l: true,
	    },
	    {
	        n: 'shadowColor',
	        int: true,
	        syntax: PropertySyntax.COLOR,
	    },
	    {
	        n: 'shadowOffsetX',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'shadowOffsetY',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'shadowBlur',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.SHADOW_BLUR,
	    },
	    {
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
	         */
	        n: 'lineWidth',
	        int: true,
	        inh: true,
	        d: '1',
	        l: true,
	        a: ['strokeWidth'],
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'increasedLineWidthForHitTesting',
	        inh: true,
	        d: '0',
	        l: true,
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'lineJoin',
	        inh: true,
	        l: true,
	        a: ['strokeLinejoin'],
	        k: ['miter', 'bevel', 'round'],
	        d: 'miter',
	    },
	    {
	        n: 'lineCap',
	        inh: true,
	        l: true,
	        a: ['strokeLinecap'],
	        k: ['butt', 'round', 'square'],
	        d: 'butt',
	    },
	    {
	        n: 'lineDash',
	        int: true,
	        inh: true,
	        k: ['none'],
	        a: ['strokeDasharray'],
	        syntax: PropertySyntax.LENGTH_PERCENTAGE_12,
	    },
	    {
	        n: 'lineDashOffset',
	        int: true,
	        inh: true,
	        d: '0',
	        a: ['strokeDashoffset'],
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'offsetPath',
	        syntax: PropertySyntax.DEFINED_PATH,
	    },
	    {
	        n: 'offsetDistance',
	        int: true,
	        syntax: PropertySyntax.OFFSET_DISTANCE,
	    },
	    {
	        n: 'dx',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'dy',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'zIndex',
	        ind: true,
	        int: true,
	        d: '0',
	        k: ['auto'],
	        syntax: PropertySyntax.Z_INDEX,
	    },
	    {
	        n: 'visibility',
	        k: ['visible', 'hidden'],
	        ind: true,
	        inh: true,
	        /**
	         * support interpolation
	         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
	         */
	        int: true,
	        d: 'visible',
	    },
	    {
	        n: 'pointerEvents',
	        inh: true,
	        k: [
	            'none',
	            'auto',
	            'stroke',
	            'fill',
	            'painted',
	            'visible',
	            'visiblestroke',
	            'visiblefill',
	            'visiblepainted',
	            // 'bounding-box',
	            'all',
	        ],
	        d: 'auto',
	    },
	    {
	        n: 'filter',
	        ind: true,
	        l: true,
	        k: ['none'],
	        d: 'none',
	        syntax: PropertySyntax.FILTER,
	    },
	    {
	        n: 'clipPath',
	        syntax: PropertySyntax.DEFINED_PATH,
	    },
	    {
	        n: 'textPath',
	        syntax: PropertySyntax.DEFINED_PATH,
	    },
	    {
	        n: 'textPathSide',
	        k: ['left', 'right'],
	        d: 'left',
	    },
	    {
	        n: 'textPathStartOffset',
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'transform',
	        p: 100,
	        int: true,
	        k: ['none'],
	        d: 'none',
	        syntax: PropertySyntax.TRANSFORM,
	    },
	    {
	        n: 'transformOrigin',
	        p: 100,
	        // int: true,
	        d: function (nodeName) {
	            if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
	                return 'center';
	            }
	            if (nodeName === Shape.TEXT) {
	                return 'text-anchor';
	            }
	            return 'left top';
	        },
	        l: true,
	        syntax: PropertySyntax.TRANSFORM_ORIGIN,
	    },
	    {
	        n: 'anchor',
	        p: 99,
	        d: function (nodeName) {
	            if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
	                return '0.5 0.5';
	            }
	            return '0 0';
	        },
	        l: true,
	        syntax: PropertySyntax.LENGTH_PERCENTAGE_12,
	    },
	    // <circle> & <ellipse>
	    {
	        n: 'cx',
	        int: true,
	        d: '0',
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'cy',
	        int: true,
	        d: '0',
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'cz',
	        int: true,
	        d: '0',
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'r',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'rx',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'ry',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    // Rect Image Group
	    {
	        // x in local space
	        n: 'x',
	        int: true,
	        d: '0',
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        // y in local space
	        n: 'y',
	        int: true,
	        d: '0',
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        // z in local space
	        n: 'z',
	        int: true,
	        d: '0',
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'width',
	        int: true,
	        l: true,
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
	         */
	        k: ['auto', 'fit-content', 'min-content', 'max-content'],
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'height',
	        int: true,
	        l: true,
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
	         */
	        k: ['auto', 'fit-content', 'min-content', 'max-content'],
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'radius',
	        int: true,
	        l: true,
	        d: '0',
	        syntax: PropertySyntax.LENGTH_PERCENTAGE_14,
	    },
	    // Line
	    {
	        n: 'x1',
	        int: true,
	        l: true,
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'y1',
	        int: true,
	        l: true,
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'z1',
	        int: true,
	        l: true,
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'x2',
	        int: true,
	        l: true,
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'y2',
	        int: true,
	        l: true,
	        syntax: PropertySyntax.COORDINATE,
	    },
	    {
	        n: 'z2',
	        int: true,
	        l: true,
	        syntax: PropertySyntax.COORDINATE,
	    },
	    // Path
	    {
	        n: 'path',
	        int: true,
	        l: true,
	        d: '',
	        a: ['d'],
	        syntax: PropertySyntax.PATH,
	        p: 50,
	    },
	    // Polyline & Polygon
	    {
	        n: 'points',
	        /**
	         * support interpolation
	         */
	        int: true,
	        l: true,
	        syntax: PropertySyntax.LIST_OF_POINTS,
	        p: 50,
	    },
	    // Text
	    {
	        n: 'text',
	        l: true,
	        d: '',
	        syntax: PropertySyntax.TEXT,
	        p: 50,
	    },
	    {
	        n: 'textTransform',
	        l: true,
	        inh: true,
	        k: ['capitalize', 'uppercase', 'lowercase', 'none'],
	        d: 'none',
	        syntax: PropertySyntax.TEXT_TRANSFORM,
	        p: 51, // it must get parsed after text
	    },
	    {
	        n: 'font',
	        l: true,
	    },
	    {
	        n: 'fontSize',
	        int: true,
	        inh: true,
	        /**
	         * @see https://www.w3schools.com/css/css_font_size.asp
	         */
	        d: '16px',
	        l: true,
	        syntax: PropertySyntax.LENGTH_PERCENTAGE,
	    },
	    {
	        n: 'fontFamily',
	        l: true,
	        inh: true,
	        d: 'sans-serif',
	    },
	    {
	        n: 'fontStyle',
	        l: true,
	        inh: true,
	        k: ['normal', 'italic', 'oblique'],
	        d: 'normal',
	    },
	    {
	        n: 'fontWeight',
	        l: true,
	        inh: true,
	        k: ['normal', 'bold', 'bolder', 'lighter'],
	        d: 'normal',
	    },
	    {
	        n: 'fontVariant',
	        l: true,
	        inh: true,
	        k: ['normal', 'small-caps'],
	        d: 'normal',
	    },
	    {
	        n: 'lineHeight',
	        l: true,
	        syntax: PropertySyntax.LENGTH,
	        int: true,
	        d: '0',
	    },
	    {
	        n: 'letterSpacing',
	        l: true,
	        syntax: PropertySyntax.LENGTH,
	        int: true,
	        d: '0',
	    },
	    {
	        n: 'miterLimit',
	        l: true,
	        syntax: PropertySyntax.NUMBER,
	        d: function (nodeName) {
	            if (nodeName === Shape.PATH ||
	                nodeName === Shape.POLYGON ||
	                nodeName === Shape.POLYLINE) {
	                return '4';
	            }
	            return '10';
	        },
	    },
	    {
	        n: 'wordWrap',
	        l: true,
	    },
	    {
	        n: 'wordWrapWidth',
	        l: true,
	    },
	    {
	        n: 'maxLines',
	        l: true,
	    },
	    {
	        n: 'textOverflow',
	        l: true,
	        d: 'clip',
	    },
	    {
	        n: 'leading',
	        l: true,
	    },
	    {
	        n: 'textBaseline',
	        l: true,
	        inh: true,
	        k: ['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'],
	        d: 'alphabetic',
	    },
	    {
	        n: 'textAlign',
	        l: true,
	        inh: true,
	        k: ['start', 'center', 'middle', 'end', 'left', 'right'],
	        d: 'start',
	    },
	    // {
	    //   n: 'whiteSpace',
	    //   l: true,
	    // },
	    {
	        n: 'markerStart',
	        syntax: PropertySyntax.MARKER,
	    },
	    {
	        n: 'markerEnd',
	        syntax: PropertySyntax.MARKER,
	    },
	    {
	        n: 'markerMid',
	        syntax: PropertySyntax.MARKER,
	    },
	    {
	        n: 'markerStartOffset',
	        syntax: PropertySyntax.LENGTH,
	        l: true,
	        int: true,
	        d: '0',
	    },
	    {
	        n: 'markerEndOffset',
	        syntax: PropertySyntax.LENGTH,
	        l: true,
	        int: true,
	        d: '0',
	    },
	];
	var GEOMETRY_ATTRIBUTE_NAMES = BUILT_IN_PROPERTIES.filter(function (n) { return !!n.l; }).map(function (n) { return n.n; });
	var propertyMetadataCache = {};
	var unresolvedProperties = new WeakMap();
	// const uniqueAttributeSet = new Set<string>();
	// const tmpVec3a = vec3.create();
	// const tmpVec3b = vec3.create();
	// const tmpVec3c = vec3.create();
	var isPropertyResolved = function (object, name) {
	    var properties = unresolvedProperties.get(object);
	    if (!properties || properties.length === 0) {
	        return true;
	    }
	    return properties.includes(name);
	};
	var DefaultStyleValueRegistry = /** @class */ (function () {
	    /**
	     * need recalc later
	     */
	    // dirty = false;
	    function DefaultStyleValueRegistry(runtime) {
	        var _this = this;
	        this.runtime = runtime;
	        BUILT_IN_PROPERTIES.forEach(function (property) {
	            _this.registerMetadata(property);
	        });
	    }
	    DefaultStyleValueRegistry.prototype.registerMetadata = function (metadata) {
	        __spreadArray([metadata.n], __read((metadata.a || [])), false).forEach(function (name) {
	            propertyMetadataCache[name] = metadata;
	        });
	    };
	    DefaultStyleValueRegistry.prototype.unregisterMetadata = function (name) {
	        delete propertyMetadataCache[name];
	    };
	    DefaultStyleValueRegistry.prototype.getPropertySyntax = function (syntax) {
	        return this.runtime.CSSPropertySyntaxFactory[syntax];
	    };
	    /**
	     * * parse value, eg.
	     * fill: 'red' => CSSRGB
	     * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
	     * fontSize: '2em' => { unit: 'px', value: 32 }
	     *
	     * * calculate used value
	     * * post process
	     */
	    DefaultStyleValueRegistry.prototype.processProperties = function (object, attributes, options) {
	        var _this = this;
	        if (options === void 0) { options = {
	            skipUpdateAttribute: false,
	            skipParse: false,
	            forceUpdateGeometry: false,
	            usedAttributes: [],
	        }; }
	        if (!this.runtime.enableCSSParsing) {
	            Object.assign(object.attributes, attributes);
	            var attributeNames_1 = Object.keys(attributes);
	            // clipPath
	            var oldClipPath = object.parsedStyle.clipPath;
	            var oldOffsetPath = object.parsedStyle.offsetPath;
	            object.parsedStyle = Object.assign(object.parsedStyle, attributes);
	            var needUpdateGeometry_1 = !!options.forceUpdateGeometry;
	            if (!needUpdateGeometry_1) {
	                for (var i = 0; i < GEOMETRY_ATTRIBUTE_NAMES.length; i++) {
	                    if (GEOMETRY_ATTRIBUTE_NAMES[i] in attributes) {
	                        needUpdateGeometry_1 = true;
	                        break;
	                    }
	                }
	            }
	            if (attributes.fill) {
	                object.parsedStyle.fill = parseColor(attributes.fill);
	            }
	            if (attributes.stroke) {
	                object.parsedStyle.stroke = parseColor(attributes.stroke);
	            }
	            if (attributes.shadowColor) {
	                object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
	            }
	            if (attributes.filter) {
	                object.parsedStyle.filter = parseFilter(attributes.filter);
	            }
	            // Rect
	            // @ts-ignore
	            if (!isNil(attributes.radius)) {
	                // @ts-ignore
	                object.parsedStyle.radius = parseDimensionArrayFormat(
	                // @ts-ignore
	                attributes.radius, 4);
	            }
	            // Polyline
	            if (!isNil(attributes.lineDash)) {
	                object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, 2);
	            }
	            // @ts-ignore
	            if (attributes.points) {
	                // @ts-ignore
	                object.parsedStyle.points = parsePoints(attributes.points, object);
	            }
	            // Path
	            // @ts-ignore
	            if (attributes.path === '') {
	                object.parsedStyle.path = __assign({}, EMPTY_PARSED_PATH);
	            }
	            // @ts-ignore
	            if (attributes.path) {
	                object.parsedStyle.path = parsePath(
	                // @ts-ignore
	                attributes.path);
	                object.parsedStyle.defX = object.parsedStyle.path.rect.x;
	                object.parsedStyle.defY = object.parsedStyle.path.rect.y;
	            }
	            // Text
	            if (attributes.textTransform) {
	                this.runtime.CSSPropertySyntaxFactory['<text-transform>'].calculator(null, null, { value: attributes.textTransform }, object, null);
	            }
	            if (attributes.clipPath) {
	                this.runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator('clipPath', oldClipPath, attributes.clipPath, object, this.runtime);
	            }
	            if (attributes.offsetPath) {
	                this.runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator('offsetPath', oldOffsetPath, attributes.offsetPath, object, this.runtime);
	            }
	            if (attributes.anchor) {
	                object.parsedStyle.anchor = parseDimensionArrayFormat(
	                // @ts-ignorex
	                attributes.anchor, 2);
	            }
	            if (attributes.transform) {
	                object.parsedStyle.transform = parseTransform(attributes.transform);
	            }
	            if (attributes.transformOrigin) {
	                object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
	            }
	            // Marker
	            // @ts-ignore
	            if (attributes.markerStart) {
	                object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory['<marker>'].calculator(null, 
	                // @ts-ignore
	                attributes.markerStart, 
	                // @ts-ignore
	                attributes.markerStart, null, null);
	            }
	            // @ts-ignore
	            if (attributes.markerEnd) {
	                object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory['<marker>'].calculator(null, 
	                // @ts-ignore
	                attributes.markerEnd, 
	                // @ts-ignore
	                attributes.markerEnd, null, null);
	            }
	            // @ts-ignore
	            if (attributes.markerMid) {
	                object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory['<marker>'].calculator('', 
	                // @ts-ignore
	                attributes.markerMid, 
	                // @ts-ignore
	                attributes.markerMid, null, null);
	            }
	            if (
	            // Circle & Ellipse
	            ((object.nodeName === Shape.CIRCLE ||
	                object.nodeName === Shape.ELLIPSE) &&
	                // @ts-ignore
	                (!isNil(attributes.cx) ||
	                    // @ts-ignore
	                    !isNil(attributes.cy))) ||
	                ((object.nodeName === Shape.RECT ||
	                    object.nodeName === Shape.IMAGE ||
	                    object.nodeName === Shape.GROUP ||
	                    object.nodeName === Shape.HTML ||
	                    object.nodeName === Shape.TEXT ||
	                    object.nodeName === Shape.MESH) &&
	                    // @ts-ignore
	                    (!isNil(attributes.x) ||
	                        // @ts-ignore
	                        !isNil(attributes.y) ||
	                        // @ts-ignore
	                        !isNil(attributes.z))) ||
	                // Line
	                (object.nodeName === Shape.LINE &&
	                    // @ts-ignore
	                    (!isNil(attributes.x1) ||
	                        // @ts-ignore
	                        !isNil(attributes.y1) ||
	                        // @ts-ignore
	                        !isNil(attributes.z1) ||
	                        // @ts-ignore
	                        !isNil(attributes.x2) ||
	                        // @ts-ignore
	                        !isNil(attributes.y2) ||
	                        // @ts-ignore
	                        !isNil(attributes.z2)))) {
	                this.runtime.CSSPropertySyntaxFactory['<coordinate>'].postProcessor(object, attributeNames_1);
	            }
	            if (!isNil(attributes.zIndex)) {
	                this.runtime.CSSPropertySyntaxFactory['<z-index>'].postProcessor(object, attributeNames_1);
	            }
	            // @ts-ignore
	            if (attributes.path) {
	                this.runtime.CSSPropertySyntaxFactory['<path>'].postProcessor(object, attributeNames_1);
	            }
	            // @ts-ignore
	            if (attributes.points) {
	                this.runtime.CSSPropertySyntaxFactory['<list-of-points>'].postProcessor(object, attributeNames_1);
	            }
	            if (!isNil(attributes.offsetDistance)) {
	                this.runtime.CSSPropertySyntaxFactory['<offset-distance>'].postProcessor(object, attributeNames_1);
	            }
	            if (attributes.transform) {
	                this.runtime.CSSPropertySyntaxFactory['<transform>'].postProcessor(object, attributeNames_1);
	            }
	            if (needUpdateGeometry_1) {
	                this.updateGeometry(object);
	            }
	            return;
	        }
	        var skipUpdateAttribute = options.skipUpdateAttribute, skipParse = options.skipParse, forceUpdateGeometry = options.forceUpdateGeometry, usedAttributes = options.usedAttributes;
	        var needUpdateGeometry = forceUpdateGeometry;
	        var attributeNames = Object.keys(attributes);
	        attributeNames.forEach(function (attributeName) {
	            var _a;
	            if (!skipUpdateAttribute) {
	                object.attributes[attributeName] = attributes[attributeName];
	            }
	            if (!needUpdateGeometry && ((_a = propertyMetadataCache[attributeName]) === null || _a === void 0 ? void 0 : _a.l)) {
	                needUpdateGeometry = true;
	            }
	        });
	        if (!skipParse) {
	            attributeNames.forEach(function (name) {
	                object.computedStyle[name] = _this.parseProperty(name, object.attributes[name], object);
	            });
	        }
	        // let hasUnresolvedProperties = false;
	        // parse according to priority
	        // path 50
	        // points 50
	        // text 50
	        // textTransform 51
	        // anchor 99
	        // transform 100
	        // transformOrigin 100
	        if (usedAttributes === null || usedAttributes === void 0 ? void 0 : usedAttributes.length) {
	            // uniqueAttributeSet.clear();
	            attributeNames = Array.from(new Set(attributeNames.concat(usedAttributes)));
	        }
	        // [
	        //   'path',
	        //   'points',
	        //   'text',
	        //   'textTransform',
	        //   'anchor',
	        //   'transform',
	        //   'transformOrigin',
	        // ].forEach((name) => {
	        //   const index = attributeNames.indexOf(name);
	        //   if (index > -1) {
	        //     attributeNames.splice(index, 1);
	        //     attributeNames.push(name);
	        //   }
	        // });
	        attributeNames.forEach(function (name) {
	            // some style props maybe deleted after parsing such as `anchor` in Text
	            if (name in object.computedStyle) {
	                object.parsedStyle[name] = _this.computeProperty(name, object.computedStyle[name], object);
	            }
	        });
	        // if (hasUnresolvedProperties) {
	        //   this.dirty = true;
	        //   return;
	        // }
	        // update geometry
	        if (needUpdateGeometry) {
	            // object.geometry.dirty = true;
	            // runtime.sceneGraphService.dirtifyToRoot(object);
	            this.updateGeometry(object);
	        }
	        attributeNames.forEach(function (name) {
	            if (name in object.parsedStyle) {
	                _this.postProcessProperty(name, object, attributeNames);
	            }
	        });
	        if (this.runtime.enableCSSParsing && object.children.length) {
	            attributeNames.forEach(function (name) {
	                if (name in object.parsedStyle && _this.isPropertyInheritable(name)) {
	                    // update children's inheritable
	                    object.children.forEach(function (child) {
	                        child.internalSetAttribute(name, null, {
	                            skipUpdateAttribute: true,
	                            skipParse: true,
	                        });
	                    });
	                }
	            });
	        }
	    };
	    /**
	     * string -> parsed value
	     */
	    DefaultStyleValueRegistry.prototype.parseProperty = function (name, value, object) {
	        var metadata = propertyMetadataCache[name];
	        var computed = value;
	        if (value === '' || isNil(value)) {
	            value = 'unset';
	        }
	        if (value === 'unset' || value === 'initial' || value === 'inherit') {
	            // computed = new CSSKeywordValue(value);
	            computed = getOrCreateKeyword(value);
	        }
	        else {
	            if (metadata) {
	                var keywords = metadata.k, syntax = metadata.syntax;
	                var handler = syntax && this.getPropertySyntax(syntax);
	                // use keywords
	                if (keywords && keywords.indexOf(value) > -1) {
	                    // computed = new CSSKeywordValue(value);
	                    computed = getOrCreateKeyword(value);
	                }
	                else if (handler && handler.parser) {
	                    // try to parse it to CSSStyleValue, eg. '10px' -> CSS.px(10)
	                    computed = handler.parser(value, object);
	                }
	            }
	        }
	        return computed;
	    };
	    /**
	     * computed value -> used value
	     */
	    DefaultStyleValueRegistry.prototype.computeProperty = function (name, computed, object) {
	        var metadata = propertyMetadataCache[name];
	        var isDocumentElement = object.id === 'g-root';
	        // let used: CSSStyleValue = computed instanceof CSSStyleValue ? computed.clone() : computed;
	        var used = computed;
	        if (metadata) {
	            var syntax = metadata.syntax, inherited = metadata.inh, defaultValue = metadata.d;
	            if (computed instanceof CSSKeywordValue) {
	                var value = computed.value;
	                /**
	                 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset
	                 */
	                if (value === 'unset') {
	                    if (inherited && !isDocumentElement) {
	                        value = 'inherit';
	                    }
	                    else {
	                        value = 'initial';
	                    }
	                }
	                if (value === 'initial') {
	                    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial
	                    if (!isNil(defaultValue)) {
	                        computed = this.parseProperty(name, isFunction$1(defaultValue)
	                            ? defaultValue(object.nodeName)
	                            : defaultValue, object);
	                    }
	                }
	                else if (value === 'inherit') {
	                    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/inherit
	                    // behave like `inherit`
	                    var resolved = this.tryToResolveProperty(object, name, {
	                        inherited: true,
	                    });
	                    if (!isNil(resolved)) {
	                        // object.parsedStyle[name] = resolved;
	                        // return false;
	                        return resolved;
	                    }
	                    else {
	                        this.addUnresolveProperty(object, name);
	                        return;
	                    }
	                }
	            }
	            var handler = syntax && this.getPropertySyntax(syntax);
	            if (handler && handler.calculator) {
	                // convert computed value to used value
	                var oldParsedValue = object.parsedStyle[name];
	                used = handler.calculator(name, oldParsedValue, computed, object, this.runtime);
	            }
	            else if (computed instanceof CSSKeywordValue) {
	                used = computed.value;
	            }
	            else {
	                used = computed;
	            }
	        }
	        // object.parsedStyle[name] = used;
	        // return false;
	        return used;
	    };
	    DefaultStyleValueRegistry.prototype.postProcessProperty = function (name, object, attributes) {
	        var metadata = propertyMetadataCache[name];
	        if (metadata && metadata.syntax) {
	            var handler = metadata.syntax && this.getPropertySyntax(metadata.syntax);
	            var propertyHandler = handler;
	            if (propertyHandler && propertyHandler.postProcessor) {
	                propertyHandler.postProcessor(object, attributes);
	            }
	        }
	    };
	    /**
	     * resolve later
	     */
	    DefaultStyleValueRegistry.prototype.addUnresolveProperty = function (object, name) {
	        var properties = unresolvedProperties.get(object);
	        if (!properties) {
	            unresolvedProperties.set(object, []);
	            properties = unresolvedProperties.get(object);
	        }
	        if (properties.indexOf(name) === -1) {
	            properties.push(name);
	        }
	    };
	    DefaultStyleValueRegistry.prototype.tryToResolveProperty = function (object, name, options) {
	        if (options === void 0) { options = {}; }
	        var inherited = options.inherited;
	        if (inherited) {
	            if (object.parentElement &&
	                isPropertyResolved(object.parentElement, name)) {
	                // const computedValue = object.parentElement.computedStyle[name];
	                var usedValue = object.parentElement.parsedStyle[name];
	                if (
	                // usedValue instanceof CSSKeywordValue &&
	                usedValue === 'unset' ||
	                    usedValue === 'initial' ||
	                    usedValue === 'inherit') {
	                    return;
	                }
	                // else if (
	                //   usedValue instanceof CSSUnitValue &&
	                //   CSSUnitValue.isRelativeUnit(usedValue.unit)
	                // ) {
	                //   return false;
	                // }
	                return usedValue;
	            }
	        }
	        return;
	    };
	    DefaultStyleValueRegistry.prototype.recalc = function (object) {
	        var properties = unresolvedProperties.get(object);
	        if (properties && properties.length) {
	            var attributes_1 = {};
	            properties.forEach(function (property) {
	                attributes_1[property] = object.attributes[property];
	            });
	            this.processProperties(object, attributes_1);
	            unresolvedProperties.delete(object);
	        }
	    };
	    /**
	     * update geometry when relative props changed,
	     * eg. r of Circle, width/height of Rect
	     */
	    DefaultStyleValueRegistry.prototype.updateGeometry = function (object) {
	        var nodeName = object.nodeName;
	        var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
	        if (geometryUpdater) {
	            var geometry_1 = object.geometry;
	            if (!geometry_1.contentBounds) {
	                geometry_1.contentBounds = new AABB();
	            }
	            if (!geometry_1.renderBounds) {
	                geometry_1.renderBounds = new AABB();
	            }
	            var parsedStyle = object.parsedStyle;
	            var _a = geometryUpdater.update(parsedStyle, object), width = _a.width, height = _a.height, _b = _a.depth, depth = _b === void 0 ? 0 : _b, _c = _a.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _a.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _a.offsetZ, offsetZ = _e === void 0 ? 0 : _e;
	            // init with content box
	            var halfExtents = [
	                Math.abs(width) / 2,
	                Math.abs(height) / 2,
	                depth / 2,
	            ];
	            // const halfExtents = vec3.set(
	            //   tmpVec3a,
	            //   Math.abs(width) / 2,
	            //   Math.abs(height) / 2,
	            //   depth / 2,
	            // );
	            // anchor is center by default, don't account for lineWidth here
	            var _f = parsedStyle, stroke = _f.stroke, lineWidth = _f.lineWidth, 
	            // lineCap,
	            // lineJoin,
	            // miterLimit,
	            increasedLineWidthForHitTesting = _f.increasedLineWidthForHitTesting, shadowType = _f.shadowType, shadowColor = _f.shadowColor, _g = _f.filter, filter = _g === void 0 ? [] : _g, transformOrigin = _f.transformOrigin;
	            var anchor = parsedStyle.anchor;
	            // <Text> use textAlign & textBaseline instead of anchor
	            if (nodeName === Shape.TEXT) {
	                delete parsedStyle.anchor;
	            }
	            else if (nodeName === Shape.MESH) {
	                parsedStyle.anchor[2] = 0.5;
	            }
	            var center = [
	                ((1 - ((anchor && anchor[0]) || 0) * 2) * width) / 2 + offsetX,
	                ((1 - ((anchor && anchor[1]) || 0) * 2) * height) / 2 + offsetY,
	                (1 - ((anchor && anchor[2]) || 0) * 2) * halfExtents[2] + offsetZ,
	            ];
	            // const center = vec3.set(
	            //   tmpVec3b,
	            //   ((1 - ((anchor && anchor[0]) || 0) * 2) * width) / 2 + offsetX,
	            //   ((1 - ((anchor && anchor[1]) || 0) * 2) * height) / 2 + offsetY,
	            //   (1 - ((anchor && anchor[2]) || 0) * 2) * halfExtents[2] + offsetZ,
	            // );
	            // update geometry's AABB
	            geometry_1.contentBounds.update(center, halfExtents);
	            // @see https://github.molgen.mpg.de/git-mirror/cairo/blob/master/src/cairo-stroke-style.c#L97..L128
	            var expansion = nodeName === Shape.POLYLINE ||
	                nodeName === Shape.POLYGON ||
	                nodeName === Shape.PATH
	                ? Math.SQRT2
	                : 0.5;
	            // if (lineCap?.value === 'square') {
	            //   expansion = Math.SQRT1_2;
	            // }
	            // if (lineJoin?.value === 'miter' && expansion < Math.SQRT2 * miterLimit) {
	            //   expansion = Math.SQRT1_2 * miterLimit;
	            // }
	            // append border only if stroke existed
	            var hasStroke = stroke && !stroke.isNone;
	            if (hasStroke) {
	                var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) *
	                    expansion;
	                // halfExtents[0] += halfLineWidth[0];
	                // halfExtents[1] += halfLineWidth[1];
	                halfExtents[0] += halfLineWidth;
	                halfExtents[1] += halfLineWidth;
	                // vec3.add(
	                //   halfExtents,
	                //   halfExtents,
	                //   vec3.set(tmpVec3c, halfLineWidth, halfLineWidth, 0),
	                // );
	            }
	            geometry_1.renderBounds.update(center, halfExtents);
	            // account for shadow, only support constant value now
	            if (shadowColor && shadowType && shadowType !== 'inner') {
	                var _h = geometry_1.renderBounds, min = _h.min, max = _h.max;
	                var _j = parsedStyle, shadowBlur = _j.shadowBlur, shadowOffsetX = _j.shadowOffsetX, shadowOffsetY = _j.shadowOffsetY;
	                var shadowBlurInPixels = shadowBlur || 0;
	                var shadowOffsetXInPixels = shadowOffsetX || 0;
	                var shadowOffsetYInPixels = shadowOffsetY || 0;
	                var shadowLeft = min[0] - shadowBlurInPixels + shadowOffsetXInPixels;
	                var shadowRight = max[0] + shadowBlurInPixels + shadowOffsetXInPixels;
	                var shadowTop = min[1] - shadowBlurInPixels + shadowOffsetYInPixels;
	                var shadowBottom = max[1] + shadowBlurInPixels + shadowOffsetYInPixels;
	                min[0] = Math.min(min[0], shadowLeft);
	                max[0] = Math.max(max[0], shadowRight);
	                min[1] = Math.min(min[1], shadowTop);
	                max[1] = Math.max(max[1], shadowBottom);
	                geometry_1.renderBounds.setMinMax(min, max);
	            }
	            // account for filter, eg. blur(5px), drop-shadow()
	            filter.forEach(function (_a) {
	                var name = _a.name, params = _a.params;
	                if (name === 'blur') {
	                    var blurRadius = params[0].value;
	                    geometry_1.renderBounds.update(geometry_1.renderBounds.center, addVec3(geometry_1.renderBounds.halfExtents, geometry_1.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
	                }
	                else if (name === 'drop-shadow') {
	                    var shadowOffsetX = params[0].value;
	                    var shadowOffsetY = params[1].value;
	                    var shadowBlur = params[2].value;
	                    var _b = geometry_1.renderBounds, min = _b.min, max = _b.max;
	                    var shadowLeft = min[0] - shadowBlur + shadowOffsetX;
	                    var shadowRight = max[0] + shadowBlur + shadowOffsetX;
	                    var shadowTop = min[1] - shadowBlur + shadowOffsetY;
	                    var shadowBottom = max[1] + shadowBlur + shadowOffsetY;
	                    min[0] = Math.min(min[0], shadowLeft);
	                    max[0] = Math.max(max[0], shadowRight);
	                    min[1] = Math.min(min[1], shadowTop);
	                    max[1] = Math.max(max[1], shadowBottom);
	                    geometry_1.renderBounds.setMinMax(min, max);
	                }
	            });
	            anchor = parsedStyle.anchor;
	            // if (nodeName === Shape.RECT) {
	            // account for negative width / height of Rect
	            // @see https://github.com/antvis/g/issues/957
	            var flipY = width < 0;
	            var flipX = height < 0;
	            // } else {
	            // }
	            // set transform origin
	            var usedOriginXValue = (flipY ? -1 : 1) *
	                (transformOrigin
	                    ? convertPercentUnit(transformOrigin[0], 0, object)
	                    : 0);
	            var usedOriginYValue = (flipX ? -1 : 1) *
	                (transformOrigin
	                    ? convertPercentUnit(transformOrigin[1], 1, object)
	                    : 0);
	            usedOriginXValue =
	                usedOriginXValue -
	                    (flipY ? -1 : 1) *
	                        ((anchor && anchor[0]) || 0) *
	                        geometry_1.contentBounds.halfExtents[0] *
	                        2;
	            usedOriginYValue =
	                usedOriginYValue -
	                    (flipX ? -1 : 1) *
	                        ((anchor && anchor[1]) || 0) *
	                        geometry_1.contentBounds.halfExtents[1] *
	                        2;
	            object.setOrigin(usedOriginXValue, usedOriginYValue);
	            // FIXME setOrigin may have already dirtified to root.
	            this.runtime.sceneGraphService.dirtifyToRoot(object);
	        }
	    };
	    DefaultStyleValueRegistry.prototype.isPropertyInheritable = function (name) {
	        var metadata = propertyMetadataCache[name];
	        if (!metadata) {
	            return false;
	        }
	        return metadata.inh;
	    };
	    return DefaultStyleValueRegistry;
	}());

	var CSSPropertyAngle = /** @class */ (function () {
	    function CSSPropertyAngle() {
	        this.parser = parseAngle;
	        this.parserWithCSSDisabled = null;
	        this.mixer = mergeNumbers;
	    }
	    CSSPropertyAngle.prototype.calculator = function (name, oldParsed, parsed, object) {
	        return convertAngleUnit(parsed);
	    };
	    return CSSPropertyAngle;
	}());

	/**
	 * clipPath / textPath / offsetPath
	 */
	var CSSPropertyClipPath = /** @class */ (function () {
	    function CSSPropertyClipPath() {
	    }
	    CSSPropertyClipPath.prototype.calculator = function (name, oldPath, newPath, object, runtime) {
	        // unset
	        if (newPath instanceof CSSKeywordValue) {
	            newPath = null;
	        }
	        runtime.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
	        if (name === 'clipPath') {
	            // should affect children
	            object.forEach(function (leaf) {
	                if (leaf.childNodes.length === 0) {
	                    runtime.sceneGraphService.dirtifyToRoot(leaf);
	                }
	            });
	        }
	        return newPath;
	    };
	    return CSSPropertyClipPath;
	}());

	var CSSPropertyColor = /** @class */ (function () {
	    function CSSPropertyColor() {
	        this.parser = parseColor;
	        this.parserWithCSSDisabled = parseColor;
	        this.mixer = mergeColors;
	    }
	    CSSPropertyColor.prototype.calculator = function (name, oldParsed, parsed, object) {
	        if (parsed instanceof CSSKeywordValue) {
	            // 'unset' 'none'
	            return parsed.value === 'none' ? noneColor : transparentColor;
	        }
	        return parsed;
	    };
	    return CSSPropertyColor;
	}());

	var CSSPropertyFilter = /** @class */ (function () {
	    function CSSPropertyFilter() {
	        this.parser = parseFilter;
	    }
	    CSSPropertyFilter.prototype.calculator = function (name, oldParsed, parsed) {
	        // unset or none
	        if (parsed instanceof CSSKeywordValue) {
	            return [];
	        }
	        return parsed;
	    };
	    return CSSPropertyFilter;
	}());

	function getFontSize(object) {
	    var fontSize = object.parsedStyle.fontSize;
	    return isNil(fontSize) ? null : fontSize;
	}
	/**
	 * <length> & <percentage>
	 */
	var CSSPropertyLengthOrPercentage = /** @class */ (function () {
	    function CSSPropertyLengthOrPercentage() {
	        this.parser = parseLengthOrPercentage;
	        this.parserWithCSSDisabled = null;
	        this.mixer = mergeNumbers;
	    }
	    /**
	     * according to parent's bounds
	     *
	     * @example
	     * CSS.percent(50) -> CSS.px(0.5 * parent.width)
	     */
	    CSSPropertyLengthOrPercentage.prototype.calculator = function (name, oldParsed, computed, object, runtime) {
	        var _a;
	        if (isNumber(computed)) {
	            return computed;
	        }
	        if (CSSUnitValue.isRelativeUnit(computed.unit)) {
	            var registry = runtime.styleValueRegistry;
	            if (computed.unit === UnitType.kPercentage) {
	                // TODO: merge dimensions
	                return 0;
	            }
	            else if (computed.unit === UnitType.kEms) {
	                if (object.parentNode) {
	                    var fontSize = getFontSize(object.parentNode);
	                    if (fontSize) {
	                        fontSize *= computed.value;
	                        return fontSize;
	                    }
	                    else {
	                        registry.addUnresolveProperty(object, name);
	                    }
	                }
	                else {
	                    registry.addUnresolveProperty(object, name);
	                }
	                return 0;
	            }
	            else if (computed.unit === UnitType.kRems) {
	                if ((_a = object === null || object === void 0 ? void 0 : object.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) {
	                    var fontSize = getFontSize(object.ownerDocument.documentElement);
	                    if (fontSize) {
	                        fontSize *= computed.value;
	                        return fontSize;
	                    }
	                    else {
	                        registry.addUnresolveProperty(object, name);
	                    }
	                }
	                else {
	                    registry.addUnresolveProperty(object, name);
	                }
	                return 0;
	            }
	        }
	        else {
	            // remove listener if exists
	            // registry.unregisterParentGeometryBoundsChangedHandler(object, name);
	            // return absolute value
	            return computed.value;
	        }
	    };
	    return CSSPropertyLengthOrPercentage;
	}());

	/**
	 * format to Tuple2<CSSUnitValue>
	 *
	 * @example
	 * rect.style.lineDash = 10;
	 * rect.style.lineDash = [10, 10];
	 * rect.style.lineDash = '10 10';
	 */
	var CSSPropertyLengthOrPercentage12 = /** @class */ (function () {
	    function CSSPropertyLengthOrPercentage12() {
	        this.mixer = mergeNumberLists;
	    }
	    CSSPropertyLengthOrPercentage12.prototype.parser = function (radius) {
	        var parsed = parseDimensionArray(isNumber(radius) ? [radius] : radius);
	        var formatted;
	        if (parsed.length === 1) {
	            formatted = [parsed[0], parsed[0]];
	        }
	        else {
	            formatted = [parsed[0], parsed[1]];
	        }
	        return formatted;
	    };
	    CSSPropertyLengthOrPercentage12.prototype.calculator = function (name, oldParsed, computed) {
	        return computed.map(function (c) { return c.value; });
	    };
	    return CSSPropertyLengthOrPercentage12;
	}());

	/**
	 * used in rounded rect
	 *
	 * @example
	 * rect.style.radius = 10;
	 * rect.style.radius = '10 10';
	 * rect.style.radius = '10 10 10 10';
	 */
	var CSSPropertyLengthOrPercentage14 = /** @class */ (function () {
	    function CSSPropertyLengthOrPercentage14() {
	        this.mixer = mergeNumberLists;
	    }
	    CSSPropertyLengthOrPercentage14.prototype.parser = function (radius) {
	        var parsed = parseDimensionArray(isNumber(radius) ? [radius] : radius);
	        var formatted;
	        // format to Tuple<CSSUnitValue>
	        if (parsed.length === 1) {
	            formatted = [parsed[0], parsed[0], parsed[0], parsed[0]];
	        }
	        else if (parsed.length === 2) {
	            formatted = [parsed[0], parsed[1], parsed[0], parsed[1]];
	        }
	        else if (parsed.length === 3) {
	            formatted = [parsed[0], parsed[1], parsed[2], parsed[1]];
	        }
	        else {
	            formatted = [parsed[0], parsed[1], parsed[2], parsed[3]];
	        }
	        return formatted;
	    };
	    CSSPropertyLengthOrPercentage14.prototype.calculator = function (name, oldParsed, computed) {
	        return computed.map(function (c) { return c.value; });
	    };
	    return CSSPropertyLengthOrPercentage14;
	}());

	var tmpMat4 = create$1();
	function parsedTransformToMat4(transform, object) {
	    var defX = object.parsedStyle.defX || 0;
	    var defY = object.parsedStyle.defY || 0;
	    // reset transform
	    object.resetLocalTransform();
	    object.setLocalPosition(defX, defY);
	    transform.forEach(function (parsed) {
	        var t = parsed.t, d = parsed.d;
	        if (t === 'scale') {
	            // scale(1) scale(1, 1)
	            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1, 1];
	            object.scaleLocal(newScale[0], newScale[1], 1);
	        }
	        else if (t === 'scalex') {
	            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1];
	            object.scaleLocal(newScale[0], 1, 1);
	        }
	        else if (t === 'scaley') {
	            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1];
	            object.scaleLocal(1, newScale[0], 1);
	        }
	        else if (t === 'scalez') {
	            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1];
	            object.scaleLocal(1, 1, newScale[0]);
	        }
	        else if (t === 'scale3d') {
	            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1, 1, 1];
	            object.scaleLocal(newScale[0], newScale[1], newScale[2]);
	        }
	        else if (t === 'translate') {
	            var newTranslation = d || [Opx, Opx];
	            object.translateLocal(newTranslation[0].value, newTranslation[1].value, 0);
	        }
	        else if (t === 'translatex') {
	            var newTranslation = d || [Opx];
	            object.translateLocal(newTranslation[0].value, 0, 0);
	        }
	        else if (t === 'translatey') {
	            var newTranslation = d || [Opx];
	            object.translateLocal(0, newTranslation[0].value, 0);
	        }
	        else if (t === 'translatez') {
	            var newTranslation = d || [Opx];
	            object.translateLocal(0, 0, newTranslation[0].value);
	        }
	        else if (t === 'translate3d') {
	            var newTranslation = d || [Opx, Opx, Opx];
	            object.translateLocal(newTranslation[0].value, newTranslation[1].value, newTranslation[2].value);
	        }
	        else if (t === 'rotate') {
	            var newAngles = d || [Odeg];
	            object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
	        }
	        else if (t === 'rotatex') {
	            var newAngles = d || [Odeg];
	            object.rotateLocal(convertAngleUnit(newAngles[0]), 0, 0);
	        }
	        else if (t === 'rotatey') {
	            var newAngles = d || [Odeg];
	            object.rotateLocal(0, convertAngleUnit(newAngles[0]), 0);
	        }
	        else if (t === 'rotatez') {
	            var newAngles = d || [Odeg];
	            object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
	        }
	        else if (t === 'rotate3d') ;
	        else if (t === 'skew') {
	            var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [0, 0];
	            object.setLocalSkew(deg2rad(newSkew[0]), deg2rad(newSkew[1]));
	        }
	        else if (t === 'skewx') {
	            var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [0];
	            object.setLocalSkew(deg2rad(newSkew[0]), object.getLocalSkew()[1]);
	        }
	        else if (t === 'skewy') {
	            var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [0];
	            object.setLocalSkew(object.getLocalSkew()[0], deg2rad(newSkew[0]));
	        }
	        else if (t === 'matrix') {
	            var _a = __read(d.map(function (s) { return s.value; }), 6), a = _a[0], b = _a[1], c = _a[2], dd = _a[3], tx = _a[4], ty = _a[5];
	            object.setLocalTransform(set(tmpMat4, a, b, 0, 0, c, dd, 0, 0, 0, 0, 1, 0, tx + defX, ty + defY, 0, 1));
	        }
	        else if (t === 'matrix3d') {
	            // @ts-ignore
	            set.apply(mat4, __spreadArray([tmpMat4], __read(d.map(function (s) { return s.value; })), false));
	            tmpMat4[12] += defX;
	            tmpMat4[13] += defY;
	            object.setLocalTransform(tmpMat4);
	        }
	    });
	    return object.getLocalTransform();
	}

	/**
	 * local position
	 */
	var CSSPropertyLocalPosition = /** @class */ (function (_super) {
	    __extends(CSSPropertyLocalPosition, _super);
	    function CSSPropertyLocalPosition() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * update local position
	     */
	    CSSPropertyLocalPosition.prototype.postProcessor = function (object, attributes) {
	        var x;
	        var y;
	        var z;
	        switch (object.nodeName) {
	            case Shape.CIRCLE:
	            case Shape.ELLIPSE:
	                var _a = object.parsedStyle, cx = _a.cx, cy = _a.cy, cz = _a.cz;
	                if (!isNil(cx)) {
	                    x = cx;
	                }
	                if (!isNil(cy)) {
	                    y = cy;
	                }
	                if (!isNil(cz)) {
	                    z = cz;
	                }
	                break;
	            case Shape.LINE:
	                var _b = object.parsedStyle, x1 = _b.x1, x2 = _b.x2, y1 = _b.y1, y2 = _b.y2;
	                var minX = Math.min(x1, x2);
	                var minY = Math.min(y1, y2);
	                x = minX;
	                y = minY;
	                z = 0;
	                break;
	            case Shape.RECT:
	            case Shape.IMAGE:
	            case Shape.GROUP:
	            case Shape.HTML:
	            case Shape.TEXT:
	            case Shape.MESH:
	                if (!isNil(object.parsedStyle.x)) {
	                    x = object.parsedStyle.x;
	                }
	                if (!isNil(object.parsedStyle.y)) {
	                    y = object.parsedStyle.y;
	                }
	                if (!isNil(object.parsedStyle.z)) {
	                    z = object.parsedStyle.z;
	                }
	                break;
	        }
	        if (object.nodeName !== Shape.PATH &&
	            object.nodeName !== Shape.POLYLINE &&
	            object.nodeName !== Shape.POLYGON) {
	            object.parsedStyle.defX = x || 0;
	            object.parsedStyle.defY = y || 0;
	        }
	        var needResetLocalPosition = !isNil(x) || !isNil(y) || !isNil(z);
	        // only if `transform` won't be processed later
	        if (needResetLocalPosition && attributes.indexOf('transform') === -1) {
	            // account for current transform if needed
	            var transform = object.parsedStyle.transform;
	            if (transform && transform.length) {
	                parsedTransformToMat4(transform, object);
	            }
	            else {
	                var _c = __read(object.getLocalPosition(), 3), ox = _c[0], oy = _c[1], oz = _c[2];
	                object.setLocalPosition(isNil(x) ? ox : x, isNil(y) ? oy : y, isNil(z) ? oz : z);
	            }
	        }
	    };
	    return CSSPropertyLocalPosition;
	}(CSSPropertyLengthOrPercentage));

	var CSSPropertyMarker = /** @class */ (function () {
	    function CSSPropertyMarker() {
	    }
	    CSSPropertyMarker.prototype.calculator = function (name, oldMarker, newMarker, object) {
	        // unset
	        if (newMarker instanceof CSSKeywordValue) {
	            newMarker = null;
	        }
	        var cloned = newMarker === null || newMarker === void 0 ? void 0 : newMarker.cloneNode(true);
	        if (cloned) {
	            // FIXME: SVG should not inherit parent's style, add a flag here
	            cloned.style.isMarker = true;
	        }
	        return cloned;
	    };
	    return CSSPropertyMarker;
	}());

	var CSSPropertyNumber = /** @class */ (function () {
	    function CSSPropertyNumber() {
	        this.mixer = mergeNumbers;
	        this.parser = parseNumber;
	        this.parserWithCSSDisabled = null;
	    }
	    CSSPropertyNumber.prototype.calculator = function (name, oldParsed, computed) {
	        return computed.value;
	    };
	    return CSSPropertyNumber;
	}());

	var CSSPropertyOffsetDistance = /** @class */ (function () {
	    function CSSPropertyOffsetDistance() {
	        this.parser = parseNumber;
	        this.parserWithCSSDisabled = null;
	        this.mixer = clampedMergeNumbers(0, 1);
	    }
	    CSSPropertyOffsetDistance.prototype.calculator = function (name, oldParsed, computed) {
	        return computed.value;
	    };
	    CSSPropertyOffsetDistance.prototype.postProcessor = function (object) {
	        var _a = object.parsedStyle, offsetPath = _a.offsetPath, offsetDistance = _a.offsetDistance;
	        if (!offsetPath) {
	            return;
	        }
	        var nodeName = offsetPath.nodeName;
	        if (nodeName === Shape.LINE ||
	            nodeName === Shape.PATH ||
	            nodeName === Shape.POLYLINE) {
	            // set position in world space
	            var point = offsetPath.getPoint(offsetDistance);
	            if (point) {
	                object.parsedStyle.defX = point.x;
	                object.parsedStyle.defY = point.y;
	                object.setLocalPosition(point.x, point.y);
	            }
	        }
	    };
	    return CSSPropertyOffsetDistance;
	}());

	/**
	 * opacity
	 */
	var CSSPropertyOpacity = /** @class */ (function () {
	    function CSSPropertyOpacity() {
	        this.parser = parseNumber;
	        this.parserWithCSSDisabled = null;
	        this.mixer = clampedMergeNumbers(0, 1);
	    }
	    CSSPropertyOpacity.prototype.calculator = function (name, oldParsed, computed) {
	        return computed.value;
	    };
	    return CSSPropertyOpacity;
	}());

	var CSSPropertyPath = /** @class */ (function () {
	    function CSSPropertyPath() {
	        /**
	         * path2Curve
	         */
	        this.parser = parsePath;
	        this.parserWithCSSDisabled = parsePath;
	        this.mixer = mergePaths;
	    }
	    CSSPropertyPath.prototype.calculator = function (name, oldParsed, parsed) {
	        // unset
	        if (parsed instanceof CSSKeywordValue && parsed.value === 'unset') {
	            return {
	                absolutePath: [],
	                hasArc: false,
	                segments: [],
	                polygons: [],
	                polylines: [],
	                curve: null,
	                totalLength: 0,
	                rect: new Rectangle(0, 0, 0, 0),
	            };
	        }
	        return parsed;
	    };
	    /**
	     * update local position
	     */
	    CSSPropertyPath.prototype.postProcessor = function (object, attributes) {
	        object.parsedStyle.defX = object.parsedStyle.path.rect.x;
	        object.parsedStyle.defY = object.parsedStyle.path.rect.y;
	        if (object.nodeName === Shape.PATH &&
	            attributes.indexOf('transform') === -1) {
	            var _a = object.parsedStyle, _b = _a.defX, defX = _b === void 0 ? 0 : _b, _c = _a.defY, defY = _c === void 0 ? 0 : _c;
	            object.setLocalPosition(defX, defY);
	        }
	    };
	    return CSSPropertyPath;
	}());

	var CSSPropertyPoints = /** @class */ (function () {
	    function CSSPropertyPoints() {
	        this.parser = parsePoints;
	        this.mixer = mergePoints;
	    }
	    /**
	     * update local position
	     */
	    CSSPropertyPoints.prototype.postProcessor = function (object, attributes) {
	        if ((object.nodeName === Shape.POLYGON ||
	            object.nodeName === Shape.POLYLINE) &&
	            attributes.indexOf('transform') === -1) {
	            var _a = object.parsedStyle, defX = _a.defX, defY = _a.defY;
	            object.setLocalPosition(defX, defY);
	        }
	    };
	    return CSSPropertyPoints;
	}());

	var CSSPropertyShadowBlur = /** @class */ (function (_super) {
	    __extends(CSSPropertyShadowBlur, _super);
	    function CSSPropertyShadowBlur() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.mixer = clampedMergeNumbers(0, Infinity);
	        return _this;
	    }
	    return CSSPropertyShadowBlur;
	}(CSSPropertyLengthOrPercentage));

	var CSSPropertyText = /** @class */ (function () {
	    function CSSPropertyText() {
	    }
	    CSSPropertyText.prototype.calculator = function (name, oldParsed, parsed, object) {
	        if (parsed instanceof CSSKeywordValue) {
	            if (parsed.value === 'unset') {
	                return '';
	            }
	            else {
	                return parsed.value;
	            }
	        }
	        // allow number as valid text content
	        return "".concat(parsed);
	    };
	    CSSPropertyText.prototype.postProcessor = function (object) {
	        object.nodeValue = "".concat(object.parsedStyle.text) || '';
	    };
	    return CSSPropertyText;
	}());

	/**
	 * it must transform after text get parsed
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-transform
	 */
	var CSSPropertyTextTransform = /** @class */ (function () {
	    function CSSPropertyTextTransform() {
	    }
	    CSSPropertyTextTransform.prototype.calculator = function (name, oldParsed, parsed, object) {
	        var rawText = object.getAttribute('text');
	        if (rawText) {
	            var transformedText = rawText;
	            if (parsed.value === 'capitalize') {
	                transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
	            }
	            else if (parsed.value === 'lowercase') {
	                transformedText = rawText.toLowerCase();
	            }
	            else if (parsed.value === 'uppercase') {
	                transformedText = rawText.toUpperCase();
	            }
	            object.parsedStyle.text = transformedText;
	        }
	        return parsed.value;
	    };
	    return CSSPropertyTextTransform;
	}());

	var canvasMap = {};
	var defaultCanvasIdCounter = 0;
	/**
	 * destroy existed canvas with the same id
	 */
	function cleanExistedCanvas(container, canvas) {
	    if (container) {
	        var id = typeof container === 'string'
	            ? container
	            : container.id || defaultCanvasIdCounter++;
	        if (canvasMap[id]) {
	            canvasMap[id].destroy();
	        }
	        canvasMap[id] = canvas;
	    }
	}
	var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

	function isElement(target) {
	    return !!target.getAttribute;
	}
	function sortedIndex(array, value) {
	    var low = 0;
	    var high = array.length;
	    while (low < high) {
	        var mid = (low + high) >>> 1;
	        if (sortByZIndex(array[mid], value) < 0) {
	            low = mid + 1;
	        }
	        else {
	            high = mid;
	        }
	    }
	    return low;
	}
	function sortByZIndex(o1, o2) {
	    var zIndex1 = Number(o1.parsedStyle.zIndex);
	    var zIndex2 = Number(o2.parsedStyle.zIndex);
	    if (zIndex1 === zIndex2) {
	        var parent_1 = o1.parentNode;
	        if (parent_1) {
	            var children = parent_1.childNodes || [];
	            return children.indexOf(o1) - children.indexOf(o2);
	        }
	    }
	    return zIndex1 - zIndex2;
	}
	function findClosestClipPathTarget(object) {
	    var _a;
	    var el = object;
	    do {
	        var clipPath = (_a = el.parsedStyle) === null || _a === void 0 ? void 0 : _a.clipPath;
	        if (clipPath)
	            return el;
	        el = el.parentElement;
	    } while (el !== null);
	    return null;
	}
	function getStyle($el, property) {
	    if (isBrowser) {
	        return document.defaultView
	            .getComputedStyle($el, null)
	            .getPropertyValue(property);
	    }
	}
	function getWidth($el) {
	    var width = getStyle($el, 'width');
	    if (width === 'auto') {
	        return $el.offsetWidth;
	    }
	    return parseFloat(width);
	}
	function getHeight($el) {
	    var height = getStyle($el, 'height');
	    if (height === 'auto') {
	        return $el.offsetHeight;
	    }
	    return parseFloat(height);
	}

	// borrow from hammer.js
	var MOUSE_POINTER_ID = 1;
	var TOUCH_TO_POINTER = {
	    touchstart: 'pointerdown',
	    touchend: 'pointerup',
	    touchendoutside: 'pointerupoutside',
	    touchmove: 'pointermove',
	    touchcancel: 'pointercancel',
	};

	function isFillOrStrokeAffected(pointerEvents, fill, stroke) {
	    // account for pointerEvents
	    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
	    var hasFill = false;
	    var hasStroke = false;
	    var isFillOtherThanNone = !!fill && !fill.isNone;
	    var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
	    if (pointerEvents === 'visiblepainted' ||
	        pointerEvents === 'painted' ||
	        pointerEvents === 'auto') {
	        hasFill = isFillOtherThanNone;
	        hasStroke = isStrokeOtherThanNone;
	    }
	    else if (pointerEvents === 'visiblefill' || pointerEvents === 'fill') {
	        hasFill = true;
	    }
	    else if (pointerEvents === 'visiblestroke' || pointerEvents === 'stroke') {
	        hasStroke = true;
	    }
	    else if (pointerEvents === 'visible' || pointerEvents === 'all') {
	        // The values of the fill and stroke do not affect event processing.
	        hasFill = true;
	        hasStroke = true;
	    }
	    return [hasFill, hasStroke];
	}

	/**
	 * Thanks for following contributor of codes
	 * https://gist.github.com/1866474
	 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
	 * https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/requestAnimationFrame/polyfill.js
	 **/
	var uId = 1;
	var uniqueId = function () { return uId++; };
	// We use `self` instead of `window` for `WebWorker` support.
	var root = typeof self === 'object' && self.self == self
	    ? self
	    : // @ts-ignore
	        typeof global === 'object' && global.global == global
	            ? // @ts-ignore
	                global
	            : {};
	var nowOffset = Date.now();
	// use performance api if exist, otherwise use Date.now.
	// Date.now polyfill required.
	var pnow = function () {
	    if (root.performance && typeof root.performance.now === 'function') {
	        return root.performance.now();
	    }
	    // fallback
	    return Date.now() - nowOffset;
	};
	var reservedCBs = {};
	var lastTime = Date.now();
	var polyfillRaf = function (callback) {
	    if (typeof callback !== 'function') {
	        throw new TypeError(callback + ' is not a function');
	    }
	    var currentTime = Date.now();
	    var gap = currentTime - lastTime;
	    var delay = gap > 16 ? 0 : 16 - gap;
	    var id = uniqueId();
	    reservedCBs[id] = callback;
	    // keys(reservedCBs).length > 1 의미는 이미 setTimeout 이 걸려있는 경우.
	    // 함께 callback 이 실행될 수 있게 reservedCBs 에만 추가해주고 return
	    if (Object.keys(reservedCBs).length > 1)
	        return id;
	    setTimeout(function () {
	        lastTime = currentTime;
	        var copied = reservedCBs;
	        reservedCBs = {};
	        Object.keys(copied).forEach(function (key) { return copied[key](pnow()); });
	    }, delay);
	    return id;
	};
	var polyfillCaf = function (id) {
	    delete reservedCBs[id];
	};
	var vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o'];
	var getRequestAnimationFrame = function (vp) {
	    if (typeof vp !== 'string')
	        return polyfillRaf;
	    if (vp === '')
	        return root['requestAnimationFrame'];
	    return root[vp + 'RequestAnimationFrame'];
	};
	var getCancelAnimationFrame = function (vp) {
	    if (typeof vp !== 'string')
	        return polyfillCaf;
	    if (vp === '')
	        return root['cancelAnimationFrame'];
	    return (root[vp + 'CancelAnimationFrame'] ||
	        root[vp + 'CancelRequestAnimationFrame']);
	};
	var find = function (arr, predicate) {
	    var i = 0;
	    while (arr[i] !== void 0) {
	        if (predicate(arr[i]))
	            return arr[i];
	        i = i + 1;
	    }
	};
	var vp = find(vendorPrefixes, function (vp) { return !!getRequestAnimationFrame(vp); });
	var raf = getRequestAnimationFrame(vp);
	var caf = getCancelAnimationFrame(vp);
	root.requestAnimationFrame = raf;
	root.cancelAnimationFrame = caf;

	var AsyncParallelHook = /** @class */ (function () {
	    function AsyncParallelHook() {
	        this.callbacks = [];
	    }
	    AsyncParallelHook.prototype.getCallbacksNum = function () {
	        return this.callbacks.length;
	    };
	    AsyncParallelHook.prototype.tapPromise = function (options, fn) {
	        this.callbacks.push(fn);
	    };
	    AsyncParallelHook.prototype.promise = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return Promise.all(this.callbacks.map(function (callback) {
	            return callback.apply(void 0, __spreadArray([], __read(args), false));
	        }));
	    };
	    return AsyncParallelHook;
	}());

	var AsyncSeriesWaterfallHook = /** @class */ (function () {
	    function AsyncSeriesWaterfallHook() {
	        this.callbacks = [];
	    }
	    AsyncSeriesWaterfallHook.prototype.tapPromise = function (options, fn) {
	        this.callbacks.push(fn);
	    };
	    AsyncSeriesWaterfallHook.prototype.promise = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return __awaiter(this, void 0, void 0, function () {
	            var result, i, callback;
	            var _a;
	            return __generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        if (!this.callbacks.length) return [3 /*break*/, 6];
	                        return [4 /*yield*/, (_a = this.callbacks)[0].apply(_a, __spreadArray([], __read(args), false))];
	                    case 1:
	                        result = _b.sent();
	                        i = 0;
	                        _b.label = 2;
	                    case 2:
	                        if (!(i < this.callbacks.length - 1)) return [3 /*break*/, 5];
	                        callback = this.callbacks[i];
	                        return [4 /*yield*/, callback(result)];
	                    case 3:
	                        // @ts-ignore
	                        result = _b.sent();
	                        _b.label = 4;
	                    case 4:
	                        i++;
	                        return [3 /*break*/, 2];
	                    case 5: return [2 /*return*/, result];
	                    case 6: return [2 /*return*/, null];
	                }
	            });
	        });
	    };
	    return AsyncSeriesWaterfallHook;
	}());

	var SyncHook = /** @class */ (function () {
	    function SyncHook() {
	        this.callbacks = [];
	    }
	    SyncHook.prototype.tap = function (options, fn) {
	        this.callbacks.push(fn);
	    };
	    SyncHook.prototype.call = function () {
	        /* eslint-disable-next-line prefer-rest-params */
	        var argsArr = arguments;
	        this.callbacks.forEach(function (callback) {
	            /* eslint-disable-next-line prefer-spread */
	            callback.apply(void 0, argsArr);
	        });
	    };
	    return SyncHook;
	}());

	var SyncWaterfallHook = /** @class */ (function () {
	    function SyncWaterfallHook() {
	        this.callbacks = [];
	    }
	    SyncWaterfallHook.prototype.tap = function (options, fn) {
	        this.callbacks.push(fn);
	    };
	    SyncWaterfallHook.prototype.call = function () {
	        if (this.callbacks.length) {
	            /* eslint-disable-next-line prefer-rest-params */
	            var argsArr = arguments;
	            /* eslint-disable-next-line prefer-spread */
	            var result = this.callbacks[0].apply(void 0, argsArr);
	            for (var i = 0; i < this.callbacks.length - 1; i++) {
	                var callback = this.callbacks[i];
	                // @ts-ignore
	                result = callback(result);
	            }
	            return result;
	        }
	        return null;
	    };
	    return SyncWaterfallHook;
	}());

	var genericFontFamilies = [
	    'serif',
	    'sans-serif',
	    'monospace',
	    'cursive',
	    'fantasy',
	    'system-ui',
	];
	var stringRegExp = /([\"\'])[^\'\"]+\1/;
	function toFontString(attributes) {
	    var fontSize = attributes.fontSize, fontFamily = attributes.fontFamily, fontStyle = attributes.fontStyle, fontVariant = attributes.fontVariant, fontWeight = attributes.fontWeight;
	    // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
	    // const fontSizeString: string = isNumber(fontSize) ? `${fontSize}px` : fontSize.toString();
	    var fontSizeString = (isNumber(fontSize) && "".concat(fontSize, "px")) || '16px';
	    // Clean-up fontFamily property by quoting each font name
	    // this will support font names with spaces
	    var fontFamilies = fontFamily.split(',');
	    for (var i = fontFamilies.length - 1; i >= 0; i--) {
	        // Trim any extra white-space
	        var fontFamily_1 = fontFamilies[i].trim();
	        // Check if font already contains strings
	        if (!stringRegExp.test(fontFamily_1) &&
	            genericFontFamilies.indexOf(fontFamily_1) < 0) {
	            fontFamily_1 = "\"".concat(fontFamily_1, "\"");
	        }
	        fontFamilies[i] = fontFamily_1;
	    }
	    return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(','));
	}

	/**
	 * @see /zh/docs/api/animation#支持变换的属性
	 *
	 * support the following formats like CSS Transform:
	 *
	 * scale
	 * * scale(x, y)
	 * * scaleX(x)
	 * * scaleY(x)
	 * * scaleZ(z)
	 * * scale3d(x, y, z)
	 *
	 * translate (unit: none, px, %(relative to its bounds))
	 * * translate(x, y) eg. translate(0, 0) translate(0, 30px) translate(100%, 100%)
	 * * translateX(0)
	 * * translateY(0)
	 * * translateZ(0)
	 * * translate3d(0, 0, 0)
	 *
	 * rotate (unit: deg rad turn)
	 * * rotate(0.5turn) rotate(30deg) rotate(1rad)
	 *
	 * none
	 *
	 * unsupported for now:
	 * * calc() eg. translate(calc(100% + 10px))
	 * * matrix/matrix3d()
	 * * skew/skewX/skewY
	 * * perspective
	 */
	var CSSPropertyTransform = /** @class */ (function () {
	    function CSSPropertyTransform() {
	        this.parser = parseTransform;
	        this.parserWithCSSDisabled = parseTransform;
	        this.mixer = mergeTransforms;
	    }
	    CSSPropertyTransform.prototype.calculator = function (name, oldParsed, parsed, object) {
	        // 'none'
	        if (parsed instanceof CSSKeywordValue) {
	            return [];
	        }
	        return parsed;
	    };
	    CSSPropertyTransform.prototype.postProcessor = function (object) {
	        var transform = object.parsedStyle.transform;
	        parsedTransformToMat4(transform, object);
	    };
	    return CSSPropertyTransform;
	}());

	/**
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin
	 * @example
	 * [10px, 10px] [10%, 10%]
	 */
	var CSSPropertyTransformOrigin = /** @class */ (function () {
	    function CSSPropertyTransformOrigin() {
	        this.parser = parseTransformOrigin;
	        // calculator(
	        //   name: string,
	        //   oldParsed: [CSSUnitValue, CSSUnitValue],
	        //   parsed: [CSSUnitValue, CSSUnitValue],
	        //   object: DisplayObject,
	        // ): [number, number] {
	        //   console.log(object, parsed);
	        //   return [parsed[0].value, parsed[1].value];
	        //   // return [convertPercentUnit(parsed[0], 0, object), convertPercentUnit(parsed[1], 1, object)];
	        // }
	    }
	    return CSSPropertyTransformOrigin;
	}());

	var CSSPropertyZIndex = /** @class */ (function () {
	    function CSSPropertyZIndex() {
	        this.parser = parseNumber;
	    }
	    CSSPropertyZIndex.prototype.calculator = function (name, oldParsed, computed, object) {
	        return computed.value;
	    };
	    CSSPropertyZIndex.prototype.postProcessor = function (object) {
	        if (object.parentNode) {
	            var parentEntity = object.parentNode;
	            var parentRenderable = parentEntity.renderable;
	            var parentSortable = parentEntity.sortable;
	            if (parentRenderable) {
	                parentRenderable.dirty = true;
	            }
	            // need re-sort on parent
	            if (parentSortable) {
	                parentSortable.dirty = true;
	                parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
	            }
	        }
	    };
	    return CSSPropertyZIndex;
	}());

	var CircleUpdater = /** @class */ (function () {
	    function CircleUpdater() {
	    }
	    CircleUpdater.prototype.update = function (parsedStyle, object) {
	        var r = parsedStyle.r;
	        var width = r * 2;
	        var height = r * 2;
	        return {
	            width: width,
	            height: height,
	        };
	    };
	    return CircleUpdater;
	}());

	var EllipseUpdater = /** @class */ (function () {
	    function EllipseUpdater() {
	    }
	    EllipseUpdater.prototype.update = function (parsedStyle, object) {
	        var rx = parsedStyle.rx, ry = parsedStyle.ry;
	        var width = rx * 2;
	        var height = ry * 2;
	        return {
	            width: width,
	            height: height,
	        };
	    };
	    return EllipseUpdater;
	}());

	var LineUpdater = /** @class */ (function () {
	    function LineUpdater() {
	    }
	    LineUpdater.prototype.update = function (parsedStyle) {
	        var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2;
	        var minX = Math.min(x1, x2);
	        var maxX = Math.max(x1, x2);
	        var minY = Math.min(y1, y2);
	        var maxY = Math.max(y1, y2);
	        var width = maxX - minX;
	        var height = maxY - minY;
	        return {
	            width: width,
	            height: height,
	        };
	    };
	    return LineUpdater;
	}());

	var PathUpdater = /** @class */ (function () {
	    function PathUpdater() {
	    }
	    PathUpdater.prototype.update = function (parsedStyle) {
	        var path = parsedStyle.path;
	        var _a = path.rect, width = _a.width, height = _a.height;
	        return {
	            width: width,
	            height: height,
	        };
	    };
	    return PathUpdater;
	}());

	var PolylineUpdater = /** @class */ (function () {
	    function PolylineUpdater() {
	    }
	    PolylineUpdater.prototype.update = function (parsedStyle) {
	        var points = parsedStyle.points.points;
	        // FIXME: account for miter lineJoin
	        var minX = Math.min.apply(Math, __spreadArray([], __read(points.map(function (point) { return point[0]; })), false));
	        var maxX = Math.max.apply(Math, __spreadArray([], __read(points.map(function (point) { return point[0]; })), false));
	        var minY = Math.min.apply(Math, __spreadArray([], __read(points.map(function (point) { return point[1]; })), false));
	        var maxY = Math.max.apply(Math, __spreadArray([], __read(points.map(function (point) { return point[1]; })), false));
	        var width = maxX - minX;
	        var height = maxY - minY;
	        return {
	            width: width,
	            height: height,
	        };
	    };
	    return PolylineUpdater;
	}());

	var RectUpdater = /** @class */ (function () {
	    function RectUpdater() {
	    }
	    RectUpdater.prototype.update = function (parsedStyle, object) {
	        var img = parsedStyle.img, _a = parsedStyle.width, width = _a === void 0 ? 0 : _a, _b = parsedStyle.height, height = _b === void 0 ? 0 : _b;
	        var contentWidth = width;
	        var contentHeight = height;
	        // resize with HTMLImageElement's size
	        if (img && !isString(img)) {
	            if (!contentWidth) {
	                contentWidth = img.width;
	                parsedStyle.width = contentWidth;
	            }
	            if (!contentHeight) {
	                contentHeight = img.height;
	                parsedStyle.height = contentHeight;
	            }
	        }
	        return {
	            width: contentWidth,
	            height: contentHeight,
	        };
	    };
	    return RectUpdater;
	}());

	var TextUpdater = /** @class */ (function () {
	    function TextUpdater(globalRuntime) {
	        this.globalRuntime = globalRuntime;
	    }
	    TextUpdater.prototype.isReadyToMeasure = function (parsedStyle, object) {
	        var text = parsedStyle.text, textAlign = parsedStyle.textAlign, textBaseline = parsedStyle.textBaseline, fontSize = parsedStyle.fontSize, fontStyle = parsedStyle.fontStyle, fontWeight = parsedStyle.fontWeight, fontVariant = parsedStyle.fontVariant, lineWidth = parsedStyle.lineWidth;
	        return (text &&
	            fontSize &&
	            fontStyle &&
	            fontWeight &&
	            fontVariant &&
	            textAlign &&
	            textBaseline &&
	            !isNil(lineWidth));
	    };
	    TextUpdater.prototype.update = function (parsedStyle, object) {
	        var _a, _b;
	        var text = parsedStyle.text, textAlign = parsedStyle.textAlign, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, dx = parsedStyle.dx, dy = parsedStyle.dy;
	        var offscreenCanvas = (((_b = (_a = object === null || object === void 0 ? void 0 : object.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getConfig()) || {}).offscreenCanvas;
	        if (!this.isReadyToMeasure(parsedStyle, object)) {
	            parsedStyle.metrics = {
	                font: '',
	                width: 0,
	                height: 0,
	                lines: [],
	                lineWidths: [],
	                lineHeight: 0,
	                maxLineWidth: 0,
	                fontProperties: {
	                    ascent: 0,
	                    descent: 0,
	                    fontSize: 0,
	                },
	                lineMetrics: [],
	            };
	            return {
	                width: 0,
	                height: 0,
	                x: 0,
	                y: 0,
	                offsetX: 0,
	                offsetY: 0,
	            };
	        }
	        var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
	        parsedStyle.metrics = metrics;
	        var width = metrics.width, height = metrics.height, lineHeight = metrics.lineHeight, fontProperties = metrics.fontProperties;
	        // anchor is left-top by default
	        var halfExtents = [width / 2, height / 2, 0];
	        // default 'left'
	        var anchor = [0, 1];
	        var lineXOffset = 0;
	        if (textAlign === 'center' || textAlign === 'middle') {
	            lineXOffset = lineWidth / 2;
	            anchor = [0.5, 1];
	        }
	        else if (textAlign === 'right' || textAlign === 'end') {
	            lineXOffset = lineWidth;
	            anchor = [1, 1];
	        }
	        var lineYOffset = 0;
	        if (textBaseline === 'middle') {
	            // eslint-disable-next-line prefer-destructuring
	            lineYOffset = halfExtents[1];
	        }
	        else if (textBaseline === 'top' || textBaseline === 'hanging') {
	            lineYOffset = halfExtents[1] * 2;
	        }
	        else if (textBaseline === 'alphabetic') {
	            // prevent calling getImageData for ascent metrics
	            lineYOffset = this.globalRuntime.enableCSSParsing
	                ? lineHeight - fontProperties.ascent
	                : 0;
	        }
	        else if (textBaseline === 'bottom' || textBaseline === 'ideographic') {
	            lineYOffset = 0;
	        }
	        // TODO: ideographic & bottom
	        if (dx) {
	            lineXOffset += dx;
	        }
	        if (dy) {
	            lineYOffset += dy;
	        }
	        // update anchor
	        parsedStyle.anchor = [anchor[0], anchor[1], 0];
	        return {
	            width: halfExtents[0] * 2,
	            height: halfExtents[1] * 2,
	            offsetX: lineXOffset,
	            offsetY: lineYOffset,
	        };
	    };
	    return TextUpdater;
	}());

	function isFederatedEvent(value) {
	    return !!value.type;
	}
	/**
	 * An DOM-compatible synthetic event implementation that is "forwarded" on behalf of an original
	 * FederatedEvent or native Event.
	 */
	var FederatedEvent = /** @class */ (function () {
	    /**
	     * The event boundary which manages this event. Propagation can only occur
	     *  within the boundary's jurisdiction.
	     */
	    function FederatedEvent(manager) {
	        /**
	         * The propagation phase.
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase
	         */
	        this.eventPhase = FederatedEvent.prototype.NONE;
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/bubbles
	         */
	        this.bubbles = true;
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/cancelBubble
	         */
	        this.cancelBubble = true;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/cancelable
	         */
	        this.cancelable = false;
	        /** Flags whether the default response of the user agent was prevent through this event. */
	        this.defaultPrevented = false;
	        /** Flags whether propagation was stopped. */
	        this.propagationStopped = false;
	        /** Flags whether propagation was immediately stopped. */
	        this.propagationImmediatelyStopped = false;
	        /**
	         * The coordinates of the evnet relative to the nearest DOM layer.
	         * This is a non-standard property.
	         */
	        this.layer = new Point();
	        /**
	         * The coordinates of the event relative to the DOM document.
	         * This is a non-standard property.
	         * relative to the DOM document.
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX
	         */
	        this.page = new Point();
	        /**
	         * relative to Canvas, origin is left-top
	         */
	        this.canvas = new Point();
	        /**
	         * relative to Viewport, account for Camera
	         */
	        this.viewport = new Point();
	        this.composed = false;
	        this.NONE = 0;
	        this.CAPTURING_PHASE = 1;
	        this.AT_TARGET = 2;
	        this.BUBBLING_PHASE = 3;
	        this.manager = manager;
	    }
	    Object.defineProperty(FederatedEvent.prototype, "name", {
	        /**
	         * @deprecated
	         */
	        get: function () {
	            return this.type;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "layerX", {
	        get: function () {
	            return this.layer.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "layerY", {
	        get: function () {
	            return this.layer.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "pageX", {
	        get: function () {
	            return this.page.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "pageY", {
	        get: function () {
	            return this.page.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "x", {
	        get: function () {
	            return this.canvas.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "y", {
	        get: function () {
	            return this.canvas.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "canvasX", {
	        get: function () {
	            return this.canvas.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "canvasY", {
	        get: function () {
	            return this.canvas.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "viewportX", {
	        get: function () {
	            return this.viewport.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedEvent.prototype, "viewportY", {
	        get: function () {
	            return this.viewport.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * The propagation path for this event
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
	     *
	     * So composedPath()[0] represents the original target.
	     * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
	     */
	    FederatedEvent.prototype.composedPath = function () {
	        if (this.manager && (!this.path || this.path[0] !== this.target)) {
	            this.path = this.target ? this.manager.propagationPath(this.target) : [];
	        }
	        return this.path;
	    };
	    Object.defineProperty(FederatedEvent.prototype, "propagationPath", {
	        /**
	         * @deprecated
	         */
	        get: function () {
	            return this.composedPath();
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
	     */
	    FederatedEvent.prototype.preventDefault = function () {
	        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
	            this.nativeEvent.preventDefault();
	        }
	        this.defaultPrevented = true;
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
	     */
	    FederatedEvent.prototype.stopImmediatePropagation = function () {
	        this.propagationImmediatelyStopped = true;
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
	     */
	    FederatedEvent.prototype.stopPropagation = function () {
	        this.propagationStopped = true;
	    };
	    /**
	     * added for compatibility with DOM Event,
	     * deprecated props and methods
	     */
	    FederatedEvent.prototype.initEvent = function () { };
	    FederatedEvent.prototype.initUIEvent = function () { };
	    FederatedEvent.prototype.clone = function () {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    return FederatedEvent;
	}());

	var FederatedMouseEvent = /** @class */ (function (_super) {
	    __extends(FederatedMouseEvent, _super);
	    function FederatedMouseEvent() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The coordinates of the mouse event relative to the canvas.
	         */
	        _this.client = new Point();
	        /**
	         * The movement in this pointer relative to the last `mousemove` event.
	         */
	        _this.movement = new Point();
	        /**
	         * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is
	         * not supported at the moment.
	         */
	        _this.offset = new Point();
	        /**
	         * The pointer coordinates in world space.
	         */
	        _this.global = new Point();
	        /**
	         * The pointer coordinates in sceen space.
	         */
	        _this.screen = new Point();
	        return _this;
	    }
	    Object.defineProperty(FederatedMouseEvent.prototype, "clientX", {
	        get: function () {
	            return this.client.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "clientY", {
	        get: function () {
	            return this.client.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "movementX", {
	        get: function () {
	            return this.movement.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "movementY", {
	        get: function () {
	            return this.movement.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "offsetX", {
	        get: function () {
	            return this.offset.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "offsetY", {
	        get: function () {
	            return this.offset.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "globalX", {
	        get: function () {
	            return this.global.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "globalY", {
	        get: function () {
	            return this.global.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "screenX", {
	        get: function () {
	            return this.screen.x;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FederatedMouseEvent.prototype, "screenY", {
	        get: function () {
	            return this.screen.y;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    FederatedMouseEvent.prototype.getModifierState = function (key) {
	        return ('getModifierState' in this.nativeEvent &&
	            this.nativeEvent.getModifierState(key));
	    };
	    FederatedMouseEvent.prototype.initMouseEvent = function () {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    return FederatedMouseEvent;
	}(FederatedEvent));

	// @ts-ignore
	var FederatedPointerEvent = /** @class */ (function (_super) {
	    __extends(FederatedPointerEvent, _super);
	    function FederatedPointerEvent() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The width of the pointer's contact along the x-axis, measured in CSS pixels.
	         * radiusX of TouchEvents will be represented by this value.
	         *
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
	         */
	        _this.width = 0;
	        /**
	         * The height of the pointer's contact along the y-axis, measured in CSS pixels.
	         * radiusY of TouchEvents will be represented by this value.
	         *
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
	         */
	        _this.height = 0;
	        /**
	         * Indicates whether or not the pointer device that created the event is the primary pointer.
	         *
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
	         */
	        _this.isPrimary = false;
	        return _this;
	    }
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
	     */
	    FederatedPointerEvent.prototype.getCoalescedEvents = function () {
	        if (this.type === 'pointermove' ||
	            this.type === 'mousemove' ||
	            this.type === 'touchmove') {
	            // @ts-ignore
	            return [this];
	        }
	        return [];
	    };
	    /**
	     * @see https://chromestatus.com/feature/5765569655603200
	     */
	    FederatedPointerEvent.prototype.getPredictedEvents = function () {
	        throw new Error('getPredictedEvents is not supported!');
	    };
	    /**
	     * @see https://github.com/antvis/G/issues/1115
	     * We currently reuses event objects in the event system,
	     * avoiding the creation of a large number of event objects.
	     * Reused objects are only used to carry different data,
	     * such as coordinate information, native event objects,
	     * and therefore the lifecycle is limited to the event handler,
	     * which can lead to unintended consequences if an attempt is made to cache the entire event object.
	     *
	     * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
	     */
	    FederatedPointerEvent.prototype.clone = function () {
	        return this.manager.clonePointerEvent(this);
	    };
	    return FederatedPointerEvent;
	}(FederatedMouseEvent));

	// @ts-ignore
	var FederatedWheelEvent = /** @class */ (function (_super) {
	    __extends(FederatedWheelEvent, _super);
	    function FederatedWheelEvent() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    FederatedWheelEvent.prototype.clone = function () {
	        return this.manager.cloneWheelEvent(this);
	    };
	    return FederatedWheelEvent;
	}(FederatedMouseEvent));

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events
	 *
	 * @example
	  const event = new CustomEvent('build', { detail: { prop1: 'xx' } });
	  circle.addEventListener('build', (e) => {
	    e.target; // circle
	    e.detail; // { prop1: 'xx' }
	  });

	  circle.dispatchEvent(event);
	 */
	var CustomEvent = /** @class */ (function (_super) {
	    __extends(CustomEvent, _super);
	    // eslint-disable-next-line @typescript-eslint/ban-types
	    function CustomEvent(eventName, object) {
	        var _this = _super.call(this, null) || this;
	        _this.type = eventName;
	        _this.detail = object;
	        // compatible with G 3.0
	        Object.assign(_this, object);
	        return _this;
	    }
	    return CustomEvent;
	}(FederatedEvent));

	var DELEGATION_SPLITTER = ':';
	/**
	 * Objects that can receive events and may have listeners for them.
	 * eg. Element, Canvas, DisplayObject
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
	 */
	var EventTarget = /** @class */ (function () {
	    function EventTarget() {
	        /**
	         * event emitter
	         */
	        this.emitter = new eventemitter3();
	    }
	    /**
	     * @deprecated
	     * @alias addEventListener
	     */
	    EventTarget.prototype.on = function (type, listener, options) {
	        this.addEventListener(type, listener, options);
	        return this;
	    };
	    /**
	     * support `capture` & `once` in options
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
	     */
	    EventTarget.prototype.addEventListener = function (type, listener, options) {
	        var capture = (isBoolean(options) && options) || (isObject(options) && options.capture);
	        var once = isObject(options) && options.once;
	        var context = isFunction$1(listener) ? undefined : listener;
	        // compatible with G 3.0
	        // support using delegate name in event type, eg. 'node:click'
	        var useDelegatedName = false;
	        var delegatedName = '';
	        if (type.indexOf(DELEGATION_SPLITTER) > -1) {
	            var _a = __read(type.split(DELEGATION_SPLITTER), 2), name_1 = _a[0], eventType = _a[1];
	            type = eventType;
	            delegatedName = name_1;
	            useDelegatedName = true;
	        }
	        type = capture ? "".concat(type, "capture") : type;
	        listener = isFunction$1(listener) ? listener : listener.handleEvent;
	        // compatible with G 3.0
	        if (useDelegatedName) {
	            var originListener_1 = listener;
	            listener = function () {
	                var _a;
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                if (((_a = args[0].target) === null || _a === void 0 ? void 0 : _a.name) !== delegatedName) {
	                    return;
	                }
	                // @ts-ignore
	                originListener_1.apply(void 0, __spreadArray([], __read(args), false));
	            };
	        }
	        if (once) {
	            this.emitter.once(type, listener, context);
	        }
	        else {
	            this.emitter.on(type, listener, context);
	        }
	        return this;
	    };
	    /**
	     * @deprecated
	     * @alias removeEventListener
	     */
	    EventTarget.prototype.off = function (type, listener, options) {
	        if (type) {
	            this.removeEventListener(type, listener, options);
	        }
	        else {
	            // remove all listeners
	            this.removeAllEventListeners();
	        }
	        return this;
	    };
	    EventTarget.prototype.removeAllEventListeners = function () {
	        this.emitter.removeAllListeners();
	    };
	    EventTarget.prototype.removeEventListener = function (type, listener, options) {
	        var capture = (isBoolean(options) && options) || (isObject(options) && options.capture);
	        var context = isFunction$1(listener) ? undefined : listener;
	        type = capture ? "".concat(type, "capture") : type;
	        listener = isFunction$1(listener) ? listener : listener === null || listener === void 0 ? void 0 : listener.handleEvent;
	        this.emitter.off(type, listener, context);
	        return this;
	    };
	    /**
	     * @deprecated
	     * @alias dispatchEvent
	     */
	    // eslint-disable-next-line @typescript-eslint/ban-types
	    EventTarget.prototype.emit = function (eventName, object) {
	        this.dispatchEvent(new CustomEvent(eventName, object));
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
	     */
	    EventTarget.prototype.dispatchEvent = function (e, skipPropagate) {
	        var _a, _b;
	        if (skipPropagate === void 0) { skipPropagate = false; }
	        if (!isFederatedEvent(e)) {
	            throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');
	        }
	        // should account for Element / Document / Canvas
	        var canvas;
	        // @ts-ignore
	        if (this.document) {
	            canvas = this;
	            // @ts-ignore
	        }
	        else if (this.defaultView) {
	            canvas = this.defaultView;
	        }
	        else {
	            canvas = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
	        }
	        // assign event manager
	        if (canvas) {
	            e.manager = canvas.getEventService() || null;
	            if (!e.manager) {
	                return false;
	            }
	            e.defaultPrevented = false;
	            e.path = [];
	            if (!skipPropagate) {
	                e.target = this;
	            }
	            (_b = e.manager) === null || _b === void 0 ? void 0 : _b.dispatchEvent(e, e.type, skipPropagate);
	        }
	        return !e.defaultPrevented;
	    };
	    return EventTarget;
	}());

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Node
	 */
	var Node$1 = /** @class */ (function (_super) {
	    __extends(Node, _super);
	    function Node() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.shadow = false;
	        /**
	         * points to canvas.document
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/ownerDocument
	         */
	        _this.ownerDocument = null;
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isConnected
	         * @example
	            circle.isConnected; // false
	            canvas.appendChild(circle);
	            circle.isConnected; // true
	         */
	        _this.isConnected = false;
	        /**
	         * Returns node's node document's document base URL.
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node
	         */
	        _this.baseURI = '';
	        /**
	         * Returns the children.
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes
	         */
	        _this.childNodes = [];
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType
	         */
	        _this.nodeType = 0;
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName
	         */
	        _this.nodeName = '';
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue
	         */
	        _this.nodeValue = null;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/ParentNode
	         */
	        _this.parentNode = null;
	        return _this;
	    }
	    Node.isNode = function (target) {
	        return !!target.childNodes;
	    };
	    Object.defineProperty(Node.prototype, "textContent", {
	        /**
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
	         */
	        get: function () {
	            var e_1, _a;
	            var out = '';
	            if (this.nodeName === Shape.TEXT) {
	                // @ts-ignore
	                out += this.style.text;
	            }
	            try {
	                for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var child = _c.value;
	                    if (child.nodeName === Shape.TEXT) {
	                        out += child.nodeValue;
	                    }
	                    else {
	                        out += child.textContent;
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return out;
	        },
	        set: function (content) {
	            var _this = this;
	            // remove all children
	            this.childNodes.slice().forEach(function (child) {
	                _this.removeChild(child);
	            });
	            if (this.nodeName === Shape.TEXT) {
	                // @ts-ignore
	                this.style.text = "".concat(content);
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
	     */
	    Node.prototype.getRootNode = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        if (this.parentNode) {
	            return this.parentNode.getRootNode(opts);
	        }
	        if (opts.composed && this.host) {
	            return this.host.getRootNode(opts);
	        }
	        return this;
	    };
	    Node.prototype.hasChildNodes = function () {
	        return this.childNodes.length > 0;
	    };
	    Node.prototype.isDefaultNamespace = function (namespace) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Node.prototype.lookupNamespaceURI = function (prefix) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Node.prototype.lookupPrefix = function (namespace) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Node.prototype.normalize = function () {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
	     */
	    Node.prototype.isEqualNode = function (otherNode) {
	        // TODO: compare 2 nodes, not sameness
	        return this === otherNode;
	    };
	    Node.prototype.isSameNode = function (otherNode) {
	        return this.isEqualNode(otherNode);
	    };
	    Object.defineProperty(Node.prototype, "parent", {
	        /**
	         * @deprecated
	         * @alias parentNode
	         */
	        get: function () {
	            return this.parentNode;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "parentElement", {
	        get: function () {
	            return null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "nextSibling", {
	        get: function () {
	            return null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "previousSibling", {
	        get: function () {
	            return null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "firstChild", {
	        get: function () {
	            return this.childNodes.length > 0 ? this.childNodes[0] : null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "lastChild", {
	        get: function () {
	            return this.childNodes.length > 0
	                ? this.childNodes[this.childNodes.length - 1]
	                : null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
	     * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
	     */
	    Node.prototype.compareDocumentPosition = function (other) {
	        var _a;
	        if (other === this) {
	            // same node
	            return 0;
	        }
	        // if (!(other instanceof Node)) {
	        //   throw new TypeError(
	        //     'Node.compareDocumentPosition: Argument 1 does not implement interface Node.',
	        //   );
	        // }
	        var node1Root = other;
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        var node2Root = this;
	        var node1Hierarchy = [node1Root];
	        var node2Hierarchy = [node2Root];
	        while ((_a = node1Root.parentNode) !== null && _a !== void 0 ? _a : node2Root.parentNode) {
	            node1Root = node1Root.parentNode
	                ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode)
	                : node1Root;
	            node2Root = node2Root.parentNode
	                ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode)
	                : node2Root;
	        }
	        // Check if they don't share the same root node
	        if (node1Root !== node2Root) {
	            return (Node.DOCUMENT_POSITION_DISCONNECTED |
	                Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
	                Node.DOCUMENT_POSITION_PRECEDING);
	        }
	        var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length
	            ? node1Hierarchy
	            : node2Hierarchy;
	        var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
	        // Check if either is a container of the other
	        if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] ===
	            shorterHierarchy[0]) {
	            return longerHierarchy === node1Hierarchy
	                ? // other is a child of this
	                    Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING
	                : // this is a child of other
	                    Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
	        }
	        // Find their first common ancestor and see whether they
	        // are preceding or following
	        var longerStart = longerHierarchy.length - shorterHierarchy.length;
	        for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
	            var shorterHierarchyNode = shorterHierarchy[i];
	            var longerHierarchyNode = longerHierarchy[longerStart + i];
	            // We found the first common ancestor
	            if (longerHierarchyNode !== shorterHierarchyNode) {
	                var siblings = shorterHierarchyNode.parentNode.childNodes;
	                if (siblings.indexOf(shorterHierarchyNode) <
	                    siblings.indexOf(longerHierarchyNode)) {
	                    // Shorter is before longer
	                    if (shorterHierarchy === node1Hierarchy) {
	                        // Other is before this
	                        return Node.DOCUMENT_POSITION_PRECEDING;
	                    }
	                    else {
	                        // This is before other
	                        return Node.DOCUMENT_POSITION_FOLLOWING;
	                    }
	                }
	                else {
	                    // Longer is before shorter
	                    if (longerHierarchy === node1Hierarchy) {
	                        // Other is before this
	                        return Node.DOCUMENT_POSITION_PRECEDING;
	                    }
	                    else {
	                        // Other is after this
	                        return Node.DOCUMENT_POSITION_FOLLOWING;
	                    }
	                }
	            }
	        }
	        return Node.DOCUMENT_POSITION_FOLLOWING;
	    };
	    /**
	     * @deprecated
	     * @alias contains
	     */
	    Node.prototype.contain = function (other) {
	        return this.contains(other);
	    };
	    Node.prototype.contains = function (other) {
	        // the node itself, one of its direct children
	        var tmp = other;
	        // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/contains
	        while (tmp && this !== tmp) {
	            tmp = tmp.parentNode;
	        }
	        return !!tmp;
	    };
	    Node.prototype.getAncestor = function (n) {
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        var temp = this;
	        while (n > 0 && temp) {
	            temp = temp.parentNode;
	            n--;
	        }
	        return temp;
	    };
	    Node.prototype.forEach = function (callback, assigned) {
	        if (assigned === void 0) { assigned = false; }
	        if (!callback(this)) {
	            (assigned ? this.childNodes.slice() : this.childNodes).forEach(function (child) {
	                child.forEach(callback);
	            });
	        }
	    };
	    /**
	     * Both nodes are in different documents or different trees in the same document.
	     */
	    Node.DOCUMENT_POSITION_DISCONNECTED = 1;
	    /**
	     * otherNode precedes the node in either a pre-order depth-first traversal
	     * of a tree containing both (e.g., as an ancestor or previous sibling or a descendant of a previous sibling or previous sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.
	     */
	    Node.DOCUMENT_POSITION_PRECEDING = 2;
	    /**
	     * otherNode follows the node in either a pre-order depth-first traversal of a tree containing both (e.g., as a descendant or following sibling or a descendant of a following sibling or following sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.
	     */
	    Node.DOCUMENT_POSITION_FOLLOWING = 4;
	    /**
	     * otherNode is an ancestor of the node.
	     */
	    Node.DOCUMENT_POSITION_CONTAINS = 8;
	    /**
	     * otherNode is a descendant of the node.
	     */
	    Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
	    /**
	     * The result relies upon arbitrary and/or implementation-specific behavior and is not guaranteed to be portable.
	     */
	    Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
	    return Node;
	}(EventTarget));

	var PROPAGATION_LIMIT = 2048;
	var EventService = /** @class */ (function () {
	    function EventService(globalRuntime, context) {
	        var _this = this;
	        this.globalRuntime = globalRuntime;
	        this.context = context;
	        this.emitter = new eventemitter3();
	        this.cursor = 'default';
	        this.mappingTable = {};
	        this.mappingState = {
	            trackingData: {},
	        };
	        this.eventPool = new Map();
	        this.tmpMatrix = create$1();
	        this.tmpVec3 = create$2();
	        this.onPointerDown = function (from) {
	            var e = _this.createPointerEvent(from);
	            _this.dispatchEvent(e, 'pointerdown');
	            if (e.pointerType === 'touch') {
	                _this.dispatchEvent(e, 'touchstart');
	            }
	            else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
	                var isRightButton = e.button === 2;
	                _this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');
	            }
	            var trackingData = _this.trackingData(from.pointerId);
	            trackingData.pressTargetsByButton[from.button] = e.composedPath();
	            _this.freeEvent(e);
	        };
	        this.onPointerUp = function (from) {
	            var _a;
	            var now = performance.now();
	            var e = _this.createPointerEvent(from, undefined, undefined, _this.context.config.alwaysTriggerPointerEventOnCanvas
	                ? _this.rootTarget
	                : undefined);
	            _this.dispatchEvent(e, 'pointerup');
	            if (e.pointerType === 'touch') {
	                _this.dispatchEvent(e, 'touchend');
	            }
	            else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
	                var isRightButton = e.button === 2;
	                _this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');
	            }
	            var trackingData = _this.trackingData(from.pointerId);
	            var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
	            var clickTarget = pressTarget;
	            // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain
	            // the pointerup location.
	            if (pressTarget && !e.composedPath().includes(pressTarget)) {
	                var currentTarget = pressTarget;
	                while (currentTarget && !e.composedPath().includes(currentTarget)) {
	                    e.currentTarget = currentTarget;
	                    _this.notifyTarget(e, 'pointerupoutside');
	                    if (e.pointerType === 'touch') {
	                        _this.notifyTarget(e, 'touchendoutside');
	                    }
	                    else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
	                        var isRightButton = e.button === 2;
	                        _this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');
	                    }
	                    if (Node$1.isNode(currentTarget)) {
	                        currentTarget = currentTarget.parentNode;
	                    }
	                }
	                delete trackingData.pressTargetsByButton[from.button];
	                // currentTarget is the most specific ancestor holding both the pointerdown and pointerup
	                // targets. That is - it's our click target!
	                clickTarget = currentTarget;
	            }
	            if (clickTarget) {
	                var clickEvent = _this.clonePointerEvent(e, 'click');
	                clickEvent.target = clickTarget;
	                clickEvent.path = [];
	                if (!trackingData.clicksByButton[from.button]) {
	                    trackingData.clicksByButton[from.button] = {
	                        clickCount: 0,
	                        target: clickEvent.target,
	                        timeStamp: now,
	                    };
	                }
	                var clickHistory = trackingData.clicksByButton[from.button];
	                if (clickHistory.target === clickEvent.target &&
	                    now - clickHistory.timeStamp < 200) {
	                    ++clickHistory.clickCount;
	                }
	                else {
	                    clickHistory.clickCount = 1;
	                }
	                clickHistory.target = clickEvent.target;
	                clickHistory.timeStamp = now;
	                clickEvent.detail = clickHistory.clickCount;
	                // @see https://github.com/antvis/G/issues/1091
	                if (!((_a = e.detail) === null || _a === void 0 ? void 0 : _a.preventClick)) {
	                    if (!_this.context.config.useNativeClickEvent &&
	                        (clickEvent.pointerType === 'mouse' ||
	                            clickEvent.pointerType === 'touch')) {
	                        _this.dispatchEvent(clickEvent, 'click');
	                    }
	                    _this.dispatchEvent(clickEvent, 'pointertap');
	                }
	                _this.freeEvent(clickEvent);
	            }
	            _this.freeEvent(e);
	        };
	        this.onPointerMove = function (from) {
	            var e = _this.createPointerEvent(from, undefined, undefined, _this.context.config.alwaysTriggerPointerEventOnCanvas
	                ? _this.rootTarget
	                : undefined);
	            var isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
	            var trackingData = _this.trackingData(from.pointerId);
	            var outTarget = _this.findMountedTarget(trackingData.overTargets);
	            // First pointerout/pointerleave
	            if (trackingData.overTargets && outTarget !== e.target) {
	                // pointerout always occurs on the overTarget when the pointer hovers over another element.
	                var outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';
	                var outEvent = _this.createPointerEvent(from, outType, outTarget || undefined);
	                _this.dispatchEvent(outEvent, 'pointerout');
	                if (isMouse)
	                    _this.dispatchEvent(outEvent, 'mouseout');
	                // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event
	                // is dispatched to all ancestors that no longer capture the pointer.
	                if (!e.composedPath().includes(outTarget)) {
	                    var leaveEvent = _this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
	                    leaveEvent.eventPhase = leaveEvent.AT_TARGET;
	                    while (leaveEvent.target &&
	                        !e.composedPath().includes(leaveEvent.target)) {
	                        leaveEvent.currentTarget = leaveEvent.target;
	                        _this.notifyTarget(leaveEvent);
	                        if (isMouse) {
	                            _this.notifyTarget(leaveEvent, 'mouseleave');
	                        }
	                        if (Node$1.isNode(leaveEvent.target)) {
	                            leaveEvent.target = leaveEvent.target.parentNode;
	                        }
	                    }
	                    _this.freeEvent(leaveEvent);
	                }
	                _this.freeEvent(outEvent);
	            }
	            // Then pointerover
	            if (outTarget !== e.target) {
	                // pointerover always occurs on the new overTarget
	                var overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';
	                var overEvent = _this.clonePointerEvent(e, overType); // clone faster
	                _this.dispatchEvent(overEvent, 'pointerover');
	                if (isMouse)
	                    _this.dispatchEvent(overEvent, 'mouseover');
	                // Probe whether the newly hovered Node is an ancestor of the original overTarget.
	                var overTargetAncestor = outTarget && Node$1.isNode(outTarget) && outTarget.parentNode;
	                while (overTargetAncestor &&
	                    overTargetAncestor !==
	                        (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
	                    if (overTargetAncestor === e.target)
	                        break;
	                    overTargetAncestor = overTargetAncestor.parentNode;
	                }
	                // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered
	                // event.
	                var didPointerEnter = !overTargetAncestor ||
	                    overTargetAncestor ===
	                        (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode);
	                if (didPointerEnter) {
	                    var enterEvent = _this.clonePointerEvent(e, 'pointerenter');
	                    enterEvent.eventPhase = enterEvent.AT_TARGET;
	                    while (enterEvent.target &&
	                        enterEvent.target !== outTarget &&
	                        enterEvent.target !==
	                            (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
	                        enterEvent.currentTarget = enterEvent.target;
	                        _this.notifyTarget(enterEvent);
	                        if (isMouse)
	                            _this.notifyTarget(enterEvent, 'mouseenter');
	                        if (Node$1.isNode(enterEvent.target)) {
	                            enterEvent.target = enterEvent.target.parentNode;
	                        }
	                    }
	                    _this.freeEvent(enterEvent);
	                }
	                _this.freeEvent(overEvent);
	            }
	            // Then pointermove
	            _this.dispatchEvent(e, 'pointermove');
	            if (e.pointerType === 'touch')
	                _this.dispatchEvent(e, 'touchmove');
	            if (isMouse) {
	                _this.dispatchEvent(e, 'mousemove');
	                _this.cursor = _this.getCursor(e.target);
	            }
	            trackingData.overTargets = e.composedPath();
	            _this.freeEvent(e);
	        };
	        this.onPointerOut = function (from) {
	            var trackingData = _this.trackingData(from.pointerId);
	            if (trackingData.overTargets) {
	                var isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';
	                var outTarget = _this.findMountedTarget(trackingData.overTargets);
	                // pointerout first
	                var outEvent = _this.createPointerEvent(from, 'pointerout', outTarget || undefined);
	                _this.dispatchEvent(outEvent);
	                if (isMouse)
	                    _this.dispatchEvent(outEvent, 'mouseout');
	                // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to
	                // get an upstream pointerout event (upstream events do not know rootTarget has descendants).
	                var leaveEvent = _this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
	                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
	                while (leaveEvent.target &&
	                    leaveEvent.target !==
	                        (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
	                    leaveEvent.currentTarget = leaveEvent.target;
	                    _this.notifyTarget(leaveEvent);
	                    if (isMouse) {
	                        _this.notifyTarget(leaveEvent, 'mouseleave');
	                    }
	                    if (Node$1.isNode(leaveEvent.target)) {
	                        leaveEvent.target = leaveEvent.target.parentNode;
	                    }
	                }
	                trackingData.overTargets = null;
	                _this.freeEvent(outEvent);
	                _this.freeEvent(leaveEvent);
	            }
	            _this.cursor = null;
	        };
	        this.onPointerOver = function (from) {
	            var trackingData = _this.trackingData(from.pointerId);
	            var e = _this.createPointerEvent(from);
	            var isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
	            _this.dispatchEvent(e, 'pointerover');
	            if (isMouse)
	                _this.dispatchEvent(e, 'mouseover');
	            if (e.pointerType === 'mouse')
	                _this.cursor = _this.getCursor(e.target);
	            // pointerenter events must be fired since the pointer entered from upstream.
	            var enterEvent = _this.clonePointerEvent(e, 'pointerenter');
	            enterEvent.eventPhase = enterEvent.AT_TARGET;
	            while (enterEvent.target &&
	                enterEvent.target !==
	                    (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
	                enterEvent.currentTarget = enterEvent.target;
	                _this.notifyTarget(enterEvent);
	                if (isMouse) {
	                    // mouseenter should not bubble
	                    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event#usage_notes
	                    _this.notifyTarget(enterEvent, 'mouseenter');
	                }
	                if (Node$1.isNode(enterEvent.target)) {
	                    enterEvent.target = enterEvent.target.parentNode;
	                }
	            }
	            trackingData.overTargets = e.composedPath();
	            _this.freeEvent(e);
	            _this.freeEvent(enterEvent);
	        };
	        this.onPointerUpOutside = function (from) {
	            var trackingData = _this.trackingData(from.pointerId);
	            var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
	            var e = _this.createPointerEvent(from);
	            if (pressTarget) {
	                var currentTarget = pressTarget;
	                while (currentTarget) {
	                    e.currentTarget = currentTarget;
	                    _this.notifyTarget(e, 'pointerupoutside');
	                    if (e.pointerType === 'touch') ;
	                    else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
	                        _this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');
	                    }
	                    if (Node$1.isNode(currentTarget)) {
	                        currentTarget = currentTarget.parentNode;
	                    }
	                }
	                delete trackingData.pressTargetsByButton[from.button];
	            }
	            _this.freeEvent(e);
	        };
	        this.onWheel = function (from) {
	            var wheelEvent = _this.createWheelEvent(from);
	            _this.dispatchEvent(wheelEvent);
	            _this.freeEvent(wheelEvent);
	        };
	        this.onClick = function (from) {
	            if (_this.context.config.useNativeClickEvent) {
	                var e = _this.createPointerEvent(from);
	                _this.dispatchEvent(e);
	                _this.freeEvent(e);
	            }
	        };
	        this.onPointerCancel = function (from) {
	            var e = _this.createPointerEvent(from, undefined, undefined, _this.context.config.alwaysTriggerPointerEventOnCanvas
	                ? _this.rootTarget
	                : undefined);
	            _this.dispatchEvent(e);
	            _this.freeEvent(e);
	        };
	    }
	    EventService.prototype.init = function () {
	        this.rootTarget = this.context.renderingContext.root.parentNode; // document
	        this.addEventMapping('pointerdown', this.onPointerDown);
	        this.addEventMapping('pointerup', this.onPointerUp);
	        this.addEventMapping('pointermove', this.onPointerMove);
	        this.addEventMapping('pointerout', this.onPointerOut);
	        this.addEventMapping('pointerleave', this.onPointerOut);
	        this.addEventMapping('pointercancel', this.onPointerCancel);
	        this.addEventMapping('pointerover', this.onPointerOver);
	        this.addEventMapping('pointerupoutside', this.onPointerUpOutside);
	        this.addEventMapping('wheel', this.onWheel);
	        this.addEventMapping('click', this.onClick);
	    };
	    EventService.prototype.destroy = function () {
	        this.emitter.removeAllListeners();
	        this.mappingTable = {};
	        this.mappingState = {};
	        this.eventPool.clear();
	    };
	    EventService.prototype.client2Viewport = function (client) {
	        var bbox = this.context.contextService.getBoundingClientRect();
	        return new Point(client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
	    };
	    EventService.prototype.viewport2Client = function (canvas) {
	        var bbox = this.context.contextService.getBoundingClientRect();
	        return new Point(canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
	    };
	    EventService.prototype.viewport2Canvas = function (_a) {
	        var x = _a.x, y = _a.y;
	        var canvas = this.rootTarget.defaultView;
	        var camera = canvas.getCamera();
	        var _b = this.context.config, width = _b.width, height = _b.height;
	        var projectionMatrixInverse = camera.getPerspectiveInverse();
	        var worldMatrix = camera.getWorldTransform();
	        var vpMatrix = multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
	        var viewport = set$1(this.tmpVec3, (x / width) * 2 - 1, (1 - y / height) * 2 - 1, 0);
	        transformMat4(viewport, viewport, vpMatrix);
	        return new Point(viewport[0], viewport[1]);
	    };
	    EventService.prototype.canvas2Viewport = function (canvasP) {
	        var canvas = this.rootTarget.defaultView;
	        var camera = canvas.getCamera();
	        // World -> Clip
	        var projectionMatrix = camera.getPerspective();
	        var viewMatrix = camera.getViewTransform();
	        var vpMatrix = multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
	        var clip = set$1(this.tmpVec3, canvasP.x, canvasP.y, 0);
	        transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
	        // Clip -> NDC -> Viewport, flip Y
	        var _a = this.context.config, width = _a.width, height = _a.height;
	        return new Point(((clip[0] + 1) / 2) * width, (1 - (clip[1] + 1) / 2) * height);
	    };
	    EventService.prototype.setPickHandler = function (pickHandler) {
	        this.pickHandler = pickHandler;
	    };
	    EventService.prototype.addEventMapping = function (type, fn) {
	        if (!this.mappingTable[type]) {
	            this.mappingTable[type] = [];
	        }
	        this.mappingTable[type].push({
	            fn: fn,
	            priority: 0,
	        });
	        this.mappingTable[type].sort(function (a, b) { return a.priority - b.priority; });
	    };
	    EventService.prototype.mapEvent = function (e) {
	        if (!this.rootTarget) {
	            return;
	        }
	        var mappers = this.mappingTable[e.type];
	        if (mappers) {
	            for (var i = 0, j = mappers.length; i < j; i++) {
	                mappers[i].fn(e);
	            }
	        }
	        else {
	            console.warn("[EventService]: Event mapping not defined for ".concat(e.type));
	        }
	    };
	    EventService.prototype.dispatchEvent = function (e, type, skipPropagate) {
	        // Canvas should skip
	        if (!skipPropagate) {
	            e.propagationStopped = false;
	            e.propagationImmediatelyStopped = false;
	            this.propagate(e, type);
	        }
	        else {
	            // target phase
	            e.eventPhase = e.AT_TARGET;
	            var canvas = this.rootTarget.defaultView || null;
	            e.currentTarget = canvas;
	            this.notifyListeners(e, type);
	        }
	        this.emitter.emit(type || e.type, e);
	    };
	    EventService.prototype.propagate = function (e, type) {
	        if (!e.target) {
	            return;
	        }
	        // [target, parent, root, Canvas]
	        var composedPath = e.composedPath();
	        // event flow: capture -> target -> bubbling
	        // capture phase
	        e.eventPhase = e.CAPTURING_PHASE;
	        for (var i = composedPath.length - 1; i >= 1; i--) {
	            e.currentTarget = composedPath[i];
	            this.notifyTarget(e, type);
	            if (e.propagationStopped || e.propagationImmediatelyStopped)
	                return;
	        }
	        // target phase
	        e.eventPhase = e.AT_TARGET;
	        e.currentTarget = e.target;
	        this.notifyTarget(e, type);
	        if (e.propagationStopped || e.propagationImmediatelyStopped)
	            return;
	        // find current target in composed path
	        var index = composedPath.indexOf(e.currentTarget);
	        // bubbling phase
	        e.eventPhase = e.BUBBLING_PHASE;
	        for (var i = index + 1; i < composedPath.length; i++) {
	            e.currentTarget = composedPath[i];
	            this.notifyTarget(e, type);
	            if (e.propagationStopped || e.propagationImmediatelyStopped)
	                return;
	        }
	    };
	    EventService.prototype.propagationPath = function (target) {
	        var propagationPath = [target];
	        var canvas = this.rootTarget.defaultView || null;
	        if (canvas && canvas === target) {
	            propagationPath.unshift(canvas.document);
	            return propagationPath;
	        }
	        for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
	            // if (Node.isNode(target) && !target.parentNode) {
	            //   throw new Error('Cannot find propagation path to disconnected target');
	            // }
	            if (Node$1.isNode(target) && target.parentNode) {
	                // [target, parent, parent, root]
	                propagationPath.push(target.parentNode);
	                target = target.parentNode;
	            }
	        }
	        if (canvas) {
	            // @ts-ignore
	            propagationPath.push(canvas);
	        }
	        return propagationPath;
	    };
	    EventService.prototype.hitTest = function (position) {
	        var viewportX = position.viewportX, viewportY = position.viewportY;
	        var _a = this.context.config, width = _a.width, height = _a.height;
	        // outside canvas
	        if (viewportX < 0 ||
	            viewportY < 0 ||
	            viewportX > width ||
	            viewportY > height) {
	            return null;
	        }
	        return (this.pickHandler(position) ||
	            this.rootTarget || // return Document
	            null);
	    };
	    /**
	     * whether the native event trigger came from Canvas,
	     * should account for HTML shape
	     */
	    EventService.prototype.isNativeEventFromCanvas = function (event) {
	        var _a;
	        var $el = this.context.contextService.getDomElement();
	        var target = (_a = event.nativeEvent) === null || _a === void 0 ? void 0 : _a.target;
	        if (target) {
	            // from <canvas>
	            if (target === $el) {
	                return true;
	            }
	            // from <svg>
	            if ($el && $el.contains) {
	                return $el.contains(target);
	            }
	        }
	        if (event.nativeEvent.composedPath) {
	            return event.nativeEvent.composedPath().indexOf($el) > -1;
	        }
	        // account for Touch
	        return false;
	    };
	    /**
	     * Find HTML from composed path in native UI event.
	     */
	    EventService.prototype.getExistedHTML = function (event) {
	        var e_1, _a;
	        if (event.nativeEvent.composedPath) {
	            try {
	                for (var _b = __values(event.nativeEvent.composedPath()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var eventTarget = _c.value;
	                    var existed = this.globalRuntime.nativeHTMLMap.get(eventTarget);
	                    if (existed) {
	                        return existed;
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        return null;
	    };
	    EventService.prototype.pickTarget = function (event) {
	        return this.hitTest({
	            clientX: event.clientX,
	            clientY: event.clientY,
	            viewportX: event.viewportX,
	            viewportY: event.viewportY,
	            x: event.canvasX,
	            y: event.canvasY,
	        });
	    };
	    EventService.prototype.createPointerEvent = function (from, type, target, fallbackTarget) {
	        var event = this.allocateEvent(FederatedPointerEvent);
	        this.copyPointerData(from, event);
	        this.copyMouseData(from, event);
	        this.copyData(from, event);
	        event.nativeEvent = from.nativeEvent;
	        event.originalEvent = from;
	        var existedHTML = this.getExistedHTML(event);
	        event.target =
	            target !== null && target !== void 0 ? target : (existedHTML ||
	                (this.isNativeEventFromCanvas(event) && this.pickTarget(event)) ||
	                fallbackTarget);
	        if (typeof type === 'string') {
	            event.type = type;
	        }
	        return event;
	    };
	    EventService.prototype.createWheelEvent = function (from) {
	        var event = this.allocateEvent(FederatedWheelEvent);
	        this.copyWheelData(from, event);
	        this.copyMouseData(from, event);
	        this.copyData(from, event);
	        event.nativeEvent = from.nativeEvent;
	        event.originalEvent = from;
	        var existedHTML = this.getExistedHTML(event);
	        event.target =
	            existedHTML ||
	                (this.isNativeEventFromCanvas(event) && this.pickTarget(event));
	        return event;
	    };
	    EventService.prototype.trackingData = function (id) {
	        if (!this.mappingState.trackingData[id]) {
	            this.mappingState.trackingData[id] = {
	                pressTargetsByButton: {},
	                clicksByButton: {},
	                overTarget: null,
	            };
	        }
	        return this.mappingState.trackingData[id];
	    };
	    EventService.prototype.cloneWheelEvent = function (from) {
	        var event = this.allocateEvent(FederatedWheelEvent);
	        event.nativeEvent = from.nativeEvent;
	        event.originalEvent = from.originalEvent;
	        this.copyWheelData(from, event);
	        this.copyMouseData(from, event);
	        this.copyData(from, event);
	        event.target = from.target;
	        event.path = from.composedPath().slice();
	        event.type = from.type;
	        return event;
	    };
	    EventService.prototype.clonePointerEvent = function (from, type) {
	        var event = this.allocateEvent(FederatedPointerEvent);
	        event.nativeEvent = from.nativeEvent;
	        event.originalEvent = from.originalEvent;
	        this.copyPointerData(from, event);
	        this.copyMouseData(from, event);
	        this.copyData(from, event);
	        event.target = from.target;
	        event.path = from.composedPath().slice();
	        event.type = type !== null && type !== void 0 ? type : event.type;
	        return event;
	    };
	    EventService.prototype.copyPointerData = function (from, to) {
	        // if (
	        //   !(
	        //     from instanceof FederatedPointerEvent &&
	        //     to instanceof FederatedPointerEvent
	        //   )
	        // )
	        //   return;
	        to.pointerId = from.pointerId;
	        to.width = from.width;
	        to.height = from.height;
	        to.isPrimary = from.isPrimary;
	        to.pointerType = from.pointerType;
	        to.pressure = from.pressure;
	        to.tangentialPressure = from.tangentialPressure;
	        to.tiltX = from.tiltX;
	        to.tiltY = from.tiltY;
	        to.twist = from.twist;
	    };
	    EventService.prototype.copyMouseData = function (from, to) {
	        // if (
	        //   !(
	        //     from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent
	        //   )
	        // )
	        //   return;
	        to.altKey = from.altKey;
	        to.button = from.button;
	        to.buttons = from.buttons;
	        to.ctrlKey = from.ctrlKey;
	        to.metaKey = from.metaKey;
	        to.shiftKey = from.shiftKey;
	        to.client.copyFrom(from.client);
	        to.movement.copyFrom(from.movement);
	        to.canvas.copyFrom(from.canvas);
	        to.screen.copyFrom(from.screen);
	        to.global.copyFrom(from.global);
	        to.offset.copyFrom(from.offset);
	    };
	    EventService.prototype.copyWheelData = function (from, to) {
	        to.deltaMode = from.deltaMode;
	        to.deltaX = from.deltaX;
	        to.deltaY = from.deltaY;
	        to.deltaZ = from.deltaZ;
	    };
	    EventService.prototype.copyData = function (from, to) {
	        to.isTrusted = from.isTrusted;
	        to.timeStamp = performance.now();
	        to.type = from.type;
	        to.detail = from.detail;
	        to.view = from.view;
	        to.page.copyFrom(from.page);
	        to.viewport.copyFrom(from.viewport);
	    };
	    EventService.prototype.allocateEvent = function (constructor) {
	        if (!this.eventPool.has(constructor)) {
	            this.eventPool.set(constructor, []);
	        }
	        // @ts-ignore
	        var event = this.eventPool.get(constructor).pop() ||
	            new constructor(this);
	        event.eventPhase = event.NONE;
	        event.currentTarget = null;
	        event.path = [];
	        event.target = null;
	        return event;
	    };
	    EventService.prototype.freeEvent = function (event) {
	        if (event.manager !== this)
	            throw new Error('It is illegal to free an event not managed by this EventBoundary!');
	        var constructor = event.constructor;
	        if (!this.eventPool.has(constructor)) {
	            this.eventPool.set(constructor, []);
	        }
	        // @ts-ignore
	        this.eventPool.get(constructor).push(event);
	    };
	    EventService.prototype.notifyTarget = function (e, type) {
	        type = type !== null && type !== void 0 ? type : e.type;
	        var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET
	            ? "".concat(type, "capture")
	            : type;
	        this.notifyListeners(e, key);
	        if (e.eventPhase === e.AT_TARGET) {
	            this.notifyListeners(e, type);
	        }
	    };
	    EventService.prototype.notifyListeners = function (e, type) {
	        // hack EventEmitter, stops if the `propagationImmediatelyStopped` flag is set
	        // @ts-ignore
	        var emitter = e.currentTarget.emitter;
	        // @ts-ignore
	        var listeners = emitter._events[type];
	        if (!listeners)
	            return;
	        if ('fn' in listeners) {
	            if (listeners.once) {
	                emitter.removeListener(type, listeners.fn, undefined, true);
	            }
	            listeners.fn.call(e.currentTarget || listeners.context, e);
	            // listeners.fn.call(listeners.context, e);
	        }
	        else {
	            for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
	                if (listeners[i].once) {
	                    emitter.removeListener(type, listeners[i].fn, undefined, true);
	                }
	                listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
	                // listeners[i].fn.call(listeners[i].context, e);
	            }
	        }
	    };
	    /**
	     * some detached nodes may exist in propagation path, need to skip them
	     */
	    EventService.prototype.findMountedTarget = function (propagationPath) {
	        if (!propagationPath) {
	            return null;
	        }
	        var currentTarget = propagationPath[propagationPath.length - 1];
	        for (var i = propagationPath.length - 2; i >= 0; i--) {
	            var target = propagationPath[i];
	            if (target === this.rootTarget ||
	                (Node$1.isNode(target) && target.parentNode === currentTarget)) {
	                currentTarget = propagationPath[i];
	            }
	            else {
	                break;
	            }
	        }
	        return currentTarget;
	    };
	    EventService.prototype.getCursor = function (target) {
	        var tmp = target;
	        while (tmp) {
	            var cursor = isElement(tmp) && tmp.getAttribute('cursor');
	            if (cursor) {
	                return cursor;
	            }
	            tmp = Node$1.isNode(tmp) && tmp.parentNode;
	        }
	    };
	    return EventService;
	}());

	/**
	 * used in following scenes:
	 * - g `ctx.measureText`
	 * - g-plugin-canvas-picker `ctx.isPointInPath`
	 * - g-plugin-device-renderer `ctx.createLinearGradient` and generate texture
	 *
	 * @see https://blog.scottlogic.com/2020/03/19/offscreen-canvas.html
	 */
	var OffscreenCanvasCreator = /** @class */ (function () {
	    function OffscreenCanvasCreator() {
	    }
	    OffscreenCanvasCreator.prototype.getOrCreateCanvas = function (offscreenCanvas, contextAttributes) {
	        if (this.canvas) {
	            return this.canvas;
	        }
	        // user-defined offscreen canvas
	        if (offscreenCanvas) {
	            this.canvas = offscreenCanvas;
	            this.context = this.canvas.getContext('2d', contextAttributes);
	        }
	        else {
	            try {
	                // OffscreenCanvas2D measureText can be up to 40% faster.
	                this.canvas = new window.OffscreenCanvas(0, 0);
	                this.context = this.canvas.getContext('2d', contextAttributes);
	                if (!this.context || !this.context.measureText) {
	                    this.canvas = document.createElement('canvas');
	                    this.context = this.canvas.getContext('2d');
	                }
	            }
	            catch (ex) {
	                this.canvas = document.createElement('canvas');
	                this.context = this.canvas.getContext('2d', contextAttributes);
	            }
	        }
	        this.canvas.width = 10;
	        this.canvas.height = 10;
	        return this.canvas;
	    };
	    OffscreenCanvasCreator.prototype.getOrCreateContext = function (offscreenCanvas, contextAttributes) {
	        if (this.context) {
	            return this.context;
	        }
	        this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
	        return this.context;
	    };
	    return OffscreenCanvasCreator;
	}());

	/**
	 * why we need re-render
	 */
	var RenderReason;
	(function (RenderReason) {
	    RenderReason[RenderReason["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
	    RenderReason[RenderReason["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
	    RenderReason[RenderReason["NONE"] = 2] = "NONE";
	})(RenderReason || (RenderReason = {}));

	/**
	 * Use frame renderer implemented by `g-canvas/svg/webgl`, in every frame we do followings:
	 * * update & merge dirty rectangles
	 * * begin frame
	 * * filter by visible
	 * * sort by z-index in scene graph
	 * * culling with strategies registered in `g-canvas/webgl`
	 * * end frame
	 */
	var RenderingService = /** @class */ (function () {
	    function RenderingService(globalRuntime, context) {
	        this.globalRuntime = globalRuntime;
	        this.context = context;
	        this.inited = false;
	        this.stats = {
	            /**
	             * total display objects in scenegraph
	             */
	            total: 0,
	            /**
	             * number of display objects need to render in current frame
	             */
	            rendered: 0,
	        };
	        this.zIndexCounter = 0;
	        this.hooks = {
	            /**
	             * called before any frame rendered
	             */
	            init: new SyncHook(),
	            initAsync: new AsyncParallelHook(),
	            /**
	             * only dirty object which has sth changed will be rendered
	             */
	            dirtycheck: new SyncWaterfallHook(),
	            /**
	             * do culling
	             */
	            cull: new SyncWaterfallHook(),
	            /**
	             * called at beginning of each frame, won't get called if nothing to re-render
	             */
	            beginFrame: new SyncHook(),
	            /**
	             * called before every dirty object get rendered
	             */
	            beforeRender: new SyncHook(),
	            /**
	             * called when every dirty object rendering even it's culled
	             */
	            render: new SyncHook(),
	            /**
	             * called after every dirty object get rendered
	             */
	            afterRender: new SyncHook(),
	            endFrame: new SyncHook(),
	            destroy: new SyncHook(),
	            /**
	             * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
	             */
	            pick: new AsyncSeriesWaterfallHook(),
	            /**
	             * Unsafe but sync version of pick.
	             */
	            pickSync: new SyncWaterfallHook(),
	            /**
	             * used in event system
	             */
	            pointerDown: new SyncHook(),
	            pointerUp: new SyncHook(),
	            pointerMove: new SyncHook(),
	            pointerOut: new SyncHook(),
	            pointerOver: new SyncHook(),
	            pointerWheel: new SyncHook(),
	            pointerCancel: new SyncHook(),
	            click: new SyncHook(),
	        };
	    }
	    RenderingService.prototype.init = function (callback) {
	        var _this = this;
	        var context = __assign(__assign({}, this.globalRuntime), this.context);
	        // register rendering plugins
	        this.context.renderingPlugins.forEach(function (plugin) {
	            plugin.apply(context, _this.globalRuntime);
	        });
	        this.hooks.init.call();
	        if (this.hooks.initAsync.getCallbacksNum() === 0) {
	            this.inited = true;
	            callback();
	        }
	        else {
	            this.hooks.initAsync.promise().then(function () {
	                _this.inited = true;
	                callback();
	            });
	        }
	    };
	    RenderingService.prototype.getStats = function () {
	        return this.stats;
	    };
	    /**
	     * Meet the following conditions:
	     * * disable DirtyRectangleRendering
	     * * camera changed
	     */
	    RenderingService.prototype.disableDirtyRectangleRendering = function () {
	        var renderer = this.context.config.renderer;
	        var enableDirtyRectangleRendering = renderer.getConfig().enableDirtyRectangleRendering;
	        return (!enableDirtyRectangleRendering ||
	            this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED));
	    };
	    RenderingService.prototype.render = function (canvasConfig, rerenderCallback) {
	        var _this = this;
	        this.stats.total = 0;
	        this.stats.rendered = 0;
	        this.zIndexCounter = 0;
	        var renderingContext = this.context.renderingContext;
	        this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
	        this.globalRuntime.sceneGraphService.triggerPendingEvents();
	        if (renderingContext.renderReasons.size && this.inited) {
	            this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
	            this.hooks.beginFrame.call();
	            renderingContext.renderListCurrentFrame.forEach(function (object) {
	                _this.hooks.beforeRender.call(object);
	                _this.hooks.render.call(object);
	                _this.hooks.afterRender.call(object);
	            });
	            this.hooks.endFrame.call();
	            renderingContext.renderListCurrentFrame = [];
	            renderingContext.renderReasons.clear();
	            rerenderCallback();
	        }
	        // console.log('stats', this.stats);
	    };
	    RenderingService.prototype.renderDisplayObject = function (displayObject, canvasConfig, renderingContext) {
	        var _this = this;
	        var _a = canvasConfig.renderer.getConfig(), enableDirtyCheck = _a.enableDirtyCheck, enableCulling = _a.enableCulling;
	        // recalc style values
	        if (this.globalRuntime.enableCSSParsing) {
	            this.globalRuntime.styleValueRegistry.recalc(displayObject);
	        }
	        // TODO: relayout
	        // dirtycheck first
	        var objectChanged = enableDirtyCheck
	            ? this.hooks.dirtycheck.call(displayObject)
	            : displayObject;
	        if (objectChanged) {
	            var objectToRender = enableCulling
	                ? this.hooks.cull.call(objectChanged, this.context.camera)
	                : objectChanged;
	            if (objectToRender) {
	                this.stats.rendered++;
	                renderingContext.renderListCurrentFrame.push(objectToRender);
	            }
	        }
	        displayObject.renderable.dirty = false;
	        displayObject.sortable.renderOrder = this.zIndexCounter++;
	        this.stats.total++;
	        // sort is very expensive, use cached result if possible
	        var sortable = displayObject.sortable;
	        if (sortable.dirty) {
	            this.sort(displayObject, sortable);
	            sortable.dirty = false;
	            sortable.dirtyChildren = [];
	            sortable.dirtyReason = undefined;
	        }
	        // recursive rendering its children
	        (sortable.sorted || displayObject.childNodes).forEach(function (child) {
	            _this.renderDisplayObject(child, canvasConfig, renderingContext);
	        });
	    };
	    RenderingService.prototype.sort = function (displayObject, sortable) {
	        if (sortable.sorted &&
	            sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
	            // avoid re-sorting the whole children list
	            sortable.dirtyChildren.forEach(function (child) {
	                var index = displayObject.childNodes.indexOf(child);
	                if (index === -1) {
	                    // remove from sorted list
	                    var index_1 = sortable.sorted.indexOf(child);
	                    if (index_1 >= 0) {
	                        sortable.sorted.splice(index_1, 1);
	                    }
	                }
	                else {
	                    if (sortable.sorted.length === 0) {
	                        sortable.sorted.push(child);
	                    }
	                    else {
	                        var index_2 = sortedIndex(sortable.sorted, child);
	                        sortable.sorted.splice(index_2, 0, child);
	                    }
	                }
	            });
	        }
	        else {
	            sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
	        }
	    };
	    RenderingService.prototype.destroy = function () {
	        this.inited = false;
	        this.hooks.destroy.call();
	        this.globalRuntime.sceneGraphService.clearPendingEvents();
	    };
	    RenderingService.prototype.dirtify = function () {
	        // need re-render
	        this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
	    };
	    return RenderingService;
	}());

	var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
	/**
	 * support the following DOM API:
	 * * getElementById
	 * * getElementsByClassName
	 * * getElementsByName
	 * * getElementsByTag
	 * * querySelector
	 * * querySelectorAll
	 */
	var DefaultSceneGraphSelector = /** @class */ (function () {
	    function DefaultSceneGraphSelector() {
	    }
	    DefaultSceneGraphSelector.prototype.selectOne = function (query, root) {
	        var _this = this;
	        if (query.startsWith('.')) {
	            return root.find(function (node) {
	                // return !node.shadow && node.id === query.substring(1);
	                return (((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1);
	            });
	        }
	        else if (query.startsWith('#')) {
	            // getElementById('id')
	            return root.find(function (node) {
	                // return !node.shadow && node.id === query.substring(1);
	                return node.id === _this.getIdOrClassname(query);
	            });
	        }
	        else if (query.startsWith('[')) {
	            var _a = this.getAttribute(query), name_1 = _a.name, value_1 = _a.value;
	            if (name_1) {
	                // getElementByName();
	                return root.find(function (node) {
	                    return root !== node &&
	                        (name_1 === 'name'
	                            ? node.name === value_1
	                            : _this.attributeToString(node, name_1) === value_1);
	                });
	            }
	            else {
	                return null;
	            }
	        }
	        else {
	            // getElementsByTag('circle');
	            return root.find(function (node) { return root !== node && node.nodeName === query; });
	        }
	    };
	    DefaultSceneGraphSelector.prototype.selectAll = function (query, root) {
	        var _this = this;
	        // only support `[name="${name}"]` `.className` `#id`
	        if (query.startsWith('.')) {
	            // getElementsByClassName('className');
	            // should not include itself
	            return root.findAll(function (node) {
	                return root !== node &&
	                    ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1;
	            });
	        }
	        else if (query.startsWith('#')) {
	            return root.findAll(function (node) {
	                return root !== node &&
	                    node.id === _this.getIdOrClassname(query);
	            });
	        }
	        else if (query.startsWith('[')) {
	            var _a = this.getAttribute(query), name_2 = _a.name, value_2 = _a.value;
	            if (name_2) {
	                // getElementsByName();
	                return root.findAll(function (node) {
	                    return root !== node &&
	                        (name_2 === 'name'
	                            ? node.name === value_2
	                            : _this.attributeToString(node, name_2) === value_2);
	                });
	            }
	            else {
	                return [];
	            }
	        }
	        else {
	            // getElementsByTag('circle');
	            return root.findAll(function (node) { return root !== node && node.nodeName === query; });
	        }
	    };
	    DefaultSceneGraphSelector.prototype.is = function (query, node) {
	        // a simple `matches` implementation
	        if (query.startsWith('.')) {
	            return node.className === this.getIdOrClassname(query);
	        }
	        else if (query.startsWith('#')) {
	            return node.id === this.getIdOrClassname(query);
	        }
	        else if (query.startsWith('[')) {
	            var _a = this.getAttribute(query), name_3 = _a.name, value = _a.value;
	            return name_3 === 'name'
	                ? node.name === value
	                : this.attributeToString(node, name_3) === value;
	        }
	        else {
	            return node.nodeName === query;
	        }
	    };
	    DefaultSceneGraphSelector.prototype.getIdOrClassname = function (query) {
	        return query.substring(1);
	    };
	    DefaultSceneGraphSelector.prototype.getAttribute = function (query) {
	        var matches = query.match(ATTRIBUTE_REGEXP);
	        var name = '';
	        var value = '';
	        if (matches && matches.length > 2) {
	            name = matches[1].replace(/"/g, '');
	            value = matches[2].replace(/"/g, '');
	        }
	        return { name: name, value: value };
	    };
	    DefaultSceneGraphSelector.prototype.attributeToString = function (node, name) {
	        if (!node.getAttribute) {
	            return '';
	        }
	        var value = node.getAttribute(name);
	        if (isNil(value)) {
	            return '';
	        }
	        if (value.toString) {
	            return value.toString();
	        }
	        return '';
	    };
	    return DefaultSceneGraphSelector;
	}());

	var MutationEvent = /** @class */ (function (_super) {
	    __extends(MutationEvent, _super);
	    function MutationEvent(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
	        var _this = _super.call(this, null) || this;
	        _this.relatedNode = relatedNode;
	        _this.prevValue = prevValue;
	        _this.newValue = newValue;
	        _this.attrName = attrName;
	        _this.attrChange = attrChange;
	        _this.prevParsedValue = prevParsedValue;
	        _this.newParsedValue = newParsedValue;
	        _this.type = typeArg;
	        return _this;
	    }
	    MutationEvent.ADDITION = 2;
	    MutationEvent.MODIFICATION = 1;
	    MutationEvent.REMOVAL = 3;
	    return MutationEvent;
	}(FederatedEvent));

	/**
	 * built-in events for element
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent
	 *
	 * TODO: use MutationObserver instead
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
	 */
	var ElementEvent;
	(function (ElementEvent) {
	    ElementEvent["REPARENT"] = "reparent";
	    ElementEvent["DESTROY"] = "destroy";
	    /**
	     * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMAttrModified
	     */
	    ElementEvent["ATTR_MODIFIED"] = "DOMAttrModified";
	    /**
	     * it has been inserted
	     * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeInserted
	     */
	    ElementEvent["INSERTED"] = "DOMNodeInserted";
	    /**
	     * it is being removed
	     * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeRemoved
	     */
	    ElementEvent["REMOVED"] = "removed";
	    /**
	     * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnodeinsertedintodocument
	     */
	    ElementEvent["MOUNTED"] = "DOMNodeInsertedIntoDocument";
	    /**
	     * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnoderemovedfromdocument
	     */
	    ElementEvent["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
	    ElementEvent["BOUNDS_CHANGED"] = "bounds-changed";
	    ElementEvent["CULLED"] = "culled";
	})(ElementEvent || (ElementEvent = {}));

	function markRenderableDirty(e) {
	    var renderable = e.renderable;
	    if (renderable) {
	        renderable.renderBoundsDirty = true;
	        renderable.boundsDirty = true;
	    }
	}
	var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, '', '', '', 0, '', '');
	/**
	 * update transform in scene graph
	 *
	 * @see https://community.khronos.org/t/scene-graphs/50542/7
	 */
	var DefaultSceneGraphService = /** @class */ (function () {
	    function DefaultSceneGraphService(runtime) {
	        var _this = this;
	        this.runtime = runtime;
	        this.pendingEvents = [];
	        this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
	        /**
	         * rotate in world space
	         */
	        this.rotate = (function () {
	            var parentInvertRotation = create$4();
	            return function (element, degrees, y, z) {
	                if (y === void 0) { y = 0; }
	                if (z === void 0) { z = 0; }
	                if (typeof degrees === 'number') {
	                    degrees = fromValues$2(degrees, y, z);
	                }
	                var transform = element.transformable;
	                if (element.parentNode === null ||
	                    !element.parentNode.transformable) {
	                    _this.rotateLocal(element, degrees);
	                }
	                else {
	                    var rotation = create$4();
	                    fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
	                    var rot = _this.getRotation(element);
	                    var parentRot = _this.getRotation(element.parentNode);
	                    copy$3(parentInvertRotation, parentRot);
	                    invert$1(parentInvertRotation, parentInvertRotation);
	                    multiply$2(rotation, parentInvertRotation, rotation);
	                    multiply$2(transform.localRotation, rotation, rot);
	                    normalize$2(transform.localRotation, transform.localRotation);
	                    _this.dirtifyLocal(element, transform);
	                }
	            };
	        })();
	        /**
	         * rotate in local space
	         * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
	         */
	        this.rotateLocal = (function () {
	            var rotation = create$4();
	            return function (element, degrees, y, z) {
	                if (y === void 0) { y = 0; }
	                if (z === void 0) { z = 0; }
	                if (typeof degrees === 'number') {
	                    degrees = fromValues$2(degrees, y, z);
	                }
	                var transform = element.transformable;
	                fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
	                mul$1(transform.localRotation, transform.localRotation, rotation);
	                _this.dirtifyLocal(element, transform);
	            };
	        })();
	        /**
	         * set euler angles(degrees) in world space
	         */
	        this.setEulerAngles = (function () {
	            var invParentRot = create$4();
	            return function (element, degrees, y, z) {
	                if (y === void 0) { y = 0; }
	                if (z === void 0) { z = 0; }
	                if (typeof degrees === 'number') {
	                    degrees = fromValues$2(degrees, y, z);
	                }
	                var transform = element.transformable;
	                if (element.parentNode === null ||
	                    !element.parentNode.transformable) {
	                    _this.setLocalEulerAngles(element, degrees);
	                }
	                else {
	                    fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
	                    var parentRotation = _this.getRotation(element.parentNode);
	                    copy$3(invParentRot, invert$1(create$4(), parentRotation));
	                    mul$1(transform.localRotation, transform.localRotation, invParentRot);
	                    _this.dirtifyLocal(element, transform);
	                }
	            };
	        })();
	        /**
	         * translate in local space
	         *
	         * @example
	         * ```
	         * translateLocal(x, y, z)
	         * translateLocal(vec3(x, y, z))
	         * ```
	         */
	        this.translateLocal = (function () {
	            return function (element, translation, y, z) {
	                if (y === void 0) { y = 0; }
	                if (z === void 0) { z = 0; }
	                if (typeof translation === 'number') {
	                    translation = fromValues$2(translation, y, z);
	                }
	                var transform = element.transformable;
	                if (equals$1(translation, create$2())) {
	                    return;
	                }
	                transformQuat(translation, translation, transform.localRotation);
	                add$1(transform.localPosition, transform.localPosition, translation);
	                _this.dirtifyLocal(element, transform);
	            };
	        })();
	        /**
	         * move to position in world space
	         *
	         * 对应 g 原版的 move/moveTo
	         * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
	         */
	        this.setPosition = (function () {
	            var parentInvertMatrix = create$1();
	            var tmpPosition = create$2();
	            return function (element, position) {
	                var transform = element.transformable;
	                tmpPosition[0] = position[0];
	                tmpPosition[1] = position[1];
	                tmpPosition[2] = position[2] || 0;
	                if (equals$1(_this.getPosition(element), tmpPosition)) {
	                    return;
	                }
	                copy$1(transform.position, tmpPosition);
	                if (element.parentNode === null ||
	                    !element.parentNode.transformable) {
	                    copy$1(transform.localPosition, tmpPosition);
	                }
	                else {
	                    var parentTransform = element.parentNode.transformable;
	                    copy(parentInvertMatrix, parentTransform.worldTransform);
	                    invert(parentInvertMatrix, parentInvertMatrix);
	                    transformMat4(transform.localPosition, tmpPosition, parentInvertMatrix);
	                }
	                _this.dirtifyLocal(element, transform);
	            };
	        })();
	        /**
	         * move to position in local space
	         */
	        this.setLocalPosition = (function () {
	            var tmpPosition = create$2();
	            return function (element, position) {
	                var transform = element.transformable;
	                tmpPosition[0] = position[0];
	                tmpPosition[1] = position[1];
	                tmpPosition[2] = position[2] || 0;
	                if (equals$1(transform.localPosition, tmpPosition)) {
	                    return;
	                }
	                copy$1(transform.localPosition, tmpPosition);
	                _this.dirtifyLocal(element, transform);
	            };
	        })();
	        /**
	         * translate in world space
	         *
	         * @example
	         * ```
	         * translate(x, y, z)
	         * translate(vec3(x, y, z))
	         * ```
	         *
	         * 对应 g 原版的 translate 2D
	         * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
	         */
	        this.translate = (function () {
	            var zeroVec3 = create$2();
	            var tmpVec3 = create$2();
	            var tr = create$2();
	            return function (element, translation, y, z) {
	                if (y === void 0) { y = 0; }
	                if (z === void 0) { z = 0; }
	                if (typeof translation === 'number') {
	                    translation = set$1(tmpVec3, translation, y, z);
	                }
	                if (equals$1(translation, zeroVec3)) {
	                    return;
	                }
	                add$1(tr, _this.getPosition(element), translation);
	                _this.setPosition(element, tr);
	            };
	        })();
	        this.setRotation = function () {
	            var parentInvertRotation = create$4();
	            return function (element, rotation, y, z, w) {
	                var transform = element.transformable;
	                if (typeof rotation === 'number') {
	                    rotation = fromValues$4(rotation, y, z, w);
	                }
	                if (element.parentNode === null ||
	                    !element.parentNode.transformable) {
	                    _this.setLocalRotation(element, rotation);
	                }
	                else {
	                    var parentRot = _this.getRotation(element.parentNode);
	                    copy$3(parentInvertRotation, parentRot);
	                    invert$1(parentInvertRotation, parentInvertRotation);
	                    multiply$2(transform.localRotation, parentInvertRotation, rotation);
	                    normalize$2(transform.localRotation, transform.localRotation);
	                    _this.dirtifyLocal(element, transform);
	                }
	            };
	        };
	        this.displayObjectDependencyMap = new WeakMap();
	        this.calcLocalTransform = (function () {
	            var tmpMat = create$1();
	            var tmpPosition = create$2();
	            var tmpQuat = fromValues$4(0, 0, 0, 1);
	            return function (transform) {
	                var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
	                if (hasSkew) {
	                    fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, fromValues$2(1, 1, 1), transform.origin);
	                    // apply skew2D
	                    if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
	                        var tmpMat4 = identity(tmpMat);
	                        tmpMat4[4] = Math.tan(transform.localSkew[0]);
	                        tmpMat4[1] = Math.tan(transform.localSkew[1]);
	                        multiply(transform.localTransform, transform.localTransform, tmpMat4);
	                    }
	                    var scaling = fromRotationTranslationScaleOrigin(tmpMat, tmpQuat, tmpPosition, transform.localScale, transform.origin);
	                    multiply(transform.localTransform, transform.localTransform, scaling);
	                }
	                else {
	                    // @see https://github.com/mattdesl/css-mat4/blob/master/index.js
	                    fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
	                }
	            };
	        })();
	    }
	    DefaultSceneGraphService.prototype.matches = function (query, root) {
	        return this.runtime.sceneGraphSelector.is(query, root);
	    };
	    DefaultSceneGraphService.prototype.querySelector = function (query, root) {
	        return this.runtime.sceneGraphSelector.selectOne(query, root);
	    };
	    DefaultSceneGraphService.prototype.querySelectorAll = function (query, root) {
	        return this.runtime.sceneGraphSelector.selectAll(query, root);
	        // .filter((node) => !node.shadow);
	    };
	    DefaultSceneGraphService.prototype.attach = function (child, parent, index) {
	        var _a, _b;
	        var detached = false;
	        if (child.parentNode) {
	            detached = child.parentNode !== parent;
	            this.detach(child);
	        }
	        child.parentNode = parent;
	        if (!isNil(index)) {
	            child.parentNode.childNodes.splice(index, 0, child);
	        }
	        else {
	            child.parentNode.childNodes.push(child);
	        }
	        // parent needs re-sort
	        var sortable = parent.sortable;
	        if (((_a = sortable === null || sortable === void 0 ? void 0 : sortable.sorted) === null || _a === void 0 ? void 0 : _a.length) ||
	            ((_b = child.style) === null || _b === void 0 ? void 0 : _b.zIndex)) {
	            if (sortable.dirtyChildren.indexOf(child) === -1) {
	                sortable.dirtyChildren.push(child);
	            }
	            // if (sortable) {
	            // only child has z-Index
	            sortable.dirty = true;
	            sortable.dirtyReason = SortReason.ADDED;
	        }
	        // this.updateGraphDepth(child);
	        var transform = child.transformable;
	        if (transform) {
	            this.dirtifyWorld(child, transform);
	        }
	        if (transform.frozen) {
	            this.unfreezeParentToRoot(child);
	        }
	        if (detached) {
	            child.dispatchEvent(reparentEvent);
	        }
	    };
	    DefaultSceneGraphService.prototype.detach = function (child) {
	        var _a, _b;
	        if (child.parentNode) {
	            var transform = child.transformable;
	            // if (transform) {
	            //   const worldTransform = this.getWorldTransform(child, transform);
	            //   mat4.getScaling(transform.localScale, worldTransform);
	            //   mat4.getTranslation(transform.localPosition, worldTransform);
	            //   mat4.getRotation(transform.localRotation, worldTransform);
	            //   transform.localDirtyFlag = true;
	            // }
	            // parent needs re-sort
	            var sortable = child.parentNode.sortable;
	            // if (sortable) {
	            if (((_a = sortable === null || sortable === void 0 ? void 0 : sortable.sorted) === null || _a === void 0 ? void 0 : _a.length) ||
	                ((_b = child.style) === null || _b === void 0 ? void 0 : _b.zIndex)) {
	                if (sortable.dirtyChildren.indexOf(child) === -1) {
	                    sortable.dirtyChildren.push(child);
	                }
	                sortable.dirty = true;
	                sortable.dirtyReason = SortReason.REMOVED;
	            }
	            var index = child.parentNode.childNodes.indexOf(child);
	            if (index > -1) {
	                child.parentNode.childNodes.splice(index, 1);
	            }
	            if (transform) {
	                this.dirtifyWorld(child, transform);
	            }
	            child.parentNode = null;
	        }
	    };
	    DefaultSceneGraphService.prototype.getOrigin = function (element) {
	        return element.transformable.origin;
	    };
	    /**
	     * same as pivot in Pixi.js
	     *
	     * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
	     */
	    DefaultSceneGraphService.prototype.setOrigin = function (element, origin, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (typeof origin === 'number') {
	            origin = [origin, y, z];
	        }
	        var transform = element.transformable;
	        if (origin[0] === transform.origin[0] &&
	            origin[1] === transform.origin[1] &&
	            origin[2] === transform.origin[2]) {
	            return;
	        }
	        var originVec = transform.origin;
	        // const delta = vec3.subtract(vec3.create(), origin, originVec);
	        // vec3.add(transform.localPosition, transform.localPosition, delta);
	        // update origin
	        originVec[0] = origin[0];
	        originVec[1] = origin[1];
	        originVec[2] = origin[2] || 0;
	        this.dirtifyLocal(element, transform);
	    };
	    /**
	     * set euler angles(degrees) in local space
	     */
	    DefaultSceneGraphService.prototype.setLocalEulerAngles = function (element, degrees, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (typeof degrees === 'number') {
	            degrees = fromValues$2(degrees, y, z);
	        }
	        var transform = element.transformable;
	        fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
	        this.dirtifyLocal(element, transform);
	    };
	    /**
	     * scale in local space
	     */
	    DefaultSceneGraphService.prototype.scaleLocal = function (element, scaling) {
	        var transform = element.transformable;
	        multiply$1(transform.localScale, transform.localScale, fromValues$2(scaling[0], scaling[1], scaling[2] || 1));
	        this.dirtifyLocal(element, transform);
	    };
	    DefaultSceneGraphService.prototype.setLocalScale = function (element, scaling) {
	        var transform = element.transformable;
	        var updatedScaling = fromValues$2(scaling[0], scaling[1], scaling[2] || transform.localScale[2]);
	        if (equals$1(updatedScaling, transform.localScale)) {
	            return;
	        }
	        copy$1(transform.localScale, updatedScaling);
	        this.dirtifyLocal(element, transform);
	    };
	    DefaultSceneGraphService.prototype.setLocalRotation = function (element, rotation, y, z, w) {
	        if (typeof rotation === 'number') {
	            rotation = fromValues$4(rotation, y, z, w);
	        }
	        var transform = element.transformable;
	        copy$3(transform.localRotation, rotation);
	        this.dirtifyLocal(element, transform);
	    };
	    DefaultSceneGraphService.prototype.setLocalSkew = function (element, skew, y) {
	        if (typeof skew === 'number') {
	            skew = fromValues$5(skew, y);
	        }
	        var transform = element.transformable;
	        copy$4(transform.localSkew, skew);
	        this.dirtifyLocal(element, transform);
	    };
	    DefaultSceneGraphService.prototype.dirtifyLocal = function (element, transform) {
	        if (!transform.localDirtyFlag) {
	            transform.localDirtyFlag = true;
	            if (!transform.dirtyFlag) {
	                this.dirtifyWorld(element, transform);
	            }
	        }
	    };
	    DefaultSceneGraphService.prototype.dirtifyWorld = function (element, transform) {
	        if (!transform.dirtyFlag) {
	            this.unfreezeParentToRoot(element);
	        }
	        this.dirtifyWorldInternal(element, transform);
	        this.dirtifyToRoot(element, true);
	    };
	    DefaultSceneGraphService.prototype.triggerPendingEvents = function () {
	        var _this = this;
	        var set = new Set();
	        var trigger = function (element, detail) {
	            if (element.isConnected && !set.has(element.entity)) {
	                _this.boundsChangedEvent.detail = detail;
	                _this.boundsChangedEvent.target = element;
	                if (element.isMutationObserved) {
	                    element.dispatchEvent(_this.boundsChangedEvent);
	                }
	                else {
	                    element.ownerDocument.defaultView.dispatchEvent(_this.boundsChangedEvent, true);
	                }
	                set.add(element.entity);
	            }
	        };
	        this.pendingEvents.forEach(function (_a) {
	            var _b = __read(_a, 2), element = _b[0], detail = _b[1];
	            if (detail.affectChildren) {
	                element.forEach(function (e) {
	                    trigger(e, detail);
	                });
	            }
	            else {
	                trigger(element, detail);
	            }
	        });
	        this.clearPendingEvents();
	        set.clear();
	    };
	    DefaultSceneGraphService.prototype.clearPendingEvents = function () {
	        this.pendingEvents = [];
	    };
	    DefaultSceneGraphService.prototype.dirtifyToRoot = function (element, affectChildren) {
	        if (affectChildren === void 0) { affectChildren = false; }
	        var p = element;
	        // only need to re-render itself
	        if (p.renderable) {
	            p.renderable.dirty = true;
	        }
	        while (p) {
	            markRenderableDirty(p);
	            p = p.parentNode;
	        }
	        if (affectChildren) {
	            element.forEach(function (e) {
	                markRenderableDirty(e);
	            });
	        }
	        // inform dependencies
	        this.informDependentDisplayObjects(element);
	        // reuse the same custom event
	        this.pendingEvents.push([element, { affectChildren: affectChildren }]);
	    };
	    DefaultSceneGraphService.prototype.updateDisplayObjectDependency = function (name, oldPath, newPath, object) {
	        // clear ref to old clip path
	        if (oldPath && oldPath !== newPath) {
	            var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
	            if (oldDependencyMap && oldDependencyMap[name]) {
	                var index = oldDependencyMap[name].indexOf(object);
	                oldDependencyMap[name].splice(index, 1);
	            }
	        }
	        if (newPath) {
	            var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
	            if (!newDependencyMap) {
	                this.displayObjectDependencyMap.set(newPath, {});
	                newDependencyMap = this.displayObjectDependencyMap.get(newPath);
	            }
	            if (!newDependencyMap[name]) {
	                newDependencyMap[name] = [];
	            }
	            newDependencyMap[name].push(object);
	        }
	    };
	    DefaultSceneGraphService.prototype.informDependentDisplayObjects = function (object) {
	        var _this = this;
	        var dependencyMap = this.displayObjectDependencyMap.get(object);
	        if (dependencyMap) {
	            Object.keys(dependencyMap).forEach(function (name) {
	                dependencyMap[name].forEach(function (target) {
	                    _this.dirtifyToRoot(target, true);
	                    target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this, _this, name, MutationEvent.MODIFICATION, _this, _this));
	                    if (target.isCustomElement && target.isConnected) {
	                        if (target.attributeChangedCallback) {
	                            target.attributeChangedCallback(name, _this, _this);
	                        }
	                    }
	                });
	            });
	        }
	    };
	    DefaultSceneGraphService.prototype.getPosition = function (element) {
	        var transform = element.transformable;
	        return getTranslation(transform.position, this.getWorldTransform(element, transform));
	    };
	    DefaultSceneGraphService.prototype.getRotation = function (element) {
	        var transform = element.transformable;
	        return getRotation(transform.rotation, this.getWorldTransform(element, transform));
	    };
	    DefaultSceneGraphService.prototype.getScale = function (element) {
	        var transform = element.transformable;
	        return getScaling(transform.scaling, this.getWorldTransform(element, transform));
	    };
	    DefaultSceneGraphService.prototype.getWorldTransform = function (element, transform) {
	        if (transform === void 0) { transform = element.transformable; }
	        if (!transform.localDirtyFlag && !transform.dirtyFlag) {
	            return transform.worldTransform;
	        }
	        if (element.parentNode && element.parentNode.transformable) {
	            this.getWorldTransform(element.parentNode);
	        }
	        this.sync(element, transform);
	        return transform.worldTransform;
	    };
	    DefaultSceneGraphService.prototype.getLocalPosition = function (element) {
	        return element.transformable.localPosition;
	    };
	    DefaultSceneGraphService.prototype.getLocalRotation = function (element) {
	        return element.transformable.localRotation;
	    };
	    DefaultSceneGraphService.prototype.getLocalScale = function (element) {
	        return element.transformable.localScale;
	    };
	    DefaultSceneGraphService.prototype.getLocalSkew = function (element) {
	        return element.transformable.localSkew;
	    };
	    DefaultSceneGraphService.prototype.getLocalTransform = function (element) {
	        var transform = element.transformable;
	        if (transform.localDirtyFlag) {
	            this.calcLocalTransform(transform);
	            transform.localDirtyFlag = false;
	        }
	        return transform.localTransform;
	    };
	    DefaultSceneGraphService.prototype.setLocalTransform = function (element, transform) {
	        var t = getTranslation(create$2(), transform);
	        var r = getRotation(create$4(), transform);
	        var s = getScaling(create$2(), transform);
	        this.setLocalScale(element, s);
	        this.setLocalPosition(element, t);
	        this.setLocalRotation(element, r);
	    };
	    DefaultSceneGraphService.prototype.resetLocalTransform = function (element) {
	        this.setLocalScale(element, [1, 1, 1]);
	        this.setLocalPosition(element, [0, 0, 0]);
	        this.setLocalEulerAngles(element, [0, 0, 0]);
	        this.setLocalSkew(element, [0, 0]);
	    };
	    DefaultSceneGraphService.prototype.getTransformedGeometryBounds = function (element, render, existedAABB) {
	        if (render === void 0) { render = false; }
	        var bounds = this.getGeometryBounds(element, render);
	        if (!AABB.isEmpty(bounds)) {
	            var aabb = existedAABB || new AABB();
	            aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
	            return aabb;
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * won't account for children
	     */
	    DefaultSceneGraphService.prototype.getGeometryBounds = function (element, render) {
	        if (render === void 0) { render = false; }
	        var geometry = element.geometry;
	        var bounds = render
	            ? geometry.renderBounds
	            : geometry.contentBounds || null;
	        // return (bounds && new AABB(bounds.center, bounds.halfExtents)) || new AABB();
	        return bounds || new AABB();
	    };
	    /**
	     * account for children in world space
	     */
	    DefaultSceneGraphService.prototype.getBounds = function (element, render) {
	        var _this = this;
	        if (render === void 0) { render = false; }
	        var renderable = element.renderable;
	        if (!renderable.boundsDirty && !render && renderable.bounds) {
	            return renderable.bounds;
	        }
	        if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
	            return renderable.renderBounds;
	        }
	        // reuse existed if possible
	        var existedAABB = render ? renderable.renderBounds : renderable.bounds;
	        // reset with geometry's aabb
	        var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);
	        // merge children's aabbs
	        var children = element.childNodes;
	        children.forEach(function (child) {
	            var childBounds = _this.getBounds(child, render);
	            if (childBounds) {
	                if (!aabb) {
	                    aabb = existedAABB || new AABB();
	                    aabb.update(childBounds.center, childBounds.halfExtents);
	                }
	                else {
	                    aabb.add(childBounds);
	                }
	            }
	        });
	        if (render) {
	            // FIXME: account for clip path
	            var clipped = findClosestClipPathTarget(element);
	            if (clipped) {
	                // use bounds under world space
	                var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render);
	                if (!aabb) {
	                    aabb = clipPathBounds;
	                }
	                else if (clipPathBounds) {
	                    aabb = clipPathBounds.intersection(aabb);
	                }
	            }
	        }
	        if (!aabb) {
	            aabb = new AABB();
	        }
	        if (aabb) {
	            if (render) {
	                renderable.renderBounds = aabb;
	            }
	            else {
	                renderable.bounds = aabb;
	            }
	        }
	        if (render) {
	            renderable.renderBoundsDirty = false;
	        }
	        else {
	            renderable.boundsDirty = false;
	        }
	        return aabb;
	    };
	    /**
	     * account for children in local space
	     */
	    DefaultSceneGraphService.prototype.getLocalBounds = function (element) {
	        if (element.parentNode) {
	            var parentInvert = create$1();
	            if (element.parentNode.transformable) {
	                parentInvert = invert(create$1(), this.getWorldTransform(element.parentNode));
	            }
	            var bounds = this.getBounds(element);
	            if (!AABB.isEmpty(bounds)) {
	                var localBounds = new AABB();
	                localBounds.setFromTransformedAABB(bounds, parentInvert);
	                return localBounds;
	            }
	        }
	        return this.getBounds(element);
	    };
	    DefaultSceneGraphService.prototype.getBoundingClientRect = function (element) {
	        var _a, _b;
	        var aabb;
	        var bounds = this.getGeometryBounds(element);
	        if (!AABB.isEmpty(bounds)) {
	            aabb = new AABB();
	            // apply transformation to aabb
	            aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
	        }
	        // calc context's offset
	        var bbox = (_b = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();
	        if (aabb) {
	            var _c = __read(aabb.getMin(), 2), left = _c[0], top_1 = _c[1];
	            var _d = __read(aabb.getMax(), 2), right = _d[0], bottom = _d[1];
	            return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top_1 + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top_1);
	        }
	        return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
	    };
	    DefaultSceneGraphService.prototype.dirtifyWorldInternal = function (element, transform) {
	        var _this = this;
	        if (!transform.dirtyFlag) {
	            transform.dirtyFlag = true;
	            transform.frozen = false;
	            element.childNodes.forEach(function (child) {
	                var childTransform = child.transformable;
	                if (!childTransform.dirtyFlag) {
	                    _this.dirtifyWorldInternal(child, childTransform);
	                }
	            });
	            var renderable = element.renderable;
	            if (renderable) {
	                renderable.renderBoundsDirty = true;
	                renderable.boundsDirty = true;
	                renderable.dirty = true;
	            }
	        }
	    };
	    DefaultSceneGraphService.prototype.syncHierarchy = function (element) {
	        var transform = element.transformable;
	        if (transform.frozen) {
	            return;
	        }
	        transform.frozen = true;
	        if (transform.localDirtyFlag || transform.dirtyFlag) {
	            this.sync(element, transform);
	        }
	        var children = element.childNodes;
	        for (var i = 0; i < children.length; i++) {
	            this.syncHierarchy(children[i]);
	        }
	    };
	    DefaultSceneGraphService.prototype.sync = function (element, transform) {
	        if (transform.localDirtyFlag) {
	            this.calcLocalTransform(transform);
	            transform.localDirtyFlag = false;
	        }
	        if (transform.dirtyFlag) {
	            var parent_1 = element.parentNode;
	            var parentTransform = parent_1 && parent_1.transformable;
	            if (parent_1 === null || !parentTransform) {
	                copy(transform.worldTransform, transform.localTransform);
	            }
	            else {
	                // TODO: should we support scale compensation?
	                // @see https://github.com/playcanvas/engine/issues/1077#issuecomment-359765557
	                multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
	            }
	            transform.dirtyFlag = false;
	        }
	    };
	    DefaultSceneGraphService.prototype.unfreezeParentToRoot = function (child) {
	        var p = child.parentNode;
	        while (p) {
	            var transform = p.transformable;
	            if (transform) {
	                transform.frozen = false;
	            }
	            p = p.parentNode;
	        }
	    };
	    return DefaultSceneGraphService;
	}());

	var TEXT_METRICS = {
	    MetricsString: '|ÉqÅ',
	    BaselineSymbol: 'M',
	    BaselineMultiplier: 1.4,
	    HeightMultiplier: 2,
	    Newlines: [
	        0x000a,
	        0x000d, // carriage return
	    ],
	    BreakingSpaces: [
	        0x0009,
	        0x0020,
	        0x2000,
	        0x2001,
	        0x2002,
	        0x2003,
	        0x2004,
	        0x2005,
	        0x2006,
	        0x2008,
	        0x2009,
	        0x200a,
	        0x205f,
	        0x3000, // ideographic space
	    ],
	};
	var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
	// Line breaking rules in CJK (Kinsoku Shori)
	// Refer from https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages
	var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
	var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
	var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
	var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
	var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
	var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
	var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
	var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
	var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
	var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
	/**
	 * Borrow from pixi/packages/text/src/TextMetrics.ts
	 */
	var TextService = /** @class */ (function () {
	    function TextService(runtime) {
	        var _this = this;
	        this.runtime = runtime;
	        /**
	         * font metrics cache
	         */
	        this.fontMetricsCache = {};
	        this.shouldBreakByKinsokuShorui = function (char, nextChar) {
	            if (_this.isBreakingSpace(nextChar))
	                return false;
	            if (char) {
	                // Line breaking rules in CJK (Kinsoku Shori)
	                if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(char)) {
	                    return true;
	                }
	            }
	            return false;
	        };
	        this.trimByKinsokuShorui = function (prev) {
	            var next = __spreadArray([], __read(prev), false);
	            var prevLine = next[next.length - 2];
	            if (!prevLine) {
	                return prev;
	            }
	            var lastChar = prevLine[prevLine.length - 1];
	            next[next.length - 2] = prevLine.slice(0, -1);
	            next[next.length - 1] = lastChar + next[next.length - 1];
	            return next;
	        };
	    }
	    /**
	     * Calculates the ascent, descent and fontSize of a given font-style.
	     */
	    TextService.prototype.measureFont = function (font, offscreenCanvas) {
	        // as this method is used for preparing assets, don't recalculate things if we don't need to
	        if (this.fontMetricsCache[font]) {
	            return this.fontMetricsCache[font];
	        }
	        var properties = {
	            ascent: 0,
	            descent: 0,
	            fontSize: 0,
	        };
	        var canvas = this.runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
	        var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas, {
	            willReadFrequently: true,
	        });
	        context.font = font;
	        var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
	        var width = Math.ceil(context.measureText(metricsString).width);
	        var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
	        var height = TEXT_METRICS.HeightMultiplier * baseline;
	        baseline = (baseline * TEXT_METRICS.BaselineMultiplier) | 0;
	        // @ts-ignore
	        canvas.width = width;
	        // @ts-ignore
	        canvas.height = height;
	        context.fillStyle = '#f00';
	        context.fillRect(0, 0, width, height);
	        context.font = font;
	        context.textBaseline = 'alphabetic';
	        context.fillStyle = '#000';
	        context.fillText(metricsString, 0, baseline);
	        var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
	        var pixels = imagedata.length;
	        var line = width * 4;
	        var i = 0;
	        var idx = 0;
	        var stop = false;
	        // ascent. scan from top to bottom until we find a non red pixel
	        for (i = 0; i < baseline; ++i) {
	            for (var j = 0; j < line; j += 4) {
	                if (imagedata[idx + j] !== 255) {
	                    stop = true;
	                    break;
	                }
	            }
	            if (!stop) {
	                idx += line;
	            }
	            else {
	                break;
	            }
	        }
	        properties.ascent = baseline - i;
	        idx = pixels - line;
	        stop = false;
	        // descent. scan from bottom to top until we find a non red pixel
	        for (i = height; i > baseline; --i) {
	            for (var j = 0; j < line; j += 4) {
	                if (imagedata[idx + j] !== 255) {
	                    stop = true;
	                    break;
	                }
	            }
	            if (!stop) {
	                idx -= line;
	            }
	            else {
	                break;
	            }
	        }
	        properties.descent = i - baseline;
	        properties.fontSize = properties.ascent + properties.descent;
	        this.fontMetricsCache[font] = properties;
	        return properties;
	    };
	    TextService.prototype.measureText = function (text, parsedStyle, offscreenCanvas) {
	        var fontSize = parsedStyle.fontSize, wordWrap = parsedStyle.wordWrap, strokeHeight = parsedStyle.lineHeight, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, textAlign = parsedStyle.textAlign, letterSpacing = parsedStyle.letterSpacing, textPath = parsedStyle.textPath; parsedStyle.textPathSide; parsedStyle.textPathStartOffset; 
	        var // dropShadow = 0,
	        // dropShadowDistance = 0,
	        _a = parsedStyle.leading, 
	        // dropShadow = 0,
	        // dropShadowDistance = 0,
	        leading = _a === void 0 ? 0 : _a;
	        var font = toFontString(parsedStyle);
	        // if (runtime.enableCSSParsing) {
	        var fontProperties = this.measureFont(font, offscreenCanvas);
	        // fallback in case UA disallow canvas data extraction
	        // (toDataURI, getImageData functions)
	        if (fontProperties.fontSize === 0) {
	            fontProperties.fontSize = fontSize;
	            fontProperties.ascent = fontSize;
	        }
	        // } else {
	        //   fontProperties = {
	        //     fontSize,
	        //   };
	        // }
	        var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
	        context.font = font;
	        // no overflowing by default
	        parsedStyle.isOverflowing = false;
	        var outputText = wordWrap
	            ? this.wordWrap(text, parsedStyle, offscreenCanvas)
	            : text;
	        var lines = outputText.split(/(?:\r\n|\r|\n)/);
	        var lineWidths = new Array(lines.length);
	        var maxLineWidth = 0;
	        // account for textPath
	        if (textPath) {
	            textPath.getTotalLength();
	            // const startingPoint = textPath.getPoint(0);
	            for (var i = 0; i < lines.length; i++) {
	                var width = context.measureText(lines[i]).width +
	                    (lines[i].length - 1) * letterSpacing;
	                // for (
	                //   let i = reverse ? lines[0].length - 1 : 0;
	                //   reverse ? i >= 0 : i < lines[0].length;
	                //   reverse ? i-- : i++
	                // ) {
	                //   graphemeInfo = lineBounds[i];
	                //   if (positionInPath > totalPathLength) {
	                //     positionInPath %= totalPathLength;
	                //   } else if (positionInPath < 0) {
	                //     positionInPath += totalPathLength;
	                //   }
	                //   // it would probably much faster to send all the grapheme position for a line
	                //   // and calculate path position/angle at once.
	                //   this.setGraphemeOnPath(
	                //     positionInPath,
	                //     graphemeInfo,
	                //     startingPoint
	                //   );
	                //   positionInPath += graphemeInfo.kernedWidth;
	                // }
	            }
	        }
	        else {
	            for (var i = 0; i < lines.length; i++) {
	                // char width + letterSpacing
	                var lineWidth_1 = context.measureText(lines[i]).width +
	                    (lines[i].length - 1) * letterSpacing;
	                lineWidths[i] = lineWidth_1;
	                maxLineWidth = Math.max(maxLineWidth, lineWidth_1);
	            }
	            var width = maxLineWidth + lineWidth;
	            // if (dropShadow) {
	            //   width += dropShadowDistance;
	            // }
	            var lineHeight_1 = strokeHeight || fontProperties.fontSize + lineWidth;
	            var height = Math.max(lineHeight_1, fontProperties.fontSize + lineWidth) +
	                (lines.length - 1) * (lineHeight_1 + leading);
	            // if (dropShadow) {
	            //   height += dropShadowDistance;
	            // }
	            lineHeight_1 += leading;
	            // handle vertical text baseline
	            var offsetY_1 = 0;
	            if (textBaseline === 'middle') {
	                offsetY_1 = -height / 2;
	            }
	            else if (textBaseline === 'bottom' ||
	                textBaseline === 'alphabetic' ||
	                textBaseline === 'ideographic') {
	                offsetY_1 = -height;
	            }
	            else if (textBaseline === 'top' || textBaseline === 'hanging') {
	                offsetY_1 = 0;
	            }
	            return {
	                font: font,
	                width: width,
	                height: height,
	                lines: lines,
	                lineWidths: lineWidths,
	                lineHeight: lineHeight_1,
	                maxLineWidth: maxLineWidth,
	                fontProperties: fontProperties,
	                lineMetrics: lineWidths.map(function (width, i) {
	                    var offsetX = 0;
	                    // handle horizontal text align
	                    if (textAlign === 'center' || textAlign === 'middle') {
	                        offsetX -= width / 2;
	                    }
	                    else if (textAlign === 'right' || textAlign === 'end') {
	                        offsetX -= width;
	                    }
	                    return new Rectangle(offsetX - lineWidth / 2, offsetY_1 + i * lineHeight_1, width + lineWidth, lineHeight_1);
	                }),
	            };
	        }
	    };
	    TextService.prototype.setGraphemeOnPath = function () { };
	    TextService.prototype.wordWrap = function (text, parsedStyle, offscreenCanvas) {
	        var _this = this;
	        var _a = parsedStyle.wordWrapWidth, wordWrapWidth = _a === void 0 ? 0 : _a, letterSpacing = parsedStyle.letterSpacing, _b = parsedStyle.maxLines, maxLines = _b === void 0 ? Infinity : _b, textOverflow = parsedStyle.textOverflow;
	        var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
	        var maxWidth = wordWrapWidth + letterSpacing;
	        var ellipsis = '';
	        if (textOverflow === 'ellipsis') {
	            ellipsis = '...';
	        }
	        else if (textOverflow && textOverflow !== 'clip') {
	            ellipsis = textOverflow;
	        }
	        var lines = [];
	        var currentIndex = 0;
	        var currentWidth = 0;
	        var cache = {};
	        var calcWidth = function (char) {
	            return _this.getFromCache(char, letterSpacing, cache, context);
	        };
	        var ellipsisWidth = Array.from(ellipsis).reduce(function (prev, cur) {
	            return prev + calcWidth(cur);
	        }, 0);
	        var chars = Array.from(text);
	        for (var i = 0; i < chars.length; i++) {
	            var char = chars[i];
	            var prevChar = text[i - 1];
	            var nextChar = text[i + 1];
	            var charWidth = calcWidth(char);
	            if (this.isNewline(char)) {
	                currentIndex++;
	                // exceed maxLines, break immediately
	                if (currentIndex >= maxLines) {
	                    parsedStyle.isOverflowing = true;
	                    break;
	                }
	                currentWidth = 0;
	                lines[currentIndex] = '';
	                continue;
	            }
	            if (currentWidth > 0 && currentWidth + charWidth > maxWidth) {
	                if (currentIndex + 1 >= maxLines) {
	                    parsedStyle.isOverflowing = true;
	                    // If there is not enough space to display the string itself, it is clipped.
	                    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow#values
	                    if (ellipsisWidth > 0 && ellipsisWidth <= maxWidth) {
	                        // Backspace from line's end.
	                        var currentLineLength = lines[currentIndex].length;
	                        var lastLineWidth = 0;
	                        var lastLineIndex = currentLineLength;
	                        for (var i_1 = 0; i_1 < currentLineLength; i_1++) {
	                            var width = calcWidth(lines[currentIndex][i_1]);
	                            if (lastLineWidth + width + ellipsisWidth > maxWidth) {
	                                lastLineIndex = i_1;
	                                break;
	                            }
	                            lastLineWidth += width;
	                        }
	                        lines[currentIndex] =
	                            (lines[currentIndex] || '').slice(0, lastLineIndex) + ellipsis;
	                    }
	                    break;
	                }
	                currentIndex++;
	                currentWidth = 0;
	                lines[currentIndex] = '';
	                if (this.isBreakingSpace(char)) {
	                    continue;
	                }
	                if (!this.canBreakInLastChar(char)) {
	                    lines = this.trimToBreakable(lines);
	                    currentWidth = this.sumTextWidthByCache(lines[currentIndex] || '', cache);
	                }
	                if (this.shouldBreakByKinsokuShorui(char, nextChar)) {
	                    lines = this.trimByKinsokuShorui(lines);
	                    currentWidth += calcWidth(prevChar || '');
	                }
	            }
	            currentWidth += charWidth;
	            lines[currentIndex] = (lines[currentIndex] || '') + char;
	        }
	        return lines.join('\n');
	    };
	    TextService.prototype.isBreakingSpace = function (char) {
	        if (typeof char !== 'string') {
	            return false;
	        }
	        return TEXT_METRICS.BreakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
	    };
	    TextService.prototype.isNewline = function (char) {
	        if (typeof char !== 'string') {
	            return false;
	        }
	        return TEXT_METRICS.Newlines.indexOf(char.charCodeAt(0)) >= 0;
	    };
	    TextService.prototype.trimToBreakable = function (prev) {
	        var next = __spreadArray([], __read(prev), false);
	        var prevLine = next[next.length - 2];
	        var index = this.findBreakableIndex(prevLine);
	        if (index === -1 || !prevLine)
	            return next;
	        var trimmedChar = prevLine.slice(index, index + 1);
	        var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
	        var trimFrom = index + 1;
	        var trimTo = index + (isTrimmedWithSpace ? 0 : 1);
	        next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
	        next[next.length - 2] = prevLine.slice(0, trimTo);
	        return next;
	    };
	    TextService.prototype.canBreakInLastChar = function (char) {
	        if (char && LATIN_REGEX.test(char))
	            return false;
	        return true;
	    };
	    TextService.prototype.sumTextWidthByCache = function (text, cache) {
	        return text.split('').reduce(function (sum, c) {
	            if (!cache[c])
	                throw Error('cannot count the word without cache');
	            return sum + cache[c];
	        }, 0);
	    };
	    TextService.prototype.findBreakableIndex = function (line) {
	        for (var i = line.length - 1; i >= 0; i--) {
	            if (!LATIN_REGEX.test(line[i]))
	                return i;
	        }
	        return -1;
	    };
	    TextService.prototype.getFromCache = function (key, letterSpacing, cache, context) {
	        var width = cache[key];
	        if (typeof width !== 'number') {
	            var spacing = key.length * letterSpacing;
	            width = context.measureText(key).width + spacing;
	            cache[key] = width;
	        }
	        return width;
	    };
	    return TextService;
	}());

	var runtime = {};
	/**
	 * Replace with IoC container
	 */
	var geometryUpdaterFactory = (function () {
	    var _a;
	    var rectUpdater = new RectUpdater();
	    var polylineUpdater = new PolylineUpdater();
	    return _a = {},
	        _a[Shape.CIRCLE] = new CircleUpdater(),
	        _a[Shape.ELLIPSE] = new EllipseUpdater(),
	        _a[Shape.RECT] = rectUpdater,
	        _a[Shape.IMAGE] = rectUpdater,
	        _a[Shape.GROUP] = rectUpdater,
	        _a[Shape.LINE] = new LineUpdater(),
	        _a[Shape.TEXT] = new TextUpdater(runtime),
	        _a[Shape.POLYLINE] = polylineUpdater,
	        _a[Shape.POLYGON] = polylineUpdater,
	        _a[Shape.PATH] = new PathUpdater(),
	        _a[Shape.HTML] = null,
	        _a[Shape.MESH] = null,
	        _a;
	})();
	var CSSPropertySyntaxFactory = (function () {
	    var _a;
	    var color = new CSSPropertyColor();
	    var length = new CSSPropertyLengthOrPercentage();
	    return _a = {},
	        _a[PropertySyntax.PERCENTAGE] = null,
	        _a[PropertySyntax.NUMBER] = new CSSPropertyNumber(),
	        _a[PropertySyntax.ANGLE] = new CSSPropertyAngle(),
	        _a[PropertySyntax.DEFINED_PATH] = new CSSPropertyClipPath(),
	        _a[PropertySyntax.PAINT] = color,
	        _a[PropertySyntax.COLOR] = color,
	        _a[PropertySyntax.FILTER] = new CSSPropertyFilter(),
	        _a[PropertySyntax.LENGTH] = length,
	        _a[PropertySyntax.LENGTH_PERCENTAGE] = length,
	        _a[PropertySyntax.LENGTH_PERCENTAGE_12] = new CSSPropertyLengthOrPercentage12(),
	        _a[PropertySyntax.LENGTH_PERCENTAGE_14] = new CSSPropertyLengthOrPercentage14(),
	        _a[PropertySyntax.COORDINATE] = new CSSPropertyLocalPosition(),
	        _a[PropertySyntax.OFFSET_DISTANCE] = new CSSPropertyOffsetDistance(),
	        _a[PropertySyntax.OPACITY_VALUE] = new CSSPropertyOpacity(),
	        _a[PropertySyntax.PATH] = new CSSPropertyPath(),
	        _a[PropertySyntax.LIST_OF_POINTS] = new CSSPropertyPoints(),
	        _a[PropertySyntax.SHADOW_BLUR] = new CSSPropertyShadowBlur(),
	        _a[PropertySyntax.TEXT] = new CSSPropertyText(),
	        _a[PropertySyntax.TEXT_TRANSFORM] = new CSSPropertyTextTransform(),
	        _a[PropertySyntax.TRANSFORM] = new CSSPropertyTransform(),
	        _a[PropertySyntax.TRANSFORM_ORIGIN] = new CSSPropertyTransformOrigin(),
	        _a[PropertySyntax.Z_INDEX] = new CSSPropertyZIndex(),
	        _a[PropertySyntax.MARKER] = new CSSPropertyMarker(),
	        _a;
	})();
	var getGlobalThis = function () {
	    if (typeof globalThis !== 'undefined')
	        return globalThis;
	    if (typeof self !== 'undefined')
	        return self;
	    if (typeof window !== 'undefined')
	        return window;
	    // @ts-ignore
	    if (typeof global !== 'undefined')
	        return global;
	    // [!] Error: The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten
	    // @see https://rollupjs.org/troubleshooting/#error-this-is-undefined
	    // if (typeof this !== 'undefined') return this;
	    throw new Error('Unable to locate global `this`');
	};
	/**
	 * Camera
	 * `g-camera-api` will provide an advanced implementation
	 */
	runtime.CameraContribution = Camera;
	/**
	 * `g-web-animations-api` will provide an AnimationTimeline
	 */
	runtime.AnimationTimeline = null;
	runtime.EasingFunction = null;
	runtime.offscreenCanvas = new OffscreenCanvasCreator();
	runtime.nativeHTMLMap = new WeakMap();
	runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
	runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
	runtime.textService = new TextService(runtime);
	runtime.geometryUpdaterFactory = geometryUpdaterFactory;
	runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
	runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
	runtime.layoutRegistry = null;
	runtime.globalThis = getGlobalThis();
	runtime.enableCSSParsing = true;
	runtime.enableDataset = false;
	runtime.enableStyleSyntax = true;

	var entityCounter = 0;
	var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, '', '', '', 0, '', '');
	var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, '', '', '', 0, '', '');
	var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
	/**
	 * Has following capabilities:
	 * * Node insert/remove, eg. appendChild, removeChild, remove...
	 * * Query eg. querySelector getElementById...
	 * * Animation
	 */
	var Element = /** @class */ (function (_super) {
	    __extends(Element, _super);
	    function Element() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Unique id.
	         */
	        _this.entity = entityCounter++;
	        _this.renderable = {
	            bounds: undefined,
	            boundsDirty: true,
	            renderBounds: undefined,
	            renderBoundsDirty: true,
	            dirtyRenderBounds: undefined,
	            dirty: false,
	            proxyNodeName: undefined,
	        };
	        _this.cullable = {
	            strategy: Strategy.Standard,
	            visibilityPlaneMask: -1,
	            visible: true,
	            enable: true,
	        };
	        _this.transformable = {
	            dirtyFlag: false,
	            localDirtyFlag: false,
	            frozen: false,
	            localPosition: [0, 0, 0],
	            localRotation: [0, 0, 0, 1],
	            localScale: [1, 1, 1],
	            localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
	            localSkew: [0, 0],
	            position: [0, 0, 0],
	            rotation: [0, 0, 0, 1],
	            scaling: [1, 1, 1],
	            worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
	            origin: [0, 0, 0],
	        };
	        _this.sortable = {
	            dirty: false,
	            sorted: undefined,
	            renderOrder: 0,
	            dirtyChildren: [],
	            dirtyReason: undefined,
	        };
	        _this.geometry = {
	            contentBounds: undefined,
	            renderBounds: undefined,
	        };
	        _this.rBushNode = {
	            aabb: undefined,
	        };
	        /**
	         * https://developer.mozilla.org/zh-CN/docs/Web/API/Element/namespaceURI
	         */
	        _this.namespaceURI = 'g';
	        _this.scrollLeft = 0;
	        _this.scrollTop = 0;
	        /**
	         * We don't support border now
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientTop
	         */
	        _this.clientTop = 0;
	        _this.clientLeft = 0;
	        /**
	         * is destroyed or not
	         */
	        _this.destroyed = false;
	        /**
	         * compatible with `style`
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
	         */
	        _this.style = {};
	        _this.computedStyle = runtime.enableCSSParsing
	            ? {
	                anchor: unsetKeywordValue,
	                opacity: unsetKeywordValue,
	                fillOpacity: unsetKeywordValue,
	                strokeOpacity: unsetKeywordValue,
	                fill: unsetKeywordValue,
	                stroke: unsetKeywordValue,
	                transform: unsetKeywordValue,
	                transformOrigin: unsetKeywordValue,
	                visibility: unsetKeywordValue,
	                pointerEvents: unsetKeywordValue,
	                lineWidth: unsetKeywordValue,
	                lineCap: unsetKeywordValue,
	                lineJoin: unsetKeywordValue,
	                increasedLineWidthForHitTesting: unsetKeywordValue,
	                fontSize: unsetKeywordValue,
	                fontFamily: unsetKeywordValue,
	                fontStyle: unsetKeywordValue,
	                fontWeight: unsetKeywordValue,
	                fontVariant: unsetKeywordValue,
	                textAlign: unsetKeywordValue,
	                textBaseline: unsetKeywordValue,
	                textTransform: unsetKeywordValue,
	                zIndex: unsetKeywordValue,
	                filter: unsetKeywordValue,
	                shadowType: unsetKeywordValue,
	            }
	            : null;
	        /**
	         * Renderers will use these used values.
	         */
	        _this.parsedStyle = {
	        // opacity: '',
	        // fillOpacity: '',
	        // strokeOpacity: '',
	        // transformOrigin: '',
	        // visibility: '',
	        // pointerEvents: '',
	        // lineWidth: '',
	        // lineCap: '',
	        // lineJoin: '',
	        // increasedLineWidthForHitTesting: '',
	        // fontSize: '',
	        // fontFamily: '',
	        // fontStyle: '',
	        // fontWeight: '',
	        // fontVariant: '',
	        // textAlign: '',
	        // textBaseline: '',
	        // textTransform: '',
	        };
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes
	         */
	        _this.attributes = {};
	        return _this;
	    }
	    Object.defineProperty(Element.prototype, "className", {
	        /**
	         * used in `getElementsByClassName`
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
	         */
	        get: function () {
	            // @ts-ignore
	            return this.getAttribute('class') || '';
	        },
	        set: function (className) {
	            this.setAttribute('class', className);
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "classList", {
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
	         */
	        get: function () {
	            return this.className.split(' ').filter(function (c) { return c !== ''; });
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "tagName", {
	        get: function () {
	            return this.nodeName;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "children", {
	        get: function () {
	            return this.childNodes;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "childElementCount", {
	        get: function () {
	            return this.childNodes.length;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "firstElementChild", {
	        get: function () {
	            return this.firstChild;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "lastElementChild", {
	        get: function () {
	            return this.lastChild;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "parentElement", {
	        get: function () {
	            return this.parentNode;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "nextSibling", {
	        get: function () {
	            if (this.parentNode) {
	                var index = this.parentNode.childNodes.indexOf(this);
	                return this.parentNode.childNodes[index + 1] || null;
	            }
	            return null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "previousSibling", {
	        get: function () {
	            if (this.parentNode) {
	                var index = this.parentNode.childNodes.indexOf(this);
	                return this.parentNode.childNodes[index - 1] || null;
	            }
	            return null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Element.prototype.cloneNode = function (deep) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.appendChild = function (child, index) {
	        var _a;
	        if (child.destroyed) {
	            throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
	        }
	        runtime.sceneGraphService.attach(child, this, index);
	        if ((_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) {
	            this.ownerDocument.defaultView.mountChildren(child);
	        }
	        insertedEvent.relatedNode = this;
	        child.dispatchEvent(insertedEvent);
	        return child;
	    };
	    Element.prototype.insertBefore = function (newChild, refChild) {
	        if (!refChild) {
	            this.appendChild(newChild);
	        }
	        else {
	            var index = this.childNodes.indexOf(refChild);
	            this.appendChild(newChild, index - 1);
	        }
	        return newChild;
	    };
	    Element.prototype.replaceChild = function (newChild, oldChild) {
	        var index = this.childNodes.indexOf(oldChild);
	        this.removeChild(oldChild);
	        this.appendChild(newChild, index);
	        return oldChild;
	    };
	    Element.prototype.removeChild = function (child) {
	        var _a;
	        // should emit on itself before detach
	        removedEvent.relatedNode = this;
	        child.dispatchEvent(removedEvent);
	        if ((_a = child.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) {
	            child.ownerDocument.defaultView.unmountChildren(child);
	        }
	        // remove from scene graph
	        runtime.sceneGraphService.detach(child);
	        return child;
	    };
	    /**
	     * Remove all children which can be appended to its original parent later again.
	     */
	    Element.prototype.removeChildren = function () {
	        for (var i = this.childNodes.length - 1; i >= 0; i--) {
	            var child = this.childNodes[i];
	            this.removeChild(child);
	        }
	    };
	    /**
	     * Recursively destroy all children which can not be appended to its original parent later again.
	     */
	    Element.prototype.destroyChildren = function () {
	        for (var i = this.childNodes.length - 1; i >= 0; i--) {
	            var child = this.childNodes[i];
	            if (child.childNodes.length) {
	                child.destroyChildren();
	            }
	            child.destroy();
	        }
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
	     */
	    Element.prototype.matches = function (selector) {
	        return runtime.sceneGraphService.matches(selector, this);
	    };
	    Element.prototype.getElementById = function (id) {
	        return runtime.sceneGraphService.querySelector("#".concat(id), this);
	    };
	    Element.prototype.getElementsByName = function (name) {
	        return runtime.sceneGraphService.querySelectorAll("[name=\"".concat(name, "\"]"), this);
	    };
	    Element.prototype.getElementsByClassName = function (className) {
	        return runtime.sceneGraphService.querySelectorAll(".".concat(className), this);
	    };
	    Element.prototype.getElementsByTagName = function (tagName) {
	        return runtime.sceneGraphService.querySelectorAll(tagName, this);
	    };
	    Element.prototype.querySelector = function (selectors) {
	        return runtime.sceneGraphService.querySelector(selectors, this);
	    };
	    Element.prototype.querySelectorAll = function (selectors) {
	        return runtime.sceneGraphService.querySelectorAll(selectors, this);
	    };
	    /**
	     * should traverses the element and its parents (heading toward the document root)
	     * until it finds a node that matches the specified CSS selector.
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
	     */
	    Element.prototype.closest = function (selectors) {
	        var el = this;
	        do {
	            if (runtime.sceneGraphService.matches(selectors, el))
	                return el;
	            el = el.parentElement;
	        } while (el !== null);
	        return null;
	    };
	    /**
	     * search in scene group, but should not include itself
	     */
	    Element.prototype.find = function (filter) {
	        var _this = this;
	        var target = null;
	        this.forEach(function (object) {
	            if (object !== _this && filter(object)) {
	                target = object;
	                return true;
	            }
	            return false;
	        });
	        return target;
	    };
	    Element.prototype.findAll = function (filter) {
	        var _this = this;
	        var objects = [];
	        this.forEach(function (object) {
	            if (object !== _this && filter(object)) {
	                objects.push(object);
	            }
	        });
	        return objects;
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
	     */
	    Element.prototype.after = function () {
	        var _this = this;
	        var nodes = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            nodes[_i] = arguments[_i];
	        }
	        if (this.parentNode) {
	            var index_1 = this.parentNode.childNodes.indexOf(this);
	            nodes.forEach(function (node, i) { var _a; return (_a = _this.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(node, index_1 + i + 1); });
	        }
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
	     */
	    Element.prototype.before = function () {
	        var _a;
	        var nodes = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            nodes[_i] = arguments[_i];
	        }
	        if (this.parentNode) {
	            var index = this.parentNode.childNodes.indexOf(this);
	            var _b = __read(nodes), first = _b[0], rest = _b.slice(1);
	            this.parentNode.appendChild(first, index);
	            (_a = first).after.apply(_a, __spreadArray([], __read(rest), false));
	        }
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
	     */
	    Element.prototype.replaceWith = function () {
	        var nodes = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            nodes[_i] = arguments[_i];
	        }
	        this.after.apply(this, __spreadArray([], __read(nodes), false));
	        this.remove();
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
	     */
	    Element.prototype.append = function () {
	        var _this = this;
	        var nodes = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            nodes[_i] = arguments[_i];
	        }
	        nodes.forEach(function (node) { return _this.appendChild(node); });
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
	     */
	    Element.prototype.prepend = function () {
	        var _this = this;
	        var nodes = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            nodes[_i] = arguments[_i];
	        }
	        nodes.forEach(function (node, i) { return _this.appendChild(node, i); });
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
	     */
	    Element.prototype.replaceChildren = function () {
	        var nodes = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            nodes[_i] = arguments[_i];
	        }
	        while (this.childNodes.length && this.firstChild) {
	            this.removeChild(this.firstChild);
	        }
	        this.append.apply(this, __spreadArray([], __read(nodes), false));
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
	     */
	    Element.prototype.remove = function () {
	        if (this.parentNode) {
	            return this.parentNode.removeChild(this);
	        }
	        return this;
	    };
	    Element.prototype.destroy = function () {
	        // destroy itself before remove
	        this.dispatchEvent(destroyEvent);
	        // remove from scenegraph first
	        this.remove();
	        // remove event listeners
	        this.emitter.removeAllListeners();
	        this.destroyed = true;
	    };
	    Element.prototype.getGeometryBounds = function () {
	        return runtime.sceneGraphService.getGeometryBounds(this);
	    };
	    Element.prototype.getRenderBounds = function () {
	        return runtime.sceneGraphService.getBounds(this, true);
	    };
	    /**
	     * get bounds in world space, account for children
	     */
	    Element.prototype.getBounds = function () {
	        return runtime.sceneGraphService.getBounds(this);
	    };
	    /**
	     * get bounds in local space, account for children
	     */
	    Element.prototype.getLocalBounds = function () {
	        return runtime.sceneGraphService.getLocalBounds(this);
	    };
	    /**
	     * account for context's bounds in client space,
	     * but not accounting for children
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
	     */
	    Element.prototype.getBoundingClientRect = function () {
	        return runtime.sceneGraphService.getBoundingClientRect(this);
	    };
	    /**
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
	     */
	    Element.prototype.getClientRects = function () {
	        return [this.getBoundingClientRect()];
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
	     * eg. circle.computedStyleMap().get('fill');
	     */
	    Element.prototype.computedStyleMap = function () {
	        return new Map(Object.entries(this.computedStyle));
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
	     */
	    Element.prototype.getAttributeNames = function () {
	        return Object.keys(this.attributes);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
	     */
	    Element.prototype.getAttribute = function (name) {
	        // @see https://github.com/antvis/G/issues/1267
	        if (isSymbol(name)) {
	            return runtime.enableCSSParsing ? null : undefined;
	        }
	        var value = this.attributes[name];
	        if (value === undefined) {
	            var attributeName = formatAttributeName(name);
	            value = this.attributes[attributeName];
	            // if the given attribute does not exist, the value returned will either be null or ""
	            return runtime.enableCSSParsing ? (isNil(value) ? null : value) : value;
	        }
	        else {
	            return value;
	        }
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
	     */
	    Element.prototype.hasAttribute = function (qualifiedName) {
	        return this.getAttributeNames().includes(qualifiedName);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
	     */
	    Element.prototype.hasAttributes = function () {
	        return !!this.getAttributeNames().length;
	    };
	    /**
	     * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
	     */
	    Element.prototype.removeAttribute = function (attributeName) {
	        this.setAttribute(attributeName, null);
	        delete this.attributes[attributeName];
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
	     */
	    Element.prototype.setAttribute = function (attributeName, value, force) {
	        this.attributes[attributeName] = value;
	    };
	    Element.prototype.getAttributeNS = function (namespace, localName) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.getAttributeNode = function (qualifiedName) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.getAttributeNodeNS = function (namespace, localName) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.hasAttributeNS = function (namespace, localName) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.removeAttributeNS = function (namespace, localName) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.removeAttributeNode = function (attr) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.setAttributeNS = function (namespace, qualifiedName, value) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.setAttributeNode = function (attr) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.setAttributeNodeNS = function (attr) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Element.prototype.toggleAttribute = function (qualifiedName, force) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    return Element;
	}(Node$1));

	function isDisplayObject(value) {
	    return !!(value === null || value === void 0 ? void 0 : value.nodeName);
	}
	var mutationEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
	var DEFAULT_STYLE_PROPS = {
	    anchor: '',
	    opacity: '',
	    fillOpacity: '',
	    strokeOpacity: '',
	    fill: '',
	    stroke: '',
	    transform: '',
	    transformOrigin: '',
	    visibility: '',
	    pointerEvents: '',
	    lineWidth: '',
	    lineCap: '',
	    lineJoin: '',
	    increasedLineWidthForHitTesting: '',
	    fontSize: '',
	    fontFamily: '',
	    fontStyle: '',
	    fontWeight: '',
	    fontVariant: '',
	    textAlign: '',
	    textBaseline: '',
	    textTransform: '',
	    zIndex: '',
	    filter: '',
	    shadowType: '',
	};
	var DEFAULT_PARSED_STYLE_PROPS = {
	    anchor: [0, 0],
	    fill: noneColor,
	    stroke: noneColor,
	    transform: [],
	    zIndex: 0,
	    filter: [],
	    shadowType: 'outer',
	    miterLimit: 10,
	};
	var DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED = __assign(__assign({}, DEFAULT_PARSED_STYLE_PROPS), { opacity: 1, fillOpacity: 1, strokeOpacity: 1, visibility: 'visible', pointerEvents: 'auto', lineWidth: 1, lineCap: 'butt', lineJoin: 'miter', increasedLineWidthForHitTesting: 0, fillRule: 'nonzero' });
	var INHERITABLE_BASE_STYLE_PROPS = [
	    'opacity',
	    'fillOpacity',
	    'strokeOpacity',
	    'transformOrigin',
	    'visibility',
	    'pointerEvents',
	    'lineWidth',
	    'lineCap',
	    'lineJoin',
	    'increasedLineWidthForHitTesting',
	];
	var INHERITABLE_STYLE_PROPS = __spreadArray(__spreadArray([], __read(INHERITABLE_BASE_STYLE_PROPS), false), [
	    'fontSize',
	    'fontFamily',
	    'fontStyle',
	    'fontWeight',
	    'fontVariant',
	    'textAlign',
	    'textBaseline',
	    'textTransform',
	], false);
	var DATASET_PREFIX = 'data-';
	/**
	 * prototype chains: DisplayObject -> Element -> Node -> EventTarget
	 *
	 * mixins: Animatable, Transformable, Visible
	 * @see https://github.com/tannerntannern/ts-mixer/blob/master/README.md#mixing-generic-classes
	 *
	 * Provide abilities in scene graph, such as:
	 * * transform `translate/rotate/scale`
	 * * add/remove child
	 * * visibility and z-index
	 *
	 * Those abilities are implemented with those components: `Transform/Sortable/Visible`.
	 *
	 * Emit following events:
	 * * init
	 * * destroy
	 * * attributeChanged
	 */
	var DisplayObject = /** @class */ (function (_super) {
	    __extends(DisplayObject, _super);
	    function DisplayObject(config) {
	        var _this = this;
	        var _a;
	        _this = _super.call(this) || this;
	        _this.isCustomElement = false;
	        _this.isMutationObserved = false;
	        /**
	         * push to active animations after calling `animate()`
	         */
	        _this.activeAnimations = [];
	        /**
	         * Use `this.style.clipPath` instead.
	         * @deprecated
	         */
	        _this.getClip = function () {
	            return this.style.clipPath || null;
	        };
	        // assign name, id to config
	        // eg. group.get('name')
	        _this.config = config;
	        // compatible with G 3.0
	        _this.config.interactive = (_a = _this.config.capture) !== null && _a !== void 0 ? _a : _this.config.interactive;
	        // init scene graph node
	        _this.id = _this.config.id || '';
	        _this.name = _this.config.name || '';
	        if (_this.config.className || _this.config.class) {
	            _this.className = _this.config.className || _this.config.class;
	        }
	        _this.nodeName = _this.config.type || Shape.GROUP;
	        // compatible with G 3.0
	        _this.config.style =
	            _this.config.style || _this.config.attrs || {};
	        Object.assign(_this.config.style, _this.config.attrs);
	        // this.config.style = {
	        //   // ...DEFAULT_STYLE_PROPS,
	        //   ...this.config.style,
	        //   ...this.config.attrs,
	        // };
	        if (_this.config.visible != null) {
	            _this.config.style.visibility =
	                _this.config.visible === false ? 'hidden' : 'visible';
	        }
	        if (_this.config.interactive != null) {
	            _this.config.style.pointerEvents =
	                _this.config.interactive === false ? 'none' : 'auto';
	        }
	        // merge parsed value
	        Object.assign(_this.parsedStyle, runtime.enableCSSParsing
	            ? DEFAULT_PARSED_STYLE_PROPS
	            : DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED, _this.config.initialParsedStyle);
	        if (runtime.enableCSSParsing) {
	            Object.assign(_this.attributes, DEFAULT_STYLE_PROPS);
	        }
	        // start to process attributes
	        _this.initAttributes(_this.config.style);
	        var Proxy = runtime.globalThis.Proxy
	            ? runtime.globalThis.Proxy
	            : function () { };
	        if (runtime.enableDataset) {
	            _this.dataset = new Proxy({}, {
	                get: function (target, name) {
	                    var formattedName = "".concat(DATASET_PREFIX).concat(kebabize(name));
	                    if (target[formattedName] !== undefined) {
	                        return target[formattedName];
	                    }
	                    return _this.getAttribute(formattedName);
	                },
	                set: function (_, prop, value) {
	                    _this.setAttribute("".concat(DATASET_PREFIX).concat(kebabize(prop)), value);
	                    return true;
	                },
	            });
	        }
	        if (runtime.enableStyleSyntax) {
	            _this.style = new Proxy(
	            // @ts-ignore
	            {
	                // ...this.attributes,
	                setProperty: function (propertyName, value) {
	                    _this.setAttribute(propertyName, value);
	                },
	                getPropertyValue: function (propertyName) {
	                    return _this.getAttribute(propertyName);
	                },
	                removeProperty: function (propertyName) {
	                    _this.removeAttribute(propertyName);
	                },
	                item: function () {
	                    return '';
	                },
	            }, {
	                get: function (target, name) {
	                    if (target[name] !== undefined) {
	                        // if (name in target) {
	                        return target[name];
	                    }
	                    return _this.getAttribute(name);
	                },
	                set: function (_, prop, value) {
	                    _this.setAttribute(prop, value);
	                    return true;
	                },
	            });
	        }
	        return _this;
	    }
	    DisplayObject.prototype.destroy = function () {
	        _super.prototype.destroy.call(this);
	        // stop all active animations
	        this.getAnimations().forEach(function (animation) {
	            animation.cancel();
	        });
	        // FIXME
	        // this.renderable = null;
	        // this.cullable = null;
	        // this.transformable = null;
	        // this.rBushNode = null;
	        // this.geometry = null;
	        // this.sortable = null;
	    };
	    DisplayObject.prototype.cloneNode = function (deep, customCloneFunc) {
	        var clonedStyle = __assign({}, this.attributes);
	        for (var attributeName in clonedStyle) {
	            var attribute = clonedStyle[attributeName];
	            // @see https://github.com/antvis/G/issues/1095
	            if (isDisplayObject(attribute) &&
	                // share the same clipPath if possible
	                attributeName !== 'clipPath' &&
	                attributeName !== 'offsetPath' &&
	                attributeName !== 'textPath') {
	                clonedStyle[attributeName] = attribute.cloneNode(deep);
	            }
	            // TODO: clone other type
	            if (customCloneFunc) {
	                clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
	            }
	        }
	        var cloned = new this.constructor({
	            // copy id & name
	            // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode#notes
	            id: this.id,
	            name: this.name,
	            className: this.name,
	            interactive: this.interactive,
	            style: clonedStyle,
	        });
	        // apply transform
	        cloned.setLocalTransform(this.getLocalTransform());
	        if (deep) {
	            this.children.forEach(function (child) {
	                // skip marker
	                if (!child.style.isMarker) {
	                    var clonedChild = child.cloneNode(deep);
	                    cloned.appendChild(clonedChild);
	                }
	            });
	        }
	        return cloned;
	    };
	    DisplayObject.prototype.initAttributes = function (attributes) {
	        if (attributes === void 0) { attributes = {}; }
	        var renderable = this.renderable;
	        var options = {
	            forceUpdateGeometry: true,
	            // usedAttributes:
	            //   // only Group / Text should account for text relative props
	            //   this.tagName === Shape.GROUP || this.tagName === Shape.TEXT
	            //     ? INHERITABLE_STYLE_PROPS
	            //     : INHERITABLE_BASE_STYLE_PROPS,
	        };
	        if (runtime.enableCSSParsing) {
	            // @ts-ignore
	            options.usedAttributes = INHERITABLE_STYLE_PROPS;
	        }
	        // account for FCP, process properties as less as possible
	        var formattedAttributes = {};
	        for (var name_1 in attributes) {
	            var attributeName = formatAttributeName(name_1);
	            formattedAttributes[attributeName] = attributes[name_1];
	        }
	        runtime.styleValueRegistry.processProperties(this, formattedAttributes, options);
	        // redraw at next frame
	        renderable.dirty = true;
	    };
	    DisplayObject.prototype.setAttribute = function (name, value, force) {
	        if (force === void 0) { force = false; }
	        var attributeName = formatAttributeName(name);
	        // ignore undefined value
	        if (isUndefined(value)) {
	            return;
	        }
	        if (force || value !== this.attributes[attributeName]) {
	            this.internalSetAttribute(attributeName, value);
	            _super.prototype.setAttribute.call(this, attributeName, value);
	        }
	    };
	    /**
	     * called when attributes get changed or initialized
	     */
	    DisplayObject.prototype.internalSetAttribute = function (name, value, parseOptions) {
	        var _a;
	        if (parseOptions === void 0) { parseOptions = {}; }
	        var renderable = this.renderable;
	        var oldValue = this.attributes[name];
	        var oldParsedValue = this.parsedStyle[name];
	        runtime.styleValueRegistry.processProperties(this, (_a = {},
	            _a[name] = value,
	            _a), parseOptions);
	        // redraw at next frame
	        renderable.dirty = true;
	        var newParsedValue = this.parsedStyle[name];
	        if (this.isConnected) {
	            mutationEvent.relatedNode = this;
	            mutationEvent.prevValue = oldValue;
	            mutationEvent.newValue = value;
	            mutationEvent.attrName = name;
	            mutationEvent.prevParsedValue = oldParsedValue;
	            mutationEvent.newParsedValue = newParsedValue;
	            if (this.isMutationObserved) {
	                this.dispatchEvent(mutationEvent);
	            }
	            else {
	                mutationEvent.target = this;
	                this.ownerDocument.defaultView.dispatchEvent(mutationEvent, true);
	            }
	        }
	        if (((this.isCustomElement && this.isConnected) || !this.isCustomElement) &&
	            this.attributeChangedCallback) {
	            this.attributeChangedCallback(name, oldValue, value, oldParsedValue, newParsedValue);
	        }
	    };
	    // #region transformable
	    /**
	     * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
	     *
	     * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
	     * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
	     */
	    DisplayObject.prototype.getBBox = function () {
	        var aabb = this.getBounds();
	        var _a = __read(aabb.getMin(), 2), left = _a[0], top = _a[1];
	        var _b = __read(aabb.getMax(), 2), right = _b[0], bottom = _b[1];
	        return new Rectangle(left, top, right - left, bottom - top);
	    };
	    DisplayObject.prototype.setOrigin = function (position, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        runtime.sceneGraphService.setOrigin(this, createVec3(position, y, z));
	        return this;
	    };
	    DisplayObject.prototype.getOrigin = function () {
	        return runtime.sceneGraphService.getOrigin(this);
	    };
	    /**
	     * set position in world space
	     */
	    DisplayObject.prototype.setPosition = function (position, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        runtime.sceneGraphService.setPosition(this, createVec3(position, y, z));
	        return this;
	    };
	    /**
	     * set position in local space
	     */
	    DisplayObject.prototype.setLocalPosition = function (position, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y, z));
	        return this;
	    };
	    /**
	     * translate in world space
	     */
	    DisplayObject.prototype.translate = function (position, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        runtime.sceneGraphService.translate(this, createVec3(position, y, z));
	        return this;
	    };
	    /**
	     * translate in local space
	     */
	    DisplayObject.prototype.translateLocal = function (position, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        runtime.sceneGraphService.translateLocal(this, createVec3(position, y, z));
	        return this;
	    };
	    DisplayObject.prototype.getPosition = function () {
	        return runtime.sceneGraphService.getPosition(this);
	    };
	    DisplayObject.prototype.getLocalPosition = function () {
	        return runtime.sceneGraphService.getLocalPosition(this);
	    };
	    /**
	     * compatible with G 3.0
	     *
	     * scaling in local space
	     * scale(10) = scale(10, 10, 10)
	     *
	     * we can't set scale in world space
	     */
	    DisplayObject.prototype.scale = function (scaling, y, z) {
	        return this.scaleLocal(scaling, y, z);
	    };
	    DisplayObject.prototype.scaleLocal = function (scaling, y, z) {
	        if (typeof scaling === 'number') {
	            y = y || scaling;
	            z = z || scaling;
	            scaling = createVec3(scaling, y, z);
	        }
	        runtime.sceneGraphService.scaleLocal(this, scaling);
	        return this;
	    };
	    /**
	     * set scaling in local space
	     */
	    DisplayObject.prototype.setLocalScale = function (scaling, y, z) {
	        if (typeof scaling === 'number') {
	            y = y || scaling;
	            z = z || scaling;
	            scaling = createVec3(scaling, y, z);
	        }
	        runtime.sceneGraphService.setLocalScale(this, scaling);
	        return this;
	    };
	    /**
	     * get scaling in local space
	     */
	    DisplayObject.prototype.getLocalScale = function () {
	        return runtime.sceneGraphService.getLocalScale(this);
	    };
	    /**
	     * get scaling in world space
	     */
	    DisplayObject.prototype.getScale = function () {
	        return runtime.sceneGraphService.getScale(this);
	    };
	    /**
	     * only return degrees of Z axis in world space
	     */
	    DisplayObject.prototype.getEulerAngles = function () {
	        var _a = __read(getEuler(create$2(), runtime.sceneGraphService.getWorldTransform(this)), 3), ez = _a[2];
	        return rad2deg(ez);
	    };
	    /**
	     * only return degrees of Z axis in local space
	     */
	    DisplayObject.prototype.getLocalEulerAngles = function () {
	        var _a = __read(getEuler(create$2(), runtime.sceneGraphService.getLocalRotation(this)), 3), ez = _a[2];
	        return rad2deg(ez);
	    };
	    /**
	     * set euler angles(degrees) in world space
	     */
	    DisplayObject.prototype.setEulerAngles = function (z) {
	        runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
	        return this;
	    };
	    /**
	     * set euler angles(degrees) in local space
	     */
	    DisplayObject.prototype.setLocalEulerAngles = function (z) {
	        runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
	        return this;
	    };
	    DisplayObject.prototype.rotateLocal = function (x, y, z) {
	        if (isNil(y) && isNil(z)) {
	            runtime.sceneGraphService.rotateLocal(this, 0, 0, x);
	        }
	        else {
	            runtime.sceneGraphService.rotateLocal(this, x, y, z);
	        }
	        return this;
	    };
	    DisplayObject.prototype.rotate = function (x, y, z) {
	        if (isNil(y) && isNil(z)) {
	            runtime.sceneGraphService.rotate(this, 0, 0, x);
	        }
	        else {
	            runtime.sceneGraphService.rotate(this, x, y, z);
	        }
	        return this;
	    };
	    DisplayObject.prototype.setRotation = function (rotation, y, z, w) {
	        runtime.sceneGraphService.setRotation(this, rotation, y, z, w);
	        return this;
	    };
	    DisplayObject.prototype.setLocalRotation = function (rotation, y, z, w) {
	        runtime.sceneGraphService.setLocalRotation(this, rotation, y, z, w);
	        return this;
	    };
	    DisplayObject.prototype.setLocalSkew = function (skew, y) {
	        runtime.sceneGraphService.setLocalSkew(this, skew, y);
	        return this;
	    };
	    DisplayObject.prototype.getRotation = function () {
	        return runtime.sceneGraphService.getRotation(this);
	    };
	    DisplayObject.prototype.getLocalRotation = function () {
	        return runtime.sceneGraphService.getLocalRotation(this);
	    };
	    DisplayObject.prototype.getLocalSkew = function () {
	        return runtime.sceneGraphService.getLocalSkew(this);
	    };
	    DisplayObject.prototype.getLocalTransform = function () {
	        return runtime.sceneGraphService.getLocalTransform(this);
	    };
	    DisplayObject.prototype.getWorldTransform = function () {
	        return runtime.sceneGraphService.getWorldTransform(this);
	    };
	    DisplayObject.prototype.setLocalTransform = function (transform) {
	        runtime.sceneGraphService.setLocalTransform(this, transform);
	        return this;
	    };
	    DisplayObject.prototype.resetLocalTransform = function () {
	        runtime.sceneGraphService.resetLocalTransform(this);
	    };
	    // #endregion transformable
	    // #region animatable
	    /**
	     * returns an array of all Animation objects affecting this element
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
	     */
	    DisplayObject.prototype.getAnimations = function () {
	        return this.activeAnimations;
	    };
	    /**
	     * create an animation with WAAPI
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
	     */
	    DisplayObject.prototype.animate = function (keyframes, options) {
	        var _a;
	        var timeline = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.timeline;
	        if (timeline) {
	            return timeline.play(this, keyframes, options);
	        }
	        return null;
	    };
	    // #endregion animatable
	    // #region visible
	    /**
	     * shortcut for Used value of `visibility`
	     */
	    DisplayObject.prototype.isVisible = function () {
	        var _a;
	        return ((_a = this.parsedStyle) === null || _a === void 0 ? void 0 : _a.visibility) === 'visible';
	    };
	    Object.defineProperty(DisplayObject.prototype, "interactive", {
	        get: function () {
	            return this.isInteractive();
	        },
	        set: function (b) {
	            this.style.pointerEvents = b ? 'auto' : 'none';
	        },
	        enumerable: false,
	        configurable: true
	    });
	    DisplayObject.prototype.isInteractive = function () {
	        var _a;
	        return ((_a = this.parsedStyle) === null || _a === void 0 ? void 0 : _a.pointerEvents) !== 'none';
	    };
	    DisplayObject.prototype.isCulled = function () {
	        return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
	    };
	    /**
	     * bring to front in current group
	     */
	    DisplayObject.prototype.toFront = function () {
	        if (this.parentNode) {
	            this.style.zIndex =
	                Math.max.apply(Math, __spreadArray([], __read(this.parentNode.children.map(function (child) {
	                    return Number(child.style.zIndex);
	                })), false)) + 1;
	        }
	        return this;
	    };
	    /**
	     * send to back in current group
	     */
	    DisplayObject.prototype.toBack = function () {
	        if (this.parentNode) {
	            this.style.zIndex =
	                Math.min.apply(Math, __spreadArray([], __read(this.parentNode.children.map(function (child) {
	                    return Number(child.style.zIndex);
	                })), false)) - 1;
	        }
	        return this;
	    };
	    // #endregion visible
	    // #region deprecated
	    /**
	     * compatible with G 3.0
	     * @alias object.config
	     * @deprecated
	     */
	    DisplayObject.prototype.getConfig = function () {
	        return this.config;
	    };
	    DisplayObject.prototype.attr = function () {
	        var _this = this;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var _a = __read(args, 2), name = _a[0], value = _a[1];
	        if (!name) {
	            return this.attributes;
	        }
	        if (isObject(name)) {
	            Object.keys(name).forEach(function (key) {
	                _this.setAttribute(key, name[key]);
	            });
	            return this;
	        }
	        if (args.length === 2) {
	            this.setAttribute(name, value);
	            return this;
	        }
	        return this.attributes[name];
	    };
	    /**
	     * return 3x3 matrix in world space
	     * @deprecated
	     */
	    DisplayObject.prototype.getMatrix = function (transformMat4) {
	        var transform = transformMat4 || this.getWorldTransform();
	        var _a = __read(getTranslation(create$2(), transform), 2), tx = _a[0], ty = _a[1];
	        var _b = __read(getScaling(create$2(), transform), 2), sx = _b[0], sy = _b[1];
	        var rotation = getRotation(create$4(), transform);
	        var _c = __read(getEuler(create$2(), rotation), 3), eux = _c[0], euz = _c[2];
	        // gimbal lock at 90 degrees
	        return fromRotationTranslationScale$1(eux || euz, tx, ty, sx, sy);
	    };
	    /**
	     * return 3x3 matrix in local space
	     * @deprecated
	     */
	    DisplayObject.prototype.getLocalMatrix = function () {
	        return this.getMatrix(this.getLocalTransform());
	    };
	    /**
	     * set 3x3 matrix in world space
	     * @deprecated
	     */
	    DisplayObject.prototype.setMatrix = function (mat) {
	        var _a = __read(decompose(mat), 5), tx = _a[0], ty = _a[1], scalingX = _a[2], scalingY = _a[3], angle = _a[4];
	        this.setEulerAngles(angle)
	            .setPosition(tx, ty)
	            .setLocalScale(scalingX, scalingY);
	    };
	    /**
	     * set 3x3 matrix in local space
	     * @deprecated
	     */
	    DisplayObject.prototype.setLocalMatrix = function (mat) {
	        var _a = __read(decompose(mat), 5), tx = _a[0], ty = _a[1], scalingX = _a[2], scalingY = _a[3], angle = _a[4];
	        this.setLocalEulerAngles(angle)
	            .setLocalPosition(tx, ty)
	            .setLocalScale(scalingX, scalingY);
	    };
	    /**
	     * Use `visibility: visible` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.show = function () {
	        if (runtime.enableCSSParsing) {
	            this.style.visibility = 'visible';
	        }
	        else {
	            this.forEach(function (object) {
	                object.style.visibility = 'visible';
	            });
	        }
	    };
	    /**
	     * Use `visibility: hidden` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.hide = function () {
	        if (runtime.enableCSSParsing) {
	            this.style.visibility = 'hidden';
	        }
	        else {
	            this.forEach(function (object) {
	                object.style.visibility = 'hidden';
	            });
	        }
	    };
	    /**
	     * Use `childElementCount` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.getCount = function () {
	        return this.childElementCount;
	    };
	    /**
	     * Use `parentElement` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.getParent = function () {
	        return this.parentElement;
	    };
	    /**
	     * Use `children` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.getChildren = function () {
	        return this.children;
	    };
	    /**
	     * Use `firstElementChild` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.getFirst = function () {
	        return this.firstElementChild;
	    };
	    /**
	     * Use `lastElementChild` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.getLast = function () {
	        return this.lastElementChild;
	    };
	    /**
	     * Use `this.children[index]` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.getChildByIndex = function (index) {
	        return this.children[index] || null;
	    };
	    /**
	     * Use `appendChild` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.add = function (child, index) {
	        return this.appendChild(child, index);
	    };
	    /**
	     * Use `this.style.clipPath` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.setClip = function (clipPath) {
	        this.style.clipPath = clipPath;
	    };
	    /**
	     * @deprecated
	     */
	    DisplayObject.prototype.set = function (name, value) {
	        // @ts-ignore
	        this.config[name] = value;
	    };
	    /**
	     * @deprecated
	     */
	    DisplayObject.prototype.get = function (name) {
	        return this.config[name];
	    };
	    /**
	     * Use `setPosition` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.moveTo = function (position, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        this.setPosition(position, y, z);
	        return this;
	    };
	    /**
	     * Use `setPosition` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.move = function (position, y, z) {
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        this.setPosition(position, y, z);
	        return this;
	    };
	    /**
	     * Use `this.style.zIndex` instead.
	     * @deprecated
	     */
	    DisplayObject.prototype.setZIndex = function (zIndex) {
	        this.style.zIndex = zIndex;
	        return this;
	    };
	    return DisplayObject;
	}(Element));

	/**
	 * holds useful CSS-related methods.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS
	 *
	 * * CSS Typed OM @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/factory_functions
	 * * register property @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
	 * * CSS Layout API
	 */
	var CSS = {
	    /**
	     * <number>
	     * @see https://drafts.csswg.org/css-values-4/#number-value
	     */
	    number: function (n) {
	        return new CSSUnitValue(n);
	    },
	    /**
	     * <percentage>
	     * @see https://drafts.csswg.org/css-values-4/#percentage-value
	     */
	    percent: function (n) {
	        return new CSSUnitValue(n, '%');
	    },
	    /**
	     * <length>
	     */
	    px: function (n) {
	        return new CSSUnitValue(n, 'px');
	    },
	    /**
	     * <length>
	     */
	    em: function (n) {
	        return new CSSUnitValue(n, 'em');
	    },
	    rem: function (n) {
	        return new CSSUnitValue(n, 'rem');
	    },
	    /**
	     * <angle>
	     */
	    deg: function (n) {
	        return new CSSUnitValue(n, 'deg');
	    },
	    /**
	     * <angle>
	     */
	    grad: function (n) {
	        return new CSSUnitValue(n, 'grad');
	    },
	    /**
	     * <angle>
	     */
	    rad: function (n) {
	        return new CSSUnitValue(n, 'rad');
	    },
	    /**
	     * <angle>
	     */
	    turn: function (n) {
	        return new CSSUnitValue(n, 'turn');
	    },
	    /**
	     * <time>
	     */
	    s: function (n) {
	        return new CSSUnitValue(n, 's');
	    },
	    /**
	     * <time>
	     */
	    ms: function (n) {
	        return new CSSUnitValue(n, 'ms');
	    },
	    /**
	     * CSS Properties & Values API
	     *
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
	     * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
	     */
	    registerProperty: function (definition) {
	        var name = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
	        runtime.styleValueRegistry.registerMetadata({
	            n: name,
	            inh: inherits,
	            int: interpolable,
	            d: initialValue,
	            syntax: syntax,
	        });
	    },
	    /**
	     * CSS Layout API
	     * register layout
	     *
	     * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
	     * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
	     */
	    registerLayout: function (name, clazz) {
	        runtime.layoutRegistry.registerLayout(name, clazz);
	    },
	};

	var Circle = /** @class */ (function (_super) {
	    __extends(Circle, _super);
	    function Circle(_a) {
	        if (_a === void 0) { _a = {}; }
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        return _super.call(this, __assign({ type: Shape.CIRCLE, style: runtime.enableCSSParsing
	                ? __assign({ cx: '', cy: '', r: '' }, style) : __assign({}, style), initialParsedStyle: {
	                anchor: [0.5, 0.5],
	                transformOrigin: runtime.enableCSSParsing
	                    ? null
	                    : [PECENTAGE_50, PECENTAGE_50],
	            } }, rest)) || this;
	    }
	    return Circle;
	}(DisplayObject));

	/**
	 * shadow root
	 * @see https://yuque.antfin-inc.com/antv/czqvg5/pgqipg
	 */
	var CustomElement = /** @class */ (function (_super) {
	    __extends(CustomElement, _super);
	    // private shadowNodes: DisplayObject[] = [];
	    function CustomElement(_a) {
	        if (_a === void 0) { _a = {}; }
	        var _this = this;
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        _this = _super.call(this, __assign({ style: runtime.enableCSSParsing
	                ? __assign({ x: '', y: '' }, style) : __assign({}, style) }, rest)) || this;
	        // static get observedAttributes(): string[] {
	        //   return [];
	        // }
	        _this.isCustomElement = true;
	        return _this;
	    }
	    return CustomElement;
	}(DisplayObject));

	var Ellipse = /** @class */ (function (_super) {
	    __extends(Ellipse, _super);
	    function Ellipse(_a) {
	        if (_a === void 0) { _a = {}; }
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        return _super.call(this, __assign({ type: Shape.ELLIPSE, style: runtime.enableCSSParsing
	                ? __assign({ cx: '', cy: '', rx: '', ry: '' }, style) : __assign({}, style), initialParsedStyle: {
	                anchor: [0.5, 0.5],
	                transformOrigin: runtime.enableCSSParsing
	                    ? null
	                    : [PECENTAGE_50, PECENTAGE_50],
	            } }, rest)) || this;
	    }
	    return Ellipse;
	}(DisplayObject));

	/**
	 * its attributes are inherited by its children.
	 * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/g
	 *
	 * @example
	 * <g fill="white" stroke="green" stroke-width="5">
	    <circle cx="40" cy="40" r="25" />
	    <circle cx="60" cy="60" r="25" />
	  </g>
	 */
	var Group = /** @class */ (function (_super) {
	    __extends(Group, _super);
	    function Group(_a) {
	        if (_a === void 0) { _a = {}; }
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        return _super.call(this, __assign({ type: Shape.GROUP, style: runtime.enableCSSParsing
	                ? __assign({ x: '', y: '', width: '', height: '' }, style) : __assign({}, style) }, rest)) || this;
	    }
	    return Group;
	}(DisplayObject));

	/**
	 * HTML container
	 * @see https://github.com/pmndrs/drei#html
	 */
	var HTML = /** @class */ (function (_super) {
	    __extends(HTML, _super);
	    function HTML(_a) {
	        if (_a === void 0) { _a = {}; }
	        var _this = this;
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        _this = _super.call(this, __assign({ type: Shape.HTML, style: runtime.enableCSSParsing
	                ? __assign({ x: '', y: '', width: 'auto', height: 'auto', innerHTML: '' }, style) : __assign({}, style) }, rest)) || this;
	        _this.cullable.enable = false;
	        return _this;
	    }
	    /**
	     * return wrapper HTMLElement
	     * * <div> in g-webgl/canvas
	     * * <foreignObject> in g-svg
	     */
	    HTML.prototype.getDomElement = function () {
	        return this.parsedStyle.$el;
	    };
	    /**
	     * override with $el.getBoundingClientRect
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
	     */
	    HTML.prototype.getBoundingClientRect = function () {
	        if (this.parsedStyle.$el) {
	            return this.parsedStyle.$el.getBoundingClientRect();
	        }
	        else {
	            var _a = this.parsedStyle, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
	            return new Rectangle(x, y, width, height);
	        }
	    };
	    HTML.prototype.getClientRects = function () {
	        return [this.getBoundingClientRect()];
	    };
	    HTML.prototype.getBounds = function () {
	        var _a, _b;
	        var clientRect = this.getBoundingClientRect();
	        // calc context's offset
	        // @ts-ignore
	        var canvasRect = (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();
	        var aabb = new AABB();
	        var minX = clientRect.left - ((canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) || 0);
	        var minY = clientRect.top - ((canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) || 0);
	        aabb.setMinMax([minX, minY, 0], [minX + clientRect.width, minY + clientRect.height, 0]);
	        return aabb;
	    };
	    HTML.prototype.getLocalBounds = function () {
	        if (this.parentNode) {
	            var parentInvert = invert(create$1(), this.parentNode.getWorldTransform());
	            var bounds = this.getBounds();
	            if (!AABB.isEmpty(bounds)) {
	                var localBounds = new AABB();
	                localBounds.setFromTransformedAABB(bounds, parentInvert);
	                return localBounds;
	            }
	        }
	        return this.getBounds();
	    };
	    return HTML;
	}(DisplayObject));

	var Image = /** @class */ (function (_super) {
	    __extends(Image, _super);
	    function Image(_a) {
	        if (_a === void 0) { _a = {}; }
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        return _super.call(this, __assign({ type: Shape.IMAGE, style: runtime.enableCSSParsing
	                ? __assign({ x: '', y: '', img: '', width: '', height: '' }, style) : __assign({}, style) }, rest)) || this;
	    }
	    return Image;
	}(DisplayObject));

	/**
	 * Create a line connecting two points.
	 * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/line
	 *
	 * Also support for using marker.
	 */
	var Line = /** @class */ (function (_super) {
	    __extends(Line, _super);
	    function Line(_a) {
	        if (_a === void 0) { _a = {}; }
	        var _this = this;
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        _this = _super.call(this, __assign({ type: Shape.LINE, style: __assign({ x1: 0, y1: 0, x2: 0, y2: 0, z1: 0, z2: 0, isBillboard: false }, style) }, rest)) || this;
	        _this.markerStartAngle = 0;
	        _this.markerEndAngle = 0;
	        var _b = _this.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd;
	        if (markerStart && isDisplayObject(markerStart)) {
	            _this.markerStartAngle = markerStart.getLocalEulerAngles();
	            _this.appendChild(markerStart);
	        }
	        if (markerEnd && isDisplayObject(markerEnd)) {
	            _this.markerEndAngle = markerEnd.getLocalEulerAngles();
	            _this.appendChild(markerEnd);
	        }
	        _this.transformMarker(true);
	        _this.transformMarker(false);
	        return _this;
	    }
	    Line.prototype.attributeChangedCallback = function (attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
	        if (attrName === 'x1' ||
	            attrName === 'y1' ||
	            attrName === 'x2' ||
	            attrName === 'y2' ||
	            attrName === 'markerStartOffset' ||
	            attrName === 'markerEndOffset') {
	            this.transformMarker(true);
	            this.transformMarker(false);
	        }
	        else if (attrName === 'markerStart') {
	            if (prevParsedValue && isDisplayObject(prevParsedValue)) {
	                this.markerStartAngle = 0;
	                prevParsedValue.remove();
	            }
	            // CSSKeyword 'unset'
	            if (newParsedValue && isDisplayObject(newParsedValue)) {
	                this.markerStartAngle = newParsedValue.getLocalEulerAngles();
	                this.appendChild(newParsedValue);
	                this.transformMarker(true);
	            }
	        }
	        else if (attrName === 'markerEnd') {
	            if (prevParsedValue && isDisplayObject(prevParsedValue)) {
	                this.markerEndAngle = 0;
	                prevParsedValue.remove();
	            }
	            if (newParsedValue && isDisplayObject(newParsedValue)) {
	                this.markerEndAngle = newParsedValue.getLocalEulerAngles();
	                this.appendChild(newParsedValue);
	                this.transformMarker(false);
	            }
	        }
	    };
	    Line.prototype.transformMarker = function (isStart) {
	        var _a = this.parsedStyle, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset, x1 = _a.x1, x2 = _a.x2, y1 = _a.y1, y2 = _a.y2, defX = _a.defX, defY = _a.defY;
	        var marker = isStart ? markerStart : markerEnd;
	        if (!marker || !isDisplayObject(marker)) {
	            return;
	        }
	        var rad = 0;
	        var x;
	        var y;
	        var ox;
	        var oy;
	        var offset;
	        var originalAngle;
	        if (isStart) {
	            ox = x1 - defX;
	            oy = y1 - defY;
	            x = x2 - x1;
	            y = y2 - y1;
	            offset = markerStartOffset || 0;
	            originalAngle = this.markerStartAngle;
	        }
	        else {
	            ox = x2 - defX;
	            oy = y2 - defY;
	            x = x1 - x2;
	            y = y1 - y2;
	            offset = markerEndOffset || 0;
	            originalAngle = this.markerEndAngle;
	        }
	        rad = Math.atan2(y, x);
	        // account for markerOffset
	        marker.setLocalEulerAngles((rad * 180) / Math.PI + originalAngle);
	        marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
	    };
	    Line.prototype.getPoint = function (ratio, inWorldSpace) {
	        if (inWorldSpace === void 0) { inWorldSpace = false; }
	        // TODO: account for z1/z2 in 3D line
	        var _a = this.parsedStyle, x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2, defX = _a.defX, defY = _a.defY;
	        var _b = pointAt$3(x1, y1, x2, y2, ratio), x = _b.x, y = _b.y;
	        var transformed = transformMat4(create$2(), fromValues$2(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
	        // apply local transformation
	        return new Point(transformed[0], transformed[1]);
	    };
	    Line.prototype.getPointAtLength = function (distance, inWorldSpace) {
	        if (inWorldSpace === void 0) { inWorldSpace = false; }
	        return this.getPoint(distance / this.getTotalLength(), inWorldSpace);
	    };
	    Line.prototype.getTotalLength = function () {
	        // TODO: account for z1/z2 in 3D line
	        var _a = this.parsedStyle, x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
	        return length$4(x1, y1, x2, y2);
	    };
	    return Line;
	}(DisplayObject));

	var Path = /** @class */ (function (_super) {
	    __extends(Path, _super);
	    function Path(_a) {
	        if (_a === void 0) { _a = {}; }
	        var _this = this;
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        _this = _super.call(this, __assign({ type: Shape.PATH, style: runtime.enableCSSParsing
	                ? __assign({ path: '', miterLimit: '' }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing
	                ? null
	                : {
	                    miterLimit: 4,
	                    path: __assign({}, EMPTY_PARSED_PATH),
	                } }, rest)) || this;
	        _this.markerStartAngle = 0;
	        _this.markerEndAngle = 0;
	        /**
	         * markers placed at the mid
	         */
	        _this.markerMidList = [];
	        var _b = _this.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerMid = _b.markerMid;
	        if (markerStart && isDisplayObject(markerStart)) {
	            _this.markerStartAngle = markerStart.getLocalEulerAngles();
	            _this.appendChild(markerStart);
	        }
	        if (markerMid && isDisplayObject(markerMid)) {
	            _this.placeMarkerMid(markerMid);
	        }
	        if (markerEnd && isDisplayObject(markerEnd)) {
	            _this.markerEndAngle = markerEnd.getLocalEulerAngles();
	            _this.appendChild(markerEnd);
	        }
	        _this.transformMarker(true);
	        _this.transformMarker(false);
	        return _this;
	    }
	    Path.prototype.attributeChangedCallback = function (attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
	        if (attrName === 'path') {
	            // recalc markers
	            this.transformMarker(true);
	            this.transformMarker(false);
	            this.placeMarkerMid(this.parsedStyle.markerMid);
	        }
	        else if (attrName === 'markerStartOffset' ||
	            attrName === 'markerEndOffset') {
	            this.transformMarker(true);
	            this.transformMarker(false);
	        }
	        else if (attrName === 'markerStart') {
	            if (prevParsedValue && isDisplayObject(prevParsedValue)) {
	                this.markerStartAngle = 0;
	                prevParsedValue.remove();
	            }
	            // CSSKeyword 'unset'
	            if (newParsedValue && isDisplayObject(newParsedValue)) {
	                this.markerStartAngle = newParsedValue.getLocalEulerAngles();
	                this.appendChild(newParsedValue);
	                this.transformMarker(true);
	            }
	        }
	        else if (attrName === 'markerEnd') {
	            if (prevParsedValue && isDisplayObject(prevParsedValue)) {
	                this.markerEndAngle = 0;
	                prevParsedValue.remove();
	            }
	            if (newParsedValue && isDisplayObject(newParsedValue)) {
	                this.markerEndAngle = newParsedValue.getLocalEulerAngles();
	                this.appendChild(newParsedValue);
	                this.transformMarker(false);
	            }
	        }
	        else if (attrName === 'markerMid') {
	            this.placeMarkerMid(newParsedValue);
	        }
	    };
	    Path.prototype.transformMarker = function (isStart) {
	        var _a = this.parsedStyle, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset, defX = _a.defX, defY = _a.defY;
	        var marker = isStart ? markerStart : markerEnd;
	        if (!marker || !isDisplayObject(marker)) {
	            return;
	        }
	        var rad = 0;
	        var x;
	        var y;
	        var ox;
	        var oy;
	        var offset;
	        var originalAngle;
	        if (isStart) {
	            var _b = __read(this.getStartTangent(), 2), p1 = _b[0], p2 = _b[1];
	            ox = p2[0] - defX;
	            oy = p2[1] - defY;
	            x = p1[0] - p2[0];
	            y = p1[1] - p2[1];
	            offset = markerStartOffset || 0;
	            originalAngle = this.markerStartAngle;
	        }
	        else {
	            var _c = __read(this.getEndTangent(), 2), p1 = _c[0], p2 = _c[1];
	            ox = p2[0] - defX;
	            oy = p2[1] - defY;
	            x = p1[0] - p2[0];
	            y = p1[1] - p2[1];
	            offset = markerEndOffset || 0;
	            originalAngle = this.markerEndAngle;
	        }
	        rad = Math.atan2(y, x);
	        // account for markerOffset
	        marker.setLocalEulerAngles((rad * 180) / Math.PI + originalAngle);
	        marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
	    };
	    Path.prototype.placeMarkerMid = function (marker) {
	        var _a = this.parsedStyle, segments = _a.path.segments, defX = _a.defX, defY = _a.defY;
	        // clear all existed markers
	        this.markerMidList.forEach(function (marker) {
	            marker.remove();
	        });
	        if (marker && isDisplayObject(marker)) {
	            for (var i = 1; i < segments.length - 1; i++) {
	                var _b = __read(segments[i].currentPoint, 2), ox = _b[0], oy = _b[1];
	                var cloned = i === 1 ? marker : marker.cloneNode(true);
	                this.markerMidList.push(cloned);
	                this.appendChild(cloned);
	                cloned.setLocalPosition(ox - defX, oy - defY);
	                // TODO: orient of marker
	            }
	        }
	    };
	    /**
	     * Returns the total length of the path.
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
	     */
	    Path.prototype.getTotalLength = function () {
	        return getOrCalculatePathTotalLength(this);
	    };
	    /**
	     * Returns the point at a given distance along the path.
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
	     */
	    Path.prototype.getPointAtLength = function (distance, inWorldSpace) {
	        if (inWorldSpace === void 0) { inWorldSpace = false; }
	        var _a = this.parsedStyle, defX = _a.defX, defY = _a.defY, absolutePath = _a.path.absolutePath;
	        var _b = getPointAtLength(absolutePath, distance), x = _b.x, y = _b.y;
	        var transformed = transformMat4(create$2(), fromValues$2(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
	        // apply local transformation
	        return new Point(transformed[0], transformed[1]);
	    };
	    /**
	     * Returns the point at a given ratio of the total length in path.
	     */
	    Path.prototype.getPoint = function (ratio, inWorldSpace) {
	        if (inWorldSpace === void 0) { inWorldSpace = false; }
	        return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
	    };
	    /**
	     * Get start tangent vector
	     */
	    Path.prototype.getStartTangent = function () {
	        var segments = this.parsedStyle.path.segments;
	        var result = [];
	        if (segments.length > 1) {
	            var startPoint = segments[0].currentPoint;
	            var endPoint = segments[1].currentPoint;
	            var tangent = segments[1].startTangent;
	            result = [];
	            if (tangent) {
	                result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
	                result.push([startPoint[0], startPoint[1]]);
	            }
	            else {
	                result.push([endPoint[0], endPoint[1]]);
	                result.push([startPoint[0], startPoint[1]]);
	            }
	        }
	        return result;
	    };
	    /**
	     * Get end tangent vector
	     */
	    Path.prototype.getEndTangent = function () {
	        var segments = this.parsedStyle.path.segments;
	        var length = segments.length;
	        var result = [];
	        if (length > 1) {
	            var startPoint = segments[length - 2].currentPoint;
	            var endPoint = segments[length - 1].currentPoint;
	            var tangent = segments[length - 1].endTangent;
	            result = [];
	            if (tangent) {
	                result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
	                result.push([endPoint[0], endPoint[1]]);
	            }
	            else {
	                result.push([startPoint[0], startPoint[1]]);
	                result.push([endPoint[0], endPoint[1]]);
	            }
	        }
	        return result;
	    };
	    return Path;
	}(DisplayObject));

	var Polygon = /** @class */ (function (_super) {
	    __extends(Polygon, _super);
	    function Polygon(_a) {
	        if (_a === void 0) { _a = {}; }
	        var _this = this;
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        _this = _super.call(this, __assign({ type: Shape.POLYGON, style: runtime.enableCSSParsing
	                ? __assign({ points: '', miterLimit: '', isClosed: true }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing
	                ? null
	                : {
	                    points: {
	                        points: [],
	                        totalLength: 0,
	                        segments: [],
	                    },
	                    miterLimit: 4,
	                    isClosed: true,
	                } }, rest)) || this;
	        _this.markerStartAngle = 0;
	        _this.markerEndAngle = 0;
	        /**
	         * markers placed at the mid
	         */
	        _this.markerMidList = [];
	        var _b = _this.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerMid = _b.markerMid;
	        if (markerStart && isDisplayObject(markerStart)) {
	            _this.markerStartAngle = markerStart.getLocalEulerAngles();
	            _this.appendChild(markerStart);
	        }
	        if (markerMid && isDisplayObject(markerMid)) {
	            _this.placeMarkerMid(markerMid);
	        }
	        if (markerEnd && isDisplayObject(markerEnd)) {
	            _this.markerEndAngle = markerEnd.getLocalEulerAngles();
	            _this.appendChild(markerEnd);
	        }
	        _this.transformMarker(true);
	        _this.transformMarker(false);
	        return _this;
	    }
	    Polygon.prototype.attributeChangedCallback = function (attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
	        if (attrName === 'points') {
	            // recalc markers
	            this.transformMarker(true);
	            this.transformMarker(false);
	            this.placeMarkerMid(this.parsedStyle.markerMid);
	        }
	        else if (attrName === 'markerStartOffset' ||
	            attrName === 'markerEndOffset') {
	            this.transformMarker(true);
	            this.transformMarker(false);
	        }
	        else if (attrName === 'markerStart') {
	            if (prevParsedValue && isDisplayObject(prevParsedValue)) {
	                this.markerStartAngle = 0;
	                prevParsedValue.remove();
	            }
	            // CSSKeyword 'unset'
	            if (newParsedValue && isDisplayObject(newParsedValue)) {
	                this.markerStartAngle = newParsedValue.getLocalEulerAngles();
	                this.appendChild(newParsedValue);
	                this.transformMarker(true);
	            }
	        }
	        else if (attrName === 'markerEnd') {
	            if (prevParsedValue && isDisplayObject(prevParsedValue)) {
	                this.markerEndAngle = 0;
	                prevParsedValue.remove();
	            }
	            if (newParsedValue && isDisplayObject(newParsedValue)) {
	                this.markerEndAngle = newParsedValue.getLocalEulerAngles();
	                this.appendChild(newParsedValue);
	                this.transformMarker(false);
	            }
	        }
	        else if (attrName === 'markerMid') {
	            this.placeMarkerMid(newParsedValue);
	        }
	    };
	    Polygon.prototype.transformMarker = function (isStart) {
	        var _a = this.parsedStyle, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset, points = _a.points.points, defX = _a.defX, defY = _a.defY;
	        var marker = isStart ? markerStart : markerEnd;
	        if (!marker || !isDisplayObject(marker)) {
	            return;
	        }
	        var rad = 0;
	        var x;
	        var y;
	        var ox;
	        var oy;
	        var offset;
	        var originalAngle;
	        ox = points[0][0] - defX;
	        oy = points[0][1] - defY;
	        if (isStart) {
	            x = points[1][0] - points[0][0];
	            y = points[1][1] - points[0][1];
	            offset = markerStartOffset || 0;
	            originalAngle = this.markerStartAngle;
	        }
	        else {
	            var length_1 = points.length;
	            if (!this.parsedStyle.isClosed) {
	                ox = points[length_1 - 1][0] - defX;
	                oy = points[length_1 - 1][1] - defY;
	                x = points[length_1 - 2][0] - points[length_1 - 1][0];
	                y = points[length_1 - 2][1] - points[length_1 - 1][1];
	            }
	            else {
	                x = points[length_1 - 1][0] - points[0][0];
	                y = points[length_1 - 1][1] - points[0][1];
	            }
	            offset = markerEndOffset || 0;
	            originalAngle = this.markerEndAngle;
	        }
	        rad = Math.atan2(y, x);
	        // account for markerOffset
	        marker.setLocalEulerAngles((rad * 180) / Math.PI + originalAngle);
	        marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
	    };
	    Polygon.prototype.placeMarkerMid = function (marker) {
	        var _a = this.parsedStyle, points = _a.points.points, defX = _a.defX, defY = _a.defY;
	        // clear all existed markers
	        this.markerMidList.forEach(function (marker) {
	            marker.remove();
	        });
	        this.markerMidList = [];
	        if (marker && isDisplayObject(marker)) {
	            for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
	                var ox = points[i][0] - defX;
	                var oy = points[i][1] - defY;
	                var cloned = i === 1 ? marker : marker.cloneNode(true);
	                this.markerMidList.push(cloned);
	                this.appendChild(cloned);
	                cloned.setLocalPosition(ox, oy);
	                // TODO: orient of marker
	            }
	        }
	    };
	    return Polygon;
	}(DisplayObject));

	/**
	 * Polyline inherits the marker-related capabilities of Polygon.
	 */
	var Polyline = /** @class */ (function (_super) {
	    __extends(Polyline, _super);
	    function Polyline(_a) {
	        if (_a === void 0) { _a = {}; }
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        return _super.call(this, __assign({ type: Shape.POLYLINE, style: runtime.enableCSSParsing
	                ? __assign({ points: '', miterLimit: '', isClosed: false }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing
	                ? null
	                : {
	                    points: {
	                        points: [],
	                        totalLength: 0,
	                        segments: [],
	                    },
	                    miterLimit: 4,
	                    isClosed: false,
	                } }, rest)) || this;
	    }
	    Polyline.prototype.getTotalLength = function () {
	        return this.parsedStyle.points.totalLength;
	    };
	    Polyline.prototype.getPointAtLength = function (distance, inWorldSpace) {
	        if (inWorldSpace === void 0) { inWorldSpace = false; }
	        return this.getPoint(distance / this.getTotalLength(), inWorldSpace);
	    };
	    Polyline.prototype.getPoint = function (ratio, inWorldSpace) {
	        if (inWorldSpace === void 0) { inWorldSpace = false; }
	        var _a = this.parsedStyle, defX = _a.defX, defY = _a.defY, _b = _a.points, points = _b.points, segments = _b.segments;
	        var subt = 0;
	        var index = 0;
	        segments.forEach(function (v, i) {
	            if (ratio >= v[0] && ratio <= v[1]) {
	                subt = (ratio - v[0]) / (v[1] - v[0]);
	                index = i;
	            }
	        });
	        var _c = pointAt$3(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt), x = _c.x, y = _c.y;
	        var transformed = transformMat4(create$2(), fromValues$2(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
	        // apply local transformation
	        return new Point(transformed[0], transformed[1]);
	    };
	    Polyline.prototype.getStartTangent = function () {
	        var points = this.parsedStyle.points.points;
	        var result = [];
	        result.push([points[1][0], points[1][1]]);
	        result.push([points[0][0], points[0][1]]);
	        return result;
	    };
	    Polyline.prototype.getEndTangent = function () {
	        var points = this.parsedStyle.points.points;
	        var l = points.length - 1;
	        var result = [];
	        result.push([points[l - 1][0], points[l - 1][1]]);
	        result.push([points[l][0], points[l][1]]);
	        return result;
	    };
	    return Polyline;
	}(Polygon));

	var Rect = /** @class */ (function (_super) {
	    __extends(Rect, _super);
	    function Rect(_a) {
	        if (_a === void 0) { _a = {}; }
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        return _super.call(this, __assign({ type: Shape.RECT, style: runtime.enableCSSParsing
	                ? __assign({ x: '', y: '', width: '', height: '', radius: '' }, style) : __assign({}, style) }, rest)) || this;
	    }
	    return Rect;
	}(DisplayObject));

	/**
	 * <text> @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextElement
	 */
	var Text = /** @class */ (function (_super) {
	    __extends(Text, _super);
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement#constants
	     */
	    // LENGTHADJUST_SPACING: number = 1;
	    // LENGTHADJUST_SPACINGANDGLYPHS: number = 2;
	    // LENGTHADJUST_UNKNOWN: number = 0;
	    function Text(_a) {
	        if (_a === void 0) { _a = {}; }
	        var style = _a.style, rest = __rest(_a, ["style"]);
	        return _super.call(this, __assign({ type: Shape.TEXT, style: runtime.enableCSSParsing
	                ? __assign({ x: '', y: '', text: '', fontSize: '', fontFamily: '', fontStyle: '', fontWeight: '', fontVariant: '', textAlign: '', textBaseline: '', textTransform: '', fill: 'black', letterSpacing: '', lineHeight: '', miterLimit: '', 
	                    // whiteSpace: 'pre',
	                    wordWrap: false, wordWrapWidth: 0, leading: 0, dx: '', dy: '', isBillboard: false, sizeAttenuation: true }, style) : __assign({ fill: 'black' }, style), initialParsedStyle: runtime.enableCSSParsing
	                ? {}
	                : {
	                    x: 0,
	                    y: 0,
	                    fontSize: 16,
	                    fontFamily: 'sans-serif',
	                    fontStyle: 'normal',
	                    fontWeight: 'normal',
	                    fontVariant: 'normal',
	                    lineHeight: 0,
	                    letterSpacing: 0,
	                    textBaseline: 'alphabetic',
	                    textAlign: 'start',
	                    wordWrap: false,
	                    wordWrapWidth: 0,
	                    leading: 0,
	                    dx: 0,
	                    dy: 0,
	                    isBillboard: false,
	                    sizeAttenuation: true,
	                } }, rest)) || this;
	    }
	    // lengthAdjust: SVGAnimatedEnumeration;
	    // textLength: SVGAnimatedLength;
	    // getCharNumAtPosition(point?: DOMPointInit): number {
	    //   throw new Error('Method not implemented.');
	    // }
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement
	     */
	    Text.prototype.getComputedTextLength = function () {
	        var _a;
	        return ((_a = this.parsedStyle.metrics) === null || _a === void 0 ? void 0 : _a.maxLineWidth) || 0;
	    };
	    // getEndPositionOfChar(charnum: number): DOMPoint {
	    //   throw new Error('Method not implemented.');
	    // }
	    // getExtentOfChar(charnum: number): DOMRect {
	    //   throw new Error('Method not implemented.');
	    // }
	    // getNumberOfChars(): number {
	    //   throw new Error('Method not implemented.');
	    // }
	    // getRotationOfChar(charnum: number): number {
	    //   throw new Error('Method not implemented.');
	    // }
	    // getStartPositionOfChar(charnum: number): DOMPoint {
	    //   throw new Error('Method not implemented.');
	    // }
	    // getSubStringLength(charnum: number, nchars: number): number {
	    //   throw new Error('Method not implemented.');
	    // }
	    // selectSubString(charnum: number, nchars: number): void {
	    //   throw new Error('Method not implemented.');
	    // }
	    Text.prototype.getLineBoundingRects = function () {
	        var _a;
	        return ((_a = this.parsedStyle.metrics) === null || _a === void 0 ? void 0 : _a.lineMetrics) || [];
	    };
	    Text.prototype.isOverflowing = function () {
	        return !!this.parsedStyle.isOverflowing;
	    };
	    return Text;
	}(DisplayObject));

	/**
	 * canvas.customElements
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry
	 */
	var CustomElementRegistry = /** @class */ (function () {
	    function CustomElementRegistry() {
	        this.registry = {};
	        this.define(Shape.CIRCLE, Circle);
	        this.define(Shape.ELLIPSE, Ellipse);
	        this.define(Shape.RECT, Rect);
	        this.define(Shape.IMAGE, Image);
	        this.define(Shape.LINE, Line);
	        this.define(Shape.GROUP, Group);
	        this.define(Shape.PATH, Path);
	        this.define(Shape.POLYGON, Polygon);
	        this.define(Shape.POLYLINE, Polyline);
	        this.define(Shape.TEXT, Text);
	        this.define(Shape.HTML, HTML);
	    }
	    CustomElementRegistry.prototype.define = function (name, constructor) {
	        this.registry[name] = constructor;
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
	     */
	    CustomElementRegistry.prototype.get = function (name) {
	        return this.registry[name];
	    };
	    return CustomElementRegistry;
	}());

	/**
	 * the entry of DOM tree
	 * Document -> Node -> EventTarget
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document
	 */
	var Document = /** @class */ (function (_super) {
	    __extends(Document, _super);
	    function Document() {
	        var _this = _super.call(this) || this;
	        /**
	         * only document has defaultView, points to canvas,
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView
	         */
	        _this.defaultView = null;
	        _this.ownerDocument = null;
	        _this.nodeName = 'document';
	        // create timeline
	        try {
	            _this.timeline = new runtime.AnimationTimeline(_this);
	        }
	        catch (e) { }
	        /**
	         * for inherited properties, the initial value is used on the root element only,
	         * as long as no specified value is supplied.
	         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial_value
	         */
	        var initialStyle = {};
	        BUILT_IN_PROPERTIES.forEach(function (_a) {
	            var n = _a.n, inh = _a.inh, d = _a.d;
	            if (inh && d) {
	                initialStyle[n] = isFunction$1(d) ? d(Shape.GROUP) : d;
	            }
	        });
	        // like <html> in DOM tree
	        _this.documentElement = new Group({
	            id: 'g-root',
	            style: initialStyle,
	        });
	        _this.documentElement.ownerDocument = _this;
	        _this.documentElement.parentNode = _this;
	        _this.childNodes = [_this.documentElement];
	        return _this;
	    }
	    Object.defineProperty(Document.prototype, "children", {
	        get: function () {
	            return this.childNodes;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Document.prototype, "childElementCount", {
	        get: function () {
	            return this.childNodes.length;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Document.prototype, "firstElementChild", {
	        get: function () {
	            return this.firstChild;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Document.prototype, "lastElementChild", {
	        get: function () {
	            return this.lastChild;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * @example const circle = document.createElement('circle', { style: { r: 10 } });
	     */
	    Document.prototype.createElement = function (tagName, options) {
	        // @observablehq/plot will create <svg>
	        if (tagName === 'svg') {
	            return this.documentElement;
	        }
	        // d3 will use <tspan>
	        var clazz = this.defaultView.customElements.get(tagName);
	        if (!clazz) {
	            console.warn('Unsupported tagName: ', tagName);
	            clazz = tagName === 'tspan' ? Text : Group;
	        }
	        var shape = new clazz(options);
	        shape.ownerDocument = this;
	        return shape;
	    };
	    Document.prototype.createElementNS = function (namespaceURI, tagName, options) {
	        return this.createElement(tagName, options);
	    };
	    Document.prototype.cloneNode = function (deep) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Document.prototype.destroy = function () {
	        try {
	            this.documentElement.destroyChildren();
	            this.timeline.destroy();
	        }
	        catch (e) { }
	    };
	    /**
	     * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
	     */
	    Document.prototype.elementsFromBBox = function (minX, minY, maxX, maxY) {
	        var rBush = this.defaultView.context.rBushRoot;
	        var rBushNodes = rBush.search({ minX: minX, minY: minY, maxX: maxX, maxY: maxY });
	        var hitTestList = [];
	        rBushNodes.forEach(function (_a) {
	            var displayObject = _a.displayObject;
	            var pointerEvents = displayObject.parsedStyle.pointerEvents;
	            // account for `visibility`
	            // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
	            var isVisibilityAffected = [
	                'auto',
	                'visiblepainted',
	                'visiblefill',
	                'visiblestroke',
	                'visible',
	            ].includes(pointerEvents);
	            if ((!isVisibilityAffected ||
	                (isVisibilityAffected && displayObject.isVisible())) &&
	                !displayObject.isCulled() &&
	                displayObject.isInteractive()) {
	                hitTestList.push(displayObject);
	            }
	        });
	        // find group with max z-index
	        hitTestList.sort(function (a, b) { return b.sortable.renderOrder - a.sortable.renderOrder; });
	        return hitTestList;
	    };
	    Document.prototype.elementFromPointSync = function (x, y) {
	        var _a = this.defaultView.canvas2Viewport({
	            x: x,
	            y: y,
	        }), viewportX = _a.x, viewportY = _a.y;
	        var _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
	        // outside canvas' viewport
	        if (viewportX < 0 ||
	            viewportY < 0 ||
	            viewportX > width ||
	            viewportY > height) {
	            return null;
	        }
	        var _c = this.defaultView.viewport2Client({
	            x: viewportX,
	            y: viewportY,
	        }), clientX = _c.x, clientY = _c.y;
	        var picked = this.defaultView
	            .getRenderingService()
	            .hooks.pickSync.call({
	            topmost: true,
	            position: {
	                x: x,
	                y: y,
	                viewportX: viewportX,
	                viewportY: viewportY,
	                clientX: clientX,
	                clientY: clientY,
	            },
	            picked: [],
	        }).picked;
	        return (picked && picked[0]) || this.documentElement;
	    };
	    /**
	     * Do picking with API instead of triggering interactive events.
	     *
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
	     */
	    Document.prototype.elementFromPoint = function (x, y) {
	        return __awaiter(this, void 0, void 0, function () {
	            var _a, viewportX, viewportY, _b, width, height, _c, clientX, clientY, picked;
	            return __generator(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        _a = this.defaultView.canvas2Viewport({
	                            x: x,
	                            y: y,
	                        }), viewportX = _a.x, viewportY = _a.y;
	                        _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
	                        // outside canvas' viewport
	                        if (viewportX < 0 ||
	                            viewportY < 0 ||
	                            viewportX > width ||
	                            viewportY > height) {
	                            return [2 /*return*/, null];
	                        }
	                        _c = this.defaultView.viewport2Client({
	                            x: viewportX,
	                            y: viewportY,
	                        }), clientX = _c.x, clientY = _c.y;
	                        return [4 /*yield*/, this.defaultView
	                                .getRenderingService()
	                                .hooks.pick.promise({
	                                topmost: true,
	                                position: {
	                                    x: x,
	                                    y: y,
	                                    viewportX: viewportX,
	                                    viewportY: viewportY,
	                                    clientX: clientX,
	                                    clientY: clientY,
	                                },
	                                picked: [],
	                            })];
	                    case 1:
	                        picked = (_d.sent()).picked;
	                        return [2 /*return*/, (picked && picked[0]) || this.documentElement];
	                }
	            });
	        });
	    };
	    Document.prototype.elementsFromPointSync = function (x, y) {
	        var _a = this.defaultView.canvas2Viewport({
	            x: x,
	            y: y,
	        }), viewportX = _a.x, viewportY = _a.y;
	        var _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
	        // outside canvas' viewport
	        if (viewportX < 0 ||
	            viewportY < 0 ||
	            viewportX > width ||
	            viewportY > height) {
	            return [];
	        }
	        var _c = this.defaultView.viewport2Client({
	            x: viewportX,
	            y: viewportY,
	        }), clientX = _c.x, clientY = _c.y;
	        var picked = this.defaultView
	            .getRenderingService()
	            .hooks.pickSync.call({
	            topmost: false,
	            position: {
	                x: x,
	                y: y,
	                viewportX: viewportX,
	                viewportY: viewportY,
	                clientX: clientX,
	                clientY: clientY,
	            },
	            picked: [],
	        }).picked;
	        if (picked[picked.length - 1] !== this.documentElement) {
	            picked.push(this.documentElement);
	        }
	        return picked;
	    };
	    /**
	     * Do picking with API instead of triggering interactive events.
	     *
	     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
	     */
	    Document.prototype.elementsFromPoint = function (x, y) {
	        return __awaiter(this, void 0, void 0, function () {
	            var _a, viewportX, viewportY, _b, width, height, _c, clientX, clientY, picked;
	            return __generator(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        _a = this.defaultView.canvas2Viewport({
	                            x: x,
	                            y: y,
	                        }), viewportX = _a.x, viewportY = _a.y;
	                        _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
	                        // outside canvas' viewport
	                        if (viewportX < 0 ||
	                            viewportY < 0 ||
	                            viewportX > width ||
	                            viewportY > height) {
	                            return [2 /*return*/, []];
	                        }
	                        _c = this.defaultView.viewport2Client({
	                            x: viewportX,
	                            y: viewportY,
	                        }), clientX = _c.x, clientY = _c.y;
	                        return [4 /*yield*/, this.defaultView
	                                .getRenderingService()
	                                .hooks.pick.promise({
	                                topmost: false,
	                                position: {
	                                    x: x,
	                                    y: y,
	                                    viewportX: viewportX,
	                                    viewportY: viewportY,
	                                    clientX: clientX,
	                                    clientY: clientY,
	                                },
	                                picked: [],
	                            })];
	                    case 1:
	                        picked = (_d.sent()).picked;
	                        if (picked[picked.length - 1] !== this.documentElement) {
	                            picked.push(this.documentElement);
	                        }
	                        return [2 /*return*/, picked];
	                }
	            });
	        });
	    };
	    /**
	     * eg. Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.
	     */
	    Document.prototype.appendChild = function (newChild, index) {
	        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
	    };
	    Document.prototype.insertBefore = function (newChild, refChild) {
	        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
	    };
	    Document.prototype.removeChild = function (oldChild, destroy) {
	        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
	    };
	    Document.prototype.replaceChild = function (newChild, oldChild, destroy) {
	        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
	    };
	    Document.prototype.append = function () {
	        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
	    };
	    Document.prototype.prepend = function () {
	        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
	    };
	    /**
	     * Execute query on documentElement.
	     */
	    Document.prototype.getElementById = function (id) {
	        return this.documentElement.getElementById(id);
	    };
	    Document.prototype.getElementsByName = function (name) {
	        return this.documentElement.getElementsByName(name);
	    };
	    Document.prototype.getElementsByTagName = function (tagName) {
	        return this.documentElement.getElementsByTagName(tagName);
	    };
	    Document.prototype.getElementsByClassName = function (className) {
	        return this.documentElement.getElementsByClassName(className);
	    };
	    Document.prototype.querySelector = function (selectors) {
	        return this.documentElement.querySelector(selectors);
	    };
	    Document.prototype.querySelectorAll = function (selectors) {
	        return this.documentElement.querySelectorAll(selectors);
	    };
	    Document.prototype.find = function (filter) {
	        return this.documentElement.find(filter);
	    };
	    Document.prototype.findAll = function (filter) {
	        return this.documentElement.findAll(filter);
	    };
	    return Document;
	}(Node$1));

	/**
	 * apply following rules:
	 * 1. `visibility` in scenegraph node
	 * 2. other custom culling strategies, eg. frustum culling
	 */
	var CullingPlugin = /** @class */ (function () {
	    function CullingPlugin(strategies) {
	        this.strategies = strategies;
	    }
	    CullingPlugin.prototype.apply = function (context) {
	        var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
	        var strategies = this.strategies;
	        renderingService.hooks.cull.tap(CullingPlugin.tag, function (object) {
	            if (object) {
	                var cullable = object.cullable;
	                // cullable.visible = true;
	                // const renderBounds = object.getRenderBounds();
	                // if (AABB.isEmpty(renderBounds)) {
	                //   cullable.visible = false;
	                // } else {
	                //   const isShape2D = shape2D.indexOf(object.nodeName as Shape) > -1;
	                //   const [p0, p1, p2, p3] = camera.getFrustum().planes;
	                //   tmpAABB.setMinMax([-p1.distance, -p3.distance, 0], [p0.distance, p2.distance, 0]);
	                //   cullable.visible = isShape2D ? renderBounds.intersects(tmpAABB) : true;
	                // }
	                if (strategies.length === 0) {
	                    cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
	                }
	                else {
	                    // eg. implemented by g-webgl(frustum culling)
	                    cullable.visible = strategies.every(function (strategy) { return strategy.isVisible(camera, object); });
	                }
	                if (!object.isCulled() && object.isVisible()) {
	                    return object;
	                }
	                else {
	                    // if (this.renderingContext.renderListLastFrame.indexOf(object) > -1) {
	                    object.dispatchEvent(new CustomEvent(ElementEvent.CULLED));
	                    // }
	                }
	                return null;
	            }
	            return object;
	        });
	        renderingService.hooks.afterRender.tap(CullingPlugin.tag, function (object) {
	            object.cullable.visibilityPlaneMask = -1;
	        });
	    };
	    CullingPlugin.tag = 'Culling';
	    return CullingPlugin;
	}());

	/**
	 * Filter dirty renderables and calculate the "dirty rectangle" which will be clear when frame began
	 */
	var DirtyCheckPlugin = /** @class */ (function () {
	    function DirtyCheckPlugin() {
	    }
	    DirtyCheckPlugin.prototype.apply = function (context) {
	        var renderingService = context.renderingService;
	        renderingService.hooks.dirtycheck.tap(DirtyCheckPlugin.tag, function (object) {
	            if (object) {
	                var renderable = object.renderable;
	                var isDirty = renderable.dirty ||
	                    renderingService.disableDirtyRectangleRendering();
	                if (isDirty) {
	                    return object;
	                }
	                else {
	                    return null;
	                }
	            }
	            return object;
	        });
	    };
	    DirtyCheckPlugin.tag = 'DirtyCheck';
	    return DirtyCheckPlugin;
	}());

	/**
	 * support mouse & touch events
	 * @see https://github.com/pixijs/pixi.js/blob/dev/packages/interaction/README.md
	 *
	 * also provide some extra events such as `drag`
	 */
	var EventPlugin = /** @class */ (function () {
	    function EventPlugin() {
	        var _this = this;
	        this.autoPreventDefault = false;
	        this.rootPointerEvent = new FederatedPointerEvent(null);
	        this.rootWheelEvent = new FederatedWheelEvent(null);
	        this.onPointerMove = function (nativeEvent) {
	            var e_1, _a;
	            var _b, _c;
	            var canvas = (_c = (_b = _this.context.renderingContext.root) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.defaultView;
	            if (canvas.supportsTouchEvents &&
	                nativeEvent.pointerType === 'touch')
	                return;
	            var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
	            try {
	                for (var normalizedEvents_1 = __values(normalizedEvents), normalizedEvents_1_1 = normalizedEvents_1.next(); !normalizedEvents_1_1.done; normalizedEvents_1_1 = normalizedEvents_1.next()) {
	                    var normalizedEvent = normalizedEvents_1_1.value;
	                    var event_1 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
	                    _this.context.eventService.mapEvent(event_1);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (normalizedEvents_1_1 && !normalizedEvents_1_1.done && (_a = normalizedEvents_1.return)) _a.call(normalizedEvents_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            _this.setCursor(_this.context.eventService.cursor);
	        };
	        this.onClick = function (nativeEvent) {
	            var e_2, _a;
	            var _b, _c;
	            var canvas = (_c = (_b = _this.context.renderingContext.root) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.defaultView;
	            var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
	            try {
	                for (var normalizedEvents_2 = __values(normalizedEvents), normalizedEvents_2_1 = normalizedEvents_2.next(); !normalizedEvents_2_1.done; normalizedEvents_2_1 = normalizedEvents_2.next()) {
	                    var normalizedEvent = normalizedEvents_2_1.value;
	                    var event_2 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
	                    _this.context.eventService.mapEvent(event_2);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (normalizedEvents_2_1 && !normalizedEvents_2_1.done && (_a = normalizedEvents_2.return)) _a.call(normalizedEvents_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	            _this.setCursor(_this.context.eventService.cursor);
	        };
	    }
	    EventPlugin.prototype.apply = function (context) {
	        var _this = this;
	        this.context = context;
	        var renderingService = context.renderingService;
	        var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
	        this.context.eventService.setPickHandler(function (position) {
	            var picked = _this.context.renderingService.hooks.pickSync.call({
	                position: position,
	                picked: [],
	                topmost: true, // we only concern the topmost element
	            }).picked;
	            return picked[0] || null;
	        });
	        renderingService.hooks.pointerWheel.tap(EventPlugin.tag, function (nativeEvent) {
	            var wheelEvent = _this.normalizeWheelEvent(nativeEvent);
	            _this.context.eventService.mapEvent(wheelEvent);
	        });
	        renderingService.hooks.pointerDown.tap(EventPlugin.tag, function (nativeEvent) {
	            var e_3, _a;
	            if (canvas.supportsTouchEvents &&
	                nativeEvent.pointerType === 'touch')
	                return;
	            var events = _this.normalizeToPointerEvent(nativeEvent, canvas);
	            if (_this.autoPreventDefault && events[0].isNormalized) {
	                var cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);
	                if (cancelable) {
	                    nativeEvent.preventDefault();
	                }
	            }
	            try {
	                for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
	                    var event_3 = events_1_1.value;
	                    var federatedEvent = _this.bootstrapEvent(_this.rootPointerEvent, event_3, canvas, nativeEvent);
	                    _this.context.eventService.mapEvent(federatedEvent);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	            _this.setCursor(_this.context.eventService.cursor);
	        });
	        renderingService.hooks.pointerUp.tap(EventPlugin.tag, function (nativeEvent) {
	            var e_4, _a;
	            if (canvas.supportsTouchEvents &&
	                nativeEvent.pointerType === 'touch')
	                return;
	            // account for element in SVG
	            var $element = _this.context.contextService.getDomElement();
	            var outside = 'outside';
	            try {
	                outside =
	                    $element &&
	                        nativeEvent.target &&
	                        nativeEvent.target !== $element &&
	                        $element.contains &&
	                        !$element.contains(nativeEvent.target)
	                        ? 'outside'
	                        : '';
	            }
	            catch (e) {
	                // nativeEvent.target maybe not Node, such as Window
	                // @see https://github.com/antvis/G/issues/1235
	            }
	            var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
	            try {
	                for (var normalizedEvents_3 = __values(normalizedEvents), normalizedEvents_3_1 = normalizedEvents_3.next(); !normalizedEvents_3_1.done; normalizedEvents_3_1 = normalizedEvents_3.next()) {
	                    var normalizedEvent = normalizedEvents_3_1.value;
	                    var event_4 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
	                    event_4.type += outside;
	                    _this.context.eventService.mapEvent(event_4);
	                }
	            }
	            catch (e_4_1) { e_4 = { error: e_4_1 }; }
	            finally {
	                try {
	                    if (normalizedEvents_3_1 && !normalizedEvents_3_1.done && (_a = normalizedEvents_3.return)) _a.call(normalizedEvents_3);
	                }
	                finally { if (e_4) throw e_4.error; }
	            }
	            _this.setCursor(_this.context.eventService.cursor);
	        });
	        renderingService.hooks.pointerMove.tap(EventPlugin.tag, this.onPointerMove);
	        renderingService.hooks.pointerOver.tap(EventPlugin.tag, this.onPointerMove);
	        renderingService.hooks.pointerOut.tap(EventPlugin.tag, this.onPointerMove);
	        renderingService.hooks.click.tap(EventPlugin.tag, this.onClick);
	        renderingService.hooks.pointerCancel.tap(EventPlugin.tag, function (nativeEvent) {
	            var e_5, _a;
	            var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
	            try {
	                for (var normalizedEvents_4 = __values(normalizedEvents), normalizedEvents_4_1 = normalizedEvents_4.next(); !normalizedEvents_4_1.done; normalizedEvents_4_1 = normalizedEvents_4.next()) {
	                    var normalizedEvent = normalizedEvents_4_1.value;
	                    var event_5 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
	                    _this.context.eventService.mapEvent(event_5);
	                }
	            }
	            catch (e_5_1) { e_5 = { error: e_5_1 }; }
	            finally {
	                try {
	                    if (normalizedEvents_4_1 && !normalizedEvents_4_1.done && (_a = normalizedEvents_4.return)) _a.call(normalizedEvents_4);
	                }
	                finally { if (e_5) throw e_5.error; }
	            }
	            _this.setCursor(_this.context.eventService.cursor);
	        });
	    };
	    EventPlugin.prototype.getViewportXY = function (nativeEvent) {
	        var x;
	        var y;
	        /**
	         * Should account for CSS Transform applied on container.
	         * @see https://github.com/antvis/G/issues/1161
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
	         */
	        var offsetX = nativeEvent.offsetX, offsetY = nativeEvent.offsetY, clientX = nativeEvent.clientX, clientY = nativeEvent.clientY;
	        if (this.context.config.supportsCSSTransform &&
	            !isNil(offsetX) &&
	            !isNil(offsetY)) {
	            x = offsetX;
	            y = offsetY;
	        }
	        else {
	            var point = this.context.eventService.client2Viewport(new Point(clientX, clientY));
	            x = point.x;
	            y = point.y;
	        }
	        return { x: x, y: y };
	    };
	    EventPlugin.prototype.bootstrapEvent = function (event, normalizedEvent, view, nativeEvent) {
	        var _a, _b;
	        event.view = view;
	        event.originalEvent = null;
	        event.nativeEvent = nativeEvent;
	        event.pointerId = normalizedEvent.pointerId;
	        event.width = normalizedEvent.width;
	        event.height = normalizedEvent.height;
	        event.isPrimary = normalizedEvent.isPrimary;
	        event.pointerType = normalizedEvent.pointerType;
	        event.pressure = normalizedEvent.pressure;
	        event.tangentialPressure = normalizedEvent.tangentialPressure;
	        event.tiltX = normalizedEvent.tiltX;
	        event.tiltY = normalizedEvent.tiltY;
	        event.twist = normalizedEvent.twist;
	        this.transferMouseData(event, normalizedEvent);
	        var x = (_a = this.getViewportXY(normalizedEvent), _a.x), y = _a.y;
	        event.viewport.x = x;
	        event.viewport.y = y;
	        var canvasX = (_b = this.context.eventService.viewport2Canvas(event.viewport), _b.x), canvasY = _b.y;
	        event.canvas.x = canvasX;
	        event.canvas.y = canvasY;
	        event.global.copyFrom(event.canvas);
	        event.offset.copyFrom(event.canvas);
	        event.isTrusted = nativeEvent.isTrusted;
	        if (event.type === 'pointerleave') {
	            event.type = 'pointerout';
	        }
	        if (event.type.startsWith('mouse')) {
	            event.type = event.type.replace('mouse', 'pointer');
	        }
	        if (event.type.startsWith('touch')) {
	            event.type = TOUCH_TO_POINTER[event.type] || event.type;
	        }
	        return event;
	    };
	    EventPlugin.prototype.normalizeWheelEvent = function (nativeEvent) {
	        var _a, _b;
	        var event = this.rootWheelEvent;
	        this.transferMouseData(event, nativeEvent);
	        event.deltaMode = nativeEvent.deltaMode;
	        event.deltaX = nativeEvent.deltaX;
	        event.deltaY = nativeEvent.deltaY;
	        event.deltaZ = nativeEvent.deltaZ;
	        var x = (_a = this.getViewportXY(nativeEvent), _a.x), y = _a.y;
	        event.viewport.x = x;
	        event.viewport.y = y;
	        var canvasX = (_b = this.context.eventService.viewport2Canvas(event.viewport), _b.x), canvasY = _b.y;
	        event.canvas.x = canvasX;
	        event.canvas.y = canvasY;
	        event.global.copyFrom(event.canvas);
	        event.offset.copyFrom(event.canvas);
	        event.nativeEvent = nativeEvent;
	        event.type = nativeEvent.type;
	        return event;
	    };
	    /**
	     * Transfers base & mouse event data from the nativeEvent to the federated event.
	     */
	    EventPlugin.prototype.transferMouseData = function (event, nativeEvent) {
	        event.isTrusted = nativeEvent.isTrusted;
	        event.srcElement = nativeEvent.srcElement;
	        event.timeStamp = performance.now();
	        event.type = nativeEvent.type;
	        event.altKey = nativeEvent.altKey;
	        event.metaKey = nativeEvent.metaKey;
	        event.shiftKey = nativeEvent.shiftKey;
	        event.ctrlKey = nativeEvent.ctrlKey;
	        event.button = nativeEvent.button;
	        event.buttons = nativeEvent.buttons;
	        event.client.x = nativeEvent.clientX;
	        event.client.y = nativeEvent.clientY;
	        event.movement.x = nativeEvent.movementX;
	        event.movement.y = nativeEvent.movementY;
	        event.page.x = nativeEvent.pageX;
	        event.page.y = nativeEvent.pageY;
	        event.screen.x = nativeEvent.screenX;
	        event.screen.y = nativeEvent.screenY;
	        event.relatedTarget = null;
	    };
	    EventPlugin.prototype.setCursor = function (cursor) {
	        this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || 'default');
	    };
	    EventPlugin.prototype.normalizeToPointerEvent = function (event, canvas) {
	        var normalizedEvents = [];
	        if (canvas.isTouchEvent(event)) {
	            for (var i = 0; i < event.changedTouches.length; i++) {
	                var touch = event.changedTouches[i];
	                // use changedTouches instead of touches since touchend has no touches
	                // @see https://stackoverflow.com/a/10079076
	                if (isUndefined(touch.button))
	                    touch.button = 0;
	                if (isUndefined(touch.buttons))
	                    touch.buttons = 1;
	                if (isUndefined(touch.isPrimary)) {
	                    touch.isPrimary =
	                        event.touches.length === 1 && event.type === 'touchstart';
	                }
	                if (isUndefined(touch.width))
	                    touch.width = touch.radiusX || 1;
	                if (isUndefined(touch.height))
	                    touch.height = touch.radiusY || 1;
	                if (isUndefined(touch.tiltX))
	                    touch.tiltX = 0;
	                if (isUndefined(touch.tiltY))
	                    touch.tiltY = 0;
	                if (isUndefined(touch.pointerType))
	                    touch.pointerType = 'touch';
	                // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Touch/identifier
	                if (isUndefined(touch.pointerId))
	                    touch.pointerId = touch.identifier || 0;
	                if (isUndefined(touch.pressure))
	                    touch.pressure = touch.force || 0.5;
	                if (isUndefined(touch.twist))
	                    touch.twist = 0;
	                if (isUndefined(touch.tangentialPressure))
	                    touch.tangentialPressure = 0;
	                touch.isNormalized = true;
	                touch.type = event.type;
	                normalizedEvents.push(touch);
	            }
	        }
	        else if (canvas.isMouseEvent(event)) {
	            var tempEvent = event;
	            if (isUndefined(tempEvent.isPrimary))
	                tempEvent.isPrimary = true;
	            if (isUndefined(tempEvent.width))
	                tempEvent.width = 1;
	            if (isUndefined(tempEvent.height))
	                tempEvent.height = 1;
	            if (isUndefined(tempEvent.tiltX))
	                tempEvent.tiltX = 0;
	            if (isUndefined(tempEvent.tiltY))
	                tempEvent.tiltY = 0;
	            if (isUndefined(tempEvent.pointerType))
	                tempEvent.pointerType = 'mouse';
	            if (isUndefined(tempEvent.pointerId))
	                tempEvent.pointerId = MOUSE_POINTER_ID;
	            if (isUndefined(tempEvent.pressure))
	                tempEvent.pressure = 0.5;
	            if (isUndefined(tempEvent.twist))
	                tempEvent.twist = 0;
	            if (isUndefined(tempEvent.tangentialPressure))
	                tempEvent.tangentialPressure = 0;
	            tempEvent.isNormalized = true;
	            normalizedEvents.push(tempEvent);
	        }
	        else {
	            normalizedEvents.push(event);
	        }
	        return normalizedEvents;
	    };
	    EventPlugin.tag = 'Event';
	    return EventPlugin;
	}());

	// group is not a 2d shape
	var shape2D = [
	    Shape.CIRCLE,
	    Shape.ELLIPSE,
	    Shape.IMAGE,
	    Shape.RECT,
	    Shape.LINE,
	    Shape.POLYLINE,
	    Shape.POLYGON,
	    Shape.TEXT,
	    Shape.PATH,
	    Shape.HTML,
	];
	var FrustumCullingStrategy = /** @class */ (function () {
	    function FrustumCullingStrategy() {
	    }
	    FrustumCullingStrategy.prototype.isVisible = function (camera, object) {
	        // return true;
	        var _a, _b;
	        var cullable = object.cullable;
	        if (!cullable.enable) {
	            return true;
	        }
	        var renderBounds = object.getRenderBounds();
	        if (AABB.isEmpty(renderBounds)) {
	            return false;
	        }
	        // get VP matrix from camera
	        var frustum = camera.getFrustum();
	        var parentVisibilityPlaneMask = (_b = (_a = object.parentNode) === null || _a === void 0 ? void 0 : _a.cullable) === null || _b === void 0 ? void 0 : _b.visibilityPlaneMask;
	        cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum.planes);
	        cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
	        return cullable.visible;
	    };
	    /**
	     *
	     * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
	     * @see https://github.com/antvis/GWebGPUEngine/issues/3
	     *
	     * * 基础相交测试 the basic intersection test
	     * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
	     * * TODO: 平面一致性测试 the plane-coherency test
	     * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
	     *
	     * @param aabb aabb
	     * @param parentPlaneMask mask of parent
	     * @param planes planes of frustum
	     */
	    FrustumCullingStrategy.prototype.computeVisibilityWithPlaneMask = function (object, aabb, parentPlaneMask, planes) {
	        if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
	            // 父节点完全位于视锥内或者外部，直接返回
	            return parentPlaneMask;
	        }
	        // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
	        // (Because if there are fewer than 31 planes, the upper bits wont be changed.)
	        var mask = Mask.INSIDE;
	        var isShape2D = shape2D.indexOf(object.nodeName) > -1;
	        // Use viewport culling for 2D shapes
	        // @see https://github.com/antvis/g/issues/914
	        for (var k = 0, len = planes.length; k < len; ++k) {
	            // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
	            var flag = 1 << k;
	            if ((parentPlaneMask & flag) === 0) {
	                // 父节点处于当前面内部，可以跳过
	                continue;
	            }
	            // skip near & far planes when testing 2D shapes
	            if (isShape2D && (k === 4 || k === 5)) {
	                continue;
	            }
	            // p-vertex n-vertex <-|plane p-vertex n-vertex
	            // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测
	            var _a = planes[k], normal = _a.normal, distance = _a.distance;
	            if (dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance <
	                0) {
	                return Mask.OUTSIDE;
	            }
	            if (dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance <
	                0) {
	                // 和当前面相交，对应位置为1，继续检测下一个面
	                mask |= flag;
	            }
	        }
	        return mask;
	    };
	    return FrustumCullingStrategy;
	}());

	var PrepareRendererPlugin = /** @class */ (function () {
	    function PrepareRendererPlugin() {
	        /**
	         * sync to RBush later
	         */
	        this.toSync = new Set();
	    }
	    // private isFirstTimeRendering = true;
	    // private syncing = false;
	    PrepareRendererPlugin.prototype.apply = function (context) {
	        var _this = this;
	        var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
	        var canvas = renderingContext.root.ownerDocument.defaultView;
	        this.rBush = rBushRoot;
	        var handleAttributeChanged = function (e) {
	            var object = e.target;
	            object.renderable.dirty = true;
	            renderingService.dirtify();
	        };
	        var handleBoundsChanged = function (e) {
	            var affectChildren = e.detail.affectChildren;
	            var object = e.target;
	            if (affectChildren) {
	                object.forEach(function (node) {
	                    _this.toSync.add(node);
	                });
	            }
	            var p = object;
	            while (p) {
	                if (p.renderable) {
	                    _this.toSync.add(p);
	                }
	                p = p.parentElement;
	            }
	            // this.pushToSync(e.composedPath().slice(0, -2) as DisplayObject[]);
	            renderingService.dirtify();
	        };
	        var handleMounted = function (e) {
	            var object = e.target;
	            if (runtime.enableCSSParsing) {
	                // recalc style values
	                runtime.styleValueRegistry.recalc(object);
	            }
	            runtime.sceneGraphService.dirtifyToRoot(object);
	            renderingService.dirtify();
	        };
	        var handleUnmounted = function (e) {
	            var object = e.target;
	            var rBushNode = object.rBushNode;
	            if (rBushNode.aabb) {
	                _this.rBush.remove(rBushNode.aabb);
	            }
	            _this.toSync.delete(object);
	            runtime.sceneGraphService.dirtifyToRoot(object);
	            renderingService.dirtify();
	        };
	        renderingService.hooks.init.tap(PrepareRendererPlugin.tag, function () {
	            canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
	            canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
	            canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
	            canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
	        });
	        renderingService.hooks.destroy.tap(PrepareRendererPlugin.tag, function () {
	            canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
	            canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
	            canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
	            canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
	            _this.toSync.clear();
	        });
	        renderingService.hooks.endFrame.tap(PrepareRendererPlugin.tag, function () {
	            // if (this.isFirstTimeRendering) {
	            //   this.isFirstTimeRendering = false;
	            //   this.syncing = true;
	            //   // @see https://github.com/antvis/G/issues/1117
	            //   setTimeout(() => {
	            //     this.syncRTree();
	            //     console.log('fcp...');
	            //   });
	            // } else {
	            //   console.log('next...');
	            _this.syncRTree();
	            // }
	        });
	    };
	    PrepareRendererPlugin.prototype.syncRTree = function () {
	        // if (this.syncing) {
	        //   return;
	        // }
	        var _this = this;
	        // bounds changed, need re-inserting its children
	        var bulk = [];
	        Array.from(this.toSync)
	            // some objects may be removed since last frame
	            .filter(function (object) { return object.isConnected; })
	            .forEach(function (node) {
	            var _a, _b;
	            var rBushNode = node.rBushNode;
	            // clear dirty node
	            if (rBushNode && rBushNode.aabb) {
	                _this.rBush.remove(rBushNode.aabb);
	            }
	            var renderBounds = node.getRenderBounds();
	            if (renderBounds) {
	                var minX = (_a = __read(renderBounds.getMin(), 2), _a[0]), minY = _a[1];
	                var maxX = (_b = __read(renderBounds.getMax(), 2), _b[0]), maxY = _b[1];
	                if (!rBushNode.aabb) {
	                    rBushNode.aabb = {};
	                }
	                rBushNode.aabb.displayObject = node;
	                rBushNode.aabb.minX = minX;
	                rBushNode.aabb.minY = minY;
	                rBushNode.aabb.maxX = maxX;
	                rBushNode.aabb.maxY = maxY;
	            }
	            if (rBushNode.aabb) {
	                // TODO: NaN occurs when width/height of Rect is 0
	                if (!isNaN(rBushNode.aabb.maxX) &&
	                    !isNaN(rBushNode.aabb.maxX) &&
	                    !isNaN(rBushNode.aabb.minX) &&
	                    !isNaN(rBushNode.aabb.minY)) {
	                    bulk.push(rBushNode.aabb);
	                }
	            }
	        });
	        // use bulk inserting, which is ~2-3 times faster
	        // @see https://github.com/mourner/rbush#bulk-inserting-data
	        this.rBush.load(bulk);
	        bulk.length = 0;
	        this.toSync.clear();
	        // this.syncing = false;
	    };
	    PrepareRendererPlugin.tag = 'Prepare';
	    return PrepareRendererPlugin;
	}());
	var CanvasEvent;
	(function (CanvasEvent) {
	    CanvasEvent["READY"] = "ready";
	    CanvasEvent["BEFORE_RENDER"] = "beforerender";
	    CanvasEvent["RERENDER"] = "rerender";
	    CanvasEvent["AFTER_RENDER"] = "afterrender";
	    CanvasEvent["BEFORE_DESTROY"] = "beforedestroy";
	    CanvasEvent["AFTER_DESTROY"] = "afterdestroy";
	    CanvasEvent["RESIZE"] = "resize";
	    CanvasEvent["DIRTY_RECTANGLE"] = "dirtyrectangle";
	    CanvasEvent["RENDERER_CHANGED"] = "rendererchanged";
	})(CanvasEvent || (CanvasEvent = {}));
	var DEFAULT_CAMERA_Z = 500;
	var DEFAULT_CAMERA_NEAR = 0.1;
	var DEFAULT_CAMERA_FAR = 1000;
	/**
	 * reuse custom event preventing from re-create them in every frame
	 */
	var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
	var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
	var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
	var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
	var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
	/**
	 * can be treated like Window in DOM
	 * provide some extra methods like `window`, such as:
	 * * `window.requestAnimationFrame`
	 * * `window.devicePixelRatio`
	 *
	 * prototype chains: Canvas(Window) -> EventTarget
	 */
	var Canvas = /** @class */ (function (_super) {
	    __extends(Canvas, _super);
	    function Canvas(config) {
	        var _this = _super.call(this) || this;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element
	         */
	        _this.Element = DisplayObject;
	        _this.inited = false;
	        _this.context = {};
	        // create document
	        _this.document = new Document();
	        _this.document.defaultView = _this;
	        // create registry of custom elements
	        _this.customElements = new CustomElementRegistry();
	        var container = config.container, canvas = config.canvas, offscreenCanvas = config.offscreenCanvas, width = config.width, height = config.height, devicePixelRatio = config.devicePixelRatio, renderer = config.renderer, background = config.background, cursor = config.cursor, document = config.document, requestAnimationFrame = config.requestAnimationFrame, cancelAnimationFrame = config.cancelAnimationFrame, createImage = config.createImage, supportsPointerEvents = config.supportsPointerEvents, supportsTouchEvents = config.supportsTouchEvents, supportsCSSTransform = config.supportsCSSTransform, useNativeClickEvent = config.useNativeClickEvent, alwaysTriggerPointerEventOnCanvas = config.alwaysTriggerPointerEventOnCanvas, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent;
	        cleanExistedCanvas(container, _this);
	        var canvasWidth = width;
	        var canvasHeight = height;
	        var dpr = devicePixelRatio;
	        // use user-defined <canvas> or OffscreenCanvas
	        if (canvas) {
	            // infer width & height with dpr
	            dpr = devicePixelRatio || (isBrowser && window.devicePixelRatio) || 1;
	            dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
	            canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
	            canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
	        }
	        /**
	         * implements `Window` interface
	         */
	        _this.devicePixelRatio = dpr;
	        _this.requestAnimationFrame =
	            requestAnimationFrame !== null && requestAnimationFrame !== void 0 ? requestAnimationFrame : raf.bind(runtime.globalThis);
	        _this.cancelAnimationFrame =
	            cancelAnimationFrame !== null && cancelAnimationFrame !== void 0 ? cancelAnimationFrame : caf.bind(runtime.globalThis);
	        /**
	         * limits query
	         */
	        // the following feature-detect from hammer.js
	        // @see https://github.com/hammerjs/hammer.js/blob/master/src/inputjs/input-consts.js#L5
	        _this.supportsTouchEvents =
	            supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : 'ontouchstart' in runtime.globalThis;
	        _this.supportsPointerEvents =
	            supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
	        _this.isTouchEvent =
	            isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : (function (event) {
	                return _this.supportsTouchEvents &&
	                    event instanceof runtime.globalThis.TouchEvent;
	            });
	        _this.isMouseEvent =
	            isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : (function (event) {
	                return !runtime.globalThis.MouseEvent ||
	                    (event instanceof runtime.globalThis.MouseEvent &&
	                        (!_this.supportsPointerEvents ||
	                            !(event instanceof runtime.globalThis.PointerEvent)));
	            });
	        _this.initRenderingContext({
	            container: container,
	            canvas: canvas,
	            width: canvasWidth,
	            height: canvasHeight,
	            renderer: renderer,
	            offscreenCanvas: offscreenCanvas,
	            devicePixelRatio: dpr,
	            cursor: cursor || 'default',
	            background: background || 'transparent',
	            createImage: createImage,
	            document: document,
	            supportsCSSTransform: supportsCSSTransform,
	            useNativeClickEvent: useNativeClickEvent,
	            alwaysTriggerPointerEventOnCanvas: alwaysTriggerPointerEventOnCanvas,
	        });
	        _this.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
	        _this.initRenderer(renderer, true);
	        return _this;
	    }
	    Canvas.prototype.initRenderingContext = function (mergedConfig) {
	        this.context.config = mergedConfig;
	        // bind rendering context, shared by all renderers
	        this.context.renderingContext = {
	            /**
	             * the root node in scene graph
	             */
	            root: this.document.documentElement,
	            renderListCurrentFrame: [],
	            unculledEntities: [],
	            renderReasons: new Set(),
	            force: false,
	            dirty: false,
	        };
	    };
	    Canvas.prototype.initDefaultCamera = function (width, height, clipSpaceNearZ) {
	        var _this = this;
	        // set a default ortho camera
	        var camera = new runtime.CameraContribution();
	        camera.clipSpaceNearZ = clipSpaceNearZ;
	        camera
	            .setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT)
	            .setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z)
	            .setFocalPoint(width / 2, height / 2, 0)
	            .setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
	        // keep ref since it will use raf in camera animation
	        camera.canvas = this;
	        // redraw when camera changed
	        camera.eventEmitter.on(CameraEvent.UPDATED, function () {
	            _this.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
	        });
	        // bind camera
	        this.context.camera = camera;
	    };
	    Canvas.prototype.getConfig = function () {
	        return this.context.config;
	    };
	    /**
	     * get the root displayObject in scenegraph
	     * @alias this.document.documentElement
	     */
	    Canvas.prototype.getRoot = function () {
	        return this.document.documentElement;
	    };
	    /**
	     * get the camera of canvas
	     */
	    Canvas.prototype.getCamera = function () {
	        return this.context.camera;
	    };
	    Canvas.prototype.getContextService = function () {
	        return this.context.contextService;
	    };
	    Canvas.prototype.getEventService = function () {
	        return this.context.eventService;
	    };
	    Canvas.prototype.getRenderingService = function () {
	        return this.context.renderingService;
	    };
	    Canvas.prototype.getRenderingContext = function () {
	        return this.context.renderingContext;
	    };
	    Canvas.prototype.getStats = function () {
	        return this.getRenderingService().getStats();
	    };
	    Object.defineProperty(Canvas.prototype, "ready", {
	        // /**
	        //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
	        //  */
	        // getComputedStyle(node: DisplayObject) {
	        //   return node.computedStyle;
	        // }
	        get: function () {
	            var _this = this;
	            if (!this.readyPromise) {
	                this.readyPromise = new Promise(function (resolve) {
	                    _this.resolveReadyPromise = function () {
	                        resolve(_this);
	                    };
	                });
	                if (this.inited) {
	                    this.resolveReadyPromise();
	                }
	            }
	            return this.readyPromise;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * `cleanUp` means clean all the internal services of Canvas which happens when calling `canvas.destroy()`.
	     */
	    Canvas.prototype.destroy = function (cleanUp, skipTriggerEvent) {
	        if (cleanUp === void 0) { cleanUp = true; }
	        if (skipTriggerEvent === void 0) { skipTriggerEvent = false; }
	        if (!skipTriggerEvent) {
	            this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY));
	        }
	        if (this.frameId) {
	            var cancelRAF = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
	            cancelRAF(this.frameId);
	        }
	        // unmount all children
	        var root = this.getRoot();
	        this.unmountChildren(root);
	        if (cleanUp) {
	            // destroy Document
	            this.document.destroy();
	            this.getEventService().destroy();
	        }
	        // destroy services
	        this.getRenderingService().destroy();
	        this.getContextService().destroy();
	        // clear root after renderservice destroyed
	        if (cleanUp && this.context.rBushRoot) {
	            // clear rbush
	            this.context.rBushRoot.clear();
	            this.context.rBushRoot = null;
	            this.context.renderingContext.root = null;
	        }
	        if (!skipTriggerEvent) {
	            this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY));
	        }
	    };
	    /**
	     * compatible with G 3.0
	     * @deprecated
	     * @alias resize
	     */
	    Canvas.prototype.changeSize = function (width, height) {
	        this.resize(width, height);
	    };
	    Canvas.prototype.resize = function (width, height) {
	        // update canvas' config
	        var canvasConfig = this.context.config;
	        canvasConfig.width = width;
	        canvasConfig.height = height;
	        // resize context
	        this.getContextService().resize(width, height);
	        // resize camera
	        var camera = this.context.camera;
	        var projectionMode = camera.getProjectionMode();
	        camera
	            .setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z)
	            .setFocalPoint(width / 2, height / 2, 0);
	        if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
	            camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
	        }
	        else {
	            camera.setAspect(width / height);
	        }
	        this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, { width: width, height: height }));
	    };
	    // proxy to document.documentElement
	    Canvas.prototype.appendChild = function (child, index) {
	        return this.document.documentElement.appendChild(child, index);
	    };
	    Canvas.prototype.insertBefore = function (newChild, refChild) {
	        return this.document.documentElement.insertBefore(newChild, refChild);
	    };
	    Canvas.prototype.removeChild = function (child) {
	        return this.document.documentElement.removeChild(child);
	    };
	    /**
	     * Remove all children which can be appended to its original parent later again.
	     */
	    Canvas.prototype.removeChildren = function () {
	        this.document.documentElement.removeChildren();
	    };
	    /**
	     * Recursively destroy all children which can not be appended to its original parent later again.
	     * But the canvas remains running which means display objects can be appended later.
	     */
	    Canvas.prototype.destroyChildren = function () {
	        this.document.documentElement.destroyChildren();
	    };
	    Canvas.prototype.render = function () {
	        var _this = this;
	        this.dispatchEvent(beforeRenderEvent);
	        var renderingService = this.getRenderingService();
	        renderingService.render(this.getConfig(), function () {
	            // trigger actual rerender event
	            // @see https://github.com/antvis/G/issues/1268
	            _this.dispatchEvent(rerenderEvent);
	        });
	        this.dispatchEvent(afterRenderEvent);
	    };
	    Canvas.prototype.run = function () {
	        var _this = this;
	        var tick = function () {
	            _this.render();
	            _this.frameId = _this.requestAnimationFrame(tick);
	        };
	        tick();
	    };
	    Canvas.prototype.initRenderer = function (renderer, firstContentfullPaint) {
	        var _this = this;
	        if (firstContentfullPaint === void 0) { firstContentfullPaint = false; }
	        if (!renderer) {
	            throw new Error('Renderer is required.');
	        }
	        // reset
	        this.inited = false;
	        this.readyPromise = undefined;
	        // FIXME: should re-create here?
	        this.context.rBushRoot = new RBush();
	        // reset rendering plugins
	        this.context.renderingPlugins = [];
	        this.context.renderingPlugins.push(new EventPlugin(), new PrepareRendererPlugin(), new DirtyCheckPlugin(), new CullingPlugin([new FrustumCullingStrategy()]));
	        //
	        this.loadRendererContainerModule(renderer);
	        // init context service
	        this.context.contextService = new this.context.ContextService(__assign(__assign({}, runtime), this.context));
	        // init rendering service
	        this.context.renderingService = new RenderingService(runtime, this.context);
	        // init event service
	        this.context.eventService = new EventService(runtime, this.context);
	        this.context.eventService.init();
	        if (this.context.contextService.init) {
	            this.context.contextService.init();
	            this.initRenderingService(renderer, firstContentfullPaint, true);
	        }
	        else {
	            this.context.contextService.initAsync().then(function () {
	                _this.initRenderingService(renderer, firstContentfullPaint);
	            });
	        }
	    };
	    Canvas.prototype.initRenderingService = function (renderer, firstContentfullPaint, async) {
	        var _this = this;
	        if (firstContentfullPaint === void 0) { firstContentfullPaint = false; }
	        if (async === void 0) { async = false; }
	        this.context.renderingService.init(function () {
	            _this.inited = true;
	            if (firstContentfullPaint) {
	                if (async) {
	                    _this.requestAnimationFrame(function () {
	                        _this.dispatchEvent(new CustomEvent(CanvasEvent.READY));
	                    });
	                }
	                else {
	                    _this.dispatchEvent(new CustomEvent(CanvasEvent.READY));
	                }
	                if (_this.readyPromise) {
	                    _this.resolveReadyPromise();
	                }
	            }
	            else {
	                _this.dispatchEvent(new CustomEvent(CanvasEvent.RENDERER_CHANGED));
	            }
	            if (!firstContentfullPaint) {
	                _this.getRoot().forEach(function (node) {
	                    var renderable = node.renderable;
	                    if (renderable) {
	                        renderable.renderBoundsDirty = true;
	                        renderable.boundsDirty = true;
	                        renderable.dirty = true;
	                    }
	                });
	            }
	            // keep current scenegraph unchanged, just trigger mounted event
	            _this.mountChildren(_this.getRoot());
	            if (renderer.getConfig().enableAutoRendering) {
	                _this.run();
	            }
	        });
	    };
	    Canvas.prototype.loadRendererContainerModule = function (renderer) {
	        var _this = this;
	        // load other container modules provided by g-canvas/g-svg/g-webgl
	        var plugins = renderer.getPlugins();
	        plugins.forEach(function (plugin) {
	            plugin.context = _this.context;
	            plugin.init(runtime);
	        });
	    };
	    Canvas.prototype.setRenderer = function (renderer) {
	        // update canvas' config
	        var canvasConfig = this.getConfig();
	        if (canvasConfig.renderer === renderer) {
	            return;
	        }
	        var oldRenderer = canvasConfig.renderer;
	        canvasConfig.renderer = renderer;
	        // keep all children undestroyed
	        this.destroy(false, true);
	        // destroy all plugins, reverse will mutate origin array
	        __spreadArray([], __read(oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()), false).reverse().forEach(function (plugin) {
	            plugin.destroy(runtime);
	        });
	        this.initRenderer(renderer);
	    };
	    Canvas.prototype.setCursor = function (cursor) {
	        var canvasConfig = this.getConfig();
	        canvasConfig.cursor = cursor;
	        this.getContextService().applyCursorStyle(cursor);
	    };
	    Canvas.prototype.unmountChildren = function (parent) {
	        var _this = this;
	        // unmountChildren recursively
	        parent.childNodes.forEach(function (child) {
	            _this.unmountChildren(child);
	        });
	        if (this.inited) {
	            if (parent.isMutationObserved) {
	                parent.dispatchEvent(unmountedEvent);
	            }
	            else {
	                unmountedEvent.target = parent;
	                this.dispatchEvent(unmountedEvent, true);
	            }
	            // skip document.documentElement
	            if (parent !== this.document.documentElement) {
	                parent.ownerDocument = null;
	            }
	            parent.isConnected = false;
	        }
	        // trigger after unmounted
	        if (parent.isCustomElement) {
	            if (parent.disconnectedCallback) {
	                parent.disconnectedCallback();
	            }
	        }
	    };
	    Canvas.prototype.mountChildren = function (parent) {
	        var _this = this;
	        if (this.inited) {
	            if (!parent.isConnected) {
	                parent.ownerDocument = this.document;
	                parent.isConnected = true;
	                if (parent.isMutationObserved) {
	                    parent.dispatchEvent(mountedEvent);
	                }
	                else {
	                    mountedEvent.target = parent;
	                    this.dispatchEvent(mountedEvent, true);
	                }
	            }
	        }
	        else {
	            console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", 'appended child: ', parent.nodeName);
	        }
	        // recursively mount children
	        parent.childNodes.forEach(function (child) {
	            _this.mountChildren(child);
	        });
	        // trigger after mounted
	        if (parent.isCustomElement) {
	            if (parent.connectedCallback) {
	                parent.connectedCallback();
	            }
	        }
	    };
	    Canvas.prototype.client2Viewport = function (client) {
	        return this.getEventService().client2Viewport(client);
	    };
	    Canvas.prototype.viewport2Client = function (canvas) {
	        return this.getEventService().viewport2Client(canvas);
	    };
	    Canvas.prototype.viewport2Canvas = function (viewport) {
	        return this.getEventService().viewport2Canvas(viewport);
	    };
	    Canvas.prototype.canvas2Viewport = function (canvas) {
	        return this.getEventService().canvas2Viewport(canvas);
	    };
	    /**
	     * @deprecated
	     * @alias client2Viewport
	     */
	    Canvas.prototype.getPointByClient = function (clientX, clientY) {
	        return this.client2Viewport({ x: clientX, y: clientY });
	    };
	    /**
	     * @deprecated
	     * @alias viewport2Client
	     */
	    Canvas.prototype.getClientByPoint = function (x, y) {
	        return this.viewport2Client({ x: x, y: y });
	    };
	    return Canvas;
	}(EventTarget));

	var getPrototypeOf = createCommonjsModule(function (module) {
	function _getPrototypeOf(o) {
	  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
	  return _getPrototypeOf(o);
	}
	module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _getPrototypeOf = /*@__PURE__*/getDefaultExportFromCjs(getPrototypeOf);

	var superPropBase = createCommonjsModule(function (module) {
	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = getPrototypeOf(object);
	    if (object === null) break;
	  }
	  return object;
	}
	module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var get = createCommonjsModule(function (module) {
	function _get() {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
	  } else {
	    module.exports = _get = function _get(target, property, receiver) {
	      var base = superPropBase(target, property);
	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);
	      if (desc.get) {
	        return desc.get.call(arguments.length < 3 ? target : receiver);
	      }
	      return desc.value;
	    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
	  }
	  return _get.apply(this, arguments);
	}
	module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _get = /*@__PURE__*/getDefaultExportFromCjs(get);

	var setPrototypeOf = createCommonjsModule(function (module) {
	function _setPrototypeOf(o, p) {
	  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
	  return _setPrototypeOf(o, p);
	}
	module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var inherits = createCommonjsModule(function (module) {
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }
	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  Object.defineProperty(subClass, "prototype", {
	    writable: false
	  });
	  if (superClass) setPrototypeOf(subClass, superClass);
	}
	module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _inherits = /*@__PURE__*/getDefaultExportFromCjs(inherits);

	var isNativeReflectConstruct = createCommonjsModule(function (module) {
	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;
	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}
	module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var assertThisInitialized = createCommonjsModule(function (module) {
	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	  return self;
	}
	module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _assertThisInitialized = /*@__PURE__*/getDefaultExportFromCjs(assertThisInitialized);

	var possibleConstructorReturn = createCommonjsModule(function (module) {
	var _typeof = _typeof_1["default"];

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof(call) === "object" || typeof call === "function")) {
	    return call;
	  } else if (call !== void 0) {
	    throw new TypeError("Derived constructors may only return object or undefined");
	  }
	  return assertThisInitialized(self);
	}
	module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var createSuper = createCommonjsModule(function (module) {
	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = isNativeReflectConstruct();
	  return function _createSuperInternal() {
	    var Super = getPrototypeOf(Derived),
	      result;
	    if (hasNativeReflectConstruct) {
	      var NewTarget = getPrototypeOf(this).constructor;
	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }
	    return possibleConstructorReturn(this, result);
	  };
	}
	module.exports = _createSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _createSuper = /*@__PURE__*/getDefaultExportFromCjs(createSuper);

	var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInRadian) {
	  return {
	    x: centerX + radius * Math.cos(angleInRadian),
	    y: centerY + radius * Math.sin(angleInRadian)
	  };
	};

	function computeArcSweep(startAngle, endAngle, anticlockwise) {
	  // 顺时针方向
	  if (!anticlockwise) {
	    if (endAngle >= startAngle) {
	      return endAngle - startAngle <= Math.PI ? 0 : 1;
	    }
	    return endAngle - startAngle <= -Math.PI ? 0 : 1;
	  }
	  // 逆时针方向
	  if (endAngle >= startAngle) {
	    return endAngle - startAngle <= Math.PI ? 1 : 0;
	  }
	  return endAngle - startAngle <= -Math.PI ? 1 : 0;
	}
	var Arc = /*#__PURE__*/function (_Path) {
	  _inherits(Arc, _Path);
	  var _super = _createSuper(Arc);
	  function Arc(config) {
	    var _this;
	    _classCallCheck(this, Arc);
	    _this = _super.call(this, config);
	    _this.updatePath();
	    return _this;
	  }
	  _createClass(Arc, [{
	    key: "setAttribute",
	    value: function setAttribute(name, value, force) {
	      _get(_getPrototypeOf(Arc.prototype), "setAttribute", this).call(this, name, value, force);
	      if (['cx', 'cy', 'startAngle', 'endAngle', 'r', 'anticlockwise'].indexOf(name) > -1) {
	        this.updatePath();
	      }
	    }
	  }, {
	    key: "updatePath",
	    value: function updatePath() {
	      var _this$parsedStyle = this.parsedStyle,
	        _this$parsedStyle$cx = _this$parsedStyle.cx,
	        cx = _this$parsedStyle$cx === void 0 ? 0 : _this$parsedStyle$cx,
	        _this$parsedStyle$cy = _this$parsedStyle.cy,
	        cy = _this$parsedStyle$cy === void 0 ? 0 : _this$parsedStyle$cy,
	        startAngle = _this$parsedStyle.startAngle,
	        endAngle = _this$parsedStyle.endAngle,
	        r = _this$parsedStyle.r,
	        anticlockwise = _this$parsedStyle.anticlockwise;
	      if (isNil(startAngle) || isNil(endAngle) || startAngle === endAngle || isNil(r) || r <= 0) {
	        return;
	      }
	      var path = this.createPath(cx, cy, deg2rad(startAngle), deg2rad(endAngle), r, anticlockwise);
	      _get(_getPrototypeOf(Arc.prototype), "setAttribute", this).call(this, 'path', path);
	    }
	  }, {
	    key: "createPath",
	    value: function createPath(x, y, startAngle, endAngle, r, anticlockwise) {
	      var start = polarToCartesian(x, y, r, startAngle);
	      var end = polarToCartesian(x, y, r, endAngle);
	      var angle = Math.abs(endAngle - startAngle);
	      if (angle >= Math.PI * 2 || isNumberEqual(angle, Math.PI * 2)) {
	        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
	        return [['M', start.x, start.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, middlePoint.x, middlePoint.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, start.x, start.y], ['Z']];
	      }
	      var arcSweep = computeArcSweep(startAngle, endAngle, anticlockwise);
	      return [['M', start.x, start.y], ['A', r, r, 0, arcSweep, anticlockwise ? 0 : 1, end.x, end.y]];
	    }
	  }]);
	  return Arc;
	}(Path);

	var SYMBOLS = {
	  circle: function circle(x, y, r) {
	    return [['M', x - r, y], ['A', r, r, 0, 1, 0, x + r, y], ['A', r, r, 0, 1, 0, x - r, y]];
	  },
	  square: function square(x, y, r) {
	    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
	  },
	  arrow: function arrow(x, y, r) {
	    return [['M', x - r, y + 2 * r / Math.sqrt(3)], ['L', x + r, y + 2 * r / Math.sqrt(3)], ['L', x, y - 2 * r / Math.sqrt(3)], ['Z']];
	  }
	};
	var Marker = /*#__PURE__*/function (_Path) {
	  _inherits(Marker, _Path);
	  var _super = _createSuper(Marker);
	  function Marker(config) {
	    var _this;
	    _classCallCheck(this, Marker);
	    _this = _super.call(this, config);
	    _this.updatePath();
	    return _this;
	  }
	  _createClass(Marker, [{
	    key: "setAttribute",
	    value: function setAttribute(name, value, force) {
	      _get(_getPrototypeOf(Marker.prototype), "setAttribute", this).call(this, name, value, force);
	      if (['x', 'y', 'symbol', 'radius'].indexOf(name) > -1) {
	        this.updatePath();
	      }
	    }
	  }, {
	    key: "updatePath",
	    value: function updatePath() {
	      var _this$parsedStyle = this.parsedStyle,
	        _this$parsedStyle$x = _this$parsedStyle.x,
	        x = _this$parsedStyle$x === void 0 ? 0 : _this$parsedStyle$x,
	        _this$parsedStyle$y = _this$parsedStyle.y,
	        y = _this$parsedStyle$y === void 0 ? 0 : _this$parsedStyle$y;
	      var _this$attributes = this.attributes,
	        radius = _this$attributes.radius,
	        symbol = _this$attributes.symbol;
	      if (!symbol) return;
	      var method = SYMBOLS[symbol];
	      if (!method) return;
	      var path = method(x, y, radius);
	      _get(_getPrototypeOf(Marker.prototype), "setAttribute", this).call(this, 'path', path);
	    }
	  }]);
	  return Marker;
	}(Path);

	var PI = Math.PI;
	var PI2 = PI * 2;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var mathACos = Math.acos;
	var mathATan2 = Math.atan2;
	// const mathAbs = Math.abs;
	var mathSqrt = Math.sqrt;
	var mathMax = Math.max;
	var mathMin = Math.min;
	var e = 1e-4;
	function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	  var dx10 = x1 - x0;
	  var dy10 = y1 - y0;
	  var dx32 = x3 - x2;
	  var dy32 = y3 - y2;
	  var t = dy32 * dx10 - dx32 * dy10;
	  if (t * t < e) {
	    return;
	  }
	  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
	  return [x0 + t * dx10, y0 + t * dy10];
	}
	// Compute perpendicular offset line of length rc.
	function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
	  var x01 = x0 - x1;
	  var y01 = y0 - y1;
	  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
	  var ox = lo * y01;
	  var oy = -lo * x01;
	  var x11 = x0 + ox;
	  var y11 = y0 + oy;
	  var x10 = x1 + ox;
	  var y10 = y1 + oy;
	  var x00 = (x11 + x10) / 2;
	  var y00 = (y11 + y10) / 2;
	  var dx = x10 - x11;
	  var dy = y10 - y11;
	  var d2 = dx * dx + dy * dy;
	  var r = radius - cr;
	  var s = x11 * y10 - x10 * y11;
	  var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d2 - s * s));
	  var cx0 = (s * dy - dx * d) / d2;
	  var cy0 = (-s * dx - dy * d) / d2;
	  var cx1 = (s * dy + dx * d) / d2;
	  var cy1 = (-s * dx + dy * d) / d2;
	  var dx0 = cx0 - x00;
	  var dy0 = cy0 - y00;
	  var dx1 = cx1 - x00;
	  var dy1 = cy1 - y00;
	  // Pick the closer of the two intersection points
	  // TODO: Is there a faster way to determine which intersection to use?
	  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
	    cx0 = cx1;
	    cy0 = cy1;
	  }
	  return {
	    cx: cx0,
	    cy: cy0,
	    x0: -ox,
	    y0: -oy,
	    x1: cx0 * (radius / r - 1),
	    y1: cy0 * (radius / r - 1)
	  };
	}
	function computeArcSweep$1(startAngle, endAngle) {
	  var clockwise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  if (!clockwise) {
	    var replaceAngle = endAngle;
	    endAngle = startAngle;
	    startAngle = replaceAngle;
	  }
	  endAngle = endAngle - startAngle < 0 ? endAngle + PI2 : endAngle;
	  return Math.abs(endAngle - startAngle) % PI2 <= PI ? 0 : 1;
	}
	var Sector = /*#__PURE__*/function (_Path) {
	  _inherits(Sector, _Path);
	  var _super = _createSuper(Sector);
	  function Sector(config) {
	    var _this;
	    _classCallCheck(this, Sector);
	    _this = _super.call(this, config);
	    _this.updatePath();
	    return _this;
	  }
	  _createClass(Sector, [{
	    key: "setAttribute",
	    value: function setAttribute(name, value, force) {
	      _get(_getPrototypeOf(Sector.prototype), "setAttribute", this).call(this, name, value, force);
	      if (['startAngle', 'endAngle', 'r', 'r0', 'radius', 'cx', 'cy'].indexOf(name) > -1) {
	        this.updatePath();
	      }
	    }
	  }, {
	    key: "updatePath",
	    value: function updatePath() {
	      var _this$parsedStyle = this.parsedStyle,
	        cx = _this$parsedStyle.cx,
	        cy = _this$parsedStyle.cy,
	        startAngle = _this$parsedStyle.startAngle,
	        endAngle = _this$parsedStyle.endAngle,
	        r = _this$parsedStyle.r,
	        r0 = _this$parsedStyle.r0,
	        radius = _this$parsedStyle.radius,
	        _this$parsedStyle$ant = _this$parsedStyle.anticlockwise,
	        anticlockwise = _this$parsedStyle$ant === void 0 ? false : _this$parsedStyle$ant;
	      if (isNil(startAngle) || isNil(endAngle) || startAngle === endAngle || isNil(r) || r <= 0) {
	        return;
	      }
	      var path = this.createPath(cx, cy, deg2rad(startAngle), deg2rad(endAngle), r, r0 ? r0 : 0, radius ? radius : [0, 0, 0, 0], anticlockwise);
	      _get(_getPrototypeOf(Sector.prototype), "setAttribute", this).call(this, 'path', path);
	    }
	  }, {
	    key: "createPath",
	    value: function createPath(x, y, startAngle, endAngle, r, r0, borderRadius, anticlockwise) {
	      var start = polarToCartesian(x, y, r, startAngle);
	      var end = polarToCartesian(x, y, r, endAngle);
	      var innerStart = polarToCartesian(x, y, r0, startAngle);
	      var innerEnd = polarToCartesian(x, y, r0, endAngle);
	      var clockwise = !anticlockwise;
	      var angle = clockwise ? endAngle - startAngle : startAngle - endAngle;
	      // 整圆
	      if (Math.abs(angle) >= PI2 || isNumberEqual(Math.abs(angle), PI2)) {
	        // 整个圆是分割成两个圆
	        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
	        var innerMiddlePoint = polarToCartesian(x, y, r0, startAngle + Math.PI);
	        var circlePathCommands = [['M', start.x, start.y], ['A', r, r, 0, 1, clockwise ? 1 : 0, middlePoint.x, middlePoint.y], ['A', r, r, 0, 1, clockwise ? 1 : 0, end.x, end.y]];
	        if (r0 > 0) {
	          circlePathCommands.push(['M', innerStart.x, innerStart.y]);
	          circlePathCommands.push(['A', r0, r0, 0, 1, clockwise ? 0 : 1, innerMiddlePoint.x, innerMiddlePoint.y]);
	          circlePathCommands.push(['A', r0, r0, 0, 1, clockwise ? 0 : 1, innerEnd.x, innerEnd.y]);
	        }
	        circlePathCommands.push(['M', start.x, start.y]);
	        circlePathCommands.push(['Z']);
	        return circlePathCommands;
	      }
	      var xrs = r * mathCos(startAngle);
	      var yrs = r * mathSin(startAngle);
	      var xire = r0 * mathCos(endAngle);
	      var yire = r0 * mathSin(endAngle);
	      var xre = r * mathCos(endAngle);
	      var yre = r * mathSin(endAngle);
	      var xirs = r0 * mathCos(startAngle);
	      var yirs = r0 * mathSin(startAngle);
	      // 顺时针反向，同 radius
	      var _borderRadius = _slicedToArray(borderRadius, 4),
	        outStartRadius = _borderRadius[0],
	        outEndRadius = _borderRadius[1],
	        innerEndRadius = _borderRadius[2],
	        innerStartRadius = _borderRadius[3];
	      var halfRadius = (r - r0) / 2;
	      var outStartBorderRadius = mathMin(halfRadius, outStartRadius);
	      var outEndBorderRadius = mathMin(halfRadius, outEndRadius);
	      var innerEndBorderRadius = mathMin(halfRadius, innerEndRadius);
	      var innerStartBorderRadius = mathMin(halfRadius, innerStartRadius);
	      var outBorderRadiusMax = mathMax(outStartBorderRadius, outEndBorderRadius);
	      var innerBorderRadiusMax = mathMax(innerEndBorderRadius, innerStartBorderRadius);
	      var limitedOutBorderRadiusMax = outBorderRadiusMax;
	      var limitedInnerBorderRadiusMax = innerBorderRadiusMax;
	      // draw corner radius
	      if (outBorderRadiusMax > e || innerBorderRadiusMax > e) {
	        // restrict the max value of corner radius
	        if (angle < PI) {
	          var it = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
	          if (it) {
	            var x0 = xrs - it[0];
	            var y0 = yrs - it[1];
	            var x1 = xre - it[0];
	            var y1 = yre - it[1];
	            var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
	            var b = mathSqrt(it[0] * it[0] + it[1] * it[1]);
	            limitedOutBorderRadiusMax = mathMin(outBorderRadiusMax, (r - b) / (a + 1));
	            limitedInnerBorderRadiusMax = mathMin(innerBorderRadiusMax, (r0 - b) / (a - 1));
	          }
	        }
	      }
	      var arcSweep = computeArcSweep$1(startAngle, endAngle, clockwise);
	      var sectorPathCommands = [];
	      if (limitedOutBorderRadiusMax > e) {
	        var crStart = mathMin(outStartRadius, limitedOutBorderRadiusMax);
	        var crEnd = mathMin(outEndRadius, limitedOutBorderRadiusMax);
	        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, r, crStart, clockwise);
	        var ct1 = computeCornerTangents(xre, yre, xire, yire, r, crEnd, clockwise);
	        sectorPathCommands.push(['M', x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
	        // Have the corners merged?
	        if (limitedOutBorderRadiusMax < outBorderRadiusMax && crStart === crEnd) {
	          var outStartBorderRadiusStartAngle = mathATan2(ct0.cy + ct0.y0, ct0.cx + ct0.x0);
	          var outStartBorderRadiusEndAngle = mathATan2(ct1.cy + ct1.y0, ct1.cx + ct1.x0);
	          sectorPathCommands.push(['A', limitedOutBorderRadiusMax, limitedOutBorderRadiusMax, 0, computeArcSweep$1(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, !clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
	        } else {
	          // draw the two corners and the ring
	          if (crStart > 0) {
	            var _outStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
	            var _outStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
	            var outStartBorderRadiusEndPoint = polarToCartesian(x, y, r, _outStartBorderRadiusEndAngle);
	            sectorPathCommands.push(['A', crStart, crStart, 0, computeArcSweep$1(_outStartBorderRadiusStartAngle, _outStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, outStartBorderRadiusEndPoint.x, outStartBorderRadiusEndPoint.y]);
	          }
	          var outRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
	          var outRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
	          var outRadiusEndPoint = polarToCartesian(x, y, r, outRadiusEndAngle);
	          sectorPathCommands.push(['A', r, r, 1, computeArcSweep$1(outRadiusStartAngle, outRadiusEndAngle, clockwise), clockwise ? 1 : 0, outRadiusEndPoint.x, outRadiusEndPoint.y]);
	          if (crEnd > 0) {
	            var outEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
	            var outEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
	            sectorPathCommands.push(['A', crEnd, crEnd, 0, computeArcSweep$1(outEndBorderRadiusStartAngle, outEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
	          }
	        }
	      } else {
	        sectorPathCommands.push(['M', start.x, start.y]);
	        sectorPathCommands.push(['A', r, r, 0, arcSweep, clockwise ? 1 : 0, end.x, end.y]);
	      }
	      // no inner ring, is a circular sector
	      if (r0 < e) {
	        sectorPathCommands.push(['L', innerEnd.x, innerEnd.y]);
	      } else if (limitedInnerBorderRadiusMax > e) {
	        var _crStart = mathMin(innerStartRadius, limitedInnerBorderRadiusMax);
	        var _crEnd = mathMin(innerEndRadius, limitedInnerBorderRadiusMax);
	        var _ct = computeCornerTangents(0, 0, xire, yire, r0, -_crEnd, clockwise);
	        var _ct2 = computeCornerTangents(xirs, yirs, 0, 0, r0, -_crStart, clockwise);
	        sectorPathCommands.push(['L', x + _ct.cx + _ct.x0, y + _ct.cy + _ct.y0]);
	        // Have the corners merged?
	        if (limitedInnerBorderRadiusMax < innerBorderRadiusMax && _crStart === _crEnd) {
	          var innerStartBorderRadiusStartAngle = mathATan2(_ct.y0, _ct.x0);
	          var innerStartBorderRadiusEndAngle = mathATan2(_ct2.y0, _ct2.x0);
	          sectorPathCommands.push(['A', limitedInnerBorderRadiusMax, limitedInnerBorderRadiusMax, 0, computeArcSweep$1(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle), 1, x + _ct2.cx + _ct2.x0, y + _ct2.cy + _ct2.y0]);
	        } else {
	          // draw the two corners and the ring
	          if (_crEnd > 0) {
	            var _innerStartBorderRadiusStartAngle = mathATan2(_ct.y0, _ct.x0);
	            var _innerStartBorderRadiusEndAngle = mathATan2(_ct.y1, _ct.x1);
	            sectorPathCommands.push(['A', _crEnd, _crEnd, 0, computeArcSweep$1(_innerStartBorderRadiusStartAngle, _innerStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + _ct.cx + _ct.x1, y + _ct.cy + _ct.y1]);
	          }
	          var innerRadiusStartAngle = mathATan2(_ct.cy + _ct.y1, _ct.cx + _ct.x1);
	          var innerRadiusEndAngle = mathATan2(_ct2.cy + _ct2.y1, _ct2.cx + _ct2.x1);
	          var innerRadiusEndPoint = polarToCartesian(x, y, r0, innerRadiusEndAngle);
	          sectorPathCommands.push(['A', r0, r0, 0, computeArcSweep$1(innerRadiusEndAngle, innerRadiusStartAngle, clockwise), clockwise ? 0 : 1, innerRadiusEndPoint.x, innerRadiusEndPoint.y]);
	          if (_crStart > 0) {
	            var innerEndBorderRadiusStartAngle = mathATan2(_ct2.y1, _ct2.x1);
	            var innerEndBorderRadiusEndAngle = mathATan2(_ct2.y0, _ct2.x0);
	            sectorPathCommands.push(['A', _crStart, _crStart, 0, computeArcSweep$1(innerEndBorderRadiusStartAngle, innerEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + _ct2.cx + _ct2.x0, y + _ct2.cy + _ct2.y0]);
	          }
	        }
	      }
	      // the inner ring is just a circular arc
	      else {
	        sectorPathCommands.push(['L', innerEnd.x, innerEnd.y]);
	        sectorPathCommands.push(['A', r0, r0, 0, arcSweep, clockwise ? 0 : 1, innerStart.x, innerStart.y]);
	      }
	      sectorPathCommands.push(['Z']);
	      return sectorPathCommands;
	    }
	  }]);
	  return Sector;
	}(Path);

	/**
	 * @fileOverview convert the line to curve
	 * @author dxq613@gmail.com
	 */
	function getPoint(v) {
	  return [v.x, v.y];
	}
	function smoothBezier(points, smooth, isLoop, constraint) {
	  var cps = [];
	  var prevPoint;
	  var nextPoint;
	  var hasConstraint = !!constraint;
	  var min$1;
	  var max$1;
	  var point;
	  var len;
	  var l;
	  var i;
	  if (hasConstraint) {
	    min$1 = [Infinity, Infinity];
	    max$1 = [-Infinity, -Infinity];
	    for (i = 0, l = points.length; i < l; i++) {
	      point = getPoint(points[i]);
	      min(min$1, min$1, point);
	      max(max$1, max$1, point);
	    }
	    min(min$1, min$1, constraint[0]);
	    max(max$1, max$1, constraint[1]);
	  }
	  for (i = 0, len = points.length; i < len; i++) {
	    point = getPoint(points[i]);
	    if (isLoop) {
	      prevPoint = getPoint(points[i ? i - 1 : len - 1]);
	      nextPoint = getPoint(points[(i + 1) % len]);
	    } else {
	      if (i === 0 || i === len - 1) {
	        cps.push([point[0], point[1]]);
	        continue;
	      } else {
	        prevPoint = getPoint(points[i - 1]);
	        nextPoint = getPoint(points[i + 1]);
	      }
	    }
	    var v = sub$1([], nextPoint, prevPoint);
	    scale$2(v, v, smooth);
	    var d0 = distance(point, prevPoint);
	    var d1 = distance(point, nextPoint);
	    var sum = d0 + d1;
	    if (sum !== 0) {
	      d0 /= sum;
	      d1 /= sum;
	    }
	    var v1 = scale$2([], v, -d0);
	    var v2 = scale$2([], v, d1);
	    var cp0 = add$2([], point, v1);
	    var cp1 = add$2([], point, v2);
	    if (hasConstraint) {
	      max(cp0, cp0, min$1);
	      min(cp0, cp0, max$1);
	      max(cp1, cp1, min$1);
	      min(cp1, cp1, max$1);
	    }
	    cps.push([cp0[0], cp0[1]]);
	    cps.push([cp1[0], cp1[1]]);
	  }
	  if (isLoop) {
	    cps.push(cps.shift());
	  }
	  return cps;
	}
	function catmullRom2bezier(pointList, z, constraint) {
	  var isLoop = !!z;
	  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
	  var len = pointList.length;
	  var d1 = [];
	  var cp1;
	  var cp2;
	  var p;
	  for (var i = 0; i < len - 1; i++) {
	    cp1 = controlPointList[i * 2];
	    cp2 = controlPointList[i * 2 + 1];
	    p = pointList[i + 1];
	    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
	  }
	  if (isLoop) {
	    cp1 = controlPointList[len];
	    cp2 = controlPointList[len + 1];
	    p = pointList[0];
	    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
	  }
	  return d1;
	}

	var smooth = /*#__PURE__*/Object.freeze({
		__proto__: null,
		smooth: catmullRom2bezier
	});

	var SmoothPolyline = /*#__PURE__*/function (_Path) {
	  _inherits(SmoothPolyline, _Path);
	  var _super = _createSuper(SmoothPolyline);
	  function SmoothPolyline(config) {
	    var _this;
	    _classCallCheck(this, SmoothPolyline);
	    _this = _super.call(this, config);
	    _this.updatePath();
	    return _this;
	  }
	  _createClass(SmoothPolyline, [{
	    key: "setAttribute",
	    value: function setAttribute(name, value, force) {
	      _get(_getPrototypeOf(SmoothPolyline.prototype), "setAttribute", this).call(this, name, value, force);
	      if (['smooth', 'points'].indexOf(name) > -1) {
	        this.updatePath();
	      }
	    }
	  }, {
	    key: "updatePath",
	    value: function updatePath() {
	      var _this$parsedStyle = this.parsedStyle,
	        smooth$1 = _this$parsedStyle.smooth,
	        points = _this$parsedStyle.points;
	      var pos = points.points;
	      var d = [['M', pos[0][0], pos[0][1]]];
	      if (smooth$1) {
	        var constaint = [[0, 0], [1, 1]];
	        var sps = catmullRom2bezier(pos.map(function (d) {
	          return {
	            x: d[0],
	            y: d[1]
	          };
	        }), false, constaint);
	        for (var i = 0, n = sps.length; i < n; i++) {
	          var sp = sps[i];
	          d.push(['C', sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);
	        }
	      } else {
	        var _i;
	        var l;
	        for (_i = 1, l = pos.length - 1; _i < l; _i++) {
	          d.push(['L', pos[_i][0], pos[_i][1]]);
	        }
	        d.push(['L', pos[l][0], pos[l][1]]);
	      }
	      _get(_getPrototypeOf(SmoothPolyline.prototype), "setAttribute", this).call(this, 'path', d);
	    }
	  }]);
	  return SmoothPolyline;
	}(Path);
	SmoothPolyline.tag = 'smooth-polyline';

	var clock = typeof performance === 'object' && performance.now ? performance : Date;
	var PRESS_DELAY = 250;
	// 计算滑动的方向
	var calcDirection = function (start, end) {
	    var xDistance = end.x - start.x;
	    var yDistance = end.y - start.y;
	    // x 的距离大于y 说明是横向，否则就是纵向
	    if (Math.abs(xDistance) > Math.abs(yDistance)) {
	        return xDistance > 0 ? 'right' : 'left';
	    }
	    return yDistance > 0 ? 'down' : 'up';
	};
	// 计算2点之间的距离
	var calcDistance = function (point1, point2) {
	    var xDistance = Math.abs(point2.x - point1.x);
	    var yDistance = Math.abs(point2.y - point1.y);
	    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
	};
	var getCenter = function (point1, point2) {
	    var x = point1.x + (point2.x - point1.x) / 2;
	    var y = point1.y + (point2.y - point1.y) / 2;
	    return { x: x, y: y };
	};
	var Gesture = /** @class */ (function (_super) {
	    __extends(Gesture, _super);
	    function Gesture(el) {
	        var _this = _super.call(this) || this;
	        _this.evCache = [];
	        _this.startPoints = [];
	        // 用来记录当前触发的事件
	        _this.processEvent = {};
	        _this.throttleTimer = 0;
	        _this.emitThrottles = [];
	        _this._start = function (ev) {
	            // 每次触点开始都重置事件
	            _this.reset();
	            // 记录touch start 的时间
	            _this.startTime = clock.now();
	            var _a = _this, evCache = _a.evCache, startPoints = _a.startPoints;
	            if (ev) {
	                var pointerId = ev.pointerId, x = ev.x, y = ev.y;
	                evCache.push({
	                    pointerId: pointerId,
	                    x: x,
	                    y: y,
	                    ev: ev,
	                });
	            }
	            // 重置 startPoints
	            startPoints.length = evCache.length;
	            for (var i = 0; i < evCache.length; i++) {
	                var _b = evCache[i], x = _b.x, y = _b.y;
	                var point = { x: x, y: y };
	                startPoints[i] = point;
	            }
	            // 单指事件
	            if (startPoints.length === 1) {
	                var event_1 = evCache[0].ev;
	                // 如果touchstart后停顿250ms, 则也触发press事件
	                // @ts-ignore
	                _this.pressTimeout = setTimeout(function () {
	                    // 这里固定触发press事件
	                    var eventType = 'press';
	                    var direction = 'none';
	                    event_1.direction = direction;
	                    event_1.deltaX = 0;
	                    event_1.deltaY = 0;
	                    event_1.points = startPoints;
	                    _this.emitStart(eventType, event_1);
	                    _this.emit(eventType, event_1);
	                    _this.eventType = eventType;
	                    _this.direction = direction;
	                }, PRESS_DELAY);
	                return;
	            }
	            // 目前只处理双指
	            _this.startDistance = calcDistance(startPoints[0], startPoints[1]);
	            _this.center = getCenter(startPoints[0], startPoints[1]);
	        };
	        _this._move = function (ev) {
	            _this.clearPressTimeout();
	            var _a = _this, startPoints = _a.startPoints, evCache = _a.evCache;
	            if (!startPoints.length)
	                return;
	            var x = ev.x, y = ev.y, pointerId = ev.pointerId;
	            var isTriggerStart = false;
	            // Find this event in the cache and update its record with this event
	            for (var i = 0, len = evCache.length; i < len; i++) {
	                if (pointerId === evCache[i].pointerId) {
	                    evCache[i] = {
	                        pointerId: pointerId,
	                        x: x,
	                        y: y,
	                        ev: ev,
	                    };
	                    isTriggerStart = true;
	                    break;
	                }
	            }
	            // 无触发start事件 需保留startPoints重新触发start
	            if (!isTriggerStart) {
	                var point_1 = { x: x, y: y };
	                startPoints.push(point_1);
	                evCache.push({
	                    pointerId: pointerId,
	                    x: x,
	                    y: y,
	                    ev: ev,
	                });
	                // 目前只处理双指
	                _this.startDistance = calcDistance(startPoints[0], startPoints[1]);
	                _this.center = getCenter(startPoints[0], startPoints[1]);
	            }
	            var point = { x: x, y: y };
	            var points = evCache.map(function (ev) {
	                return { x: ev.x, y: ev.y };
	            });
	            // 记录最后2次move的时间和坐标，为了给swipe事件用
	            var now = clock.now();
	            _this.prevMoveTime = _this.lastMoveTime;
	            _this.prevMovePoint = _this.lastMovePoint;
	            _this.lastMoveTime = now;
	            _this.lastMovePoint = point;
	            if (startPoints.length === 1) {
	                var startPoint = startPoints[0];
	                var deltaX = x - startPoint.x;
	                var deltaY = y - startPoint.y;
	                var direction = _this.direction || calcDirection(startPoint, point);
	                _this.direction = direction;
	                // 获取press或者pan的事件类型
	                // press 按住滑动, pan表示平移
	                // 如果start后立刻move，则触发pan, 如果有停顿，则触发press
	                var eventType = _this.getEventType(point);
	                ev.direction = direction;
	                ev.deltaX = deltaX;
	                ev.deltaY = deltaY;
	                ev.points = points;
	                _this.emitStart(eventType, ev);
	                _this.emit(eventType, ev);
	                return;
	            }
	            // 多指触控
	            var startDistance = _this.startDistance;
	            var currentDistance = calcDistance(points[0], points[1]);
	            // 缩放比例
	            ev.zoom = currentDistance / startDistance;
	            ev.center = _this.center;
	            ev.points = points;
	            // 触发缩放事件
	            _this.emitStart('pinch', ev);
	            // touch 多指会被拆成多个手指的 move, 会触发多次 move，所以这里需要做节流
	            _this._throttleEmit('pinch', ev);
	        };
	        _this._end = function (ev) {
	            var _a = _this, evCache = _a.evCache, startPoints = _a.startPoints;
	            var points = evCache.map(function (ev) {
	                return { x: ev.x, y: ev.y };
	            });
	            ev.points = points;
	            _this.emitEnd(ev);
	            // 单指
	            if (evCache.length === 1) {
	                // swipe事件处理, 在end之后触发
	                var now = clock.now();
	                var lastMoveTime = _this.lastMoveTime;
	                // 做这个判断是为了最后一次touchmove后到end前，是否还有一个停顿的过程
	                // 100 是拍的一个值，理论这个值会很短，一般不卡顿的话在10ms以内
	                if (now - lastMoveTime < 100) {
	                    var prevMoveTime = _this.prevMoveTime || _this.startTime;
	                    var intervalTime = lastMoveTime - prevMoveTime;
	                    // 时间间隔一定要大于0, 否则计算没意义
	                    if (intervalTime > 0) {
	                        var prevMovePoint = _this.prevMovePoint || startPoints[0];
	                        var lastMovePoint = _this.lastMovePoint || startPoints[0];
	                        // move速率
	                        var velocity = calcDistance(prevMovePoint, lastMovePoint) / intervalTime;
	                        // 0.3 是参考hammerjs的设置
	                        if (velocity > 0.3) {
	                            ev.velocity = velocity;
	                            ev.direction = calcDirection(prevMovePoint, lastMovePoint);
	                            _this.emit('swipe', ev);
	                        }
	                    }
	                }
	            }
	            // remove event from cache
	            for (var i = 0, len = evCache.length; i < len; i++) {
	                if (evCache[i].pointerId === ev.pointerId) {
	                    evCache.splice(i, 1);
	                    startPoints.splice(i, 1);
	                    break;
	                }
	            }
	            _this.reset();
	            // 多指离开 1 指后，重新触发一次start
	            if (evCache.length > 0) {
	                _this._start();
	            }
	        };
	        _this._cancel = function (ev) {
	            var evCache = _this.evCache;
	            var points = evCache.map(function (ev) {
	                return { x: ev.x, y: ev.y };
	            });
	            ev.points = points;
	            _this.emitEnd(ev);
	            _this.evCache = [];
	            _this.reset();
	        };
	        _this.el = el;
	        _this._initEvent();
	        return _this;
	    }
	    Gesture.prototype._initEvent = function () {
	        var _this = this;
	        var _a, _b;
	        var el = this.el;
	        if (el.isConnected) {
	            // @ts-ignore
	            (_a = el.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView.addEventListener('pointermove', this._move);
	        }
	        else {
	            el.isMutationObserved = true;
	            el.on(ElementEvent.MOUNTED, function (e) {
	                var _a;
	                return (_a = el.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView.addEventListener('pointermove', 
	                // @ts-ignore
	                _this._move);
	            });
	        }
	        el.addEventListener('pointerdown', this._start);
	        if (el.isConnected) {
	            // @ts-ignore
	            (_b = el.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView.addEventListener('pointerup', this._end);
	        }
	        else {
	            el.on(ElementEvent.MOUNTED, function (e) { var _a; 
	            // @ts-ignore
	            return (_a = el.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView.addEventListener('pointerup', _this._end); });
	        }
	        el.addEventListener('pointercancel', this._cancel);
	        el.addEventListener('pointerupoutside', this._end);
	    };
	    Gesture.prototype.getEventType = function (point) {
	        var _a = this, eventType = _a.eventType, startTime = _a.startTime, startPoints = _a.startPoints;
	        if (eventType) {
	            return eventType;
	        }
	        var type;
	        // @ts-ignore
	        var panEventListeners = this._events.pan;
	        // 如果没有pan事件的监听，默认都是press
	        if (!panEventListeners) {
	            type = 'press';
	        }
	        else {
	            // 如果有pan事件的处理，press则需要停顿250ms, 且移动距离小于10
	            var now = clock.now();
	            if (now - startTime > PRESS_DELAY &&
	                calcDistance(startPoints[0], point) < 10) {
	                type = 'press';
	            }
	            else {
	                type = 'pan';
	            }
	        }
	        this.eventType = type;
	        return type;
	    };
	    Gesture.prototype.enable = function (eventType) {
	        this.processEvent[eventType] = true;
	    };
	    // 是否进行中的事件
	    Gesture.prototype.isProcess = function (eventType) {
	        return this.processEvent[eventType];
	    };
	    // 触发start事件
	    Gesture.prototype.emitStart = function (type, ev) {
	        if (this.isProcess(type)) {
	            return;
	        }
	        this.enable(type);
	        this.emit("".concat(type, "start"), ev);
	    };
	    // 触发事件
	    Gesture.prototype._throttleEmit = function (type, ev) {
	        var _this = this;
	        var _a, _b;
	        // 主要是节流处理
	        this.pushEvent(type, ev);
	        var _c = this, el = _c.el, throttleTimer = _c.throttleTimer, emitThrottles = _c.emitThrottles, processEvent = _c.processEvent;
	        if (throttleTimer) {
	            return;
	        }
	        // @ts-ignore
	        var global = ((_a = el.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) || ((_b = el.document) === null || _b === void 0 ? void 0 : _b.defaultView);
	        this.throttleTimer = global.requestAnimationFrame(function () {
	            for (var i = 0, len = emitThrottles.length; i < len; i++) {
	                var _a = emitThrottles[i], type_1 = _a.type, ev_1 = _a.ev;
	                if (processEvent[type_1]) {
	                    _this.emit(type_1, ev_1);
	                }
	            }
	            // 清空
	            _this.throttleTimer = 0;
	            _this.emitThrottles.length = 0;
	        });
	    };
	    // 触发end事件
	    Gesture.prototype.emitEnd = function (ev) {
	        var _this = this;
	        var processEvent = this.processEvent;
	        Object.keys(processEvent).forEach(function (type) {
	            _this.emit("".concat(type, "end"), ev);
	            delete processEvent[type];
	        });
	    };
	    Gesture.prototype.pushEvent = function (type, ev) {
	        var emitThrottles = this.emitThrottles;
	        var newEvent = { type: type, ev: ev };
	        for (var i = 0, len = emitThrottles.length; i < len; i++) {
	            if (emitThrottles[i].type === type) {
	                emitThrottles.splice(i, 1, newEvent);
	                return;
	            }
	        }
	        emitThrottles.push(newEvent);
	    };
	    Gesture.prototype.clearPressTimeout = function () {
	        if (this.pressTimeout) {
	            clearTimeout(this.pressTimeout);
	            this.pressTimeout = null;
	        }
	    };
	    Gesture.prototype.reset = function () {
	        this.clearPressTimeout();
	        this.startTime = 0;
	        this.startDistance = 0;
	        this.direction = null;
	        this.eventType = null;
	        this.prevMoveTime = 0;
	        this.prevMovePoint = null;
	        this.lastMoveTime = 0;
	        this.lastMovePoint = null;
	    };
	    return Gesture;
	}(eventemitter3));

	var G_SHAPE_EVENT = {
	  click: true,
	  touchstart: true,
	  touchmove: true,
	  touchend: true,
	  touchendoutside: true,
	  dragenter: true,
	  dragleave: true,
	  dragover: true,
	  drop: true,
	  dragstart: true,
	  drag: true,
	  dragend: true
	};
	var GESTURE_EVENT = {
	  panstart: true,
	  pan: true,
	  panend: true,
	  pressstart: true,
	  press: true,
	  pressend: true,
	  swipe: true,
	  pinchstart: true,
	  pinch: true,
	  pinchend: true
	};
	var Gesture$1 = /*#__PURE__*/function () {
	  function Gesture$1(element) {
	    _classCallCheck(this, Gesture$1);
	    this.el = element;
	    this.gesture = new Gesture(element);
	  }
	  _createClass(Gesture$1, [{
	    key: "on",
	    value: function on(eventName, listener) {
	      var el = this.el,
	        gesture = this.gesture;
	      if (G_SHAPE_EVENT[eventName]) {
	        el.addEventListener(eventName, listener);
	        return;
	      }
	      if (GESTURE_EVENT[eventName]) {
	        gesture.on(eventName, listener);
	      }
	    }
	  }, {
	    key: "off",
	    value: function off(eventName, listener) {
	      var el = this.el,
	        gesture = this.gesture;
	      if (G_SHAPE_EVENT[eventName]) {
	        el.removeEventListener(eventName, listener);
	        return;
	      }
	      if (GESTURE_EVENT[eventName]) {
	        gesture.off(eventName, listener);
	      }
	    }
	  }]);
	  return Gesture$1;
	}();

	var SHAPE_TAG = {};
	/**
	 * 注册新的标签
	 */
	var registerTag = function registerTag(name, ShapeConstructor) {
	  SHAPE_TAG[name] = ShapeConstructor;
	};
	var getTag = function getTag(type) {
	  return SHAPE_TAG[type];
	};

	var EVENT_LIST = [['click', 'onClick'], ['touchstart', 'onTouchStart'], ['touchmove', 'onTouchMove'], ['touchend', 'onTouchEnd'], ['touchendoutside', 'onTouchEndOutside'],
	// drage 相关
	['dragenter', 'onDragEnter'], ['dragleave', 'onDragLeave'], ['dragover', 'onDragOver'], ['drop', 'onDrop'], ['dragstart', 'onDragStart'], ['drag', 'onDrag'], ['dragend', 'onDragEnd'],
	// pan
	['panstart', 'onPanStart'], ['pan', 'onPan'], ['panend', 'onPanEnd'],
	// press
	['pressstart', 'onPressStart'], ['press', 'onPress'], ['pressend', 'onPressEnd'],
	// swipe
	['swipe', 'onSwipe'],
	// pinch
	['pinchstart', 'onPinchStart'], ['pinch', 'onPinch'], ['pinchend', 'onPinchEnd']];
	// 默认标签
	var TagElements = [['group', Rect], ['text', Text], ['circle', Circle], ['path', Path], ['ellipse', Ellipse], ['rect', Rect], ['image', Image], ['line', Line], ['polyline', SmoothPolyline], ['polygon', Polygon], ['arc', Arc], ['marker', Marker], ['sector', Sector]];
	TagElements.map(function (_ref) {
	  var _ref2 = _slicedToArray(_ref, 2),
	    type = _ref2[0],
	    ShapeClass = _ref2[1];
	  registerTag(type, ShapeClass);
	});
	// 注册 css 属性，不能注册已有属性，比如 r width等
	var SECTOR_CSS_PROPERTY = [{
	  name: 'r0',
	  inherits: false,
	  interpolable: true,
	  syntax: PropertySyntax.LENGTH_PERCENTAGE
	}, {
	  name: 'startAngle',
	  inherits: false,
	  interpolable: true,
	  syntax: PropertySyntax.ANGLE
	}, {
	  name: 'endAngle',
	  inherits: false,
	  interpolable: true,
	  syntax: PropertySyntax.ANGLE
	}];
	SECTOR_CSS_PROPERTY.forEach(function (property) {
	  CSS.registerProperty(property);
	});
	function createShape(type, props) {
	  if (!type) return null;
	  var ShapeClass = getTag(type);
	  if (!ShapeClass) return null;
	  // const result = checkCSSRule(type, originStyle);
	  var shape = new ShapeClass(props);
	  // @ts-ignore
	  shape.gesture = addEvent(shape, props);
	  return shape;
	}
	function updateShape(shape, props, lastProps) {
	  // @ts-ignore
	  var gesture = shape.gesture;
	  // 如果 shape 上存在 gesture，说明是 jsx 标签创建的元素，才需要更新事件
	  if (gesture) {
	    // 先清除上次 props 绑定的事件
	    EVENT_LIST.forEach(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        eventName = _ref4[0],
	        handlerName = _ref4[1];
	      if (!lastProps[handlerName]) return;
	      gesture.off(eventName, lastProps[handlerName]);
	    });
	    // 绑定最新的事件
	    EVENT_LIST.forEach(function (_ref5) {
	      var _ref6 = _slicedToArray(_ref5, 2),
	        eventName = _ref6[0],
	        handlerName = _ref6[1];
	      if (!props[handlerName]) return;
	      gesture.on(eventName, props[handlerName]);
	    });
	  }
	  return shape;
	}
	function addEvent(shape, props) {
	  var gesture = new Gesture$1(shape);
	  EVENT_LIST.forEach(function (_ref7) {
	    var _ref8 = _slicedToArray(_ref7, 2),
	      eventName = _ref8[0],
	      handlerName = _ref8[1];
	    if (!props[handlerName]) return;
	    gesture.on(eventName, props[handlerName]);
	  });
	  return gesture;
	}

	function objToString(obj) {
	  return Object.prototype.toString.call(obj);
	}
	function objectKeys(obj) {
	  return Object.keys(obj);
	}
	function equal(a, b) {
	  if (a === b) return true;
	  if (_typeof(a) !== _typeof(b)) {
	    return false;
	  }
	  // null 和 undefined
	  if (a == null || b == null) {
	    return false;
	  }
	  // 特殊处理NaN
	  if (Number.isNaN(a) && Number.isNaN(b)) {
	    return true;
	  }
	  if (objToString(a) !== objToString(b)) {
	    return false;
	  }
	  // 函数不相等，也认为不同
	  if (isFunction(a)) {
	    return false;
	  }
	  // 值类型，Number String Boolean
	  if (_typeof(a) !== 'object') {
	    return false;
	  }
	  if (isArray(a)) {
	    if (a.length !== b.length) {
	      return false;
	    }
	    for (var i = a.length - 1; i >= 0; i--) {
	      if (!equal(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	  if (!isPlainObject(a)) {
	    return false;
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  // having the same number of owned properties (keys incorporates hasOwnProperty)
	  if (ka.length !== kb.length) {
	    return false;
	  }
	  // the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  // ~~~cheap key test
	  for (var _i = ka.length - 1; _i >= 0; _i--) {
	    if (ka[_i] != kb[_i]) {
	      return false;
	    }
	  }
	  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
	  for (var _i2 = ka.length - 1; _i2 >= 0; _i2--) {
	    var key = ka[_i2];
	    if (!equal(a[key], b[key])) {
	      return false;
	    }
	  }
	  return true;
	}

	var arrayWithoutHoles = createCommonjsModule(function (module) {
	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return arrayLikeToArray(arr);
	}
	module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var iterableToArray = createCommonjsModule(function (module) {
	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}
	module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var nonIterableSpread = createCommonjsModule(function (module) {
	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var toConsumableArray = createCommonjsModule(function (module) {
	function _toConsumableArray(arr) {
	  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
	}
	module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _toConsumableArray = /*@__PURE__*/getDefaultExportFromCjs(toConsumableArray);

	var FunctionComponent = 0;
	var ClassComponent = 1;
	var Shape$1 = 2;
	function getWorkTag(type) {
	  if (isString(type)) {
	    return Shape$1;
	  }
	  if (type.prototype && type.prototype.isF2Component) {
	    return ClassComponent;
	  }
	  return FunctionComponent;
	}

	// 查找 transform 最近的 shape 元素
	function findClosestShapeNode(vNode) {
	  var tag = vNode.tag,
	    children = vNode.children;
	  if (tag === Shape$1) {
	    return vNode;
	  }
	  var shapeNode;
	  Children.map(children, function (child) {
	    if (shapeNode) return;
	    shapeNode = findClosestShapeNode(child);
	  });
	  return shapeNode;
	}

	var eventemitter3$1 = createCommonjsModule(function (module) {

	var has = Object.prototype.hasOwnProperty
	  , prefix = '~';

	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @private
	 */
	function Events() {}

	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);

	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}

	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Add a listener for a given event.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} once Specify if the listener is a one-time listener.
	 * @returns {EventEmitter}
	 * @private
	 */
	function addListener(emitter, event, fn, context, once) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('The listener must be a function');
	  }

	  var listener = new EE(fn, context || emitter, once)
	    , evt = prefix ? prefix + event : event;

	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
	  else emitter._events[evt] = [emitter._events[evt], listener];

	  return emitter;
	}

	/**
	 * Clear event by name.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} evt The Event name.
	 * @private
	 */
	function clearEvent(emitter, evt) {
	  if (--emitter._eventsCount === 0) emitter._events = new Events();
	  else delete emitter._events[evt];
	}

	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = []
	    , events
	    , name;

	  if (this._eventsCount === 0) return names;

	  for (name in (events = this._events)) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Array} The registered listeners.
	 * @public
	 */
	EventEmitter.prototype.listeners = function listeners(event) {
	  var evt = prefix ? prefix + event : event
	    , handlers = this._events[evt];

	  if (!handlers) return [];
	  if (handlers.fn) return [handlers.fn];

	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
	    ee[i] = handlers[i].fn;
	  }

	  return ee;
	};

	/**
	 * Return the number of listeners listening to a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Number} The number of listeners.
	 * @public
	 */
	EventEmitter.prototype.listenerCount = function listenerCount(event) {
	  var evt = prefix ? prefix + event : event
	    , listeners = this._events[evt];

	  if (!listeners) return 0;
	  if (listeners.fn) return 1;
	  return listeners.length;
	};

	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Add a listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  return addListener(this, event, fn, context, false);
	};

	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  return addListener(this, event, fn, context, true);
	};

	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {*} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return this;
	  if (!fn) {
	    clearEvent(this, evt);
	    return this;
	  }

	  var listeners = this._events[evt];

	  if (listeners.fn) {
	    if (
	      listeners.fn === fn &&
	      (!once || listeners.once) &&
	      (!context || listeners.context === context)
	    ) {
	      clearEvent(this, evt);
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (
	        listeners[i].fn !== fn ||
	        (once && !listeners[i].once) ||
	        (context && listeners[i].context !== context)
	      ) {
	        events.push(listeners[i]);
	      }
	    }

	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
	    else clearEvent(this, evt);
	  }

	  return this;
	};

	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {(String|Symbol)} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;

	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) clearEvent(this, evt);
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;

	//
	// Expose the module.
	//
	{
	  module.exports = EventEmitter;
	}
	});

	function applyStyle(shape, style) {
	  if (!style) return;
	  Object.keys(style).forEach(function (key) {
	    // 特殊处理 clip 和 offset
	    if (key === 'clip' || key === 'offset') {
	      var effect = style[key];
	      // value 为 ref
	      if (isDisplayObject(effect === null || effect === void 0 ? void 0 : effect.current)) {
	        shape.setAttribute("".concat(key, "Path"), effect.current);
	        return;
	      }
	      var effectConfig = isFunction(effect) ? effect(style) : effect;
	      if (effectConfig) {
	        var type = effectConfig.type,
	          _style = effectConfig.style;
	        var effectShape = createShape(type, {
	          style: _style
	        });
	        shape.setAttribute("".concat(key, "Path"), effectShape);
	      }
	    } else {
	      shape.setAttribute(key, style[key]);
	    }
	  });
	}

	var Animator = /*#__PURE__*/function (_EE) {
	  _inherits(Animator, _EE);
	  var _super = _createSuper(Animator);
	  function Animator(timeline) {
	    var _this;
	    _classCallCheck(this, Animator);
	    _this = _super.call(this);
	    _this.timeline = timeline;
	    return _this;
	  }
	  _createClass(Animator, [{
	    key: "animate",
	    value: function animate(shape, start, end, effect) {
	      this.shape = shape;
	      this.start = start;
	      this.end = end;
	      this.effect = effect;
	    }
	    // 首次播放
	  }, {
	    key: "run",
	    value: function run() {
	      var vNode = this.vNode,
	        shape = this.shape,
	        start = this.start,
	        end = this.end,
	        effect = this.effect,
	        children = this.children;
	      var animations = [];
	      if (effect) {
	        var _effect$property = effect.property,
	          property = _effect$property === void 0 ? [] : _effect$property,
	          easing = effect.easing,
	          duration = effect.duration,
	          delay = effect.delay,
	          iterations = effect.iterations,
	          clip = effect.clip,
	          _effect$direction = effect.direction,
	          direction = _effect$direction === void 0 ? 'normal' : _effect$direction,
	          _effect$onFrame = effect.onFrame,
	          onFrame = _effect$onFrame === void 0 ? function () {} : _effect$onFrame,
	          _effect$onEnd = effect.onEnd,
	          onEnd = _effect$onEnd === void 0 ? function () {} : _effect$onEnd;
	        // shape 动画
	        if (property.length && duration > 0) {
	          // 应用样式
	          var style = _objectSpread(_objectSpread({}, omit(start, property)), omit(end, property));
	          applyStyle(shape, style);
	          // 开始帧
	          var keyframeStart = property.reduce(function (prev, cur) {
	            prev[cur] = start[cur];
	            return prev;
	          }, {});
	          // 结束帧
	          var keyframeEnd = pick(end, property);
	          var animation = shape.animate([keyframeStart, keyframeEnd], {
	            fill: 'both',
	            easing: easing,
	            duration: duration,
	            delay: delay,
	            iterations: iterations,
	            direction: direction
	          });
	          if (animation) {
	            animation.onframe = onFrame;
	            animation.onfinish = onEnd;
	            // 过滤无限循环的动画
	            if (iterations !== Infinity) {
	              animations.push(animation);
	            }
	          } else {
	            // 如果没有执行动画，直接应用结束样式
	            applyStyle(shape, end);
	          }
	        } else {
	          // 直接应用结束样式
	          applyStyle(shape, end);
	        }
	        // clip 动画
	        if (clip) {
	          var clipConfig = isFunction(clip) ? clip(end) : clip;
	          if (clipConfig) {
	            var clipType = clipConfig.type,
	              clipStyle = clipConfig.style,
	              _clipConfig$property = clipConfig.property,
	              clipProperty = _clipConfig$property === void 0 ? [] : _clipConfig$property,
	              clipEasing = clipConfig.easing,
	              clipDuration = clipConfig.duration,
	              clipDelay = clipConfig.delay,
	              clipIterations = clipConfig.iterations,
	              clipStart = clipConfig.start,
	              clipEnd = clipConfig.end,
	              clipDirection = clipConfig.direction;
	            if (clipProperty.length && (clipDuration || duration) > 0) {
	              var clipStartStyle = _objectSpread(_objectSpread({}, clipStyle), clipStart);
	              var clipEndStyle = _objectSpread(_objectSpread({}, clipStyle), clipEnd);
	              // 开始帧
	              var clipKeyframeStart = clipProperty.reduce(function (prev, cur) {
	                prev[cur] = clipStartStyle[cur];
	                return prev;
	              }, {});
	              // 结束帧
	              var clipKeyframeEnd = pick(clipEndStyle, clipProperty);
	              var clipShape = createShape(clipType, {
	                style: clipStartStyle
	              });
	              shape.setAttribute('clipPath', clipShape);
	              // g 中 clip 为全局，且如果要在 clip上加动画，需要手动加到canvas上
	              shape.ownerDocument.documentElement.appendChild(clipShape);
	              var clipAnimation = clipShape.animate([clipKeyframeStart, clipKeyframeEnd], {
	                fill: 'both',
	                easing: clipEasing || easing,
	                duration: clipDuration || duration,
	                delay: clipDelay || delay,
	                iterations: clipIterations || iterations,
	                direction: clipDirection || direction
	              });
	              // 过滤无限循环的动画
	              if (clipAnimation) {
	                var clipFinished = clipAnimation.finished;
	                clipFinished.then(function () {
	                  // 删掉 clip
	                  shape.setAttribute('clipPath', null);
	                  clipShape.destroy();
	                });
	                if ((clipIterations || iterations) !== Infinity) {
	                  animations.push(clipAnimation);
	                }
	              } else {
	                // 没有动画，直接删掉 clip
	                shape.setAttribute('clipPath', null);
	                clipShape.destroy();
	              }
	            }
	          }
	        }
	      }
	      if (children && children.length) {
	        children.forEach(function (child) {
	          if (!child) return;
	          var childAnimator = child.run();
	          if (childAnimator) {
	            animations.push.apply(animations, _toConsumableArray(childAnimator));
	          }
	        });
	      }
	      this.animations = animations;
	      if (this.timeline) {
	        this.timeline.push(animations);
	      }
	      // TODO：这段代码放这个位置感觉挺奇怪，看看是否有更合适的地方
	      if (vNode) {
	        var component = vNode.component;
	        if (vNode && vNode.component) {
	          // @ts-ignore
	          component.animationWillPlay && component.animationWillPlay();
	        }
	      }
	      this.endEmit(animations);
	      return animations;
	    }
	  }, {
	    key: "play",
	    value: function play() {
	      var animations = this.animations;
	      if (!animations || !animations.length) return;
	      animations.forEach(function (d) {
	        d.play();
	      });
	    }
	  }, {
	    key: "pause",
	    value: function pause() {
	      var animations = this.animations;
	      if (!animations || !animations.length) return;
	      animations.forEach(function (d) {
	        d.pause();
	      });
	    }
	  }, {
	    key: "goTo",
	    value: function goTo(frame) {
	      var animations = this.animations;
	      if (!animations || !animations.length) return;
	      animations.forEach(function (d) {
	        d.currentTime = frame;
	      });
	    }
	  }, {
	    key: "finish",
	    value: function finish() {
	      var animations = this.animations;
	      if (!animations || !animations.length) return;
	      animations.forEach(function (d) {
	        d.pause();
	      });
	    }
	  }, {
	    key: "endEmit",
	    value: function endEmit(animations) {
	      var _this2 = this;
	      if (!animations.length) {
	        this.emit('end');
	        return null;
	      }
	      var finished = Promise.all(animations.map(function (d) {
	        return d.finished;
	      }));
	      finished.then(function () {
	        _this2.emit('end');
	      });
	    }
	  }, {
	    key: "reset",
	    value: function reset(shape) {
	      this.shape = shape;
	      this.start = null;
	      this.end = null;
	      this.effect = null;
	      this.children = null;
	    }
	  }]);
	  return Animator;
	}(eventemitter3$1);

	function findAllShapeNode(vNode) {
	  var shapeNodes = [];
	  Children.map(vNode, function (node) {
	    if (!node) return;
	    var tag = node.tag,
	      type = node.type,
	      children = node.children;
	    if (tag === Shape$1 && type !== 'group') {
	      shapeNodes.push(node);
	    }
	    if (children) {
	      shapeNodes.push.apply(shapeNodes, _toConsumableArray(findAllShapeNode(children)));
	    }
	  });
	  return shapeNodes;
	}
	function morphShape(lastNode, nextNode, animator) {
	  var nextProps = nextNode.props,
	    nextShape = nextNode.shape,
	    nextStyle = nextNode.style,
	    context = nextNode.context;
	  var lastShape = lastNode.shape,
	    lastStyle = lastNode.style,
	    lastAnimation = lastNode.animator;
	  // 形变动画之前先把原 shape 销毁
	  lastShape.destroy();
	  var animate = nextProps.animate,
	    animation = nextProps.animation;
	  var animationEffect = animation ? animation.update : null;
	  if (animate === false || !animationEffect) {
	    return animator;
	  }
	  animator = animator || new Animator(context.timeline);
	  // shape 形变
	  var start = animationEffect.start,
	    end = animationEffect.end,
	    _animationEffect$prop = animationEffect.property,
	    property = _animationEffect$prop === void 0 ? [] : _animationEffect$prop;
	  var nextParsedStyle = nextShape.parsedStyle;
	  var lastParsedStyle = lastShape.parsedStyle;
	  var lastPath = convertToPath(lastShape);
	  var nextPath = convertToPath(nextShape);
	  var startStyle = _objectSpread(_objectSpread(_objectSpread({}, lastStyle), start), {}, {
	    path: lastPath
	  });
	  var endStyle = _objectSpread(_objectSpread(_objectSpread({}, nextStyle), end), {}, {
	    path: nextPath
	  });
	  var pathShape = createShape('path', {
	    style: _objectSpread(_objectSpread({}, startStyle), {}, {
	      path: ''
	    })
	  });
	  // 形变双方都有的属性才能动画
	  var animateProperty = property.filter(function (key) {
	    return nextParsedStyle.hasOwnProperty(key) && lastParsedStyle.hasOwnProperty(key);
	  }).concat('path');
	  animator.animate(pathShape, startStyle, endStyle, _objectSpread(_objectSpread({}, animationEffect), {}, {
	    property: animateProperty
	  }));
	  var _nextNode$context = nextNode === null || nextNode === void 0 ? void 0 : nextNode.context,
	    timeline = _nextNode$context.timeline;
	  timeline && timeline.delete(lastAnimation);
	  animator.once('end', function () {
	    applyStyle(nextShape, endStyle);
	    pathShape.replaceWith(nextShape);
	  });
	  return animator;
	}
	function appearAnimation(vNode) {
	  return Children.map(vNode, function (node) {
	    if (!node) return;
	    var tag = node.tag,
	      shape = node.shape,
	      style = node.style,
	      children = node.children,
	      animate = node.animate,
	      props = node.props,
	      animator = node.animator;
	    animator.reset(shape);
	    // 有叶子节点，先执行叶子节点
	    animator.children = children ? createAnimation(node, children, null) : null;
	    // 不需要执行动画
	    if (animate === false || tag !== Shape$1) {
	      applyStyle(shape, style);
	      return animator;
	    }
	    var animation = props.animation;
	    var animationEffect = animation ? animation.appear : null;
	    if (!animationEffect) {
	      // 没有动画直接应用样式
	      applyStyle(shape, style);
	      return animator;
	    }
	    var _animationEffect$star = animationEffect.start,
	      start = _animationEffect$star === void 0 ? {} : _animationEffect$star,
	      end = animationEffect.end;
	    var endStyle = _objectSpread(_objectSpread({}, style), end);
	    animator.animate(shape, start, endStyle, animationEffect);
	    return animator;
	  });
	}
	function updateAnimation(nextNode, lastNode) {
	  var nextTag = nextNode.tag,
	    nextType = nextNode.type,
	    nextStyle = nextNode.style,
	    nextChildren = nextNode.children,
	    nextProps = nextNode.props,
	    nextShape = nextNode.shape,
	    animator = nextNode.animator,
	    animate = nextNode.animate;
	  var lastTag = lastNode.tag,
	    lastType = lastNode.type,
	    lastStyle = lastNode.style,
	    lastChildren = lastNode.children,
	    lastShape = lastNode.shape;
	  animator.reset(nextShape);
	  // 先处理叶子节点
	  animator.children = createAnimation(nextNode, nextChildren, lastChildren);
	  var animation = nextProps.animation;
	  var animationEffect = animation ? animation.update : null;
	  // 类型相同
	  if (nextType === lastType) {
	    // 清除之前的样式
	    var resetStyle = lastStyle ? Object.keys(lastStyle).reduce(function (prev, cur) {
	      prev[cur] = '';
	      return prev;
	    }, {}) : null;
	    // 需要更新的样式
	    var style = _objectSpread(_objectSpread({}, resetStyle), nextStyle);
	    // 组件，直接更新
	    if (nextTag !== Shape$1) {
	      applyStyle(nextShape, style);
	      return animator;
	    }
	    // 没有动画直接应用样式
	    if (animate === false || !animationEffect) {
	      applyStyle(nextShape, style);
	      return animator;
	    }
	    var start = animationEffect.start,
	      end = animationEffect.end;
	    var startStyle = _objectSpread(_objectSpread({}, lastStyle), start);
	    var endStyle = _objectSpread(_objectSpread({}, style), end);
	    animator.animate(nextShape, startStyle, endStyle, animationEffect);
	    return animator;
	  }
	  // 无法处理形变
	  if (nextTag !== Shape$1 || lastTag !== Shape$1) {
	    lastShape.destroy();
	    return animator;
	  }
	  // 从 shape 到 group
	  if (nextType === 'group') {
	    var shapeNodes = findAllShapeNode(nextNode.children);
	    return shapeNodes.map(function (node) {
	      return morphShape(lastNode, node);
	    });
	  }
	  // 从 group 到 shape
	  if (lastType === 'group') {
	    var _shapeNodes = findAllShapeNode(lastNode.children);
	    return _shapeNodes.map(function (node) {
	      return morphShape(node, nextNode);
	    });
	  }
	  // 没有动画直接应用样式
	  if (animate === false || !animationEffect) {
	    applyStyle(nextShape, nextStyle);
	    return animator;
	  }
	  return morphShape(lastNode, nextNode, animator);
	}
	function destroyAnimation(node) {
	  return Children.map(node, function (vNode) {
	    if (!vNode) return null;
	    var tag = vNode.tag,
	      shape = vNode.shape,
	      children = vNode.children,
	      animate = vNode.animate,
	      style = vNode.style,
	      props = vNode.props,
	      animator = vNode.animator,
	      context = vNode.context;
	    var timeline = context.timeline;
	    if (shape.destroyed) {
	      return null;
	    }
	    // 重置
	    animator.reset(shape);
	    // 先处理叶子节点
	    var childrenAnimation = children ? Children.toArray(children).map(function (child) {
	      return destroyAnimation(child);
	    }).filter(Boolean) : null;
	    // 不需要动画直接删除
	    if (animate === false) {
	      shape.destroy();
	      return animator;
	    }
	    var animation = props.animation;
	    var animationEffect = animation ? animation.leave : null;
	    // 没有叶子节点的动画， 直接删除
	    if (!(childrenAnimation && childrenAnimation.length) && !animationEffect) {
	      shape.destroy();
	      return animator;
	    }
	    animator.children = childrenAnimation;
	    // 图形有动画
	    if (animationEffect && tag === Shape$1) {
	      var start = animationEffect.start,
	        _animationEffect$end = animationEffect.end,
	        end = _animationEffect$end === void 0 ? {} : _animationEffect$end;
	      var startStyle = _objectSpread(_objectSpread({}, style), start);
	      var endStyle = end;
	      animator.animate(shape, startStyle, endStyle, animationEffect);
	      timeline && timeline.delete(animator.animations);
	    }
	    // 动画结束后，删除图形（包括子元素动画）
	    animator.once('end', function () {
	      shape.destroy();
	    });
	    return animator;
	  });
	}
	function createAnimator(nextNode, lastNode) {
	  if (!nextNode && !lastNode) {
	    return null;
	  }
	  // delete 动画
	  if (!nextNode && lastNode) {
	    return destroyAnimation(lastNode);
	  }
	  // 如果有 transform 则从 transform 比
	  var transform = nextNode.transform;
	  if (transform) {
	    var closestShapeNode = findClosestShapeNode(nextNode);
	    nextNode.transform = null;
	    closestShapeNode.transform = transform;
	  }
	  if (nextNode.transform) {
	    if (!lastNode) {
	      return updateAnimation(nextNode, nextNode.transform);
	    }
	    return [updateAnimation(nextNode, nextNode.transform), destroyAnimation(lastNode)];
	  }
	  // appear 动画
	  if (nextNode && !lastNode) {
	    return appearAnimation(nextNode);
	  }
	  // update 动画
	  return updateAnimation(nextNode, lastNode);
	}
	function insertShape(parent, shape, nextSibling) {
	  if (nextSibling) {
	    parent.insertBefore(shape, nextSibling);
	  } else {
	    parent.appendChild(shape);
	  }
	}
	// 处理 children 的动画
	function createAnimation(parent, nextChildren, lastChildren) {
	  if (!nextChildren && !lastChildren) {
	    return [];
	  }
	  var parentShape = parent.shape;
	  // 上一个处理的元素
	  var prevSibling;
	  var childrenAnimator = [];
	  Children.compare(nextChildren, lastChildren, function (nextNode, lastNode) {
	    // shape 层才执行动画
	    var animator = createAnimator(nextNode, lastNode);
	    Children.map(animator, function (item) {
	      if (!item) return;
	      childrenAnimator.push(item);
	      var shape = item.shape;
	      if (!shape || shape.destroyed) return;
	      var nextSibling;
	      // 更新文档流
	      if (!prevSibling) {
	        nextSibling = parentShape.firstChild;
	      } else {
	        nextSibling = prevSibling.nextSibling;
	      }
	      if (nextSibling !== shape) {
	        insertShape(parentShape, shape, nextSibling);
	      }
	      prevSibling = shape;
	    });
	  });
	  return childrenAnimator;
	}

	var rect = (function (layout) {
	  var left = layout.left,
	    top = layout.top,
	    width = layout.width,
	    height = layout.height;
	  return {
	    x: left,
	    y: top,
	    width: width,
	    height: height
	  };
	});

	var line = (function (layout) {
	  var left = layout.left,
	    top = layout.top,
	    width = layout.width,
	    height = layout.height;
	  return {
	    x1: left,
	    y1: top,
	    x2: left + width,
	    y2: top + height
	  };
	});

	var text = (function (layout) {
	  var height = layout.height,
	    left = layout.left,
	    top = layout.top;
	  return {
	    x: left,
	    y: top + height / 2,
	    // 通过middle + top 才能比较好的实现文本对齐
	    textBaseline: 'middle'
	  };
	});

	var circle = (function (layout) {
	  var left = layout.left,
	    top = layout.top,
	    width = layout.width;
	  var r = width / 2;
	  return {
	    cx: left + r,
	    cy: top + r,
	    r: r
	  };
	});

	var marker = (function (layout) {
	  var left = layout.left,
	    top = layout.top,
	    width = layout.width;
	  var r = width / 2;
	  return {
	    x: left + r,
	    y: top,
	    radius: r
	  };
	});

	var map$1 = {
	  rect: rect,
	  line: line,
	  text: text,
	  circle: circle,
	  marker: marker,
	  group: rect
	};
	var getShapeAttrs = (function (type, layout) {
	  if (!layout) return null;
	  var fn = map$1[type] || rect;
	  return fn(layout);
	});

	/* eslint-disable */
	// @ts-nocheck
	// from css-layout
	var CSS_UNDEFINED;
	var CSS_DIRECTION_INHERIT = 'inherit';
	var CSS_DIRECTION_LTR = 'ltr';
	var CSS_DIRECTION_RTL = 'rtl';
	var CSS_FLEX_DIRECTION_ROW = 'row';
	var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';
	var CSS_FLEX_DIRECTION_COLUMN = 'column';
	var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';
	var CSS_JUSTIFY_FLEX_START = 'flex-start';
	var CSS_JUSTIFY_CENTER = 'center';
	var CSS_JUSTIFY_FLEX_END = 'flex-end';
	var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';
	var CSS_JUSTIFY_SPACE_AROUND = 'space-around';
	var CSS_ALIGN_FLEX_START = 'flex-start';
	var CSS_ALIGN_CENTER = 'center';
	var CSS_ALIGN_FLEX_END = 'flex-end';
	var CSS_ALIGN_STRETCH = 'stretch';
	var CSS_POSITION_RELATIVE = 'relative';
	var CSS_POSITION_ABSOLUTE = 'absolute';
	var leading = {
	  row: 'left',
	  'row-reverse': 'right',
	  column: 'top',
	  'column-reverse': 'bottom'
	};
	var trailing = {
	  row: 'right',
	  'row-reverse': 'left',
	  column: 'bottom',
	  'column-reverse': 'top'
	};
	var pos = {
	  row: 'left',
	  'row-reverse': 'right',
	  column: 'top',
	  'column-reverse': 'bottom'
	};
	var dim = {
	  row: 'width',
	  'row-reverse': 'width',
	  column: 'height',
	  'column-reverse': 'height'
	};
	// When transpiled to Java / C the node type has layout, children and style
	// properties. For the JavaScript version this function adds these properties
	// if they don't already exist.
	function fillNodes(node) {
	  if (!node.layout || node.isDirty) {
	    node.layout = {
	      width: undefined,
	      height: undefined,
	      top: 0,
	      left: 0,
	      right: 0,
	      bottom: 0
	    };
	  }
	  if (!node.style) {
	    node.style = {};
	  }
	  if (!node.children) {
	    node.children = [];
	  }
	  node.children.forEach(fillNodes);
	  return node;
	}
	function isUndefined$1(value) {
	  return value === undefined;
	}
	function isRowDirection(flexDirection) {
	  return flexDirection === CSS_FLEX_DIRECTION_ROW || flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;
	}
	function isColumnDirection(flexDirection) {
	  return flexDirection === CSS_FLEX_DIRECTION_COLUMN || flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;
	}
	function getLeadingMargin(node, axis) {
	  if (node.style.marginStart !== undefined && isRowDirection(axis)) {
	    return node.style.marginStart;
	  }
	  var value = null;
	  switch (axis) {
	    case 'row':
	      value = node.style.marginLeft;
	      break;
	    case 'row-reverse':
	      value = node.style.marginRight;
	      break;
	    case 'column':
	      value = node.style.marginTop;
	      break;
	    case 'column-reverse':
	      value = node.style.marginBottom;
	      break;
	  }
	  if (value !== undefined) {
	    return value;
	  }
	  if (node.style.margin !== undefined) {
	    return node.style.margin;
	  }
	  return 0;
	}
	function getTrailingMargin(node, axis) {
	  if (node.style.marginEnd !== undefined && isRowDirection(axis)) {
	    return node.style.marginEnd;
	  }
	  var value = null;
	  switch (axis) {
	    case 'row':
	      value = node.style.marginRight;
	      break;
	    case 'row-reverse':
	      value = node.style.marginLeft;
	      break;
	    case 'column':
	      value = node.style.marginBottom;
	      break;
	    case 'column-reverse':
	      value = node.style.marginTop;
	      break;
	  }
	  if (value != null) {
	    return value;
	  }
	  if (node.style.margin !== undefined) {
	    return node.style.margin;
	  }
	  return 0;
	}
	function getLeadingPadding(node, axis) {
	  if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0 && isRowDirection(axis)) {
	    return node.style.paddingStart;
	  }
	  var value = null;
	  switch (axis) {
	    case 'row':
	      value = node.style.paddingLeft;
	      break;
	    case 'row-reverse':
	      value = node.style.paddingRight;
	      break;
	    case 'column':
	      value = node.style.paddingTop;
	      break;
	    case 'column-reverse':
	      value = node.style.paddingBottom;
	      break;
	  }
	  if (value != null && value >= 0) {
	    return value;
	  }
	  if (node.style.padding !== undefined && node.style.padding >= 0) {
	    return node.style.padding;
	  }
	  return 0;
	}
	function getTrailingPadding(node, axis) {
	  if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0 && isRowDirection(axis)) {
	    return node.style.paddingEnd;
	  }
	  var value = null;
	  switch (axis) {
	    case 'row':
	      value = node.style.paddingRight;
	      break;
	    case 'row-reverse':
	      value = node.style.paddingLeft;
	      break;
	    case 'column':
	      value = node.style.paddingBottom;
	      break;
	    case 'column-reverse':
	      value = node.style.paddingTop;
	      break;
	  }
	  if (value != null && value >= 0) {
	    return value;
	  }
	  if (node.style.padding !== undefined && node.style.padding >= 0) {
	    return node.style.padding;
	  }
	  return 0;
	}
	function getLeadingBorder(node, axis) {
	  if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0 && isRowDirection(axis)) {
	    return node.style.borderStartWidth;
	  }
	  var value = null;
	  switch (axis) {
	    case 'row':
	      value = node.style.borderLeftWidth;
	      break;
	    case 'row-reverse':
	      value = node.style.borderRightWidth;
	      break;
	    case 'column':
	      value = node.style.borderTopWidth;
	      break;
	    case 'column-reverse':
	      value = node.style.borderBottomWidth;
	      break;
	  }
	  if (value != null && value >= 0) {
	    return value;
	  }
	  if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {
	    return node.style.borderWidth;
	  }
	  return 0;
	}
	function getTrailingBorder(node, axis) {
	  if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0 && isRowDirection(axis)) {
	    return node.style.borderEndWidth;
	  }
	  var value = null;
	  switch (axis) {
	    case 'row':
	      value = node.style.borderRightWidth;
	      break;
	    case 'row-reverse':
	      value = node.style.borderLeftWidth;
	      break;
	    case 'column':
	      value = node.style.borderBottomWidth;
	      break;
	    case 'column-reverse':
	      value = node.style.borderTopWidth;
	      break;
	  }
	  if (value != null && value >= 0) {
	    return value;
	  }
	  if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {
	    return node.style.borderWidth;
	  }
	  return 0;
	}
	function getLeadingPaddingAndBorder(node, axis) {
	  return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);
	}
	function getTrailingPaddingAndBorder(node, axis) {
	  return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);
	}
	function getBorderAxis(node, axis) {
	  return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);
	}
	function getMarginAxis(node, axis) {
	  return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);
	}
	function getPaddingAndBorderAxis(node, axis) {
	  return getLeadingPaddingAndBorder(node, axis) + getTrailingPaddingAndBorder(node, axis);
	}
	function getJustifyContent(node) {
	  if (node.style.justifyContent) {
	    return node.style.justifyContent;
	  }
	  return 'flex-start';
	}
	function getAlignContent(node) {
	  if (node.style.alignContent) {
	    return node.style.alignContent;
	  }
	  return 'flex-start';
	}
	function getAlignItem(node, child) {
	  if (child.style.alignSelf) {
	    return child.style.alignSelf;
	  }
	  if (node.style.alignItems) {
	    return node.style.alignItems;
	  }
	  return 'stretch';
	}
	function resolveAxis(axis, direction) {
	  if (direction === CSS_DIRECTION_RTL) {
	    if (axis === CSS_FLEX_DIRECTION_ROW) {
	      return CSS_FLEX_DIRECTION_ROW_REVERSE;
	    } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {
	      return CSS_FLEX_DIRECTION_ROW;
	    }
	  }
	  return axis;
	}
	function resolveDirection(node, parentDirection) {
	  var direction;
	  if (node.style.direction) {
	    direction = node.style.direction;
	  } else {
	    direction = CSS_DIRECTION_INHERIT;
	  }
	  if (direction === CSS_DIRECTION_INHERIT) {
	    direction = parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection;
	  }
	  return direction;
	}
	function getFlexDirection(node) {
	  if (node.style.flexDirection) {
	    return node.style.flexDirection;
	  }
	  return CSS_FLEX_DIRECTION_COLUMN;
	}
	function getCrossFlexDirection(flexDirection, direction) {
	  if (isColumnDirection(flexDirection)) {
	    return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
	  } else {
	    return CSS_FLEX_DIRECTION_COLUMN;
	  }
	}
	function getPositionType(node) {
	  if (node.style.position) {
	    return node.style.position;
	  }
	  return 'relative';
	}
	function isFlex(node) {
	  return getPositionType(node) === CSS_POSITION_RELATIVE && node.style.flex > 0;
	}
	function isFlexWrap(node) {
	  return node.style.flexWrap === 'wrap';
	}
	function getDimWithMargin(node, axis) {
	  return node.layout[dim[axis]] + getMarginAxis(node, axis);
	}
	function isDimDefined(node, axis) {
	  return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;
	}
	function isPosDefined(node, pos) {
	  return node.style[pos] !== undefined;
	}
	function isMeasureDefined(node) {
	  return node.style.measure !== undefined;
	}
	function getPosition(node, pos) {
	  if (node.style[pos] !== undefined) {
	    return node.style[pos];
	  }
	  return 0;
	}
	function boundAxis(node, axis, value) {
	  var min = {
	    row: node.style.minWidth,
	    'row-reverse': node.style.minWidth,
	    column: node.style.minHeight,
	    'column-reverse': node.style.minHeight
	  }[axis];
	  var max = {
	    row: node.style.maxWidth,
	    'row-reverse': node.style.maxWidth,
	    column: node.style.maxHeight,
	    'column-reverse': node.style.maxHeight
	  }[axis];
	  var boundValue = value;
	  if (max !== undefined && max >= 0 && boundValue > max) {
	    boundValue = max;
	  }
	  if (min !== undefined && min >= 0 && boundValue < min) {
	    boundValue = min;
	  }
	  return boundValue;
	}
	function fmaxf(a, b) {
	  if (a > b) {
	    return a;
	  }
	  return b;
	}
	// When the user specifically sets a value for width or height
	function setDimensionFromStyle(node, axis) {
	  // The parent already computed us a width or height. We just skip it
	  if (node.layout[dim[axis]] !== undefined) {
	    return;
	  }
	  // We only run if there's a width or height defined
	  if (!isDimDefined(node, axis)) {
	    return;
	  }
	  // The dimensions can never be smaller than the padding and border
	  node.layout[dim[axis]] = fmaxf(boundAxis(node, axis, node.style[dim[axis]]), getPaddingAndBorderAxis(node, axis));
	}
	function setTrailingPosition(node, child, axis) {
	  child.layout[trailing[axis]] = node.layout[dim[axis]] - child.layout[dim[axis]] - child.layout[pos[axis]];
	}
	// If both left and right are defined, then use left. Otherwise return
	// +left or -right depending on which is defined.
	function getRelativePosition(node, axis) {
	  if (node.style[leading[axis]] !== undefined) {
	    return getPosition(node, leading[axis]);
	  }
	  return -getPosition(node, trailing[axis]);
	}
	function layoutNodeImpl(node, parentMaxWidth, /*css_direction_t*/parentDirection) {
	  var /*css_direction_t*/direction = resolveDirection(node, parentDirection);
	  var /*(c)!css_flex_direction_t*/ /*(java)!int*/mainAxis = resolveAxis(getFlexDirection(node), direction);
	  var /*(c)!css_flex_direction_t*/ /*(java)!int*/crossAxis = getCrossFlexDirection(mainAxis, direction);
	  var /*(c)!css_flex_direction_t*/ /*(java)!int*/resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
	  // Handle width and height style attributes
	  setDimensionFromStyle(node, mainAxis);
	  setDimensionFromStyle(node, crossAxis);
	  // Set the resolved resolution in the node's layout
	  node.layout.direction = direction;
	  // The position is set by the parent, but we need to complete it with a
	  // delta composed of the margin and left/top/right/bottom
	  node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
	  node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
	  node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
	  node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
	  // Inline immutable values from the target node to avoid excessive method
	  // invocations during the layout calculation.
	  var /*int*/childCount = node.children.length;
	  var /*float*/paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);
	  if (isMeasureDefined(node)) {
	    var /*bool*/isResolvedRowDimDefined = !isUndefined$1(node.layout[dim[resolvedRowAxis]]);
	    var /*float*/width = CSS_UNDEFINED;
	    if (isDimDefined(node, resolvedRowAxis)) {
	      width = node.style.width;
	    } else if (isResolvedRowDimDefined) {
	      width = node.layout[dim[resolvedRowAxis]];
	    } else {
	      width = parentMaxWidth - getMarginAxis(node, resolvedRowAxis);
	    }
	    width -= paddingAndBorderAxisResolvedRow;
	    // We only need to give a dimension for the text if we haven't got any
	    // for it computed yet. It can either be from the style attribute or because
	    // the element is flexible.
	    var /*bool*/isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;
	    var /*bool*/isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) && isUndefined$1(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);
	    // Let's not measure the text if we already know both dimensions
	    if (isRowUndefined || isColumnUndefined) {
	      var /*css_dim_t*/measureDim = node.style.measure( /*(c)!node->context,*/
	      /*(java)!layoutContext.measureOutput,*/
	      width);
	      if (isRowUndefined) {
	        node.layout.width = measureDim.width + paddingAndBorderAxisResolvedRow;
	      }
	      if (isColumnUndefined) {
	        node.layout.height = measureDim.height + getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);
	      }
	    }
	    if (childCount === 0) {
	      return;
	    }
	  }
	  var /*bool*/isNodeFlexWrap = isFlexWrap(node);
	  var /*css_justify_t*/justifyContent = getJustifyContent(node);
	  var /*float*/leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);
	  var /*float*/leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);
	  var /*float*/paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);
	  var /*float*/paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);
	  var /*bool*/isMainDimDefined = !isUndefined$1(node.layout[dim[mainAxis]]);
	  var /*bool*/isCrossDimDefined = !isUndefined$1(node.layout[dim[crossAxis]]);
	  var /*bool*/isMainRowDirection = isRowDirection(mainAxis);
	  var /*int*/i;
	  var /*int*/ii;
	  var /*css_node_t**/child;
	  var /*(c)!css_flex_direction_t*/ /*(java)!int*/axis;
	  var /*css_node_t**/firstAbsoluteChild = null;
	  var /*css_node_t**/currentAbsoluteChild = null;
	  var /*float*/definedMainDim = CSS_UNDEFINED;
	  if (isMainDimDefined) {
	    definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;
	  }
	  // We want to execute the next two loops one per line with flex-wrap
	  var /*int*/startLine = 0;
	  var /*int*/endLine = 0;
	  // var/*int*/ nextOffset = 0;
	  var /*int*/alreadyComputedNextLayout = 0;
	  // We aggregate the total dimensions of the container in those two variables
	  var /*float*/linesCrossDim = 0;
	  var /*float*/linesMainDim = 0;
	  var /*int*/linesCount = 0;
	  while (endLine < childCount) {
	    // <Loop A> Layout non flexible children and count children by type
	    // mainContentDim is accumulation of the dimensions and margin of all the
	    // non flexible children. This will be used in order to either set the
	    // dimensions of the node if none already exist, or to compute the
	    // remaining space left for the flexible children.
	    var /*float*/mainContentDim = 0;
	    // There are three kind of children, non flexible, flexible and absolute.
	    // We need to know how many there are in order to distribute the space.
	    var /*int*/flexibleChildrenCount = 0;
	    var /*float*/totalFlexible = 0;
	    var /*int*/nonFlexibleChildrenCount = 0;
	    // Use the line loop to position children in the main axis for as long
	    // as they are using a simple stacking behaviour. Children that are
	    // immediately stacked in the initial loop will not be touched again
	    // in <Loop C>.
	    var /*bool*/isSimpleStackMain = isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START || !isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER;
	    var /*int*/firstComplexMain = isSimpleStackMain ? childCount : startLine;
	    // Use the initial line loop to position children in the cross axis for
	    // as long as they are relatively positioned with alignment STRETCH or
	    // FLEX_START. Children that are immediately stacked in the initial loop
	    // will not be touched again in <Loop D>.
	    var /*bool*/isSimpleStackCross = true;
	    var /*int*/firstComplexCross = childCount;
	    var /*css_node_t**/firstFlexChild = null;
	    var /*css_node_t**/currentFlexChild = null;
	    var /*float*/mainDim = leadingPaddingAndBorderMain;
	    var /*float*/crossDim = 0;
	    var /*float*/maxWidth;
	    for (i = startLine; i < childCount; ++i) {
	      child = node.children[i];
	      child.lineIndex = linesCount;
	      child.nextAbsoluteChild = null;
	      child.nextFlexChild = null;
	      var /*css_align_t*/alignItem = getAlignItem(node, child);
	      // Pre-fill cross axis dimensions when the child is using stretch before
	      // we call the recursive layout pass
	      if (alignItem === CSS_ALIGN_STRETCH && getPositionType(child) === CSS_POSITION_RELATIVE && isCrossDimDefined && !isDimDefined(child, crossAxis)) {
	        child.layout[dim[crossAxis]] = fmaxf(boundAxis(child, crossAxis, node.layout[dim[crossAxis]] - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
	        // You never want to go smaller than padding
	        getPaddingAndBorderAxis(child, crossAxis));
	      } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {
	        // Store a private linked list of absolutely positioned children
	        // so that we can efficiently traverse them later.
	        if (firstAbsoluteChild === null) {
	          firstAbsoluteChild = child;
	        }
	        if (currentAbsoluteChild !== null) {
	          currentAbsoluteChild.nextAbsoluteChild = child;
	        }
	        currentAbsoluteChild = child;
	        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both
	        // left and right or top and bottom).
	        for (ii = 0; ii < 2; ii++) {
	          axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
	          if (!isUndefined$1(node.layout[dim[axis]]) && !isDimDefined(child, axis) && isPosDefined(child, leading[axis]) && isPosDefined(child, trailing[axis])) {
	            child.layout[dim[axis]] = fmaxf(boundAxis(child, axis, node.layout[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis])),
	            // You never want to go smaller than padding
	            getPaddingAndBorderAxis(child, axis));
	          }
	        }
	      }
	      var /*float*/nextContentDim = 0;
	      // It only makes sense to consider a child flexible if we have a computed
	      // dimension for the node.
	      if (isMainDimDefined && isFlex(child)) {
	        flexibleChildrenCount++;
	        totalFlexible += child.style.flex;
	        // Store a private linked list of flexible children so that we can
	        // efficiently traverse them later.
	        if (firstFlexChild === null) {
	          firstFlexChild = child;
	        }
	        if (currentFlexChild !== null) {
	          currentFlexChild.nextFlexChild = child;
	        }
	        currentFlexChild = child;
	        // Even if we don't know its exact size yet, we already know the padding,
	        // border and margin. We'll use this partial information, which represents
	        // the smallest possible size for the child, to compute the remaining
	        // available space.
	        nextContentDim = getPaddingAndBorderAxis(child, mainAxis) + getMarginAxis(child, mainAxis);
	      } else {
	        maxWidth = CSS_UNDEFINED;
	        if (!isMainRowDirection) {
	          if (isDimDefined(node, resolvedRowAxis)) {
	            maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
	          } else {
	            maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
	          }
	        }
	        // This is the main recursive call. We layout non flexible children.
	        if (alreadyComputedNextLayout === 0) {
	          layoutNode( /*(java)!layoutContext, */child, maxWidth, direction);
	        }
	        // Absolute positioned elements do not take part of the layout, so we
	        // don't use them to compute mainContentDim
	        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
	          nonFlexibleChildrenCount++;
	          // At this point we know the final size and margin of the element.
	          nextContentDim = getDimWithMargin(child, mainAxis);
	        }
	      }
	      // The element we are about to add would make us go to the next line
	      if (isNodeFlexWrap && isMainDimDefined && mainContentDim + nextContentDim > definedMainDim &&
	      // If there's only one element, then it's bigger than the content
	      // and needs its own line
	      i !== startLine) {
	        nonFlexibleChildrenCount--;
	        alreadyComputedNextLayout = 1;
	        break;
	      }
	      // Disable simple stacking in the main axis for the current line as
	      // we found a non-trivial child. The remaining children will be laid out
	      // in <Loop C>.
	      if (isSimpleStackMain && (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {
	        isSimpleStackMain = false;
	        firstComplexMain = i;
	      }
	      // Disable simple stacking in the cross axis for the current line as
	      // we found a non-trivial child. The remaining children will be laid out
	      // in <Loop D>.
	      if (isSimpleStackCross && (getPositionType(child) !== CSS_POSITION_RELATIVE || alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START || isUndefined$1(child.layout[dim[crossAxis]]))) {
	        isSimpleStackCross = false;
	        firstComplexCross = i;
	      }
	      if (isSimpleStackMain) {
	        child.layout[pos[mainAxis]] += mainDim;
	        if (isMainDimDefined) {
	          setTrailingPosition(node, child, mainAxis);
	        }
	        mainDim += getDimWithMargin(child, mainAxis);
	        crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
	      }
	      if (isSimpleStackCross) {
	        child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;
	        if (isCrossDimDefined) {
	          setTrailingPosition(node, child, crossAxis);
	        }
	      }
	      alreadyComputedNextLayout = 0;
	      mainContentDim += nextContentDim;
	      endLine = i + 1;
	    }
	    // <Loop B> Layout flexible children and allocate empty space
	    // In order to position the elements in the main axis, we have two
	    // controls. The space between the beginning and the first element
	    // and the space between each two elements.
	    var /*float*/leadingMainDim = 0;
	    var /*float*/betweenMainDim = 0;
	    // The remaining available space that needs to be allocated
	    var /*float*/remainingMainDim = 0;
	    if (isMainDimDefined) {
	      remainingMainDim = definedMainDim - mainContentDim;
	    } else {
	      remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;
	    }
	    // If there are flexible children in the mix, they are going to fill the
	    // remaining space
	    if (flexibleChildrenCount !== 0) {
	      var /*float*/flexibleMainDim = remainingMainDim / totalFlexible;
	      var /*float*/baseMainDim;
	      var /*float*/boundMainDim;
	      // If the flex share of remaining space doesn't meet min/max bounds,
	      // remove this child from flex calculations.
	      currentFlexChild = firstFlexChild;
	      while (currentFlexChild !== null) {
	        baseMainDim = flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis);
	        boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);
	        if (baseMainDim !== boundMainDim) {
	          remainingMainDim -= boundMainDim;
	          totalFlexible -= currentFlexChild.style.flex;
	        }
	        currentFlexChild = currentFlexChild.nextFlexChild;
	      }
	      flexibleMainDim = remainingMainDim / totalFlexible;
	      // The non flexible children can overflow the container, in this case
	      // we should just assume that there is no space available.
	      if (flexibleMainDim < 0) {
	        flexibleMainDim = 0;
	      }
	      currentFlexChild = firstFlexChild;
	      while (currentFlexChild !== null) {
	        // At this point we know the final size of the element in the main
	        // dimension
	        currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis, flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis));
	        maxWidth = CSS_UNDEFINED;
	        if (isDimDefined(node, resolvedRowAxis)) {
	          maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
	        } else if (!isMainRowDirection) {
	          maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
	        }
	        // And we recursively call the layout algorithm for this child
	        layoutNode( /*(java)!layoutContext, */currentFlexChild, maxWidth, direction);
	        child = currentFlexChild;
	        currentFlexChild = currentFlexChild.nextFlexChild;
	        child.nextFlexChild = null;
	      }
	      // We use justifyContent to figure out how to allocate the remaining
	      // space available
	    } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {
	      if (justifyContent === CSS_JUSTIFY_CENTER) {
	        leadingMainDim = remainingMainDim / 2;
	      } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {
	        leadingMainDim = remainingMainDim;
	      } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {
	        remainingMainDim = fmaxf(remainingMainDim, 0);
	        if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {
	          betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1);
	        } else {
	          betweenMainDim = 0;
	        }
	      } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {
	        // Space on the edges is half of the space between elements
	        betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount);
	        leadingMainDim = betweenMainDim / 2;
	      }
	    }
	    // <Loop C> Position elements in the main axis and compute dimensions
	    // At this point, all the children have their dimensions set. We need to
	    // find their position. In order to do that, we accumulate data in
	    // variables that are also useful to compute the total dimensions of the
	    // container!
	    mainDim += leadingMainDim;
	    for (i = firstComplexMain; i < endLine; ++i) {
	      child = node.children[i];
	      if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[mainAxis])) {
	        // In case the child is position absolute and has left/top being
	        // defined, we override the position to whatever the user said
	        // (and margin/border).
	        child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) + getLeadingBorder(node, mainAxis) + getLeadingMargin(child, mainAxis);
	      } else {
	        // If the child is position absolute (without top/left) or relative,
	        // we put it at the current accumulated offset.
	        child.layout[pos[mainAxis]] += mainDim;
	        // Define the trailing position accordingly.
	        if (isMainDimDefined) {
	          setTrailingPosition(node, child, mainAxis);
	        }
	        // Now that we placed the element, we need to update the variables
	        // We only need to do that for relative elements. Absolute elements
	        // do not take part in that phase.
	        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
	          // The main dimension is the sum of all the elements dimension plus
	          // the spacing.
	          mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);
	          // The cross dimension is the max of the elements dimension since there
	          // can only be one element in that cross dimension.
	          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
	        }
	      }
	    }
	    var /*float*/containerCrossAxis = node.layout[dim[crossAxis]];
	    if (!isCrossDimDefined) {
	      containerCrossAxis = fmaxf(
	      // For the cross dim, we add both sides at the end because the value
	      // is aggregate via a max function. Intermediate negative values
	      // can mess this computation otherwise
	      boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross);
	    }
	    // <Loop D> Position elements in the cross axis
	    for (i = firstComplexCross; i < endLine; ++i) {
	      child = node.children[i];
	      if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[crossAxis])) {
	        // In case the child is absolutely positionned and has a
	        // top/left/bottom/right being set, we override all the previously
	        // computed positions to set it correctly.
	        child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) + getLeadingBorder(node, crossAxis) + getLeadingMargin(child, crossAxis);
	      } else {
	        var /*float*/leadingCrossDim = leadingPaddingAndBorderCross;
	        // For a relative children, we're either using alignItems (parent) or
	        // alignSelf (child) in order to determine the position in the cross axis
	        if (getPositionType(child) === CSS_POSITION_RELATIVE) {
	          // This variable is intentionally re-defined as the code is transpiled to a block scope language
	          var /*css_align_t*/alignItem = getAlignItem(node, child);
	          if (alignItem === CSS_ALIGN_STRETCH) {
	            // You can only stretch if the dimension has not already been set
	            // previously.
	            if (isUndefined$1(child.layout[dim[crossAxis]])) {
	              child.layout[dim[crossAxis]] = fmaxf(boundAxis(child, crossAxis, containerCrossAxis - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
	              // You never want to go smaller than padding
	              getPaddingAndBorderAxis(child, crossAxis));
	            }
	          } else if (alignItem !== CSS_ALIGN_FLEX_START) {
	            // The remaining space between the parent dimensions+padding and child
	            // dimensions+margin.
	            var /*float*/remainingCrossDim = containerCrossAxis - paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);
	            if (alignItem === CSS_ALIGN_CENTER) {
	              leadingCrossDim += remainingCrossDim / 2;
	            } else {
	              // CSS_ALIGN_FLEX_END
	              leadingCrossDim += remainingCrossDim;
	            }
	          }
	        }
	        // And we apply the position
	        child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;
	        // Define the trailing position accordingly.
	        if (isCrossDimDefined) {
	          setTrailingPosition(node, child, crossAxis);
	        }
	      }
	    }
	    linesCrossDim += crossDim;
	    linesMainDim = fmaxf(linesMainDim, mainDim);
	    linesCount += 1;
	    startLine = endLine;
	  }
	  // <Loop E>
	  //
	  // Note(prenaux): More than one line, we need to layout the crossAxis
	  // according to alignContent.
	  //
	  // Note that we could probably remove <Loop D> and handle the one line case
	  // here too, but for the moment this is safer since it won't interfere with
	  // previously working code.
	  //
	  // See specs:
	  // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm
	  // section 9.4
	  //
	  if (linesCount > 1 && isCrossDimDefined) {
	    var /*float*/nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] - paddingAndBorderAxisCross;
	    var /*float*/remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;
	    var /*float*/crossDimLead = 0;
	    var /*float*/currentLead = leadingPaddingAndBorderCross;
	    var /*css_align_t*/alignContent = getAlignContent(node);
	    if (alignContent === CSS_ALIGN_FLEX_END) {
	      currentLead += remainingAlignContentDim;
	    } else if (alignContent === CSS_ALIGN_CENTER) {
	      currentLead += remainingAlignContentDim / 2;
	    } else if (alignContent === CSS_ALIGN_STRETCH) {
	      if (nodeCrossAxisInnerSize > linesCrossDim) {
	        crossDimLead = remainingAlignContentDim / linesCount;
	      }
	    }
	    var /*int*/endIndex = 0;
	    for (i = 0; i < linesCount; ++i) {
	      var /*int*/startIndex = endIndex;
	      // compute the line's height and find the endIndex
	      var /*float*/lineHeight = 0;
	      for (ii = startIndex; ii < childCount; ++ii) {
	        child = node.children[ii];
	        if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
	          continue;
	        }
	        if (child.lineIndex !== i) {
	          break;
	        }
	        if (!isUndefined$1(child.layout[dim[crossAxis]])) {
	          lineHeight = fmaxf(lineHeight, child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis));
	        }
	      }
	      endIndex = ii;
	      lineHeight += crossDimLead;
	      for (ii = startIndex; ii < endIndex; ++ii) {
	        child = node.children[ii];
	        if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
	          continue;
	        }
	        var /*css_align_t*/alignContentAlignItem = getAlignItem(node, child);
	        if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {
	          child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
	        } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {
	          child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];
	        } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {
	          var /*float*/childHeight = child.layout[dim[crossAxis]];
	          child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;
	        } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {
	          child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
	          // TODO(prenaux): Correctly set the height of items with undefined
	          //                (auto) crossAxis dimension.
	        }
	      }

	      currentLead += lineHeight;
	    }
	  }
	  var /*bool*/needsMainTrailingPos = false;
	  var /*bool*/needsCrossTrailingPos = false;
	  // If the user didn't specify a width or height, and it has not been set
	  // by the container, then we set it via the children.
	  if (!isMainDimDefined) {
	    node.layout[dim[mainAxis]] = fmaxf(
	    // We're missing the last padding at this point to get the final
	    // dimension
	    boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),
	    // We can never assign a width smaller than the padding and borders
	    paddingAndBorderAxisMain);
	    if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
	      needsMainTrailingPos = true;
	    }
	  }
	  if (!isCrossDimDefined) {
	    node.layout[dim[crossAxis]] = fmaxf(
	    // For the cross dim, we add both sides at the end because the value
	    // is aggregate via a max function. Intermediate negative values
	    // can mess this computation otherwise
	    boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross);
	    if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
	      needsCrossTrailingPos = true;
	    }
	  }
	  // <Loop F> Set trailing position if necessary
	  if (needsMainTrailingPos || needsCrossTrailingPos) {
	    for (i = 0; i < childCount; ++i) {
	      child = node.children[i];
	      if (needsMainTrailingPos) {
	        setTrailingPosition(node, child, mainAxis);
	      }
	      if (needsCrossTrailingPos) {
	        setTrailingPosition(node, child, crossAxis);
	      }
	    }
	  }
	  // <Loop G> Calculate dimensions for absolutely positioned elements
	  currentAbsoluteChild = firstAbsoluteChild;
	  while (currentAbsoluteChild !== null) {
	    // Pre-fill dimensions when using absolute position and both offsets for
	    // the axis are defined (either both left and right or top and bottom).
	    for (ii = 0; ii < 2; ii++) {
	      axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
	      if (!isUndefined$1(node.layout[dim[axis]]) && !isDimDefined(currentAbsoluteChild, axis) && isPosDefined(currentAbsoluteChild, leading[axis]) && isPosDefined(currentAbsoluteChild, trailing[axis])) {
	        currentAbsoluteChild.layout[dim[axis]] = fmaxf(boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] - getBorderAxis(node, axis) - getMarginAxis(currentAbsoluteChild, axis) - getPosition(currentAbsoluteChild, leading[axis]) - getPosition(currentAbsoluteChild, trailing[axis])),
	        // You never want to go smaller than padding
	        getPaddingAndBorderAxis(currentAbsoluteChild, axis));
	      }
	      if (isPosDefined(currentAbsoluteChild, trailing[axis]) && !isPosDefined(currentAbsoluteChild, leading[axis])) {
	        currentAbsoluteChild.layout[leading[axis]] = node.layout[dim[axis]] - currentAbsoluteChild.layout[dim[axis]] - getPosition(currentAbsoluteChild, trailing[axis]);
	      }
	    }
	    child = currentAbsoluteChild;
	    currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;
	    child.nextAbsoluteChild = null;
	  }
	}
	// 在外层做的margin补丁
	function saveMargin(node) {
	  var style = node.style;
	  var margin = {};
	  ['marginTop', 'marginRight', 'marginBottom', 'marginLeft' // 只支持marginLeft
	  ].forEach(function (key) {
	    // 只处理百分号
	    var value = style[key];
	    if (value && /^-?\d+%$/.test(value)) {
	      margin[key] = value;
	      style[key] = 0;
	    }
	  });
	  node.margin = margin;
	}
	function percent2Num(value) {
	  var percent = Number(value.substr(0, value.length - 1));
	  return percent / 100;
	}
	function layoutMargin(node) {
	  var margin = node.margin,
	    layout = node.layout;
	  Object.keys(margin).forEach(function (key) {
	    var percent = percent2Num(margin[key]);
	    if ((key === 'marginLeft' || key === 'marginRight') && layout.width) {
	      layout.left += layout.width * percent;
	    } else if ((key === 'marginTop' || key === 'marginBottom') && layout.height) {
	      layout.top += layout.height * percent;
	    }
	  });
	}
	function layoutNode(node, parentMaxWidth, parentDirection) {
	  node.shouldUpdate = true;
	  // hack
	  saveMargin(node);
	  var direction = node.style.direction || CSS_DIRECTION_LTR;
	  var skipLayout = !node.isDirty && node.lastLayout && node.lastLayout.requestedHeight === node.layout.height && node.lastLayout.requestedWidth === node.layout.width && node.lastLayout.parentMaxWidth === parentMaxWidth && node.lastLayout.direction === direction;
	  if (skipLayout) {
	    node.layout.width = node.lastLayout.width;
	    node.layout.height = node.lastLayout.height;
	    node.layout.top = node.lastLayout.top;
	    node.layout.left = node.lastLayout.left;
	  } else {
	    if (!node.lastLayout) {
	      node.lastLayout = {};
	    }
	    node.lastLayout.requestedWidth = node.layout.width;
	    node.lastLayout.requestedHeight = node.layout.height;
	    node.lastLayout.parentMaxWidth = parentMaxWidth;
	    node.lastLayout.direction = direction;
	    // Reset child layouts
	    node.children.forEach(function (child) {
	      child.layout.width = undefined;
	      child.layout.height = undefined;
	      child.layout.top = 0;
	      child.layout.left = 0;
	    });
	    layoutNodeImpl(node, parentMaxWidth, parentDirection);
	    node.lastLayout.width = node.layout.width;
	    node.lastLayout.height = node.layout.height;
	    node.lastLayout.top = node.layout.top;
	    node.lastLayout.left = node.layout.left;
	  }
	  // hack
	  layoutMargin(node);
	}
	/* eslint-enable */
	function computeLayout(node) {
	  if (!node) return node;
	  fillNodes(node);
	  layoutNode(node, null, null);
	  return node;
	}

	function createMeasure(style, measureText) {
	  return function /* width */
	  () {
	    var text = style.text,
	      width = style.width,
	      height = style.height;
	    var outputWidth = width;
	    var outputHeight = height;
	    if (!isNumber(width) || !isNumber(height)) {
	      var _measureText = measureText(text, style),
	        measureWidth = _measureText.width,
	        measureHeight = _measureText.height;
	      if (!isNumber(width)) {
	        outputWidth = measureWidth;
	      }
	      if (!isNumber(height)) {
	        outputHeight = measureHeight;
	      }
	    }
	    return {
	      width: outputWidth,
	      height: outputHeight
	    };
	  };
	}
	function getChildrenLayout(nodeTree) {
	  if (!nodeTree) return;
	  var left = 0;
	  var top = 0;
	  var right = 0;
	  var bottom = 0;
	  var width = 0;
	  var height = 0;
	  nodeTree.forEach(function (node) {
	    var layout = node.layout;
	    if (!layout) return;
	    left = Math.min(left, layout.left);
	    top = Math.min(top, layout.top);
	    right = Math.min(right, layout.left + layout.width);
	    bottom = Math.min(bottom, layout.top + layout.height);
	    width = Math.max(width, layout.width);
	    height = Math.max(height, layout.height);
	  });
	  return {
	    left: left,
	    top: top,
	    right: right,
	    bottom: bottom,
	    width: width,
	    height: height
	  };
	}
	var NodeTree = /*#__PURE__*/function () {
	  function NodeTree(node) {
	    _classCallCheck(this, NodeTree);
	    var className = node.className,
	      children = node.children,
	      layout = node.layout;
	    var nodeChildren = children && children.length ? children.map(function (child) {
	      return new NodeTree(child);
	    }) : undefined;
	    var nodeLayout = layout ? layout : getChildrenLayout(nodeChildren);
	    this.children = nodeChildren;
	    this.layout = nodeLayout;
	    this.className = className;
	  }
	  _createClass(NodeTree, [{
	    key: "getElementsByClassName",
	    value: function getElementsByClassName(targetClassName) {
	      var result = [];
	      var className = this.className,
	        children = this.children;
	      if (className === targetClassName) {
	        result.push(this);
	      }
	      if (children) {
	        children.forEach(function (child) {
	          result.push.apply(result, _toConsumableArray(child.getElementsByClassName(targetClassName)));
	        });
	      }
	      return result;
	    }
	  }]);
	  return NodeTree;
	}(); // 展开数组
	function extendMap(arr, fn) {
	  if (!arr) {
	    return arr;
	  }
	  var newArray = [];
	  if (!isArray(arr)) {
	    var rst = fn(arr);
	    if (!rst) {
	      return newArray;
	    }
	    if (isArray(rst)) {
	      newArray = newArray.concat(rst);
	    } else {
	      newArray.push(rst);
	    }
	    return newArray;
	  }
	  for (var i = 0; i < arr.length; i++) {
	    var element = arr[i];
	    if (isArray(element)) {
	      newArray = newArray.concat(extendMap(element, fn));
	    } else if (element) {
	      var _rst = fn(element);
	      if (!_rst) {
	        continue;
	      }
	      if (isArray(_rst)) {
	        newArray = newArray.concat(_rst);
	      } else {
	        newArray.push(_rst);
	      }
	    }
	  }
	  return newArray;
	}
	// 主要是把function节点，全部转换成string标签节点
	function renderJSXElement(element, context, updater) {
	  if (!element) return element;
	  var px2hd = context.px2hd,
	    measureText = context.measureText;
	  var type = element.type,
	    props = element.props;
	  var tag = getWorkTag(type);
	  // 只处理 function 组件
	  if (tag === FunctionComponent) {
	    // @ts-ignore
	    var newElement = type(element.props, context, updater);
	    // return element if type is string
	    return renderJSXElement(newElement, context, updater);
	  }
	  var className = props.className,
	    _props$style = props.style,
	    customStyle = _props$style === void 0 ? {} : _props$style,
	    attrs = props.attrs,
	    newChildren = props.children;
	  var style = px2hd(_objectSpread(_objectSpread({}, customStyle), attrs));
	  // 文本需要计算文本的宽高来进行flex布局
	  if (type === 'text') {
	    style.measure = createMeasure(style, measureText);
	  }
	  // render children first
	  var nextChildren = newChildren ? Children.toArray(newChildren).map(function (child) {
	    return renderJSXElement(child, context, updater);
	  }) : [];
	  return {
	    type: type,
	    className: className,
	    children: nextChildren.filter(Boolean),
	    style: style
	  };
	}
	// 计算布局
	function computeLayout$1(component, newChildren) {
	  var context = component.context,
	    updater = component.updater;
	  var nodeTree = renderJSXElement(newChildren, context, updater);
	  computeLayout(nodeTree);
	  // 构造一个 NodeTree, 方便外部使用
	  return new NodeTree(nodeTree);
	}
	function createChildNodeTree(parent, vNodeChildren) {
	  var tag = parent.tag;
	  var children = extendMap(vNodeChildren, function (child) {
	    var childTag = child.tag,
	      childStyle = child.style,
	      childChildren = child.children;
	    // 如果组件的根节点不是 flex, 则该组件不需要计算 flex 布局
	    if (tag !== Shape$1 && childTag === Shape$1 && childStyle.display !== 'flex') {
	      return null;
	    }
	    // 如果子组件不是 shape，则布局计算时，忽略当前节点
	    if (childTag !== Shape$1) {
	      return createChildNodeTree(child, childChildren);
	    }
	    return createNodeTree(child);
	  });
	  return children;
	}
	// 创建组件的布局树
	function createNodeTree(vNode) {
	  var tag = vNode.tag,
	    type = vNode.type,
	    style = vNode.style,
	    context = vNode.context,
	    vNodeChildren = vNode.children;
	  var measureText = context.measureText;
	  var children = createChildNodeTree(vNode, vNodeChildren);
	  // 文本需要计算文本的宽高来进行flex布局
	  if (type === 'text') {
	    style.measure = createMeasure(style, measureText);
	  }
	  return {
	    tag: tag,
	    type: type,
	    style: style,
	    children: children,
	    // 保留对 vNode 的引用，用于把布局结果回填
	    vNode: vNode
	  };
	}
	function fillElementLayout(node) {
	  var type = node.type,
	    style = node.style,
	    vNode = node.vNode,
	    children = node.children,
	    layout = node.layout;
	  var attrs = getShapeAttrs(type, layout);
	  if (style.measure) {
	    delete style.measure;
	  }
	  // 更新布局和样式
	  vNode.layout = layout;
	  vNode.style = _objectSpread(_objectSpread({}, attrs), style);
	  if (!children || !children.length) {
	    return;
	  }
	  for (var i = 0, len = children.length; i < len; i++) {
	    var child = children[i];
	    fillElementLayout(child);
	  }
	}
	function fillComponentLayout(vNode) {
	  var layout = vNode.layout,
	    vNodeChildren = vNode.children;
	  Children.map(vNodeChildren, function (child) {
	    if (!child) {
	      return;
	    }
	    var childTag = child.tag,
	      childLayout = child.layout,
	      style = child.style;
	    if (childTag !== Shape$1 && layout && !childLayout) {
	      child.layout = layout;
	      child.style = _objectSpread({
	        width: layout.width,
	        height: layout.height
	      }, style);
	    }
	    fillComponentLayout(child);
	  });
	}

	var _excluded = ["animate", "transformFrom"];
	function pickElement(element) {
	  if (!element) return element;
	  return Children.map(element, function (item) {
	    if (!item) return item;
	    // 只需要这几个元素就可以了
	    return pick(item, ['key', 'ref', 'type', 'props']);
	  });
	}
	function getStyle$1(tagType, props, context) {
	  var _props$style = props.style,
	    customStyle = _props$style === void 0 ? {} : _props$style,
	    attrs = props.attrs,
	    zIndex = props.zIndex;
	  if (tagType === Shape$1) {
	    return context.px2hd(_objectSpread(_objectSpread({}, customStyle), attrs));
	  }
	  if (isNumber(zIndex)) {
	    return {
	      zIndex: zIndex
	    };
	  }
	  return {};
	}
	// vnode 上的 context 做父子节点的 context 传递
	function readVNodeContext(vNodeType, parentContext) {
	  // @ts-ignore
	  var contextInjecter = vNodeType.contextInjecter;
	  if (!contextInjecter) {
	    return parentContext;
	  }
	  // copy parentContext
	  return _objectSpread({}, parentContext);
	}
	// component 上的 context 是实际使用的 context
	function readComponentContext(vNodeType, vNodeContext) {
	  // @ts-ignore
	  var contextType = vNodeType.contextType;
	  if (!contextType) {
	    return vNodeContext;
	  }
	  var _currentValue = contextType._currentValue;
	  if (!_currentValue) {
	    return vNodeContext;
	  }
	  return _currentValue;
	}
	function createVNode(parent, vNode) {
	  var canvas = parent.canvas,
	    parentContext = parent.context,
	    updater = parent.updater,
	    parentAnimate = parent.animate;
	  var ref = vNode.ref,
	    type = vNode.type,
	    originProps = vNode.props;
	  var animate = originProps.animate,
	    transformFrom = originProps.transformFrom,
	    props = _objectWithoutProperties(originProps, _excluded);
	  var tag = getWorkTag(type);
	  var context = readVNodeContext(type, parentContext);
	  var animator = new Animator(context.timeline);
	  var style = getStyle$1(tag, props, context);
	  animator.vNode = vNode;
	  vNode.parent = parent;
	  vNode.tag = tag;
	  vNode.style = style;
	  vNode.context = context;
	  vNode.updater = updater;
	  vNode.canvas = canvas;
	  vNode.animate = isBoolean(animate) ? animate : parentAnimate;
	  vNode.animator = animator;
	  // shape 标签
	  if (tag === Shape$1) {
	    var shape = createShape(type, _objectSpread(_objectSpread({}, props), {}, {
	      style: style
	    }));
	    if (ref) {
	      ref.current = shape;
	    }
	    // @ts-ignore
	    shape._vNode = vNode; // shape 保留 vNode 的引用
	    vNode.shape = shape;
	  } else {
	    var componentContext = readComponentContext(type, context);
	    // 组件
	    var component;
	    if (tag === ClassComponent) {
	      // @ts-ignore
	      component = new type(props, componentContext, updater);
	    } else {
	      component = new Component(props, componentContext, updater);
	      component.render = function () {
	        // @ts-ignore
	        return type(this.props, componentContext, updater);
	      };
	    }
	    var group = new Group();
	    component.container = group;
	    // 设置ref
	    if (ref) {
	      ref.current = component;
	    }
	    component.context = componentContext;
	    component.updater = updater;
	    component.animator = animator;
	    component._vNode = vNode;
	    vNode.shape = group;
	    vNode.component = component;
	  }
	  if (transformFrom && transformFrom.current) {
	    var transformVNode = transformFrom.current._vNode;
	    vNode.transform = findClosestShapeNode(transformVNode);
	    if (vNode.transform) {
	      vNode.transform.parent.children = null;
	    }
	  }
	  return vNode;
	}
	function updateVNode(parent, nextNode, lastNode) {
	  var canvas = parent.canvas,
	    context = parent.context,
	    updater = parent.updater,
	    parentAnimate = parent.animate;
	  var tag = lastNode.tag,
	    animator = lastNode.animator,
	    component = lastNode.component,
	    shape = lastNode.shape,
	    children = lastNode.children,
	    lastProps = lastNode.props;
	  var type = nextNode.type,
	    props = nextNode.props;
	  var animate = props.animate;
	  animator.vNode = nextNode;
	  nextNode.parent = parent;
	  nextNode.tag = tag;
	  nextNode.canvas = canvas;
	  nextNode.context = readVNodeContext(type, context);
	  nextNode.updater = updater;
	  nextNode.component = component;
	  nextNode.shape = updateShape(shape, props, lastProps);
	  nextNode.parent = parent;
	  nextNode.children = children;
	  nextNode.animate = isBoolean(animate) ? animate : parentAnimate;
	  nextNode.animator = animator;
	  nextNode.style = getStyle$1(tag, props, context);
	  // 更新 component
	  if (component) {
	    component._vNode = nextNode;
	  } else {
	    // 说明是 shape 标签
	    // @ts-ignore
	    shape._vNode = nextNode;
	  }
	  return nextNode;
	}
	function createElement(parent, element) {
	  return Children.map(element, function (el) {
	    if (!el) return el;
	    return createVNode(parent, el);
	  });
	}
	function destroyElement(vNode) {
	  Children.map(vNode, function (node) {
	    if (!node) return;
	    var component = node.component,
	      children = node.children;
	    if (component) {
	      component.willUnmount();
	      destroyElement(children);
	      component.didUnmount();
	      component.destroy();
	    } else {
	      destroyElement(children);
	    }
	  });
	}
	function updateElement(parent, nextElement, lastElement) {
	  var nextType = nextElement.type,
	    nextProps = nextElement.props;
	  var lastType = lastElement.type,
	    lastProps = lastElement.props;
	  if (nextType === lastType) {
	    var _nextVNode = updateVNode(parent, nextElement, lastElement);
	    // props 无变化 和 context 都无变化
	    if (equal(nextProps, lastProps) && parent.context === lastElement.context) {
	      return null;
	    }
	    return _nextVNode;
	  }
	  var nextVNode = createVNode(parent, nextElement);
	  destroyElement(lastElement);
	  return nextVNode;
	}
	function diffElement(parent, nextElement, lastElement) {
	  if (!nextElement && !lastElement) {
	    return null;
	  }
	  // 删除
	  if (!nextElement && lastElement) {
	    destroyElement(lastElement);
	    return null;
	  }
	  // 新建
	  if (nextElement && !lastElement) {
	    return createElement(parent, nextElement);
	  }
	  // 更新
	  return updateElement(parent, nextElement, lastElement);
	}
	function renderComponentNodes(componentNodes) {
	  if (!componentNodes || !componentNodes.length) {
	    return;
	  }
	  // 1. shouldUpdate & willReceiveProps
	  var shouldProcessChildren = componentNodes.filter(function (node) {
	    var type = node.type,
	      component = node.component,
	      props = node.props,
	      context = node.context,
	      layout = node.layout;
	    // 更新组件 layout
	    component.layout = layout;
	    // 新创建的 component
	    if (!component.isMounted) return true;
	    // 不需要更新
	    if (component.shouldUpdate(props) === false) {
	      return false;
	    }
	    var componentContext = readComponentContext(type, context);
	    component.willReceiveProps(props, componentContext);
	    component.props = props;
	    component.context = context;
	    return true;
	  });
	  if (!shouldProcessChildren.length) {
	    return;
	  }
	  // 2. willMount / willUpdate
	  shouldProcessChildren.forEach(function (child) {
	    var component = child.component;
	    if (!component.isMounted) {
	      component.willMount();
	    } else {
	      component.willUpdate();
	    }
	  });
	  // 3. render
	  shouldProcessChildren.forEach(function (child) {
	    var canvas = child.canvas,
	      component = child.component,
	      children = child.children;
	    var newChildren = canvas.toRawChildren(component.render());
	    renderChildren(child, newChildren, children);
	    if (!component.isMounted) {
	      component.didMount();
	      component.isMounted = true;
	    } else {
	      component.didUpdate();
	    }
	  });
	}
	function renderVNode(vNode, nextChildren, lastChildren) {
	  var component = vNode.component;
	  // 不修改原始对象，这里重新 pick 一次，
	  var newChildren = pickElement(nextChildren);
	  // 设置新的 children
	  vNode.children = newChildren;
	  // 如果是组件，需要同时更新组件的 children
	  // 等同于 vNode.tag === ClassComponent || vNode.tag === FunctionComponent
	  if (component) {
	    component.children = newChildren;
	  }
	  var componentNodeChildren = [];
	  Children.compare(newChildren, lastChildren, function (next, last) {
	    var element = diffElement(vNode, next, last);
	    Children.map(element, function (child) {
	      if (!child) return;
	      var tag = child.tag,
	        childProps = child.props,
	        childLastChildren = child.children;
	      var childrenNode = [];
	      if (tag === Shape$1) {
	        childrenNode = renderVNode(child, childProps.children, childLastChildren);
	      } else {
	        childrenNode = [child];
	      }
	      componentNodeChildren = componentNodeChildren.concat(childrenNode);
	    });
	  });
	  return componentNodeChildren;
	}
	function renderChildren(parent, nextChildren, lastChildren) {
	  // 返回的都是 classComponent 的节点
	  var componentNodeChildren = renderVNode(parent, nextChildren, lastChildren);
	  // 计算 flex 布局
	  var nodeTree = createNodeTree(parent);
	  computeLayout(nodeTree);
	  fillElementLayout(nodeTree);
	  fillComponentLayout(parent);
	  var newChildren = parent.children;
	  if (!componentNodeChildren.length) {
	    return newChildren;
	  }
	  renderComponentNodes(componentNodeChildren);
	  return newChildren;
	}
	function render(vNode) {
	  var lastChildren = vNode.children,
	    props = vNode.props;
	  var nextChildren = props.children;
	  // render 节点
	  var children = renderChildren(vNode, nextChildren, lastChildren);
	  // 创建动画
	  var childrenAnimation = createAnimation(vNode, children, lastChildren);
	  // 执行动画
	  if (childrenAnimation.length) {
	    childrenAnimation.forEach(function (animator) {
	      animator.run();
	    });
	  }
	}
	// setState 触发的更新
	function updateComponents(components) {
	  if (!components.length) return;
	  components.forEach(function (component) {
	    var vNode = component._vNode,
	      lastChildren = component.children,
	      props = component.props,
	      animator = component.animator;
	    // 是否需要更新
	    if (component.shouldUpdate(props) === false) {
	      return false;
	    }
	    component.willUpdate();
	    var canvas = vNode.canvas,
	      context = vNode.context;
	    var newChildren = canvas.toRawChildren(component.render());
	    var nextChildren = renderChildren(vNode, newChildren, lastChildren);
	    // 更新 children
	    component.children = nextChildren;
	    vNode.children = nextChildren;
	    // 创建动画
	    var childrenAnimation = createAnimation(vNode, nextChildren, lastChildren);
	    if (childrenAnimation.length) {
	      animator.children = childrenAnimation;
	    }
	    // 执行动画
	    animator.run();
	    var timeline = context.timeline;
	    if (timeline) {
	      timeline.push(animator.animations);
	      timeline.play.animationWillPlay();
	    }
	    component.didUpdate();
	  });
	}

	function generatePath$6(context, parsedStyle) {
	    var r = parsedStyle.r;
	    context.arc(r, r, r, 0, Math.PI * 2, false);
	}

	function generatePath$5(context, parsedStyle) {
	    var rxInPixels = parsedStyle.rx, ryInPixels = parsedStyle.ry;
	    var rx = rxInPixels;
	    var ry = ryInPixels;
	    // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse
	    if (context.ellipse) {
	        context.ellipse(rx, ry, rx, ry, 0, 0, Math.PI * 2, false);
	    }
	    else {
	        // 如果不支持，则使用圆来绘制，进行变形
	        var r = rx > ry ? rx : ry;
	        var scaleX = rx > ry ? 1 : rx / ry;
	        var scaleY = rx > ry ? ry / rx : 1;
	        context.save();
	        context.scale(scaleX, scaleY);
	        context.arc(0, 0, r, 0, Math.PI * 2);
	    }
	}

	function generatePath$4(context, parsedStyle) {
	    var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
	    var startOffsetX = 0;
	    var startOffsetY = 0;
	    var endOffsetX = 0;
	    var endOffsetY = 0;
	    var rad = 0;
	    var x;
	    var y;
	    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
	        x = x2 - x1;
	        y = y2 - y1;
	        rad = Math.atan2(y, x);
	        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
	        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
	    }
	    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
	        x = x1 - x2;
	        y = y1 - y2;
	        rad = Math.atan2(y, x);
	        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
	        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
	    }
	    context.moveTo(x1 - defX + startOffsetX, y1 - defY + startOffsetY);
	    context.lineTo(x2 - defX + endOffsetX, y2 - defY + endOffsetY);
	}

	function generatePath$3(context, parsedStyle) {
	    var _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
	    var _c = parsedStyle.path, absolutePath = _c.absolutePath, segments = _c.segments;
	    var startOffsetX = 0;
	    var startOffsetY = 0;
	    var endOffsetX = 0;
	    var endOffsetY = 0;
	    var rad = 0;
	    var x;
	    var y;
	    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
	        var _d = __read(markerStart.parentNode.getStartTangent(), 2), p1 = _d[0], p2 = _d[1];
	        x = p1[0] - p2[0];
	        y = p1[1] - p2[1];
	        rad = Math.atan2(y, x);
	        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
	        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
	    }
	    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
	        var _e = __read(markerEnd.parentNode.getEndTangent(), 2), p1 = _e[0], p2 = _e[1];
	        x = p1[0] - p2[0];
	        y = p1[1] - p2[1];
	        rad = Math.atan2(y, x);
	        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
	        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
	    }
	    for (var i = 0; i < absolutePath.length; i++) {
	        var params = absolutePath[i];
	        var command = params[0];
	        var nextSegment = absolutePath[i + 1];
	        var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
	        var useEndOffset = (i === absolutePath.length - 1 ||
	            (nextSegment && (nextSegment[0] === 'M' || nextSegment[0] === 'Z'))) &&
	            endOffsetX !== 0 &&
	            endOffsetY !== 0;
	        switch (command) {
	            case 'M':
	                // Use start marker offset
	                if (useStartOffset) {
	                    context.moveTo(params[1] - defX + startOffsetX, params[2] - defY + startOffsetY);
	                    context.lineTo(params[1] - defX, params[2] - defY);
	                }
	                else {
	                    context.moveTo(params[1] - defX, params[2] - defY);
	                }
	                break;
	            case 'L':
	                if (useEndOffset) {
	                    context.lineTo(params[1] - defX + endOffsetX, params[2] - defY + endOffsetY);
	                }
	                else {
	                    context.lineTo(params[1] - defX, params[2] - defY);
	                }
	                break;
	            case 'Q':
	                context.quadraticCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY);
	                if (useEndOffset) {
	                    context.lineTo(params[3] - defX + endOffsetX, params[4] - defY + endOffsetY);
	                }
	                break;
	            case 'C':
	                context.bezierCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY, params[5] - defX, params[6] - defY);
	                if (useEndOffset) {
	                    context.lineTo(params[5] - defX + endOffsetX, params[6] - defY + endOffsetY);
	                }
	                break;
	            case 'A': {
	                var arcParams = segments[i].arcParams;
	                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
	                // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse
	                if (context.ellipse) {
	                    context.ellipse(cx - defX, cy - defY, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
	                }
	                else {
	                    // @see https://stackoverflow.com/a/47494351
	                    var r = rx > ry ? rx : ry;
	                    var scaleX = rx > ry ? 1 : rx / ry;
	                    var scaleY = rx > ry ? ry / rx : 1;
	                    context.translate(cx - defX, cy - defY);
	                    context.rotate(xRotation);
	                    context.scale(scaleX, scaleY);
	                    context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
	                    context.scale(1 / scaleX, 1 / scaleY);
	                    context.rotate(-xRotation);
	                    context.translate(-(cx - defX), -(cy - defY));
	                }
	                if (useEndOffset) {
	                    context.lineTo(params[6] - defX + endOffsetX, params[7] - defY + endOffsetY);
	                }
	                break;
	            }
	            case 'Z':
	                context.closePath();
	                break;
	        }
	    }
	}

	function generatePath$2(context, parsedStyle) {
	    var _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
	    var points = parsedStyle.points.points;
	    var length = points.length;
	    var x1 = points[0][0] - defX;
	    var y1 = points[0][1] - defY;
	    var x2 = points[length - 1][0] - defX;
	    var y2 = points[length - 1][1] - defY;
	    var startOffsetX = 0;
	    var startOffsetY = 0;
	    var endOffsetX = 0;
	    var endOffsetY = 0;
	    var rad = 0;
	    var x;
	    var y;
	    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
	        x = points[1][0] - points[0][0];
	        y = points[1][1] - points[0][1];
	        rad = Math.atan2(y, x);
	        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
	        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
	    }
	    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
	        x = points[length - 1][0] - points[0][0];
	        y = points[length - 1][1] - points[0][1];
	        rad = Math.atan2(y, x);
	        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
	        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
	    }
	    context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
	    for (var i = 1; i < length - 1; i++) {
	        var point = points[i];
	        context.lineTo(point[0] - defX, point[1] - defY);
	    }
	    context.lineTo(x2, y2);
	}

	function generatePath$1(context, parsedStyle) {
	    var _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
	    var points = parsedStyle.points.points;
	    var length = points.length;
	    var x1 = points[0][0] - defX;
	    var y1 = points[0][1] - defY;
	    var x2 = points[length - 1][0] - defX;
	    var y2 = points[length - 1][1] - defY;
	    var startOffsetX = 0;
	    var startOffsetY = 0;
	    var endOffsetX = 0;
	    var endOffsetY = 0;
	    var rad = 0;
	    var x;
	    var y;
	    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
	        x = points[1][0] - points[0][0];
	        y = points[1][1] - points[0][1];
	        rad = Math.atan2(y, x);
	        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
	        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
	    }
	    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
	        x = points[length - 2][0] - points[length - 1][0];
	        y = points[length - 2][1] - points[length - 1][1];
	        rad = Math.atan2(y, x);
	        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
	        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
	    }
	    context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
	    for (var i = 1; i < length - 1; i++) {
	        var point = points[i];
	        context.lineTo(point[0] - defX, point[1] - defY);
	    }
	    context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
	}

	function generatePath(context, parsedStyle) {
	    var radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
	    var w = width;
	    var h = height;
	    var hasRadius = radius && radius.some(function (r) { return r !== 0; });
	    if (!hasRadius) {
	        // Canvas support negative width/height of rect
	        context.rect(0, 0, w, h);
	    }
	    else {
	        var signX = width > 0 ? 1 : -1;
	        var signY = height > 0 ? 1 : -1;
	        var sweepFlag = signX + signY === 0;
	        var _a = __read(radius.map(function (r) {
	            return clamp(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
	        }), 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];
	        context.moveTo(signX * tlr, 0);
	        context.lineTo(w - signX * trr, 0);
	        if (trr !== 0) {
	            context.arc(w - signX * trr, signY * trr, trr, (-signY * Math.PI) / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
	        }
	        context.lineTo(w, h - signY * brr);
	        if (brr !== 0) {
	            context.arc(w - signX * brr, h - signY * brr, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
	        }
	        context.lineTo(signX * blr, h);
	        if (blr !== 0) {
	            context.arc(signX * blr, h - signY * blr, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
	        }
	        context.lineTo(0, signY * tlr);
	        if (tlr !== 0) {
	            context.arc(signX * tlr, signY * tlr, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
	        }
	    }
	}

	var Plugin = /** @class */ (function (_super) {
	    __extends(Plugin, _super);
	    function Plugin() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.name = 'canvas-path-generator';
	        return _this;
	    }
	    Plugin.prototype.init = function () {
	        var _a;
	        var pathGeneratorFactory = (_a = {},
	            _a[Shape.CIRCLE] = generatePath$6,
	            _a[Shape.ELLIPSE] = generatePath$5,
	            _a[Shape.RECT] = generatePath,
	            _a[Shape.LINE] = generatePath$4,
	            _a[Shape.POLYLINE] = generatePath$1,
	            _a[Shape.POLYGON] = generatePath$2,
	            _a[Shape.PATH] = generatePath$3,
	            _a[Shape.TEXT] = undefined,
	            _a[Shape.GROUP] = undefined,
	            _a[Shape.IMAGE] = undefined,
	            _a[Shape.HTML] = undefined,
	            _a[Shape.MESH] = undefined,
	            _a);
	        // @ts-ignore
	        this.context.pathGeneratorFactory = pathGeneratorFactory;
	    };
	    Plugin.prototype.destroy = function () {
	        // @ts-ignore
	        delete this.context.pathGeneratorFactory;
	    };
	    return Plugin;
	}(AbstractRendererPlugin));

	var tmpVec3a = create$2();
	var tmpVec3b = create$2();
	var tmpVec3c = create$2();
	var tmpMat4$1 = create$1();
	/**
	 * pick shape(s) with Mouse/Touch event
	 *
	 * 1. find AABB with r-tree
	 * 2. do math calculation with geometry in an accurate way
	 */
	var CanvasPickerPlugin = /** @class */ (function () {
	    function CanvasPickerPlugin() {
	        var _this = this;
	        this.isHit = function (displayObject, position, worldTransform, isClipPath) {
	            // use picker for current shape's type
	            var pick = _this.context.pointInPathPickerFactory[displayObject.nodeName];
	            if (pick) {
	                // invert with world matrix
	                var invertWorldMat = invert(tmpMat4$1, worldTransform);
	                // transform client position to local space, do picking in local space
	                var localPosition = transformMat4(tmpVec3b, set$1(tmpVec3c, position[0], position[1], 0), invertWorldMat);
	                // account for anchor
	                var halfExtents = displayObject.getGeometryBounds().halfExtents;
	                var anchor = displayObject.parsedStyle.anchor;
	                localPosition[0] += ((anchor && anchor[0]) || 0) * halfExtents[0] * 2;
	                localPosition[1] += ((anchor && anchor[1]) || 0) * halfExtents[1] * 2;
	                if (pick(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this.isPointInPath, _this.context, _this.runtime)) {
	                    return true;
	                }
	            }
	            return false;
	        };
	        /**
	         * use native picking method
	         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath
	         */
	        this.isPointInPath = function (displayObject, position) {
	            var context = _this.runtime.offscreenCanvas.getOrCreateContext(_this.context.config.offscreenCanvas);
	            var generatePath = _this.context.pathGeneratorFactory[displayObject.nodeName];
	            if (generatePath) {
	                context.beginPath();
	                generatePath(context, displayObject.parsedStyle);
	                context.closePath();
	            }
	            return context.isPointInPath(position.x, position.y);
	        };
	    }
	    CanvasPickerPlugin.prototype.apply = function (context, runtime) {
	        var _this = this;
	        var _a;
	        var renderingService = context.renderingService, renderingContext = context.renderingContext;
	        this.context = context;
	        this.runtime = runtime;
	        var document = (_a = renderingContext.root) === null || _a === void 0 ? void 0 : _a.ownerDocument;
	        renderingService.hooks.pick.tapPromise(CanvasPickerPlugin.tag, function (result) { return __awaiter(_this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.pick(document, result)];
	            });
	        }); });
	        renderingService.hooks.pickSync.tap(CanvasPickerPlugin.tag, function (result) {
	            return _this.pick(document, result);
	        });
	    };
	    CanvasPickerPlugin.prototype.pick = function (document, result) {
	        var _a, e_1, _b;
	        var topmost = result.topmost, x = (_a = result.position, _a.x), y = _a.y;
	        // position in world space
	        var position = set$1(tmpVec3a, x, y, 0);
	        // query by AABB first with spatial index(r-tree)
	        var hitTestList = document.elementsFromBBox(position[0], position[1], position[0], position[1]);
	        // test with clip path & origin shape
	        // @see https://github.com/antvis/g/issues/1064
	        var pickedDisplayObjects = [];
	        try {
	            for (var hitTestList_1 = __values(hitTestList), hitTestList_1_1 = hitTestList_1.next(); !hitTestList_1_1.done; hitTestList_1_1 = hitTestList_1.next()) {
	                var displayObject = hitTestList_1_1.value;
	                var worldTransform = displayObject.getWorldTransform();
	                var isHitOriginShape = this.isHit(displayObject, position, worldTransform, false);
	                if (isHitOriginShape) {
	                    // should look up in the ancestor node
	                    var clipped = findClosestClipPathTarget(displayObject);
	                    if (clipped) {
	                        var clipPath = clipped.parsedStyle.clipPath;
	                        var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);
	                        if (isHitClipPath) {
	                            if (topmost) {
	                                result.picked = [displayObject];
	                                return result;
	                            }
	                            else {
	                                pickedDisplayObjects.push(displayObject);
	                            }
	                        }
	                    }
	                    else {
	                        if (topmost) {
	                            result.picked = [displayObject];
	                            return result;
	                        }
	                        else {
	                            pickedDisplayObjects.push(displayObject);
	                        }
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (hitTestList_1_1 && !hitTestList_1_1.done && (_b = hitTestList_1.return)) _b.call(hitTestList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        result.picked = pickedDisplayObjects;
	        return result;
	    };
	    CanvasPickerPlugin.tag = 'CanvasPicker';
	    return CanvasPickerPlugin;
	}());

	function isPointInPath$7(displayObject, position, isClipPath) {
	    var _a = displayObject.parsedStyle, r = _a.r, fill = _a.fill, stroke = _a.stroke, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, pointerEvents = _a.pointerEvents;
	    var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
	    var absDistance = distance$1(r, r, position.x, position.y);
	    var _b = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _b[0], hasStroke = _b[1];
	    if ((hasFill && hasStroke) || isClipPath) {
	        return absDistance <= r + halfLineWidth;
	    }
	    if (hasFill) {
	        return absDistance <= r;
	    }
	    if (hasStroke) {
	        return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
	    }
	    return false;
	}

	function ellipseDistance(squareX, squareY, rx, ry) {
	    return squareX / (rx * rx) + squareY / (ry * ry);
	}
	function isPointInPath$6(displayObject, position, isClipPath) {
	    var _a = displayObject.parsedStyle, rx = _a.rx, ry = _a.ry, fill = _a.fill, stroke = _a.stroke, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, pointerEvents = _a.pointerEvents;
	    var x = position.x, y = position.y;
	    var _b = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _b[0], hasStroke = _b[1];
	    var halfLineWith = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
	    var squareX = (x - rx) * (x - rx);
	    var squareY = (y - ry) * (y - ry);
	    // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;
	    if ((hasFill && hasStroke) || isClipPath) {
	        return (ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=
	            1);
	    }
	    if (hasFill) {
	        return ellipseDistance(squareX, squareY, rx, ry) <= 1;
	    }
	    if (hasStroke) {
	        return (ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >=
	            1 &&
	            ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=
	                1);
	    }
	    return false;
	}

	function inBox(minX, minY, width, height, x, y) {
	    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
	}
	function inRect(minX, minY, width, height, lineWidth, x, y) {
	    var halfWidth = lineWidth / 2;
	    // 将四个边看做矩形来检测，比边的检测算法要快
	    return (inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边
	        inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 右边
	        inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 下边
	        inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)); // 左边
	}
	function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
	    var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间
	    // if (angle < startAngle || angle > endAngle) {
	    //   return false;
	    // }
	    var point = {
	        x: cx + r * Math.cos(angle),
	        y: cy + r * Math.sin(angle),
	    };
	    return distance$1(point.x, point.y, x, y) <= lineWidth / 2;
	}
	function inLine(x1, y1, x2, y2, lineWidth, x, y) {
	    var minX = Math.min(x1, x2);
	    var maxX = Math.max(x1, x2);
	    var minY = Math.min(y1, y2);
	    var maxY = Math.max(y1, y2);
	    var halfWidth = lineWidth / 2;
	    // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内
	    // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差
	    if (!(x >= minX - halfWidth &&
	        x <= maxX + halfWidth &&
	        y >= minY - halfWidth &&
	        y <= maxY + halfWidth)) {
	        return false;
	    }
	    // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能
	    return pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
	}
	function inPolyline(points, lineWidth, x, y, isClose) {
	    var count = points.length;
	    if (count < 2) {
	        return false;
	    }
	    for (var i = 0; i < count - 1; i++) {
	        var x1 = points[i][0];
	        var y1 = points[i][1];
	        var x2 = points[i + 1][0];
	        var y2 = points[i + 1][1];
	        if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
	            return true;
	        }
	    }
	    // 如果封闭，则计算起始点和结束点的边
	    if (isClose) {
	        var first = points[0];
	        var last = points[count - 1];
	        if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {
	            return true;
	        }
	    }
	    return false;
	}
	// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526
	var tolerance = 1e-6;
	// 三态函数，判断两个double在eps精度下的大小关系
	function dcmp(x) {
	    if (Math.abs(x) < tolerance) {
	        return 0;
	    }
	    return x < 0 ? -1 : 1;
	}
	// 判断点Q是否在p1和p2的线段上
	function onSegment(p1, p2, q) {
	    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&
	        Math.min(p1[0], p2[0]) <= q[0] &&
	        q[0] <= Math.max(p1[0], p2[0]) &&
	        Math.min(p1[1], p2[1]) <= q[1] &&
	        q[1] <= Math.max(p1[1], p2[1])) {
	        return true;
	    }
	    return false;
	}
	// 判断点P在多边形内-射线法
	function inPolygon(points, x, y) {
	    var isHit = false;
	    var n = points.length;
	    if (n <= 2) {
	        // svg 中点小于 3 个时，不显示，也无法被拾取
	        return false;
	    }
	    for (var i = 0; i < n; i++) {
	        var p1 = points[i];
	        var p2 = points[(i + 1) % n];
	        if (onSegment(p1, p2, [x, y])) {
	            // 点在多边形一条边上
	            return true;
	        }
	        // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
	        // 后一个判断被测点 在 射线与边交点 的左边
	        if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&
	            dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0) {
	            isHit = !isHit;
	        }
	    }
	    return isHit;
	}
	function inPolygons(polygons, x, y) {
	    var isHit = false;
	    for (var i = 0; i < polygons.length; i++) {
	        var points = polygons[i];
	        isHit = inPolygon(points, x, y);
	        if (isHit) {
	            break;
	        }
	    }
	    return isHit;
	}

	function isPointInPath$5(displayObject, position, isClipPath) {
	    var _a = displayObject.parsedStyle, x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, pointerEvents = _a.pointerEvents, fill = _a.fill, stroke = _a.stroke;
	    var _d = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasStroke = _d[1];
	    if ((!hasStroke && !isClipPath) || !lineWidth) {
	        return false;
	    }
	    return inLine(x1, y1, x2, y2, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y);
	}

	// TODO: replace it with method in @antv/util
	function isPointInStroke(segments, lineWidth, px, py, length) {
	    var isHit = false;
	    var halfWidth = lineWidth / 2;
	    for (var i = 0; i < segments.length; i++) {
	        var segment = segments[i];
	        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;
	        // 如果在前面已经生成过包围盒，直接按照包围盒计算
	        if (box &&
	            !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, px, py)) {
	            continue;
	        }
	        switch (segment.command) {
	            // L 和 Z 都是直线， M 不进行拾取
	            case 'L':
	            case 'Z':
	                isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);
	                if (isHit) {
	                    return true;
	                }
	                break;
	            case 'Q':
	                var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);
	                isHit = qDistance <= lineWidth / 2;
	                if (isHit) {
	                    return true;
	                }
	                break;
	            case 'C':
	                var cDistance = pointDistance$3(prePoint[0], // 上一段结束位置, 即 C 的起始点
	                prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
	                params[2], params[3], params[4], params[5], params[6], px, py, length);
	                isHit = cDistance <= lineWidth / 2;
	                if (isHit) {
	                    return true;
	                }
	                break;
	            case 'A':
	                // cache conversion result
	                if (!segment.cubicParams) {
	                    segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], undefined);
	                }
	                var args = segment.cubicParams;
	                // fixArc
	                var prePointInCubic = prePoint;
	                for (var i_1 = 0; i_1 < args.length; i_1 += 6) {
	                    var cDistance_1 = pointDistance$3(prePointInCubic[0], // 上一段结束位置, 即 C 的起始点
	                    prePointInCubic[1], args[i_1], args[i_1 + 1], args[i_1 + 2], args[i_1 + 3], args[i_1 + 4], args[i_1 + 5], px, py, length);
	                    prePointInCubic = [args[i_1 + 4], args[i_1 + 5]];
	                    isHit = cDistance_1 <= lineWidth / 2;
	                    if (isHit) {
	                        return true;
	                    }
	                }
	                break;
	        }
	    }
	    return isHit;
	}
	function isPointInPath$4(displayObject, position, isClipPath, isPointInPath, renderingPluginContext, runtime) {
	    var _a = displayObject.parsedStyle, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, stroke = _a.stroke, fill = _a.fill, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, path = _a.path, pointerEvents = _a.pointerEvents;
	    var segments = path.segments, hasArc = path.hasArc, polylines = path.polylines, polygons = path.polygons;
	    var _d = __read(isFillOrStrokeAffected(pointerEvents, 
	    // Only a closed path can be filled.
	    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill, stroke), 2), hasFill = _d[0], hasStroke = _d[1];
	    var totalLength = getOrCalculatePathTotalLength(displayObject);
	    var isHit = false;
	    if (hasFill || isClipPath) {
	        if (hasArc) {
	            // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割
	            isHit = isPointInPath(displayObject, position);
	        }
	        else {
	            // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理
	            isHit =
	                inPolygons(polygons, position.x + x, position.y + y) ||
	                    inPolygons(polylines, position.x + x, position.y + y);
	        }
	        return isHit;
	    }
	    else if (hasStroke || isClipPath) {
	        isHit = isPointInStroke(segments, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, totalLength);
	    }
	    return isHit;
	}

	function isPointInPath$3(displayObject, position, isClipPath) {
	    var _a = displayObject.parsedStyle, stroke = _a.stroke, fill = _a.fill, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, points = _a.points, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, pointerEvents = _a.pointerEvents;
	    var _d = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _d[0], hasStroke = _d[1];
	    var isHit = false;
	    if (hasStroke || isClipPath) {
	        isHit = inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, true);
	    }
	    if (!isHit && (hasFill || isClipPath)) {
	        isHit = inPolygon(points.points, position.x + x, position.y + y);
	    }
	    return isHit;
	}

	function isPointInPath$2(displayObject, position, isClipPath) {
	    var _a = displayObject.parsedStyle, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, points = _a.points, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, pointerEvents = _a.pointerEvents, fill = _a.fill, stroke = _a.stroke;
	    var _d = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasStroke = _d[1];
	    if ((!hasStroke && !isClipPath) || !lineWidth) {
	        return false;
	    }
	    return inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, false);
	}

	function isPointInPath$1(displayObject, position, isClipPath, isPointInPath, runtime) {
	    var _a = displayObject.parsedStyle, radius = _a.radius, fill = _a.fill, stroke = _a.stroke, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, width = _a.width, height = _a.height, pointerEvents = _a.pointerEvents;
	    var _b = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _b[0], hasStroke = _b[1];
	    var hasRadius = radius && radius.some(function (r) { return r !== 0; });
	    var lineWidthForHitTesting = (lineWidth || 0) + (increasedLineWidthForHitTesting || 0);
	    // 无圆角时的策略
	    if (!hasRadius) {
	        var halfWidth = lineWidthForHitTesting / 2;
	        // 同时填充和带有边框
	        if ((hasFill && hasStroke) || isClipPath) {
	            return inBox(0 - halfWidth, 0 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
	        }
	        // 仅填充
	        if (hasFill) {
	            return inBox(0, 0, width, height, position.x, position.y);
	        }
	        if (hasStroke) {
	            return inRect(0, 0, width, height, lineWidthForHitTesting, position.x, position.y);
	        }
	    }
	    else {
	        var isHit = false;
	        if (hasStroke || isClipPath) {
	            isHit = inRectWithRadius(0, 0, width, height, radius.map(function (r) {
	                return clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
	            }), lineWidthForHitTesting, position.x, position.y);
	        }
	        // 仅填充时带有圆角的矩形直接通过图形拾取
	        // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形
	        if (!isHit && (hasFill || isClipPath)) {
	            isHit = isPointInPath(displayObject, position);
	        }
	        return isHit;
	    }
	    return false;
	}
	function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x, y) {
	    var _a = __read(radiusArray, 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];
	    return (inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) ||
	        inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x, y) ||
	        inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x, y) ||
	        inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) ||
	        inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) ||
	        inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x, y) ||
	        inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x, y) ||
	        inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y));
	}

	function isPointInPath(displayObject, position, isClipPath, isPointInPath, renderingPluginContext, runtime) {
	    var _a = displayObject.parsedStyle, pointerEvents = _a.pointerEvents, width = _a.width, height = _a.height;
	    if (pointerEvents === 'non-transparent-pixel') {
	        var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
	        var canvas = runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
	        var context = runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas, {
	            willReadFrequently: true,
	        });
	        canvas.width = width;
	        canvas.height = height;
	        renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, displayObject.parsedStyle, displayObject, undefined, undefined, undefined);
	        var imagedata = context.getImageData(position.x, position.y, 1, 1).data;
	        return imagedata.every(function (component) { return component !== 0; });
	    }
	    return true;
	}

	var Plugin$1 = /** @class */ (function (_super) {
	    __extends(Plugin, _super);
	    function Plugin() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.name = 'canvas-picker';
	        return _this;
	    }
	    Plugin.prototype.init = function () {
	        var _a;
	        var trueFunc = function () { return true; };
	        var pointInPathPickerFactory = (_a = {},
	            _a[Shape.CIRCLE] = isPointInPath$7,
	            _a[Shape.ELLIPSE] = isPointInPath$6,
	            _a[Shape.RECT] = isPointInPath$1,
	            _a[Shape.LINE] = isPointInPath$5,
	            _a[Shape.POLYLINE] = isPointInPath$2,
	            _a[Shape.POLYGON] = isPointInPath$3,
	            _a[Shape.PATH] = isPointInPath$4,
	            _a[Shape.TEXT] = trueFunc,
	            _a[Shape.GROUP] = null,
	            _a[Shape.IMAGE] = isPointInPath,
	            _a[Shape.HTML] = null,
	            _a[Shape.MESH] = null,
	            _a);
	        // @ts-ignore
	        this.context.pointInPathPickerFactory = pointInPathPickerFactory;
	        this.addRenderingPlugin(new CanvasPickerPlugin());
	    };
	    Plugin.prototype.destroy = function () {
	        // @ts-ignore
	        delete this.context.pointInPathPickerFactory;
	        this.removeAllRenderingPlugins();
	    };
	    return Plugin;
	}(AbstractRendererPlugin));

	/**
	 * support 2 modes in rendering:
	 * * immediate
	 * * delayed: render at the end of frame with dirty-rectangle
	 */
	var CanvasRendererPlugin = /** @class */ (function () {
	    function CanvasRendererPlugin(canvasRendererPluginOptions) {
	        this.canvasRendererPluginOptions = canvasRendererPluginOptions;
	        this.removedRBushNodeAABBs = [];
	        this.renderQueue = [];
	        /**
	         * This stack is only used by clipPath for now.
	         */
	        this.restoreStack = [];
	        this.clearFullScreen = false;
	        /**
	         * view projection matrix
	         */
	        this.vpMatrix = create$1();
	        this.dprMatrix = create$1();
	        this.tmpMat4 = create$1();
	        this.vec3a = create$2();
	        this.vec3b = create$2();
	        this.vec3c = create$2();
	        this.vec3d = create$2();
	    }
	    CanvasRendererPlugin.prototype.apply = function (context, runtime) {
	        var _this = this;
	        this.context = context;
	        var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot, 
	        // @ts-ignore
	        pathGeneratorFactory = context.pathGeneratorFactory;
	        this.rBush = rBushRoot;
	        this.pathGeneratorFactory = pathGeneratorFactory;
	        var contextService = context.contextService;
	        var canvas = renderingContext.root.ownerDocument.defaultView;
	        var handleUnmounted = function (e) {
	            var object = e.target;
	            // remove r-bush node
	            // @ts-ignore
	            var rBushNode = object.rBushNode;
	            if (rBushNode.aabb) {
	                // save removed aabbs for dirty-rectangle rendering later
	                _this.removedRBushNodeAABBs.push(rBushNode.aabb);
	            }
	        };
	        var handleCulled = function (e) {
	            var object = e.target;
	            // @ts-ignore
	            var rBushNode = object.rBushNode;
	            if (rBushNode.aabb) {
	                // save removed aabbs for dirty-rectangle rendering later
	                _this.removedRBushNodeAABBs.push(rBushNode.aabb);
	            }
	        };
	        renderingService.hooks.init.tap(CanvasRendererPlugin.tag, function () {
	            canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
	            canvas.addEventListener(ElementEvent.CULLED, handleCulled);
	            // clear fullscreen
	            var dpr = contextService.getDPR();
	            var width = config.width, height = config.height;
	            var context = contextService.getContext();
	            _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);
	        });
	        renderingService.hooks.destroy.tap(CanvasRendererPlugin.tag, function () {
	            canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
	            canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
	            // this.renderQueue = [];
	            // this.removedRBushNodeAABBs = [];
	            // this.restoreStack = [];
	        });
	        renderingService.hooks.beginFrame.tap(CanvasRendererPlugin.tag, function () {
	            var _a, _b;
	            var context = contextService.getContext();
	            var dpr = contextService.getDPR();
	            var width = config.width, height = config.height;
	            var dirtyObjectNumThreshold = (_a = _this.canvasRendererPluginOptions, _a.dirtyObjectNumThreshold), dirtyObjectRatioThreshold = _a.dirtyObjectRatioThreshold;
	            // some heuristic conditions such as 80% object changed
	            var total = (_b = renderingService.getStats(), _b.total), rendered = _b.rendered;
	            var ratio = rendered / total;
	            _this.clearFullScreen =
	                renderingService.disableDirtyRectangleRendering() ||
	                    (rendered > dirtyObjectNumThreshold &&
	                        ratio > dirtyObjectRatioThreshold);
	            if (context) {
	                context.resetTransform
	                    ? context.resetTransform()
	                    : context.setTransform(1, 0, 0, 1, 0, 0);
	                if (_this.clearFullScreen) {
	                    _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);
	                }
	            }
	        });
	        var renderByZIndex = function (object, context) {
	            if (object.isVisible() && !object.isCulled()) {
	                _this.renderDisplayObject(object, context, _this.context, _this.restoreStack, runtime);
	                // if (object.renderable.) {
	                // if we did a full screen rendering last frame
	                _this.saveDirtyAABB(object);
	                // }
	            }
	            var sorted = object.sortable.sorted || object.childNodes;
	            // should account for z-index
	            sorted.forEach(function (child) {
	                renderByZIndex(child, context);
	            });
	        };
	        // render at the end of frame
	        renderingService.hooks.endFrame.tap(CanvasRendererPlugin.tag, function () {
	            var context = contextService.getContext();
	            // clear & clip dirty rectangle
	            var dpr = contextService.getDPR();
	            fromScaling(_this.dprMatrix, [dpr, dpr, 1]);
	            multiply(_this.vpMatrix, _this.dprMatrix, camera.getOrthoMatrix());
	            // if (this.clearFullScreen) {
	            if (_this.clearFullScreen) {
	                // console.log('canvas renderer fcp...');
	                renderByZIndex(renderingContext.root, context);
	            }
	            else {
	                // console.log('canvas renderer next...');
	                // merge removed AABB
	                var dirtyRenderBounds = _this.safeMergeAABB.apply(_this, __spreadArray([_this.mergeDirtyAABBs(_this.renderQueue)], __read(_this.removedRBushNodeAABBs.map(function (_a) {
	                    var minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
	                    var aabb = new AABB();
	                    aabb.setMinMax(
	                    // vec3.fromValues(minX, minY, 0),
	                    // vec3.fromValues(maxX, maxY, 0),
	                    [minX, minY, 0], [maxX, maxY, 0]);
	                    return aabb;
	                })), false));
	                _this.removedRBushNodeAABBs = [];
	                if (AABB.isEmpty(dirtyRenderBounds)) {
	                    _this.renderQueue = [];
	                    return;
	                }
	                var dirtyRect = _this.convertAABB2Rect(dirtyRenderBounds);
	                var x = dirtyRect.x, y = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
	                var tl = transformMat4(_this.vec3a, [x, y, 0], _this.vpMatrix);
	                var tr = transformMat4(_this.vec3b, [x + width, y, 0], _this.vpMatrix);
	                var bl = transformMat4(_this.vec3c, [x, y + height, 0], _this.vpMatrix);
	                var br = transformMat4(_this.vec3d, [x + width, y + height, 0], _this.vpMatrix);
	                var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
	                var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
	                var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
	                var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
	                var ix = Math.floor(minx);
	                var iy = Math.floor(miny);
	                var iwidth = Math.ceil(maxx - minx);
	                var iheight = Math.ceil(maxy - miny);
	                context.save();
	                _this.clearRect(context, ix, iy, iwidth, iheight, config.background);
	                context.beginPath();
	                context.rect(ix, iy, iwidth, iheight);
	                context.clip();
	                // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations
	                context.setTransform(_this.vpMatrix[0], _this.vpMatrix[1], _this.vpMatrix[4], _this.vpMatrix[5], _this.vpMatrix[12], _this.vpMatrix[13]);
	                // draw dirty rectangle
	                var enableDirtyRectangleRenderingDebug = config.renderer.getConfig().enableDirtyRectangleRenderingDebug;
	                if (enableDirtyRectangleRenderingDebug) {
	                    canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
	                        dirtyRect: {
	                            x: ix,
	                            y: iy,
	                            width: iwidth,
	                            height: iheight,
	                        },
	                    }));
	                }
	                // search objects intersect with dirty rectangle
	                var dirtyObjects = _this.searchDirtyObjects(dirtyRenderBounds);
	                // do rendering
	                dirtyObjects
	                    // sort by z-index
	                    .sort(function (a, b) { return a.sortable.renderOrder - b.sortable.renderOrder; })
	                    .forEach(function (object) {
	                    // culled object should not be rendered
	                    if (object && object.isVisible() && !object.isCulled()) {
	                        _this.renderDisplayObject(object, context, _this.context, _this.restoreStack, runtime);
	                    }
	                });
	                context.restore();
	                // save dirty AABBs in last frame
	                _this.renderQueue.forEach(function (object) {
	                    _this.saveDirtyAABB(object);
	                });
	                // clear queue
	                _this.renderQueue = [];
	            }
	            // pop restore stack, eg. root -> parent -> child
	            _this.restoreStack.forEach(function () {
	                context.restore();
	            });
	            // clear restore stack
	            _this.restoreStack = [];
	        });
	        renderingService.hooks.render.tap(CanvasRendererPlugin.tag, function (object) {
	            if (!_this.clearFullScreen) {
	                // render at the end of frame
	                _this.renderQueue.push(object);
	            }
	        });
	    };
	    CanvasRendererPlugin.prototype.clearRect = function (context, x, y, width, height, background) {
	        // clearRect is faster than fillRect @see https://stackoverflow.com/a/30830253
	        context.clearRect(x, y, width, height);
	        if (background) {
	            context.fillStyle = background;
	            context.fillRect(x, y, width, height);
	        }
	    };
	    CanvasRendererPlugin.prototype.renderDisplayObject = function (object, context, canvasContext, restoreStack, runtime) {
	        var nodeName = object.nodeName;
	        // console.log('canvas render:', object);
	        // restore to its ancestor
	        var parent = restoreStack[restoreStack.length - 1];
	        if (parent &&
	            !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
	            context.restore();
	            restoreStack.pop();
	        }
	        // @ts-ignore
	        var styleRenderer = this.context.styleRendererFactory[nodeName];
	        var generatePath = this.pathGeneratorFactory[nodeName];
	        // clip path
	        var clipPath = object.parsedStyle.clipPath;
	        if (clipPath) {
	            this.applyWorldTransform(context, clipPath);
	            // generate path in local space
	            var generatePath_1 = this.pathGeneratorFactory[clipPath.nodeName];
	            if (generatePath_1) {
	                context.save();
	                // save clip
	                restoreStack.push(object);
	                context.beginPath();
	                generatePath_1(context, clipPath.parsedStyle);
	                context.closePath();
	                context.clip();
	            }
	        }
	        // fill & stroke
	        if (styleRenderer) {
	            this.applyWorldTransform(context, object);
	            context.save();
	            // apply attributes to context
	            this.applyAttributesToContext(context, object);
	        }
	        if (generatePath) {
	            context.beginPath();
	            generatePath(context, object.parsedStyle);
	            if (object.nodeName !== Shape.LINE &&
	                object.nodeName !== Shape.PATH &&
	                object.nodeName !== Shape.POLYLINE) {
	                context.closePath();
	            }
	        }
	        // fill & stroke
	        if (styleRenderer) {
	            styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime);
	            // restore applied attributes, eg. shadowBlur shadowColor...
	            context.restore();
	        }
	        // finish rendering, clear dirty flag
	        object.renderable.dirty = false;
	    };
	    CanvasRendererPlugin.prototype.convertAABB2Rect = function (aabb) {
	        var min = aabb.getMin();
	        var max = aabb.getMax();
	        // expand the rectangle a bit to avoid artifacts
	        // @see https://www.yuque.com/antv/ou292n/bi8nix#ExvCu
	        var minX = Math.floor(min[0]);
	        var minY = Math.floor(min[1]);
	        var maxX = Math.ceil(max[0]);
	        var maxY = Math.ceil(max[1]);
	        var width = maxX - minX;
	        var height = maxY - minY;
	        return { x: minX, y: minY, width: width, height: height };
	    };
	    /**
	     * TODO: merge dirty rectangles with some strategies.
	     * For now, we just simply merge all the rectangles into one.
	     * @see https://idom.me/articles/841.html
	     */
	    CanvasRendererPlugin.prototype.mergeDirtyAABBs = function (dirtyObjects) {
	        // merge into a big AABB
	        // TODO: skip descendant if ancestor is caculated, but compareNodePosition is really slow
	        var aabb = new AABB();
	        dirtyObjects.forEach(function (object) {
	            var renderBounds = object.getRenderBounds();
	            aabb.add(renderBounds);
	            var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
	            if (dirtyRenderBounds) {
	                aabb.add(dirtyRenderBounds);
	            }
	        });
	        return aabb;
	    };
	    CanvasRendererPlugin.prototype.searchDirtyObjects = function (dirtyRectangle) {
	        var _a, _b;
	        // search in r-tree, get all affected nodes
	        var minX = (_a = __read(dirtyRectangle.getMin(), 2), _a[0]), minY = _a[1];
	        var maxX = (_b = __read(dirtyRectangle.getMax(), 2), _b[0]), maxY = _b[1];
	        var rBushNodes = this.rBush.search({
	            minX: minX,
	            minY: minY,
	            maxX: maxX,
	            maxY: maxY,
	        });
	        return rBushNodes.map(function (_a) {
	            var displayObject = _a.displayObject;
	            return displayObject;
	        });
	    };
	    CanvasRendererPlugin.prototype.saveDirtyAABB = function (object) {
	        var renderable = object.renderable;
	        if (!renderable.dirtyRenderBounds) {
	            renderable.dirtyRenderBounds = new AABB();
	        }
	        var renderBounds = object.getRenderBounds();
	        if (renderBounds) {
	            // save last dirty aabb
	            renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
	        }
	    };
	    /**
	     * TODO: batch the same global attributes
	     */
	    CanvasRendererPlugin.prototype.applyAttributesToContext = function (context, object) {
	        var _a;
	        var stroke = (_a = object.parsedStyle, _a.stroke), fill = _a.fill, opacity = _a.opacity, lineDash = _a.lineDash, lineDashOffset = _a.lineDashOffset;
	        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash
	        if (lineDash) {
	            context.setLineDash(lineDash);
	        }
	        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset
	        if (!isNil(lineDashOffset)) {
	            context.lineDashOffset = lineDashOffset;
	        }
	        if (!isNil(opacity)) {
	            context.globalAlpha *= opacity;
	        }
	        if (!isNil(stroke) &&
	            !Array.isArray(stroke) &&
	            !stroke.isNone) {
	            context.strokeStyle = object.attributes.stroke;
	        }
	        if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {
	            context.fillStyle = object.attributes.fill;
	        }
	    };
	    CanvasRendererPlugin.prototype.applyWorldTransform = function (context, object, matrix) {
	        var tx = 0;
	        var ty = 0;
	        var anchor = (object.parsedStyle || {}).anchor;
	        var anchorX = (anchor && anchor[0]) || 0;
	        var anchorY = (anchor && anchor[1]) || 0;
	        if (anchorX !== 0 || anchorY !== 0) {
	            // const bounds = object.getGeometryBounds();
	            var bounds = object.geometry.contentBounds;
	            var width = (bounds && bounds.halfExtents[0] * 2) || 0;
	            var height = (bounds && bounds.halfExtents[1] * 2) || 0;
	            tx = -(anchorX * width);
	            ty = -(anchorY * height);
	        }
	        // apply clip shape's RTS
	        if (matrix) {
	            copy(this.tmpMat4, object.getLocalTransform());
	            this.vec3a[0] = tx;
	            this.vec3a[1] = ty;
	            this.vec3a[2] = 0;
	            translate(this.tmpMat4, this.tmpMat4, this.vec3a);
	            multiply(this.tmpMat4, matrix, this.tmpMat4);
	            multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
	        }
	        else {
	            // apply RTS transformation in world space
	            copy(this.tmpMat4, object.getWorldTransform());
	            this.vec3a[0] = tx;
	            this.vec3a[1] = ty;
	            this.vec3a[2] = 0;
	            translate(this.tmpMat4, this.tmpMat4, this.vec3a);
	            multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
	        }
	        // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations
	        context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
	    };
	    CanvasRendererPlugin.prototype.safeMergeAABB = function () {
	        var aabbs = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            aabbs[_i] = arguments[_i];
	        }
	        var merged = new AABB();
	        aabbs.forEach(function (aabb) {
	            merged.add(aabb);
	        });
	        return merged;
	    };
	    CanvasRendererPlugin.tag = 'CanvasRenderer';
	    return CanvasRendererPlugin;
	}());

	var DefaultRenderer = /** @class */ (function () {
	    function DefaultRenderer(imagePool) {
	        this.imagePool = imagePool;
	    }
	    DefaultRenderer.prototype.render = function (context, parsedStyle, object, canvasContext, plugin, runtime) {
	        var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, opacity = parsedStyle.opacity, fillOpacity = parsedStyle.fillOpacity, stroke = parsedStyle.stroke, strokeOpacity = parsedStyle.strokeOpacity, lineWidth = parsedStyle.lineWidth, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
	        var hasFill = !isNil(fill) && !fill.isNone;
	        var hasStroke = !isNil(stroke) && !stroke.isNone && lineWidth > 0;
	        var isFillTransparent = fill.alpha === 0;
	        var hasFilter = !!(filter && filter.length);
	        var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
	        var nodeName = object.nodeName;
	        var isInnerShadow = shadowType === 'inner';
	        var shouldDrawShadowWithStroke = hasStroke &&
	            hasShadow &&
	            (nodeName === Shape.PATH ||
	                nodeName === Shape.LINE ||
	                nodeName === Shape.POLYLINE ||
	                isFillTransparent ||
	                isInnerShadow);
	        if (hasFill) {
	            context.globalAlpha = opacity * fillOpacity;
	            if (!shouldDrawShadowWithStroke) {
	                setShadowAndFilter(object, context, hasShadow);
	            }
	            this.fill(context, object, fill, fillRule, canvasContext, plugin, runtime);
	            if (!shouldDrawShadowWithStroke) {
	                this.clearShadowAndFilter(context, hasFilter, hasShadow);
	            }
	        }
	        if (hasStroke) {
	            context.globalAlpha = opacity * strokeOpacity;
	            context.lineWidth = lineWidth;
	            if (!isNil(miterLimit)) {
	                context.miterLimit = miterLimit;
	            }
	            if (!isNil(lineCap)) {
	                context.lineCap = lineCap;
	            }
	            if (!isNil(lineJoin)) {
	                context.lineJoin = lineJoin;
	            }
	            if (shouldDrawShadowWithStroke) {
	                if (isInnerShadow) {
	                    context.globalCompositeOperation = 'source-atop';
	                }
	                setShadowAndFilter(object, context, true);
	                if (isInnerShadow) {
	                    this.stroke(context, object, stroke, canvasContext, plugin, runtime);
	                    context.globalCompositeOperation = 'source-over';
	                    this.clearShadowAndFilter(context, hasFilter, true);
	                }
	            }
	            this.stroke(context, object, stroke, canvasContext, plugin, runtime);
	        }
	    };
	    DefaultRenderer.prototype.clearShadowAndFilter = function (context, hasFilter, hasShadow) {
	        if (hasShadow) {
	            context.shadowColor = 'transparent';
	            context.shadowBlur = 0;
	        }
	        if (hasFilter) {
	            // save drop-shadow filter
	            var oldFilter = context.filter;
	            if (!isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {
	                context.filter =
	                    oldFilter.replace(/drop-shadow\([^)]*\)/, '').trim() || 'none';
	            }
	        }
	    };
	    DefaultRenderer.prototype.fill = function (context, object, fill, fillRule, canvasContext, plugin, runtime) {
	        var _this = this;
	        if (Array.isArray(fill)) {
	            fill.forEach(function (gradient) {
	                context.fillStyle = _this.getColor(gradient, object, context);
	                fillRule ? context.fill(fillRule) : context.fill();
	            });
	        }
	        else {
	            if (isPattern(fill)) {
	                context.fillStyle = this.getPattern(fill, object, context, canvasContext, plugin, runtime);
	            }
	            fillRule ? context.fill(fillRule) : context.fill();
	        }
	    };
	    DefaultRenderer.prototype.stroke = function (context, object, stroke, canvasContext, plugin, runtime) {
	        var _this = this;
	        if (Array.isArray(stroke)) {
	            stroke.forEach(function (gradient) {
	                context.strokeStyle = _this.getColor(gradient, object, context);
	                context.stroke();
	            });
	        }
	        else {
	            if (isPattern(stroke)) {
	                context.strokeStyle = this.getPattern(stroke, object, context, canvasContext, plugin, runtime);
	            }
	            context.stroke();
	        }
	    };
	    DefaultRenderer.prototype.getPattern = function (pattern, object, context, canvasContext, plugin, runtime) {
	        var $offscreenCanvas;
	        var dpr;
	        if (pattern.image.nodeName === 'rect') {
	            var _a = pattern.image.parsedStyle, width = _a.width, height = _a.height;
	            dpr = canvasContext.contextService.getDPR();
	            var offscreenCanvas = canvasContext.config.offscreenCanvas;
	            $offscreenCanvas = runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
	            $offscreenCanvas.width = width * dpr;
	            $offscreenCanvas.height = height * dpr;
	            var offscreenCanvasContext_1 = runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
	            var restoreStack_1 = [];
	            // offscreenCanvasContext.scale(1 / dpr, 1 / dpr);
	            pattern.image.forEach(function (object) {
	                plugin.renderDisplayObject(object, offscreenCanvasContext_1, canvasContext, restoreStack_1, runtime);
	            });
	            restoreStack_1.forEach(function () {
	                offscreenCanvasContext_1.restore();
	            });
	        }
	        var canvasPattern = this.imagePool.getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, function () {
	            // set dirty rectangle flag
	            object.renderable.dirty = true;
	            canvasContext.renderingService.dirtify();
	        });
	        return canvasPattern;
	    };
	    DefaultRenderer.prototype.getColor = function (parsedColor, object, context) {
	        var color;
	        if (parsedColor.type === GradientType.LinearGradient ||
	            parsedColor.type === GradientType.RadialGradient) {
	            var bounds = object.getGeometryBounds();
	            var width = (bounds && bounds.halfExtents[0] * 2) || 1;
	            var height = (bounds && bounds.halfExtents[1] * 2) || 1;
	            color = this.imagePool.getOrCreateGradient(__assign(__assign({ type: parsedColor.type }, parsedColor.value), { width: width, height: height }), context);
	        }
	        return color;
	    };
	    return DefaultRenderer;
	}());
	/**
	 * apply before fill and stroke but only once
	 */
	function setShadowAndFilter(object, context, hasShadow) {
	    var _a = object.parsedStyle, filter = _a.filter, shadowColor = _a.shadowColor, shadowBlur = _a.shadowBlur, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY;
	    if (filter && filter.length) {
	        // use raw filter string
	        context.filter = object.style.filter;
	    }
	    if (hasShadow) {
	        context.shadowColor = shadowColor.toString();
	        context.shadowBlur = shadowBlur || 0;
	        context.shadowOffsetX = shadowOffsetX || 0;
	        context.shadowOffsetY = shadowOffsetY || 0;
	    }
	}

	var ImageRenderer = /** @class */ (function () {
	    function ImageRenderer(imagePool) {
	        this.imagePool = imagePool;
	    }
	    ImageRenderer.prototype.render = function (context, parsedStyle, object) {
	        var width = parsedStyle.width, height = parsedStyle.height, img = parsedStyle.img, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
	        var image;
	        var iw = width;
	        var ih = height;
	        if (isString(img)) {
	            // image has been loaded in `mounted` hook
	            image = this.imagePool.getImageSync(img);
	        }
	        else {
	            iw || (iw = img.width);
	            ih || (ih = img.height);
	            image = img;
	        }
	        if (image) {
	            var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
	            setShadowAndFilter(object, context, hasShadow);
	            // node-canvas will throw the following err:
	            // Error: Image given has not completed loading
	            try {
	                context.drawImage(image, 0, 0, iw, ih);
	            }
	            catch (e) { }
	        }
	    };
	    return ImageRenderer;
	}());

	var TextRenderer = /** @class */ (function () {
	    function TextRenderer() {
	    }
	    TextRenderer.prototype.render = function (context, parsedStyle, object) {
	        var _a = parsedStyle, lineWidth = _a.lineWidth, textAlign = _a.textAlign, textBaseline = _a.textBaseline, lineJoin = _a.lineJoin, miterLimit = _a.miterLimit, letterSpacing = _a.letterSpacing, stroke = _a.stroke, fill = _a.fill, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity, opacity = _a.opacity, metrics = _a.metrics, dx = _a.dx, dy = _a.dy, shadowColor = _a.shadowColor, shadowBlur = _a.shadowBlur;
	        var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
	        context.font = font;
	        context.lineWidth = lineWidth;
	        context.textAlign = textAlign === 'middle' ? 'center' : textAlign;
	        var formattedTextBaseline = textBaseline;
	        if (
	        // formattedTextBaseline === 'bottom' ||
	        !runtime.enableCSSParsing &&
	            formattedTextBaseline === 'alphabetic') {
	            formattedTextBaseline = 'bottom';
	        }
	        context.lineJoin = lineJoin;
	        if (!isNil(miterLimit)) {
	            context.miterLimit = miterLimit;
	        }
	        var linePositionY = 0;
	        // handle vertical text baseline
	        if (textBaseline === 'middle') {
	            linePositionY = -height / 2 - lineHeight / 2;
	        }
	        else if (textBaseline === 'bottom' ||
	            textBaseline === 'alphabetic' ||
	            textBaseline === 'ideographic') {
	            linePositionY = -height;
	        }
	        else if (textBaseline === 'top' || textBaseline === 'hanging') {
	            linePositionY = -lineHeight;
	        }
	        // account for dx & dy
	        var offsetX = dx || 0;
	        linePositionY += dy || 0;
	        if (lines.length === 1) {
	            if (formattedTextBaseline === 'bottom') {
	                formattedTextBaseline = 'middle';
	                linePositionY -= 0.5 * height;
	            }
	            else if (formattedTextBaseline === 'top') {
	                formattedTextBaseline = 'middle';
	                linePositionY += 0.5 * height;
	            }
	        }
	        context.textBaseline = formattedTextBaseline;
	        var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
	        setShadowAndFilter(object, context, hasShadow);
	        // draw lines line by line
	        for (var i = 0; i < lines.length; i++) {
	            var linePositionX = lineWidth / 2 + offsetX;
	            linePositionY += lineHeight;
	            // no need to re-position X, cause we already set text align
	            // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign
	            if (!isNil(stroke) && !stroke.isNone && lineWidth) {
	                this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity, true);
	            }
	            if (!isNil(fill)) {
	                this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity);
	            }
	        }
	    };
	    TextRenderer.prototype.drawLetterSpacing = function (context, text, lineMetrics, textAlign, x, y, letterSpacing, fillOpacity, strokeOpacity, opacity, isStroke) {
	        if (isStroke === void 0) { isStroke = false; }
	        // letterSpacing of 0 means normal, render all texts directly
	        if (letterSpacing === 0) {
	            if (isStroke) {
	                this.strokeText(context, text, x, y, strokeOpacity);
	            }
	            else {
	                this.fillText(context, text, x, y, fillOpacity, opacity);
	            }
	            return;
	        }
	        // draw text using left align
	        var currentTextAlign = context.textAlign;
	        context.textAlign = 'left';
	        var currentPosition = x;
	        if (textAlign === 'center' || textAlign === 'middle') {
	            currentPosition = x - lineMetrics.width / 2;
	        }
	        else if (textAlign === 'right' || textAlign === 'end') {
	            currentPosition = x - lineMetrics.width;
	        }
	        var stringArray = Array.from(text);
	        var previousWidth = context.measureText(text).width;
	        var currentWidth = 0;
	        for (var i = 0; i < stringArray.length; ++i) {
	            var currentChar = stringArray[i];
	            if (isStroke) {
	                this.strokeText(context, currentChar, currentPosition, y, strokeOpacity);
	            }
	            else {
	                this.fillText(context, currentChar, currentPosition, y, fillOpacity, opacity);
	            }
	            currentWidth = context.measureText(text.substring(i + 1)).width;
	            currentPosition += previousWidth - currentWidth + letterSpacing;
	            previousWidth = currentWidth;
	        }
	        context.textAlign = currentTextAlign;
	    };
	    TextRenderer.prototype.fillText = function (context, text, x, y, fillOpacity, opacity) {
	        var currentGlobalAlpha;
	        var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;
	        if (applyOpacity) {
	            currentGlobalAlpha = context.globalAlpha;
	            context.globalAlpha = fillOpacity * opacity;
	        }
	        context.fillText(text, x, y);
	        if (applyOpacity) {
	            context.globalAlpha = currentGlobalAlpha;
	        }
	    };
	    TextRenderer.prototype.strokeText = function (context, text, x, y, strokeOpacity) {
	        var currentGlobalAlpha;
	        var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;
	        if (applyOpacity) {
	            currentGlobalAlpha = context.globalAlpha;
	            context.globalAlpha = strokeOpacity;
	        }
	        context.strokeText(text, x, y);
	        if (applyOpacity) {
	            context.globalAlpha = currentGlobalAlpha;
	        }
	    };
	    return TextRenderer;
	}());

	var RectRenderer = /** @class */ (function (_super) {
	    __extends(RectRenderer, _super);
	    function RectRenderer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return RectRenderer;
	}(DefaultRenderer));

	var CircleRenderer = /** @class */ (function (_super) {
	    __extends(CircleRenderer, _super);
	    function CircleRenderer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return CircleRenderer;
	}(DefaultRenderer));

	var EllipseRenderer = /** @class */ (function (_super) {
	    __extends(EllipseRenderer, _super);
	    function EllipseRenderer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return EllipseRenderer;
	}(DefaultRenderer));

	var LineRenderer = /** @class */ (function (_super) {
	    __extends(LineRenderer, _super);
	    function LineRenderer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return LineRenderer;
	}(DefaultRenderer));

	var PolylineRenderer = /** @class */ (function (_super) {
	    __extends(PolylineRenderer, _super);
	    function PolylineRenderer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return PolylineRenderer;
	}(DefaultRenderer));

	var PolygonRenderer = /** @class */ (function (_super) {
	    __extends(PolygonRenderer, _super);
	    function PolygonRenderer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return PolygonRenderer;
	}(DefaultRenderer));

	var PathRenderer = /** @class */ (function (_super) {
	    __extends(PathRenderer, _super);
	    function PathRenderer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return PathRenderer;
	}(DefaultRenderer));

	var Plugin$2 = /** @class */ (function (_super) {
	    __extends(Plugin, _super);
	    function Plugin(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.options = options;
	        _this.name = 'canvas-renderer';
	        return _this;
	    }
	    Plugin.prototype.init = function () {
	        var _a;
	        var canvasRendererPluginOptions = __assign({ dirtyObjectNumThreshold: 500, dirtyObjectRatioThreshold: 0.8 }, this.options);
	        // @ts-ignore
	        var imagePool = this.context.imagePool;
	        var defaultRenderer = new DefaultRenderer(imagePool);
	        var defaultStyleRendererFactory = (_a = {},
	            _a[Shape.CIRCLE] = defaultRenderer,
	            _a[Shape.ELLIPSE] = defaultRenderer,
	            _a[Shape.RECT] = defaultRenderer,
	            _a[Shape.IMAGE] = new ImageRenderer(imagePool),
	            _a[Shape.TEXT] = new TextRenderer(),
	            _a[Shape.LINE] = defaultRenderer,
	            _a[Shape.POLYLINE] = defaultRenderer,
	            _a[Shape.POLYGON] = defaultRenderer,
	            _a[Shape.PATH] = defaultRenderer,
	            _a[Shape.GROUP] = undefined,
	            _a[Shape.HTML] = undefined,
	            _a[Shape.MESH] = undefined,
	            _a);
	        this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
	        this.context.styleRendererFactory = defaultStyleRendererFactory;
	        this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
	    };
	    Plugin.prototype.destroy = function () {
	        this.removeAllRenderingPlugins();
	        delete this.context.defaultStyleRendererFactory;
	        delete this.context.styleRendererFactory;
	    };
	    return Plugin;
	}(AbstractRendererPlugin));

	var DragndropPlugin = /** @class */ (function () {
	    function DragndropPlugin(dragndropPluginOptions) {
	        this.dragndropPluginOptions = dragndropPluginOptions;
	    }
	    DragndropPlugin.prototype.apply = function (context) {
	        var _this = this;
	        var renderingService = context.renderingService, renderingContext = context.renderingContext;
	        var document = renderingContext.root.ownerDocument;
	        // TODO: should we add an option like `draggable` to Canvas
	        var canvas = document.defaultView;
	        var handlePointerdown = function (event) {
	            var target = event.target;
	            var isDocument = target === document;
	            var draggableEventTarget = isDocument && _this.dragndropPluginOptions.isDocumentDraggable
	                ? document
	                : target.closest && target.closest('[draggable=true]');
	            // `draggable` may be set on ancestor nodes:
	            // @see https://github.com/antvis/G/issues/1088
	            if (draggableEventTarget) {
	                // delay triggering dragstart event
	                var dragstartTriggered_1 = false;
	                var dragstartTimeStamp_1 = event.timeStamp;
	                var dragstartClientCoordinates_1 = [
	                    event.clientX,
	                    event.clientY,
	                ];
	                var currentDroppable_1 = null;
	                var lastDragClientCoordinates_1 = [event.clientX, event.clientY];
	                // @ts-ignore
	                // eslint-disable-next-line no-inner-declarations
	                var handlePointermove_1 = function (event) { return __awaiter(_this, void 0, void 0, function () {
	                    var timeElapsed, distanceMoved, point, elementsBelow, elementBelow, droppableBelow;
	                    return __generator(this, function (_a) {
	                        switch (_a.label) {
	                            case 0:
	                                if (!dragstartTriggered_1) {
	                                    timeElapsed = event.timeStamp - dragstartTimeStamp_1;
	                                    distanceMoved = distanceSquareRoot([event.clientX, event.clientY], dragstartClientCoordinates_1);
	                                    // check thresholds
	                                    if (timeElapsed <=
	                                        this.dragndropPluginOptions.dragstartTimeThreshold ||
	                                        distanceMoved <=
	                                            this.dragndropPluginOptions.dragstartDistanceThreshold) {
	                                        return [2 /*return*/];
	                                    }
	                                    // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragstart_event
	                                    event.type = 'dragstart';
	                                    draggableEventTarget.dispatchEvent(event);
	                                    dragstartTriggered_1 = true;
	                                }
	                                // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/drag_event
	                                event.type = 'drag';
	                                // @ts-ignore
	                                event.dx = event.clientX - lastDragClientCoordinates_1[0];
	                                // @ts-ignore
	                                event.dy = event.clientY - lastDragClientCoordinates_1[1];
	                                draggableEventTarget.dispatchEvent(event);
	                                lastDragClientCoordinates_1 = [event.clientX, event.clientY];
	                                if (!!isDocument) return [3 /*break*/, 2];
	                                point = this.dragndropPluginOptions.overlap === 'pointer'
	                                    ? [event.canvasX, event.canvasY]
	                                    : target.getBounds().center;
	                                return [4 /*yield*/, document.elementsFromPoint(point[0], point[1])];
	                            case 1:
	                                elementsBelow = _a.sent();
	                                elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
	                                droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest('[droppable=true]')) ||
	                                    (this.dragndropPluginOptions.isDocumentDroppable
	                                        ? document
	                                        : null);
	                                if (currentDroppable_1 !== droppableBelow) {
	                                    if (currentDroppable_1) {
	                                        // null when we were not over a droppable before this event
	                                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragleave_event
	                                        event.type = 'dragleave';
	                                        event.target = currentDroppable_1;
	                                        currentDroppable_1.dispatchEvent(event);
	                                    }
	                                    if (droppableBelow) {
	                                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragleave_event
	                                        event.type = 'dragenter';
	                                        event.target = droppableBelow;
	                                        droppableBelow.dispatchEvent(event);
	                                    }
	                                    currentDroppable_1 = droppableBelow;
	                                    if (currentDroppable_1) {
	                                        // null if we're not coming over a droppable now
	                                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragover_event
	                                        event.type = 'dragover';
	                                        event.target = currentDroppable_1;
	                                        currentDroppable_1.dispatchEvent(event);
	                                    }
	                                }
	                                _a.label = 2;
	                            case 2: return [2 /*return*/];
	                        }
	                    });
	                }); };
	                canvas.addEventListener('pointermove', handlePointermove_1);
	                var stopDragging = function (originalPointerUpEvent) {
	                    if (dragstartTriggered_1) {
	                        // prevent click event being triggerd
	                        // @see https://github.com/antvis/G/issues/1091
	                        originalPointerUpEvent.detail = {
	                            preventClick: true,
	                        };
	                        // clone event first
	                        var event_1 = originalPointerUpEvent.clone();
	                        // drop should fire before dragend
	                        // @see https://javascript.tutorialink.com/is-there-a-defined-ordering-between-dragend-and-drop-events/
	                        if (currentDroppable_1) {
	                            // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/drop_event
	                            event_1.type = 'drop';
	                            event_1.target = currentDroppable_1;
	                            currentDroppable_1.dispatchEvent(event_1);
	                        }
	                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragend_event
	                        event_1.type = 'dragend';
	                        draggableEventTarget.dispatchEvent(event_1);
	                        dragstartTriggered_1 = false;
	                    }
	                    canvas.removeEventListener('pointermove', handlePointermove_1);
	                };
	                target.addEventListener('pointerup', stopDragging, { once: true });
	                target.addEventListener('pointerupoutside', stopDragging, {
	                    once: true,
	                });
	            }
	        };
	        renderingService.hooks.init.tap(DragndropPlugin.tag, function () {
	            canvas.addEventListener('pointerdown', handlePointerdown);
	        });
	        renderingService.hooks.destroy.tap(DragndropPlugin.tag, function () {
	            canvas.removeEventListener('pointerdown', handlePointerdown);
	        });
	    };
	    DragndropPlugin.tag = 'Dragndrop';
	    return DragndropPlugin;
	}());

	var Plugin$3 = /** @class */ (function (_super) {
	    __extends(Plugin, _super);
	    function Plugin(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.options = options;
	        _this.name = 'dragndrop';
	        return _this;
	    }
	    Plugin.prototype.init = function () {
	        this.addRenderingPlugin(new DragndropPlugin(__assign({ overlap: 'pointer', isDocumentDraggable: false, isDocumentDroppable: false, dragstartDistanceThreshold: 0, dragstartTimeThreshold: 0 }, this.options)));
	    };
	    Plugin.prototype.destroy = function () {
	        this.removeAllRenderingPlugins();
	    };
	    Plugin.prototype.setOptions = function (options) {
	        Object.assign(this.plugins[0].dragndropPluginOptions, options);
	    };
	    return Plugin;
	}(AbstractRendererPlugin));

	var ImagePool = /** @class */ (function () {
	    function ImagePool(canvasConfig) {
	        this.canvasConfig = canvasConfig;
	        this.imageCache = {};
	        this.gradientCache = {};
	        this.patternCache = {};
	    }
	    ImagePool.prototype.getImageSync = function (src, callback) {
	        if (!this.imageCache[src]) {
	            this.getOrCreateImage(src).then(function () {
	                if (callback) {
	                    callback();
	                }
	            });
	        }
	        else {
	            if (callback) {
	                callback();
	            }
	        }
	        return this.imageCache[src];
	    };
	    ImagePool.prototype.getOrCreateImage = function (src) {
	        var _this = this;
	        if (this.imageCache[src]) {
	            return Promise.resolve(this.imageCache[src]);
	        }
	        // @see https://github.com/antvis/g/issues/938
	        var createImage = this.canvasConfig.createImage;
	        return new Promise(function (resolve, reject) {
	            var image;
	            if (createImage) {
	                image = createImage(src);
	            }
	            else if (isBrowser) {
	                image = new window.Image();
	            }
	            if (image) {
	                image.onload = function () {
	                    _this.imageCache[src] = image;
	                    resolve(image);
	                };
	                image.onerror = function (ev) {
	                    reject(ev);
	                };
	                image.crossOrigin = 'Anonymous';
	                image.src = src;
	            }
	        });
	    };
	    ImagePool.prototype.getOrCreatePatternSync = function (pattern, context, $offscreenCanvas, dpr, callback) {
	        var patternKey = this.generatePatternKey(pattern);
	        if (patternKey && this.patternCache[patternKey]) {
	            return this.patternCache[patternKey];
	        }
	        var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;
	        var src;
	        var needScaleWithDPR = false;
	        // Image URL
	        if (isString(image)) {
	            src = this.getImageSync(image, callback);
	        }
	        else if ($offscreenCanvas) {
	            src = $offscreenCanvas;
	            needScaleWithDPR = true;
	        }
	        else {
	            src = image;
	        }
	        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createPattern
	        var canvasPattern = src && context.createPattern(src, repetition);
	        if (canvasPattern) {
	            var mat = void 0;
	            // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasPattern/setTransform
	            if (transform) {
	                mat = parsedTransformToMat4(parseTransform(transform), new DisplayObject({}));
	            }
	            else {
	                mat = identity(create$1());
	            }
	            if (needScaleWithDPR) {
	                scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
	            }
	            canvasPattern.setTransform({
	                a: mat[0],
	                b: mat[1],
	                c: mat[4],
	                d: mat[5],
	                e: mat[12],
	                f: mat[13],
	            });
	        }
	        if (patternKey && canvasPattern) {
	            this.patternCache[patternKey] = canvasPattern;
	        }
	        return canvasPattern;
	    };
	    ImagePool.prototype.getOrCreateGradient = function (params, context) {
	        var key = this.generateGradientKey(params);
	        var type = params.type, steps = params.steps, width = params.width, height = params.height, angle = params.angle, cx = params.cx, cy = params.cy, size = params.size;
	        if (this.gradientCache[key]) {
	            return this.gradientCache[key];
	        }
	        var gradient = null;
	        if (type === GradientType.LinearGradient) {
	            var _a = computeLinearGradient(width, height, angle), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
	            // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createLinearGradient
	            gradient = context.createLinearGradient(x1, y1, x2, y2);
	        }
	        else if (type === GradientType.RadialGradient) {
	            var _b = computeRadialGradient(width, height, cx, cy, size), x = _b.x, y = _b.y, r = _b.r;
	            // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createRadialGradient
	            gradient = context.createRadialGradient(x, y, 0, x, y, r);
	        }
	        if (gradient) {
	            steps.forEach(function (_a) {
	                var offset = _a.offset, color = _a.color;
	                if (offset.unit === UnitType.kPercentage) {
	                    gradient === null || gradient === void 0 ? void 0 : gradient.addColorStop(offset.value / 100, color.toString());
	                }
	            });
	            this.gradientCache[key] = gradient;
	        }
	        return this.gradientCache[key];
	    };
	    ImagePool.prototype.generateGradientKey = function (params) {
	        var type = params.type, width = params.width, height = params.height, steps = params.steps, angle = params.angle, cx = params.cx, cy = params.cy, size = params.size;
	        return "gradient-".concat(type, "-").concat((angle === null || angle === void 0 ? void 0 : angle.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size === null || size === void 0 ? void 0 : size.toString()) || 0, "-").concat(width, "-").concat(height, "-").concat(steps
	            .map(function (_a) {
	            var offset = _a.offset, color = _a.color;
	            return "".concat(offset).concat(color);
	        })
	            .join('-'));
	    };
	    ImagePool.prototype.generatePatternKey = function (pattern) {
	        var image = pattern.image, repetition = pattern.repetition;
	        // only generate cache for Image
	        if (isString(image)) {
	            return "pattern-".concat(image, "-").concat(repetition);
	        }
	        else if (image.nodeName === 'rect') {
	            return "pattern-".concat(image.entity, "-").concat(repetition);
	        }
	    };
	    return ImagePool;
	}());

	var LoadImagePlugin = /** @class */ (function () {
	    function LoadImagePlugin() {
	    }
	    LoadImagePlugin.prototype.apply = function (context) {
	        // @ts-ignore
	        var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
	        var canvas = renderingContext.root.ownerDocument.defaultView;
	        var handleMounted = function (e) {
	            var object = e.target;
	            var nodeName = object.nodeName, attributes = object.attributes;
	            if (nodeName === Shape.IMAGE) {
	                var img = attributes.img;
	                if (isString(img)) {
	                    imagePool.getImageSync(img, function () {
	                        // set dirty rectangle flag
	                        object.renderable.dirty = true;
	                        renderingService.dirtify();
	                    });
	                }
	            }
	        };
	        var handleAttributeChanged = function (e) {
	            var object = e.target;
	            var attrName = e.attrName, newValue = e.newValue;
	            if (object.nodeName === Shape.IMAGE) {
	                if (attrName === 'img') {
	                    if (isString(newValue)) {
	                        imagePool.getOrCreateImage(newValue).then(function () {
	                            // set dirty rectangle flag
	                            object.renderable.dirty = true;
	                            renderingService.dirtify();
	                        });
	                    }
	                }
	            }
	        };
	        renderingService.hooks.init.tap(LoadImagePlugin.tag, function () {
	            canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
	            canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
	        });
	        renderingService.hooks.destroy.tap(LoadImagePlugin.tag, function () {
	            canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
	            canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
	        });
	    };
	    LoadImagePlugin.tag = 'LoadImage';
	    return LoadImagePlugin;
	}());

	var Plugin$4 = /** @class */ (function (_super) {
	    __extends(Plugin, _super);
	    function Plugin() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.name = 'image-loader';
	        return _this;
	    }
	    Plugin.prototype.init = function () {
	        // @ts-ignore
	        this.context.imagePool = new ImagePool(this.context.config);
	        this.addRenderingPlugin(new LoadImagePlugin());
	    };
	    Plugin.prototype.destroy = function () {
	        this.removeAllRenderingPlugins();
	    };
	    return Plugin;
	}(AbstractRendererPlugin));

	/**
	 * listen to mouse/touch/pointer events on DOM wrapper, trigger pointer events
	 */
	var MobileInteractionPlugin = /** @class */ (function () {
	    function MobileInteractionPlugin() {
	    }
	    MobileInteractionPlugin.prototype.apply = function (context) {
	        var renderingService = context.renderingService, contextService = context.contextService, config = context.config;
	        // 获取小程序上下文
	        var canvasEl = contextService.getDomElement();
	        var onPointerDown = function (ev) {
	            renderingService.hooks.pointerDown.call(ev);
	        };
	        var onPointerUp = function (ev) {
	            renderingService.hooks.pointerUp.call(ev);
	        };
	        var onPointerMove = function (ev) {
	            // 触发 G 定义的标准 pointerMove 事件
	            renderingService.hooks.pointerMove.call(ev);
	        };
	        var onPointerOver = function (ev) {
	            renderingService.hooks.pointerOver.call(ev);
	        };
	        var onPointerOut = function (ev) {
	            renderingService.hooks.pointerOut.call(ev);
	        };
	        var onClick = function (ev) {
	            renderingService.hooks.click.call(ev);
	        };
	        var onPointerCancel = function (ev) {
	            renderingService.hooks.pointerCancel.call(ev);
	        };
	        renderingService.hooks.init.tap(MobileInteractionPlugin.tag, function () {
	            // 基于小程序上下文的事件监听方式，绑定事件监听，可以参考下面基于 DOM 的方式
	            canvasEl.addEventListener('touchstart', onPointerDown, true);
	            canvasEl.addEventListener('touchend', onPointerUp, true);
	            canvasEl.addEventListener('touchmove', onPointerMove, true);
	            canvasEl.addEventListener('touchcancel', onPointerCancel, true);
	            // FIXME: 这里不应该只在 canvasEl 上监听 mousemove 和 mouseup，而应该在更高层级的节点上例如 document 监听。
	            // 否则无法判断是否移出了 canvasEl
	            // canvasEl.addEventListener('mousemove', onPointerMove, true);
	            // canvasEl.addEventListener('mousedown', onPointerDown, true);
	            canvasEl.addEventListener('mouseout', onPointerOut, true);
	            canvasEl.addEventListener('mouseover', onPointerOver, true);
	            // canvasEl.addEventListener('mouseup', onPointerUp, true);
	            if (config.useNativeClickEvent) {
	                canvasEl.addEventListener('click', onClick, true);
	            }
	        });
	        renderingService.hooks.destroy.tap(MobileInteractionPlugin.tag, function () {
	            // 基于小程序上下文的事件监听方式，移除事件监听
	            canvasEl.removeEventListener('touchstart', onPointerDown, true);
	            canvasEl.removeEventListener('touchend', onPointerUp, true);
	            canvasEl.removeEventListener('touchmove', onPointerMove, true);
	            canvasEl.removeEventListener('touchcancel', onPointerCancel, true);
	            // canvasEl.removeEventListener('mousemove', onPointerMove, true);
	            // canvasEl.removeEventListener('mousedown', onPointerDown, true);
	            canvasEl.removeEventListener('mouseout', onPointerOut, true);
	            canvasEl.removeEventListener('mouseover', onPointerOver, true);
	            // canvasEl.removeEventListener('mouseup', onPointerUp, true);
	            if (config.useNativeClickEvent) {
	                canvasEl.removeEventListener('click', onClick, true);
	            }
	        });
	    };
	    MobileInteractionPlugin.tag = 'MobileInteraction';
	    return MobileInteractionPlugin;
	}());

	var Plugin$5 = /** @class */ (function (_super) {
	    __extends(Plugin, _super);
	    function Plugin() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.name = 'mobile-interaction';
	        return _this;
	    }
	    Plugin.prototype.init = function () {
	        this.addRenderingPlugin(new MobileInteractionPlugin());
	    };
	    Plugin.prototype.destroy = function () {
	        this.removeAllRenderingPlugins();
	    };
	    return Plugin;
	}(AbstractRendererPlugin));

	function isCanvasElement(el) {
	    if (!el || typeof el !== 'object')
	        return false;
	    if (el.nodeType === 1 && el.nodeName) {
	        // HTMLCanvasElement
	        return true;
	    }
	    // CanvasElement
	    return !!el.isCanvasElement;
	}

	var Canvas2DContextService = /** @class */ (function () {
	    function Canvas2DContextService(context) {
	        this.canvasConfig = context.config;
	    }
	    Canvas2DContextService.prototype.init = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var _a, canvas, devicePixelRatio, dpr;
	            return __generator(this, function (_b) {
	                _a = this.canvasConfig, canvas = _a.canvas, devicePixelRatio = _a.devicePixelRatio;
	                this.$canvas = canvas;
	                // 实际获取到小程序环境的上下文
	                this.context = this.$canvas.getContext('2d');
	                dpr = devicePixelRatio || 1;
	                dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
	                this.dpr = dpr;
	                this.resize(this.canvasConfig.width, this.canvasConfig.height);
	                return [2 /*return*/];
	            });
	        });
	    };
	    Canvas2DContextService.prototype.getContext = function () {
	        return this.context;
	    };
	    Canvas2DContextService.prototype.getDomElement = function () {
	        return this.$canvas;
	    };
	    Canvas2DContextService.prototype.getDPR = function () {
	        return this.dpr;
	    };
	    Canvas2DContextService.prototype.getBoundingClientRect = function () {
	        if (this.$canvas.getBoundingClientRect) {
	            return this.$canvas.getBoundingClientRect();
	        }
	    };
	    Canvas2DContextService.prototype.destroy = function () {
	        // TODO: 小程序环境销毁 context
	        this.context = null;
	        this.$canvas = null;
	    };
	    Canvas2DContextService.prototype.resize = function (width, height) {
	        var devicePixelRatio = this.canvasConfig.devicePixelRatio;
	        var pixelRatio = devicePixelRatio;
	        var canvasDOM = this.$canvas; // HTMLCanvasElement or canvasElement
	        // 浏览器环境设置style样式
	        if (canvasDOM.style) {
	            canvasDOM.style.width = width + 'px';
	            canvasDOM.style.height = height + 'px';
	        }
	        if (isCanvasElement(canvasDOM)) {
	            canvasDOM.width = width * pixelRatio;
	            canvasDOM.height = height * pixelRatio;
	            if (pixelRatio !== 1) {
	                this.context.scale(pixelRatio, pixelRatio);
	            }
	        }
	    };
	    Canvas2DContextService.prototype.applyCursorStyle = function (cursor) {
	        // 小程序环境无需设置鼠标样式
	    };
	    Canvas2DContextService.prototype.toDataURL = function (options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var type, encoderOptions;
	            return __generator(this, function (_a) {
	                type = options.type, encoderOptions = options.encoderOptions;
	                return [2 /*return*/, this.context.canvas.toDataURL(type, encoderOptions)];
	            });
	        });
	    };
	    return Canvas2DContextService;
	}());

	var ContextRegisterPlugin = /** @class */ (function (_super) {
	    __extends(ContextRegisterPlugin, _super);
	    function ContextRegisterPlugin() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.name = 'mobile-canvas-context-register';
	        return _this;
	    }
	    ContextRegisterPlugin.prototype.init = function () {
	        this.context.ContextService = Canvas2DContextService;
	    };
	    ContextRegisterPlugin.prototype.destroy = function () {
	        delete this.context.ContextService;
	    };
	    return ContextRegisterPlugin;
	}(AbstractRendererPlugin));

	var Renderer = /** @class */ (function (_super) {
	    __extends(Renderer, _super);
	    function Renderer(config) {
	        var _this = _super.call(this, config) || this;
	        // register Canvas2DContext
	        _this.registerPlugin(new ContextRegisterPlugin());
	        _this.registerPlugin(new Plugin$4());
	        _this.registerPlugin(new Plugin());
	        // enable rendering with Canvas2D API
	        _this.registerPlugin(new Plugin$2());
	        _this.registerPlugin(new Plugin$5());
	        // enable picking with Canvas2D API
	        _this.registerPlugin(new Plugin$1());
	        _this.registerPlugin(new Plugin$3({
	            isDocumentDraggable: isNil(config === null || config === void 0 ? void 0 : config.isDocumentDraggable) ? true : config.isDocumentDraggable,
	            isDocumentDroppable: isNil(config === null || config === void 0 ? void 0 : config.isDocumentDroppable) ? true : config.isDocumentDroppable,
	            dragstartDistanceThreshold: isNil(config === null || config === void 0 ? void 0 : config.dragstartDistanceThreshold)
	                ? 10
	                : config.dragstartDistanceThreshold,
	            dragstartTimeThreshold: isNil(config === null || config === void 0 ? void 0 : config.dragstartTimeThreshold)
	                ? 50
	                : config.dragstartTimeThreshold,
	        }));
	        return _this;
	    }
	    return Renderer;
	}(AbstractRenderer));

	var _excluded$1 = ["key", "ref"];
	// 实现jsx-classic 入口
	function jsx(type, config) {
	  var _ref = config || {},
	    key = _ref.key,
	    ref = _ref.ref,
	    props = _objectWithoutProperties(_ref, _excluded$1);
	  // 保持和automatic模式一致
	  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    children[_key - 2] = arguments[_key];
	  }
	  if (children.length) {
	    props.children = children.length === 1 ? children[0] : children;
	  }
	  return {
	    key: key,
	    ref: ref,
	    type: type,
	    props: props
	  };
	}

	var fragment = (function (props) {
	  return props.children;
	});

	var asyncToGenerator = createCommonjsModule(function (module) {
	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }
	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}
	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	      args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);
	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }
	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }
	      _next(undefined);
	    });
	  };
	}
	module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _asyncToGenerator = /*@__PURE__*/getDefaultExportFromCjs(asyncToGenerator);

	var regeneratorRuntime$1 = createCommonjsModule(function (module) {
	var _typeof = _typeof_1["default"];
	function _regeneratorRuntime() {
	  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
	    return exports;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
	  var exports = {},
	    Op = Object.prototype,
	    hasOwn = Op.hasOwnProperty,
	    defineProperty = Object.defineProperty || function (obj, key, desc) {
	      obj[key] = desc.value;
	    },
	    $Symbol = "function" == typeof Symbol ? Symbol : {},
	    iteratorSymbol = $Symbol.iterator || "@@iterator",
	    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
	    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	  function define(obj, key, value) {
	    return Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }), obj[key];
	  }
	  try {
	    define({}, "");
	  } catch (err) {
	    define = function define(obj, key, value) {
	      return obj[key] = value;
	    };
	  }
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
	      generator = Object.create(protoGenerator.prototype),
	      context = new Context(tryLocsList || []);
	    return defineProperty(generator, "_invoke", {
	      value: makeInvokeMethod(innerFn, self, context)
	    }), generator;
	  }
	  function tryCatch(fn, obj, arg) {
	    try {
	      return {
	        type: "normal",
	        arg: fn.call(obj, arg)
	      };
	    } catch (err) {
	      return {
	        type: "throw",
	        arg: err
	      };
	    }
	  }
	  exports.wrap = wrap;
	  var ContinueSentinel = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });
	  var getProto = Object.getPrototypeOf,
	    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      define(prototype, method, function (arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }
	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if ("throw" !== record.type) {
	        var result = record.arg,
	          value = result.value;
	        return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
	          invoke("next", value, resolve, reject);
	        }, function (err) {
	          invoke("throw", err, resolve, reject);
	        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
	          result.value = unwrapped, resolve(result);
	        }, function (error) {
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	      reject(record.arg);
	    }
	    var previousPromise;
	    defineProperty(this, "_invoke", {
	      value: function value(method, arg) {
	        function callInvokeWithMethodAndArg() {
	          return new PromiseImpl(function (resolve, reject) {
	            invoke(method, arg, resolve, reject);
	          });
	        }
	        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }
	    });
	  }
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = "suspendedStart";
	    return function (method, arg) {
	      if ("executing" === state) throw new Error("Generator is already running");
	      if ("completed" === state) {
	        if ("throw" === method) throw arg;
	        return doneResult();
	      }
	      for (context.method = method, context.arg = arg;;) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
	          if ("suspendedStart" === state) throw state = "completed", context.arg;
	          context.dispatchException(context.arg);
	        } else "return" === context.method && context.abrupt("return", context.arg);
	        state = "executing";
	        var record = tryCatch(innerFn, self, context);
	        if ("normal" === record.type) {
	          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
	          return {
	            value: record.arg,
	            done: context.done
	          };
	        }
	        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
	      }
	    };
	  }
	  function maybeInvokeDelegate(delegate, context) {
	    var methodName = context.method,
	      method = delegate.iterator[methodName];
	    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
	    var record = tryCatch(method, delegate.iterator, context.arg);
	    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
	    var info = record.arg;
	    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
	  }
	  function pushTryEntry(locs) {
	    var entry = {
	      tryLoc: locs[0]
	    };
	    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
	  }
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal", delete record.arg, entry.completion = record;
	  }
	  function Context(tryLocsList) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
	  }
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) return iteratorMethod.call(iterable);
	      if ("function" == typeof iterable.next) return iterable;
	      if (!isNaN(iterable.length)) {
	        var i = -1,
	          next = function next() {
	            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
	            return next.value = undefined, next.done = !0, next;
	          };
	        return next.next = next;
	      }
	    }
	    return {
	      next: doneResult
	    };
	  }
	  function doneResult() {
	    return {
	      value: undefined,
	      done: !0
	    };
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: !0
	  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: !0
	  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
	    var ctor = "function" == typeof genFun && genFun.constructor;
	    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
	  }, exports.mark = function (genFun) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
	  }, exports.awrap = function (arg) {
	    return {
	      __await: arg
	    };
	  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    void 0 === PromiseImpl && (PromiseImpl = Promise);
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
	    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
	    return this;
	  }), define(Gp, "toString", function () {
	    return "[object Generator]";
	  }), exports.keys = function (val) {
	    var object = Object(val),
	      keys = [];
	    for (var key in object) keys.push(key);
	    return keys.reverse(), function next() {
	      for (; keys.length;) {
	        var key = keys.pop();
	        if (key in object) return next.value = key, next.done = !1, next;
	      }
	      return next.done = !0, next;
	    };
	  }, exports.values = values, Context.prototype = {
	    constructor: Context,
	    reset: function reset(skipTempReset) {
	      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
	    },
	    stop: function stop() {
	      this.done = !0;
	      var rootRecord = this.tryEntries[0].completion;
	      if ("throw" === rootRecord.type) throw rootRecord.arg;
	      return this.rval;
	    },
	    dispatchException: function dispatchException(exception) {
	      if (this.done) throw exception;
	      var context = this;
	      function handle(loc, caught) {
	        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
	      }
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i],
	          record = entry.completion;
	        if ("root" === entry.tryLoc) return handle("end");
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc"),
	            hasFinally = hasOwn.call(entry, "finallyLoc");
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
	            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
	          } else {
	            if (!hasFinally) throw new Error("try statement without catch or finally");
	            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
	          }
	        }
	      }
	    },
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
	      var record = finallyEntry ? finallyEntry.completion : {};
	      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
	    },
	    complete: function complete(record, afterLoc) {
	      if ("throw" === record.type) throw record.arg;
	      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
	    },
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
	      }
	    },
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if ("throw" === record.type) {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      return this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
	    }
	  }, exports;
	}
	module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	// TODO(Babel 8): Remove this file.

	var runtime$1 = regeneratorRuntime$1();
	var regenerator = runtime$1;

	// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
	try {
	  regeneratorRuntime = runtime$1;
	} catch (accidentalStrictMode) {
	  if (typeof globalThis === "object") {
	    globalThis.regeneratorRuntime = runtime$1;
	  } else {
	    Function("r", "regeneratorRuntime = r")(runtime$1);
	  }
	}

	var CanvasElement = /** @class */ (function () {
	    function CanvasElement(ctx) {
	        this.isCanvasElement = true;
	        this.emitter = new eventemitter3();
	        this.context = ctx;
	        // 有可能是 node canvas 创建的 context 对象
	        var canvas = ctx.canvas || {};
	        this.width = canvas.width || 0;
	        this.height = canvas.height || 0;
	    }
	    CanvasElement.prototype.getContext = function (contextId, contextAttributes) {
	        return this.context;
	    };
	    CanvasElement.prototype.getBoundingClientRect = function () {
	        var width = this.width;
	        var height = this.height;
	        // 默认都处理成可视窗口的顶部位置
	        return {
	            top: 0,
	            right: width,
	            bottom: height,
	            left: 0,
	            width: width,
	            height: height,
	            x: 0,
	            y: 0,
	        };
	    };
	    CanvasElement.prototype.addEventListener = function (type, listener, options) {
	        // TODO: implement options
	        this.emitter.on(type, listener);
	    };
	    CanvasElement.prototype.removeEventListener = function (type, listener, options) {
	        this.emitter.off(type, listener);
	    };
	    /**
	     * @see https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget-dispatchEvent
	     */
	    CanvasElement.prototype.dispatchEvent = function (e) {
	        this.emitter.emit(e.type, e);
	        return true;
	    };
	    return CanvasElement;
	}());
	function supportEventListener(canvas) {
	    if (!canvas) {
	        return false;
	    }
	    // 非 HTMLCanvasElement
	    if (canvas.nodeType !== 1 ||
	        !canvas.nodeName ||
	        canvas.nodeName.toLowerCase() !== 'canvas') {
	        return false;
	    }
	    // 微信小程序canvas.getContext('2d')时也是CanvasRenderingContext2D
	    // 也会有ctx.canvas, 而且nodeType也是1，所以还要在看下是否支持addEventListener
	    var support = false;
	    try {
	        canvas.addEventListener('eventTest', function () {
	            support = true;
	        });
	        canvas.dispatchEvent(new Event('eventTest'));
	    }
	    catch (error) {
	        support = false;
	    }
	    return support;
	}
	function createMobileCanvasElement(ctx) {
	    if (!ctx) {
	        return null;
	    }
	    if (supportEventListener(ctx.canvas)) {
	        return ctx.canvas;
	    }
	    return new CanvasElement(ctx);
	}

	function createUpdater(canvas) {
	  var setStateQueue = [];
	  function process() {
	    var item;
	    var renderComponents = [];
	    var renderCallbackQueue = [];
	    while (item = setStateQueue.shift()) {
	      var _item = item,
	        state = _item.state,
	        component = _item.component,
	        callback = _item.callback;
	      // 组件已销毁，不再触发 setState
	      if (component.destroyed) {
	        continue;
	      }
	      // 如果没有prevState，则将当前的state作为初始的prevState
	      if (!component.prevState) {
	        component.prevState = Object.assign({}, component.state);
	      }
	      // 如果stateChange是一个方法，也就是setState的第二种形式
	      if (typeof state === 'function') {
	        Object.assign(component.state, state(component.prevState, component.props));
	      } else {
	        // 如果stateChange是一个对象，则直接合并到setState中
	        Object.assign(component.state, state);
	      }
	      component.prevState = component.state;
	      if (typeof callback === 'function') {
	        renderCallbackQueue.push({
	          callback: callback,
	          component: component
	        });
	      }
	      if (renderComponents.indexOf(component) < 0) {
	        renderComponents.push(component);
	      }
	    }
	    canvas.updateComponents(renderComponents);
	    // callback queue
	    commitRenderQueue(renderCallbackQueue);
	  }
	  function enqueueSetState(component, state, callback) {
	    if (setStateQueue.length === 0) {
	      setTimeout(process, 0);
	    }
	    setStateQueue.push({
	      component: component,
	      state: state,
	      callback: callback
	    });
	  }
	  function commitRenderQueue(callbackQueue) {
	    for (var i = 0; i < callbackQueue.length; i++) {
	      var _callbackQueue$i = callbackQueue[i],
	        callback = _callbackQueue$i.callback,
	        component = _callbackQueue$i.component;
	      callback.call(component);
	    }
	  }
	  var updater = {
	    // isMounted: function(publicInstance) {
	    //   return false;
	    // },
	    enqueueForceUpdate: enqueueSetState,
	    // enqueueReplaceState: function(publicInstance, completeState) {
	    // },
	    enqueueSetState: enqueueSetState
	  };
	  return updater;
	}

	var THEME = {
	  fontSize: '24px',
	  fontFamily: '"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif',
	  pixelRatio: 1,
	  padding: [0, 0, 0, 0]
	};

	var elementStyle = {
	  fillStyle: 'String',
	  font: 'String',
	  globalAlpha: 'Number',
	  lineCap: 'String',
	  lineWidth: ['Number', 'String'],
	  lineJoin: 'String',
	  miterLimit: 'Number',
	  shadowBlur: 'Number',
	  shadowColor: 'String',
	  shadowOffsetX: 'Number',
	  shadowOffsetY: 'Number',
	  strokeStyle: 'String',
	  textAlign: 'String',
	  textBaseline: 'String',
	  lineDash: ['Array', 'Number'],
	  shadow: 'String',
	  matrix: 'Array',
	  stroke: 'String',
	  fill: ['String', 'Object'],
	  opacity: 'Number',
	  fillOpacity: 'Number',
	  strokeOpacity: 'Number'
	};
	// css规则表 TODO：补充 / 多种类型
	var DEFAULT_CSS_RULE = {
	  group: _objectSpread({}, elementStyle),
	  text: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    x: 'Number',
	    y: 'Number',
	    text: 'String',
	    width: 'Number',
	    height: 'Number',
	    fontSize: ['Number', 'String'],
	    fontFamily: 'String',
	    fontStyle: 'String',
	    fontWeight: ['Number', 'String'],
	    fontVariant: 'String'
	  }),
	  circle: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    cx: 'Number',
	    cy: 'Number',
	    r: 'Number'
	  }),
	  path: _objectSpread({}, elementStyle),
	  ellipse: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    cy: 'Number',
	    cx: 'Number',
	    ry: 'Number',
	    rx: 'Number'
	  }),
	  rect: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    width: 'Number',
	    height: 'Number',
	    x: 'Number',
	    y: 'Number',
	    radius: ['Array', 'Number']
	  }),
	  image: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    width: 'Number',
	    height: 'Number',
	    x: 'Number',
	    y: 'Number',
	    img: 'String',
	    src: 'String'
	  }),
	  line: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    x1: 'Number',
	    x2: 'Number',
	    y1: 'Number',
	    y2: 'Number'
	  }),
	  polyline: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    points: 'Array',
	    smooth: 'Boolean'
	  }),
	  polygon: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    points: 'Array'
	  }),
	  arc: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    x: 'Number',
	    y: 'Number',
	    r: 'Number',
	    startAngle: ['Number', 'String'],
	    endAngle: ['Number', 'String'],
	    anticlockwise: 'Boolean'
	  }),
	  marker: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    x: 'Number',
	    y: 'Number',
	    radius: 'Number',
	    symbol: 'String'
	  }),
	  sector: _objectSpread(_objectSpread({}, elementStyle), {}, {
	    x: 'Number',
	    y: 'Number',
	    startAngle: ['Number', 'String'],
	    endAngle: ['Number', 'String'],
	    r: 'Number',
	    r0: 'Number',
	    anticlockwise: 'Boolean'
	  })
	};
	function checkCSSRule(type, style) {
	  if (!style) {
	    return style;
	  }
	  var cssStyle = {};
	  Object.keys(style).forEach(function (key) {
	    var value = style[key];
	    if (isNil(value)) {
	      return;
	    }
	    var rule = DEFAULT_CSS_RULE[type] && DEFAULT_CSS_RULE[type][key];
	    if (!rule) {
	      cssStyle[key] = value;
	      return;
	    }
	    var valueType = Object.prototype.toString.call(value);
	    if (isArray(rule)) {
	      for (var i = 0, len = rule.length; i < len; i++) {
	        if (valueType === "[object ".concat(rule[i], "]")) {
	          cssStyle[key] = value;
	          return;
	        }
	      }
	      // 没有匹配的类型
	      return;
	    }
	    // string
	    if (valueType === "[object ".concat(rule, "]")) {
	      cssStyle[key] = value;
	    }
	  });
	  return cssStyle;
	}

	// 默认设置50
	var ONE_REM;
	try {
	  // xgraph下这段会抛错
	  ONE_REM = parseInt(document.documentElement.style.fontSize, 10) || 50;
	} catch (e) {
	  ONE_REM = 50;
	}
	var SCALE = ONE_REM / 100;
	/**
	 * 像素转换
	 * @param {Number} px - 750视觉稿像素
	 * @return {Number} 屏幕上实际像素
	 */
	function defaultPx2hd(px) {
	  if (!px) {
	    return 0;
	  }
	  return Number((px * SCALE).toFixed(1));
	}
	function parsePadding(padding) {
	  if (isNumber(padding)) {
	    return [padding, padding, padding, padding];
	  }
	  var top = padding[0];
	  var right = isNumber(padding[1]) ? padding[1] : padding[0];
	  var bottom = isNumber(padding[2]) ? padding[2] : top;
	  var left = isNumber(padding[3]) ? padding[3] : right;
	  return [top, right, bottom, left];
	}
	function batch2hd(px2hd) {
	  var batchPx2hd = function batchPx2hd(value) {
	    // 处理带px的数据
	    if (isString(value) && /^-?\d+(\.\d+)?px$/.test(value)) {
	      var num = value.substr(0, value.length - 2);
	      return px2hd(Number(num));
	    }
	    if (isArray(value)) {
	      return value.map(function (v) {
	        return batchPx2hd(v);
	      });
	    }
	    if (isPlainObject(value)) {
	      var result = {};
	      for (var key in value) {
	        if (value.hasOwnProperty(key)) {
	          var rst = batchPx2hd(value[key]);
	          if (!rst) {
	            result[key] = rst;
	            continue;
	          }
	          if (key === 'padding' || key === 'margin') {
	            var paddingArray = parsePadding(rst);
	            result[key] = paddingArray;
	            result["".concat(key, "Top")] = paddingArray[0];
	            result["".concat(key, "Right")] = paddingArray[1];
	            result["".concat(key, "Bottom")] = paddingArray[2];
	            result["".concat(key, "Left")] = paddingArray[3];
	            continue;
	          }
	          result[key] = rst;
	        }
	      }
	      return result;
	    }
	    // 默认直接返回
	    return value;
	  };
	  return batchPx2hd;
	}
	var px2hd = batch2hd(defaultPx2hd);

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationPlaybackEvent
	 */
	// @ts-ignore
	var AnimationEvent = /** @class */ (function (_super) {
	    __extends(AnimationEvent, _super);
	    function AnimationEvent(manager, target, currentTime, timelineTime) {
	        var _this = _super.call(this, manager) || this;
	        _this.currentTime = currentTime;
	        _this.timelineTime = timelineTime;
	        // @ts-ignore
	        _this.target = target;
	        _this.type = 'finish';
	        _this.bubbles = false;
	        // @ts-ignore
	        _this.currentTarget = target;
	        _this.defaultPrevented = false;
	        _this.eventPhase = _this.AT_TARGET;
	        _this.timeStamp = Date.now();
	        _this.currentTime = currentTime;
	        _this.timelineTime = timelineTime;
	        return _this;
	    }
	    return AnimationEvent;
	}(FederatedEvent));

	var sequenceNumber = 0;
	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/Animation
	 */
	var Animation = /** @class */ (function () {
	    function Animation(effect, timeline) {
	        var _a;
	        this.currentTimePending = false;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/playState
	         */
	        // playState: AnimationPlayState;
	        this._idle = true;
	        this._paused = false;
	        this._finishedFlag = true;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/currentTime
	         */
	        this._currentTime = 0;
	        this._playbackRate = 1;
	        this._inTimeline = true;
	        this.effect = effect;
	        effect.animation = this;
	        this.timeline = timeline;
	        this.id = "".concat(sequenceNumber++);
	        this._inEffect = !!this.effect.update(0);
	        this._totalDuration = Number((_a = this.effect) === null || _a === void 0 ? void 0 : _a.getComputedTiming().endTime);
	        this._holdTime = 0;
	        this._paused = false;
	        this.oldPlayState = 'idle';
	        this.updatePromises();
	    }
	    Object.defineProperty(Animation.prototype, "pending", {
	        // animation: InternalAnimation | null;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
	         */
	        get: function () {
	            return ((this._startTime === null && !this._paused && this.playbackRate !== 0) ||
	                this.currentTimePending);
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "playState", {
	        get: function () {
	            if (this._idle)
	                return 'idle';
	            if (this._isFinished)
	                return 'finished';
	            if (this._paused)
	                return 'paused';
	            return 'running';
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "ready", {
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
	         * @example
	          animation.pause();
	          animation.ready.then(function() {
	            // Displays 'running'
	            alert(animation.playState);
	          });
	          animation.play();
	         */
	        get: function () {
	            var _this = this;
	            if (!this.readyPromise) {
	                if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
	                    this.timeline.animationsWithPromises.push(this);
	                }
	                this.readyPromise = new Promise(function (resolve, reject) {
	                    _this.resolveReadyPromise = function () {
	                        resolve(_this);
	                    };
	                    _this.rejectReadyPromise = function () {
	                        reject(new Error());
	                    };
	                });
	                if (!this.pending) {
	                    this.resolveReadyPromise();
	                }
	            }
	            return this.readyPromise;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "finished", {
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
	         * @example
	          Promise.all(
	            elem.getAnimations().map(
	              function(animation) {
	                return animation.finished
	              }
	            )
	          ).then(
	            function() {
	              return elem.remove();
	            }
	          );
	         */
	        get: function () {
	            var _this = this;
	            if (!this.finishedPromise) {
	                if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
	                    this.timeline.animationsWithPromises.push(this);
	                }
	                this.finishedPromise = new Promise(function (resolve, reject) {
	                    _this.resolveFinishedPromise = function () {
	                        resolve(_this);
	                    };
	                    _this.rejectFinishedPromise = function () {
	                        reject(new Error());
	                    };
	                });
	                if (this.playState === 'finished') {
	                    this.resolveFinishedPromise();
	                }
	            }
	            return this.finishedPromise;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "currentTime", {
	        get: function () {
	            this.updatePromises();
	            return this._idle || this.currentTimePending ? null : this._currentTime;
	        },
	        set: function (newTime) {
	            var _a;
	            newTime = Number(newTime);
	            if (isNaN(newTime))
	                return;
	            this.timeline.restart();
	            if (!this._paused && this._startTime !== null) {
	                this._startTime =
	                    Number((_a = this.timeline) === null || _a === void 0 ? void 0 : _a.currentTime) - newTime / this.playbackRate;
	            }
	            this.currentTimePending = false;
	            if (this._currentTime === newTime) {
	                return;
	            }
	            if (this._idle) {
	                this._idle = false;
	                this._paused = true;
	            }
	            this.tickCurrentTime(newTime, true);
	            this.timeline.applyDirtiedAnimation(this);
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "startTime", {
	        get: function () {
	            return this._startTime;
	        },
	        set: function (newTime) {
	            if (newTime !== null) {
	                this.updatePromises();
	                newTime = Number(newTime);
	                if (isNaN(newTime))
	                    return;
	                if (this._paused || this._idle)
	                    return;
	                this._startTime = newTime;
	                this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) *
	                    this.playbackRate);
	                this.timeline.applyDirtiedAnimation(this);
	                this.updatePromises();
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "playbackRate", {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (value) {
	            if (value === this._playbackRate) {
	                return;
	            }
	            this.updatePromises();
	            var oldCurrentTime = this.currentTime;
	            this._playbackRate = value;
	            this.startTime = null;
	            if (this.playState !== 'paused' && this.playState !== 'idle') {
	                this._finishedFlag = false;
	                this._idle = false;
	                this.ensureAlive();
	                this.timeline.applyDirtiedAnimation(this);
	            }
	            if (oldCurrentTime !== null) {
	                this.currentTime = oldCurrentTime;
	            }
	            this.updatePromises();
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "_isFinished", {
	        get: function () {
	            return (!this._idle &&
	                ((this._playbackRate > 0 &&
	                    Number(this._currentTime) >= this._totalDuration) ||
	                    (this._playbackRate < 0 && Number(this._currentTime) <= 0)));
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "totalDuration", {
	        get: function () {
	            return this._totalDuration;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "_needsTick", {
	        get: function () {
	            return this.pending || this.playState === 'running' || !this._finishedFlag;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * state machine,
	     * resolve/reject ready/finished Promise according to current state
	     */
	    Animation.prototype.updatePromises = function () {
	        var oldPlayState = this.oldPlayState;
	        var newPlayState = this.pending ? 'pending' : this.playState;
	        if (this.readyPromise && newPlayState !== oldPlayState) {
	            if (newPlayState === 'idle') {
	                this.rejectReadyPromise();
	                this.readyPromise = undefined;
	            }
	            else if (oldPlayState === 'pending') {
	                this.resolveReadyPromise();
	            }
	            else if (newPlayState === 'pending') {
	                this.readyPromise = undefined;
	            }
	        }
	        if (this.finishedPromise && newPlayState !== oldPlayState) {
	            if (newPlayState === 'idle') {
	                this.rejectFinishedPromise();
	                this.finishedPromise = undefined;
	            }
	            else if (newPlayState === 'finished') {
	                this.resolveFinishedPromise();
	            }
	            else if (oldPlayState === 'finished') {
	                this.finishedPromise = undefined;
	            }
	        }
	        this.oldPlayState = newPlayState;
	        return this.readyPromise || this.finishedPromise;
	    };
	    Animation.prototype.play = function () {
	        this.updatePromises();
	        this._paused = false;
	        if (this._isFinished || this._idle) {
	            this.rewind();
	            this._startTime = null;
	        }
	        this._finishedFlag = false;
	        this._idle = false;
	        this.ensureAlive();
	        this.timeline.applyDirtiedAnimation(this);
	        if (this.timeline.animations.indexOf(this) === -1) {
	            this.timeline.animations.push(this);
	        }
	        this.updatePromises();
	    };
	    Animation.prototype.pause = function () {
	        this.updatePromises();
	        if (this.currentTime) {
	            this._holdTime = this.currentTime;
	        }
	        if (!this._isFinished && !this._paused && !this._idle) {
	            this.currentTimePending = true;
	        }
	        else if (this._idle) {
	            this.rewind();
	            this._idle = false;
	        }
	        this._startTime = null;
	        this._paused = true;
	        this.updatePromises();
	    };
	    Animation.prototype.finish = function () {
	        this.updatePromises();
	        if (this._idle)
	            return;
	        this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
	        this._startTime = this._totalDuration - this.currentTime;
	        this.currentTimePending = false;
	        this.timeline.applyDirtiedAnimation(this);
	        this.updatePromises();
	    };
	    Animation.prototype.cancel = function () {
	        var _this = this;
	        this.updatePromises();
	        if (!this._inEffect)
	            return;
	        this._inEffect = false;
	        this._idle = true;
	        this._paused = false;
	        this._finishedFlag = true;
	        this._currentTime = 0;
	        this._startTime = null;
	        this.effect.update(null);
	        // effects are invalid after cancellation as the animation state
	        // needs to un-apply.
	        this.timeline.applyDirtiedAnimation(this);
	        this.updatePromises();
	        /**
	         * 1. Reject the current finished promise with a DOMException named "AbortError".
	         * 2. Let current finished promise be a new promise
	         * @see https://w3c.github.io/csswg-drafts/web-animations-1/#canceling-an-animation-section
	         */
	        // if (this.finishedPromise) {
	        //   this.rejectFinishedPromise();
	        //   this.finishedPromise = undefined;
	        // }
	        if (this.oncancel) {
	            var event_1 = new AnimationEvent(null, this, this.currentTime, null);
	            setTimeout(function () {
	                _this.oncancel(event_1);
	            });
	        }
	    };
	    Animation.prototype.reverse = function () {
	        this.updatePromises();
	        var oldCurrentTime = this.currentTime;
	        this.playbackRate *= -1;
	        this.play();
	        if (oldCurrentTime !== null) {
	            this.currentTime = oldCurrentTime;
	        }
	        this.updatePromises();
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
	     */
	    Animation.prototype.updatePlaybackRate = function (playbackRate) {
	        this.playbackRate = playbackRate;
	    };
	    Animation.prototype.targetAnimations = function () {
	        var _a;
	        var target = (_a = this.effect) === null || _a === void 0 ? void 0 : _a.target;
	        return target.getAnimations();
	    };
	    Animation.prototype.markTarget = function () {
	        var animations = this.targetAnimations();
	        if (animations.indexOf(this) === -1) {
	            animations.push(this);
	        }
	    };
	    Animation.prototype.unmarkTarget = function () {
	        var animations = this.targetAnimations();
	        var index = animations.indexOf(this);
	        if (index !== -1) {
	            animations.splice(index, 1);
	        }
	    };
	    Animation.prototype.tick = function (timelineTime, isAnimationFrame) {
	        if (!this._idle && !this._paused) {
	            if (this._startTime === null) {
	                if (isAnimationFrame) {
	                    this.startTime = timelineTime - this._currentTime / this.playbackRate;
	                }
	            }
	            else if (!this._isFinished) {
	                this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
	            }
	        }
	        if (isAnimationFrame) {
	            this.currentTimePending = false;
	            this.fireEvents(timelineTime);
	        }
	    };
	    Animation.prototype.rewind = function () {
	        if (this.playbackRate >= 0) {
	            this.currentTime = 0;
	        }
	        else if (this._totalDuration < Infinity) {
	            this.currentTime = this._totalDuration;
	        }
	        else {
	            throw new Error('Unable to rewind negative playback rate animation with infinite duration');
	        }
	    };
	    Animation.prototype.persist = function () {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Animation.prototype.addEventListener = function (type, listener, options) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Animation.prototype.removeEventListener = function (type, listener, options) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Animation.prototype.dispatchEvent = function (event) {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    // replaceState: AnimationReplaceState;
	    Animation.prototype.commitStyles = function () {
	        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
	    };
	    Animation.prototype.ensureAlive = function () {
	        var _a, _b;
	        // If an animation is playing backwards and is not fill backwards/both
	        // then it should go out of effect when it reaches the start of its
	        // active interval (currentTime === 0).
	        if (this.playbackRate < 0 && this.currentTime === 0) {
	            this._inEffect = !!((_a = this.effect) === null || _a === void 0 ? void 0 : _a.update(-1));
	        }
	        else {
	            this._inEffect = !!((_b = this.effect) === null || _b === void 0 ? void 0 : _b.update(this.currentTime));
	        }
	        if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
	            this._inTimeline = true;
	            this.timeline.animations.push(this);
	        }
	    };
	    Animation.prototype.tickCurrentTime = function (newTime, ignoreLimit) {
	        if (newTime !== this._currentTime) {
	            this._currentTime = newTime;
	            if (this._isFinished && !ignoreLimit) {
	                this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
	            }
	            this.ensureAlive();
	        }
	    };
	    Animation.prototype.fireEvents = function (baseTime) {
	        var _this = this;
	        if (this._isFinished) {
	            if (!this._finishedFlag) {
	                if (this.onfinish) {
	                    var event_2 = new AnimationEvent(null, this, this.currentTime, baseTime);
	                    setTimeout(function () {
	                        if (_this.onfinish) {
	                            _this.onfinish(event_2);
	                        }
	                    });
	                }
	                this._finishedFlag = true;
	            }
	        }
	        else {
	            if (this.onframe && this.playState === 'running') {
	                var event_3 = new AnimationEvent(null, this, this.currentTime, baseTime);
	                this.onframe(event_3);
	            }
	            this._finishedFlag = false;
	        }
	    };
	    return Animation;
	}());

	/**
	 * https://github.com/gre/bezier-easing
	 * BezierEasing - use bezier curve for transition easing function
	 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
	 */
	// These values are established by empiricism with tests (tradeoff: performance VS precision)
	var NEWTON_ITERATIONS = 4;
	var NEWTON_MIN_SLOPE = 0.001;
	var SUBDIVISION_PRECISION = 0.0000001;
	var SUBDIVISION_MAX_ITERATIONS = 10;
	var kSplineTableSize = 11;
	var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
	var float32ArraySupported = typeof Float32Array === 'function';
	var A = function (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; };
	var B = function (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; };
	var C = function (aA1) { return 3.0 * aA1; };
	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	var calcBezier = function (aT, aA1, aA2) {
	    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
	};
	// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	var getSlope = function (aT, aA1, aA2) {
	    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	};
	var binarySubdivide = function (aX, aA, aB, mX1, mX2) {
	    var currentX, currentT, i = 0;
	    do {
	        currentT = aA + (aB - aA) / 2.0;
	        currentX = calcBezier(currentT, mX1, mX2) - aX;
	        if (currentX > 0.0)
	            aB = currentT;
	        else
	            aA = currentT;
	    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	    return currentT;
	};
	var newtonRaphsonIterate = function (aX, aGuessT, mX1, mX2) {
	    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	        var currentSlope = getSlope(aGuessT, mX1, mX2);
	        if (currentSlope === 0.0)
	            return aGuessT;
	        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	        aGuessT -= currentX / currentSlope;
	    }
	    return aGuessT;
	};
	var bezier = function (mX1, mY1, mX2, mY2) {
	    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1))
	        throw new Error('bezier x values must be in [0, 1] range');
	    if (mX1 === mY1 && mX2 === mY2)
	        return function (t) { return t; };
	    // Precompute samples table
	    var sampleValues = float32ArraySupported
	        ? new Float32Array(kSplineTableSize)
	        : new Array(kSplineTableSize);
	    for (var i = 0; i < kSplineTableSize; ++i) {
	        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	    }
	    var getTForX = function (aX) {
	        var intervalStart = 0.0;
	        var currentSample = 1;
	        var lastSample = kSplineTableSize - 1;
	        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample)
	            intervalStart += kSampleStepSize;
	        --currentSample;
	        // Interpolate to provide an initial guess for t
	        var dist = (aX - sampleValues[currentSample]) /
	            (sampleValues[currentSample + 1] - sampleValues[currentSample]);
	        var guessForT = intervalStart + dist * kSampleStepSize;
	        var initialSlope = getSlope(guessForT, mX1, mX2);
	        if (initialSlope >= NEWTON_MIN_SLOPE)
	            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	        else if (initialSlope === 0.0)
	            return guessForT;
	        else {
	            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	        }
	    };
	    return function (t) {
	        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
	        if (t === 0 || t === 1)
	            return t;
	        return calcBezier(getTForX(t), mY1, mY2);
	    };
	};

	var convertToDash = function (str) {
	    str = str.replace(/([A-Z])/g, function (letter) { return "-".concat(letter.toLowerCase()); });
	    // Remove first dash
	    return str.charAt(0) === '-' ? str.substring(1) : str;
	};
	/**
	  Easing Functions from anime.js, they are tried and true, so, its better to use them instead of other alternatives
	*/
	var Quad = function (t) { return Math.pow(t, 2); };
	var Cubic = function (t) { return Math.pow(t, 3); };
	var Quart = function (t) { return Math.pow(t, 4); };
	var Quint = function (t) { return Math.pow(t, 5); };
	var Expo = function (t) { return Math.pow(t, 6); };
	var Sine = function (t) { return 1 - Math.cos((t * Math.PI) / 2); };
	var Circ = function (t) { return 1 - Math.sqrt(1 - t * t); };
	var Back = function (t) { return t * t * (3 * t - 2); };
	var Bounce = function (t) {
	    var pow2, b = 4;
	    while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) { }
	    return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
	};
	var Elastic = function (t, params) {
	    if (params === void 0) { params = []; }
	    var _a = __read(params, 2), _b = _a[0], amplitude = _b === void 0 ? 1 : _b, _c = _a[1], period = _c === void 0 ? 0.5 : _c;
	    var a = clamp(Number(amplitude), 1, 10);
	    var p = clamp(Number(period), 0.1, 2);
	    if (t === 0 || t === 1)
	        return t;
	    return (-a *
	        Math.pow(2, 10 * (t - 1)) *
	        Math.sin(((t - 1 - (p / (Math.PI * 2)) * Math.asin(1 / a)) * (Math.PI * 2)) / p));
	};
	var Spring = function (t, params, duration) {
	    if (params === void 0) { params = []; }
	    var _a = __read(params, 4), _b = _a[0], mass = _b === void 0 ? 1 : _b, _c = _a[1], stiffness = _c === void 0 ? 100 : _c, _d = _a[2], damping = _d === void 0 ? 10 : _d, _e = _a[3], velocity = _e === void 0 ? 0 : _e;
	    mass = clamp(mass, 0.1, 1000);
	    stiffness = clamp(stiffness, 0.1, 1000);
	    damping = clamp(damping, 0.1, 1000);
	    velocity = clamp(velocity, 0.1, 1000);
	    var w0 = Math.sqrt(stiffness / mass);
	    var zeta = damping / (2 * Math.sqrt(stiffness * mass));
	    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
	    var a = 1;
	    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
	    var progress = duration ? (duration * t) / 1000 : t;
	    if (zeta < 1) {
	        progress =
	            Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
	    }
	    else {
	        progress = (a + b * progress) * Math.exp(-progress * w0);
	    }
	    if (t === 0 || t === 1)
	        return t;
	    return 1 - progress;
	};
	/**
	 * Cache the durations at set easing parameters
	 */
	// export const EasingDurationCache: Map<string | TypeEasingFunction, number> = new Map();
	/**
	 * The threshold for an infinite loop
	 */
	// const INTINITE_LOOP_LIMIT = 10000;
	/** Convert easing parameters to Array of numbers, e.g. "spring(2, 500)" to [2, 500] */
	// export const parseEasingParameters = (str: string) => {
	//   const match = /(\(|\s)([^)]+)\)?/.exec(str);
	//   return match
	//     ? match[2].split(',').map((value) => {
	//         const num = parseFloat(value);
	//         return !Number.isNaN(num) ? num : value.trim();
	//       })
	//     : [];
	// };
	/**
	 * The spring easing function will only look smooth at certain durations, with certain parameters.
	 * This functions returns the optimal duration to create a smooth springy animation based on physics
	 *
	 * Note: it can also be used to determine the optimal duration of other types of easing function, but be careful of 'in-'
	 * easing functions, because of the nature of the function it can sometimes create an infinite loop, I suggest only using
	 * `getEasingDuration` for `spring`, specifically 'out-spring' and 'spring'
	 */
	// export const getEasingDuration = (easing: string | TypeEasingFunction = 'spring') => {
	//   if (EasingDurationCache.has(easing)) return EasingDurationCache.get(easing);
	//   // eslint-disable-next-line @typescript-eslint/no-use-before-define
	//   const easingFunction = typeof easing == 'function' ? easing : getEasingFunction(easing as string);
	//   const params = typeof easing == 'function' ? [] : parseEasingParameters(easing);
	//   const frame = 1 / 6;
	//   let elapsed = 0;
	//   let rest = 0;
	//   let count = 0;
	//   while (++count < INTINITE_LOOP_LIMIT) {
	//     elapsed += frame;
	//     if (easingFunction(elapsed, params, undefined) === 1) {
	//       rest++;
	//       if (rest >= 16) break;
	//     } else {
	//       rest = 0;
	//     }
	//   }
	//   const duration = elapsed * frame * 1000;
	//   EasingDurationCache.set(easing, duration);
	//   return duration;
	// };
	/**
	  These Easing Functions are based off of the Sozi Project's easing functions
	  https://github.com/sozi-projects/Sozi/blob/d72e44ebd580dc7579d1e177406ad41e632f961d/src/js/player/Timing.js
	*/
	var Steps = function (t, params) {
	    if (params === void 0) { params = []; }
	    var _a = __read(params, 2), _b = _a[0], steps = _b === void 0 ? 10 : _b, type = _a[1];
	    var trunc = type == 'start' ? Math.ceil : Math.floor;
	    return trunc(clamp(t, 0, 1) * steps) / steps;
	};
	// @ts-ignore
	var Bezier = function (t, params) {
	    if (params === void 0) { params = []; }
	    var _a = __read(params, 4), mX1 = _a[0], mY1 = _a[1], mX2 = _a[2], mY2 = _a[3];
	    return bezier(mX1, mY1, mX2, mY2)(t);
	};
	/** The default `ease-in` easing function */
	var easein = bezier(0.42, 0.0, 1.0, 1.0);
	/** Converts easing functions to their `out`counter parts */
	var EaseOut = function (ease) {
	    return function (t, params, duration) {
	        if (params === void 0) { params = []; }
	        return 1 - ease(1 - t, params, duration);
	    };
	};
	/** Converts easing functions to their `in-out` counter parts */
	var EaseInOut = function (ease) {
	    return function (t, params, duration) {
	        if (params === void 0) { params = []; }
	        return t < 0.5 ? ease(t * 2, params, duration) / 2 : 1 - ease(t * -2 + 2, params, duration) / 2;
	    };
	};
	/** Converts easing functions to their `out-in` counter parts */
	var EaseOutIn = function (ease) {
	    return function (t, params, duration) {
	        if (params === void 0) { params = []; }
	        return t < 0.5
	            ? (1 - ease(1 - t * 2, params, duration)) / 2
	            : (ease(t * 2 - 1, params, duration) + 1) / 2;
	    };
	};
	var EasingFunctions = {
	    steps: Steps,
	    'step-start': function (t) { return Steps(t, [1, 'start']); },
	    'step-end': function (t) { return Steps(t, [1, 'end']); },
	    linear: function (t) { return t; },
	    'cubic-bezier': Bezier,
	    ease: function (t) { return Bezier(t, [0.25, 0.1, 0.25, 1.0]); },
	    in: easein,
	    out: EaseOut(easein),
	    'in-out': EaseInOut(easein),
	    'out-in': EaseOutIn(easein),
	    'in-quad': Quad,
	    'out-quad': EaseOut(Quad),
	    'in-out-quad': EaseInOut(Quad),
	    'out-in-quad': EaseOutIn(Quad),
	    'in-cubic': Cubic,
	    'out-cubic': EaseOut(Cubic),
	    'in-out-cubic': EaseInOut(Cubic),
	    'out-in-cubic': EaseOutIn(Cubic),
	    'in-quart': Quart,
	    'out-quart': EaseOut(Quart),
	    'in-out-quart': EaseInOut(Quart),
	    'out-in-quart': EaseOutIn(Quart),
	    'in-quint': Quint,
	    'out-quint': EaseOut(Quint),
	    'in-out-quint': EaseInOut(Quint),
	    'out-in-quint': EaseOutIn(Quint),
	    'in-expo': Expo,
	    'out-expo': EaseOut(Expo),
	    'in-out-expo': EaseInOut(Expo),
	    'out-in-expo': EaseOutIn(Expo),
	    'in-sine': Sine,
	    'out-sine': EaseOut(Sine),
	    'in-out-sine': EaseInOut(Sine),
	    'out-in-sine': EaseOutIn(Sine),
	    'in-circ': Circ,
	    'out-circ': EaseOut(Circ),
	    'in-out-circ': EaseInOut(Circ),
	    'out-in-circ': EaseOutIn(Circ),
	    'in-back': Back,
	    'out-back': EaseOut(Back),
	    'in-out-back': EaseInOut(Back),
	    'out-in-back': EaseOutIn(Back),
	    'in-bounce': Bounce,
	    'out-bounce': EaseOut(Bounce),
	    'in-out-bounce': EaseInOut(Bounce),
	    'out-in-bounce': EaseOutIn(Bounce),
	    'in-elastic': Elastic,
	    'out-elastic': EaseOut(Elastic),
	    'in-out-elastic': EaseInOut(Elastic),
	    'out-in-elastic': EaseOutIn(Elastic),
	    spring: Spring,
	    'spring-in': Spring,
	    'spring-out': EaseOut(Spring),
	    'spring-in-out': EaseInOut(Spring),
	    'spring-out-in': EaseOutIn(Spring),
	};
	/**
	 * Convert string easing to their proper form
	 */
	var complexEasingSyntax = function (ease) {
	    return convertToDash(ease)
	        .replace(/^ease-/, '') // Remove the "ease-" keyword
	        .replace(/(\(|\s).+/, '') // Remove the function brackets and parameters
	        .toLowerCase()
	        .trim();
	};
	/** Re-maps a number from one range to another. Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. */
	var getEasingFunction = function (ease) {
	    return EasingFunctions[complexEasingSyntax(ease)] || EasingFunctions.linear;
	};
	// /**
	//  * Allows you to register new easing functions
	//  */
	// export const registerEasingFunction = (key: string, fn: TypeEasingFunction) => {
	//   Object.assign(EasingFunctions, {
	//     [key]: fn,
	//   });
	// };
	// /**
	//  * Allows you to register multiple new easing functions
	//  */
	// export const registerEasingFunctions = (...obj: typeof EasingFunctions[]) => {
	//   Object.assign(EasingFunctions, ...obj);
	// };

	var linear = function (x) {
	    return x;
	};
	var Start = 1;
	var Middle = 0.5;
	var End = 0;
	function step(count, pos) {
	    return function (x) {
	        if (x >= 1) {
	            return 1;
	        }
	        var stepSize = 1 / count;
	        x += pos * stepSize;
	        return x - (x % stepSize);
	    };
	}
	var numberString = '\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*';
	var cubicBezierRe = new RegExp('cubic-bezier\\(' +
	    numberString +
	    ',' +
	    numberString +
	    ',' +
	    numberString +
	    ',' +
	    numberString +
	    '\\)');
	var step1Re = /steps\(\s*(\d+)\s*\)/;
	var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
	function parseEasingFunction(normalizedEasing) {
	    var cubicData = cubicBezierRe.exec(normalizedEasing);
	    if (cubicData) {
	        // @ts-ignore
	        return bezier.apply(void 0, __spreadArray([], __read(cubicData.slice(1).map(Number)), false));
	    }
	    var step1Data = step1Re.exec(normalizedEasing);
	    if (step1Data) {
	        return step(Number(step1Data[1]), End);
	    }
	    var step2Data = step2Re.exec(normalizedEasing);
	    if (step2Data) {
	        // @ts-ignore
	        return step(Number(step2Data[1]), { start: Start, middle: Middle, end: End }[step2Data[2]]);
	    }
	    return getEasingFunction(normalizedEasing);
	}
	function calculateActiveDuration(timing) {
	    // @ts-ignore
	    return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
	}
	function repeatedDuration(timing) {
	    var _a;
	    // https://drafts.csswg.org/web-animations/#calculating-the-active-duration
	    if (timing.duration === 0 || timing.iterations === 0) {
	        return 0;
	    }
	    // @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration#value
	    // if (timing.duration === 'auto') {
	    //   timing.duration = 0;
	    // }
	    return (timing.duration === 'auto' ? 0 : Number(timing.duration)) * ((_a = timing.iterations) !== null && _a !== void 0 ? _a : 1);
	}
	var PhaseNone = 0;
	var PhaseBefore = 1;
	var PhaseAfter = 2;
	var PhaseActive = 3;
	function calculatePhase(activeDuration, localTime, timing) {
	    // https://drafts.csswg.org/web-animations/#animation-effect-phases-and-states
	    if (localTime === null) {
	        return PhaseNone;
	    }
	    var endTime = timing.endTime;
	    if (localTime < Math.min(timing.delay, endTime)) {
	        return PhaseBefore;
	    }
	    if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
	        return PhaseAfter;
	    }
	    return PhaseActive;
	}
	function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
	    // https://drafts.csswg.org/web-animations/#calculating-the-active-time
	    switch (phase) {
	        case PhaseBefore:
	            if (fillMode === 'backwards' || fillMode === 'both')
	                return 0;
	            return null;
	        case PhaseActive:
	            return localTime - delay;
	        case PhaseAfter:
	            if (fillMode === 'forwards' || fillMode === 'both')
	                return activeDuration;
	            return null;
	        case PhaseNone:
	            return null;
	    }
	}
	function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
	    // https://drafts.csswg.org/web-animations/#calculating-the-overall-progress
	    var overallProgress = iterationStart;
	    if (iterationDuration === 0) {
	        if (phase !== PhaseBefore) {
	            overallProgress += iterations;
	        }
	    }
	    else {
	        overallProgress += activeTime / iterationDuration;
	    }
	    return overallProgress;
	}
	function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
	    // https://drafts.csswg.org/web-animations/#calculating-the-simple-iteration-progress
	    var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
	    if (simpleIterationProgress === 0 &&
	        phase === PhaseAfter &&
	        iterations !== 0 &&
	        (activeTime !== 0 || iterationDuration === 0)) {
	        simpleIterationProgress = 1;
	    }
	    return simpleIterationProgress;
	}
	function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
	    // https://drafts.csswg.org/web-animations/#calculating-the-current-iteration
	    if (phase === PhaseAfter && iterations === Infinity) {
	        return Infinity;
	    }
	    if (simpleIterationProgress === 1) {
	        return Math.floor(overallProgress) - 1;
	    }
	    return Math.floor(overallProgress);
	}
	function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
	    // https://drafts.csswg.org/web-animations/#calculating-the-directed-progress
	    var currentDirection = playbackDirection;
	    if (playbackDirection !== 'normal' && playbackDirection !== 'reverse') {
	        var d = currentIteration;
	        if (playbackDirection === 'alternate-reverse') {
	            d += 1;
	        }
	        currentDirection = 'normal';
	        if (d !== Infinity && d % 2 !== 0) {
	            currentDirection = 'reverse';
	        }
	    }
	    if (currentDirection === 'normal') {
	        return simpleIterationProgress;
	    }
	    return 1 - simpleIterationProgress;
	}
	function calculateIterationProgress(activeDuration, localTime, timing) {
	    var phase = calculatePhase(activeDuration, localTime, timing);
	    var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
	    if (activeTime === null)
	        return null;
	    var duration = timing.duration === 'auto' ? 0 : timing.duration;
	    var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
	    var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
	    var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
	    var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
	    timing.currentIteration = currentIteration;
	    timing.progress = directedProgress;
	    // https://drafts.csswg.org/web-animations/#calculating-the-transformed-progress
	    // https://drafts.csswg.org/web-animations/#calculating-the-iteration-progress
	    return timing.easingFunction(directedProgress);
	}

	function convertEffectInput(keyframes, timing, target) {
	    var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
	    var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
	    return function (target, fraction) {
	        if (fraction !== null) {
	            interpolations
	                .filter(function (interpolation) {
	                return (fraction >= interpolation.applyFrom &&
	                    fraction < interpolation.applyTo);
	            })
	                .forEach(function (interpolation) {
	                var offsetFraction = fraction - interpolation.startOffset;
	                var localDuration = interpolation.endOffset - interpolation.startOffset;
	                var scaledLocalTime = localDuration === 0
	                    ? 0
	                    : interpolation.easingFunction(offsetFraction / localDuration);
	                // apply updated attribute
	                target.setAttribute(interpolation.property, interpolation.interpolation(scaledLocalTime));
	                // if (interpolation.property === 'visibility') {
	                //   console.log(
	                //     scaledLocalTime,
	                //     interpolation.interpolation(scaledLocalTime),
	                //   );
	                // }
	            });
	        }
	        else {
	            for (var property in propertySpecificKeyframeGroups)
	                if (isNotReservedWord(property)) {
	                    // clear attribute
	                    target.setAttribute(property, null);
	                }
	        }
	    };
	}
	function isNotReservedWord(member) {
	    return (member !== 'offset' &&
	        member !== 'easing' &&
	        member !== 'composite' &&
	        member !== 'computedOffset');
	}
	function makePropertySpecificKeyframeGroups(keyframes, timing) {
	    var propertySpecificKeyframeGroups = {};
	    for (var i = 0; i < keyframes.length; i++) {
	        for (var member in keyframes[i]) {
	            if (isNotReservedWord(member)) {
	                var propertySpecificKeyframe = {
	                    offset: keyframes[i].offset,
	                    computedOffset: keyframes[i].computedOffset,
	                    easing: keyframes[i].easing,
	                    easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
	                    value: keyframes[i][member],
	                };
	                propertySpecificKeyframeGroups[member] =
	                    propertySpecificKeyframeGroups[member] || [];
	                propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
	            }
	        }
	    }
	    return propertySpecificKeyframeGroups;
	}
	function makeInterpolations(propertySpecificKeyframeGroups, target) {
	    var interpolations = [];
	    for (var groupName in propertySpecificKeyframeGroups) {
	        var keyframes = propertySpecificKeyframeGroups[groupName];
	        for (var i = 0; i < keyframes.length - 1; i++) {
	            var startIndex = i;
	            var endIndex = i + 1;
	            var startOffset = keyframes[startIndex].computedOffset;
	            var endOffset = keyframes[endIndex].computedOffset;
	            var applyFrom = startOffset;
	            var applyTo = endOffset;
	            if (i === 0) {
	                applyFrom = -Infinity;
	                if (endOffset === 0) {
	                    endIndex = startIndex;
	                }
	            }
	            if (i === keyframes.length - 2) {
	                applyTo = Infinity;
	                if (startOffset === 1) {
	                    startIndex = endIndex;
	                }
	            }
	            interpolations.push({
	                applyFrom: applyFrom,
	                applyTo: applyTo,
	                startOffset: keyframes[startIndex].computedOffset,
	                endOffset: keyframes[endIndex].computedOffset,
	                easingFunction: keyframes[startIndex].easingFunction,
	                property: groupName,
	                interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target),
	            });
	        }
	    }
	    interpolations.sort(function (leftInterpolation, rightInterpolation) {
	        return leftInterpolation.startOffset - rightInterpolation.startOffset;
	    });
	    return interpolations;
	}
	var InterpolationFactory = function (from, to, 
	// eslint-disable-next-line @typescript-eslint/ban-types
	convertToString) {
	    return function (f) {
	        var interpolated = interpolate(from, to, f);
	        return !runtime.enableCSSParsing && isNumber(interpolated)
	            ? interpolated
	            : convertToString(interpolated);
	    };
	};
	function propertyInterpolation(property, left, right, target) {
	    var metadata = propertyMetadataCache[property];
	    // discrete step
	    // if (property === 'visibility') {
	    //   return function (t: number) {
	    //     if (t === 0) return left;
	    //     if (t === 1) return right;
	    //     debugger;
	    //     return t < 0.5 ? left : right;
	    //   };
	    // }
	    if (metadata && metadata.syntax && metadata.int) {
	        var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
	        if (propertyHandler) {
	            var usedLeft = void 0;
	            var usedRight = void 0;
	            if (runtime.enableCSSParsing) {
	                var computedLeft = runtime.styleValueRegistry.parseProperty(property, left, target);
	                var computedRight = runtime.styleValueRegistry.parseProperty(property, right, target);
	                usedLeft = runtime.styleValueRegistry.computeProperty(property, computedLeft, target);
	                usedRight = runtime.styleValueRegistry.computeProperty(property, computedRight, target);
	            }
	            else {
	                var parser = propertyHandler.parserWithCSSDisabled;
	                usedLeft = parser ? parser(left, target) : left;
	                usedRight = parser ? parser(right, target) : right;
	            }
	            // merger [left, right, n2string()]
	            var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
	            if (interpolationArgs) {
	                var interp_1 = InterpolationFactory.apply(void 0, __spreadArray([], __read(interpolationArgs), false));
	                return function (t) {
	                    if (t === 0)
	                        return left;
	                    if (t === 1)
	                        return right;
	                    return interp_1(t);
	                };
	            }
	        }
	    }
	    // eslint-disable-next-line @typescript-eslint/no-use-before-define
	    return InterpolationFactory(false, true, function (bool) {
	        return bool ? right : left;
	    });
	}
	/**
	 * interpolate with number, boolean, number[], boolean[]
	 */
	function interpolate(from, to, f) {
	    if (typeof from === 'number' && typeof to === 'number') {
	        return from * (1 - f) + to * f;
	    }
	    if ((typeof from === 'boolean' && typeof to === 'boolean') ||
	        (typeof from === 'string' && typeof to === 'string') // skip string, eg. path ['M', 10, 10]
	    ) {
	        return f < 0.5 ? from : to;
	    }
	    if (Array.isArray(from) && Array.isArray(to)) {
	        // interpolate arrays/matrix
	        var fromLength = from.length;
	        var toLength = to.length;
	        var length_1 = Math.max(fromLength, toLength);
	        var r = [];
	        for (var i = 0; i < length_1; i++) {
	            r.push(interpolate(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
	        }
	        return r;
	    }
	    throw new Error('Mismatched interpolation arguments ' + from + ':' + to);
	}

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming
	 */
	var AnimationEffectTiming = /** @class */ (function () {
	    function AnimationEffectTiming() {
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/delay
	         */
	        this.delay = 0;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/direction
	         */
	        this.direction = 'normal';
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration
	         */
	        this.duration = 'auto';
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing
	         */
	        this._easing = 'linear';
	        this.easingFunction = linear;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/endDelay
	         */
	        this.endDelay = 0;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/fill
	         */
	        this.fill = 'auto';
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterationStart
	         */
	        this.iterationStart = 0;
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterations
	         */
	        this.iterations = 1;
	        this.currentIteration = null;
	        this.progress = null;
	    }
	    Object.defineProperty(AnimationEffectTiming.prototype, "easing", {
	        get: function () {
	            return this._easing;
	        },
	        set: function (value) {
	            this.easingFunction = parseEasingFunction(value);
	            this._easing = value;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return AnimationEffectTiming;
	}());

	/**
	 * @example
	  {
	    translateY: [200, 300],
	    scale: [1, 10],
	  }

	 * groups' length can be different, the following config should generate 3 frames:
	  @example
	  {
	    translateY: [200, 300, 400],
	    scale: [1, 10],
	  }
	 */
	function convertToArrayForm(effectInput) {
	    var normalizedEffectInput = [];
	    for (var property in effectInput) {
	        // skip reserved props
	        if (property in ['easing', 'offset', 'composite']) {
	            continue;
	        }
	        // @ts-ignore
	        var values = effectInput[property];
	        if (!Array.isArray(values)) {
	            values = [values];
	        }
	        var numKeyframes = values.length;
	        for (var i = 0; i < numKeyframes; i++) {
	            if (!normalizedEffectInput[i]) {
	                var keyframe = {};
	                if ('offset' in effectInput) {
	                    keyframe.offset = Number(effectInput.offset);
	                }
	                if ('easing' in effectInput) {
	                    // @ts-ignore
	                    keyframe.easing = effectInput.easing;
	                }
	                if ('composite' in effectInput) {
	                    // @ts-ignore
	                    keyframe.composite = effectInput.composite;
	                }
	                normalizedEffectInput[i] = keyframe;
	            }
	            if (values[i] !== undefined && values[i] !== null) {
	                normalizedEffectInput[i][property] = values[i];
	            }
	        }
	    }
	    normalizedEffectInput.sort(function (a, b) {
	        return (a.computedOffset || 0) - (b.computedOffset || 0);
	    });
	    return normalizedEffectInput;
	}
	function normalizeKeyframes(effectInput, timing) {
	    if (effectInput === null) {
	        return [];
	    }
	    if (!Array.isArray(effectInput)) {
	        effectInput = convertToArrayForm(effectInput);
	    }
	    var keyframes = effectInput.map(function (originalKeyframe) {
	        var keyframe = {};
	        if (timing === null || timing === void 0 ? void 0 : timing.composite) {
	            // This will be auto if the composite operation specified on the effect is being used.
	            // @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats
	            keyframe.composite = 'auto';
	        }
	        for (var member in originalKeyframe) {
	            var memberValue = originalKeyframe[member];
	            if (member === 'offset') {
	                if (memberValue !== null) {
	                    memberValue = Number(memberValue);
	                    if (!isFinite(memberValue))
	                        throw new Error('Keyframe offsets must be numbers.');
	                    if (memberValue < 0 || memberValue > 1)
	                        throw new Error('Keyframe offsets must be between 0 and 1.');
	                    keyframe.computedOffset = memberValue;
	                }
	            }
	            else if (member === 'composite') {
	                // TODO: Support add & accumulate in KeyframeEffect.composite
	                // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/composite
	                if (['replace', 'add', 'accumulate', 'auto'].indexOf(memberValue) === -1) {
	                    throw new Error("".concat(memberValue, " compositing is not supported"));
	                }
	            }
	            else ;
	            // assign to keyframe, no need to parse shorthand value
	            keyframe[member] = memberValue;
	        }
	        if (keyframe.offset === undefined) {
	            keyframe.offset = null;
	        }
	        if (keyframe.easing === undefined) {
	            // override with timing.easing
	            keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || 'linear';
	        }
	        if (keyframe.composite === undefined) {
	            keyframe.composite = 'auto';
	        }
	        return keyframe;
	    });
	    var everyFrameHasOffset = true;
	    var previousOffset = -Infinity;
	    for (var i = 0; i < keyframes.length; i++) {
	        var offset = keyframes[i].offset;
	        if (!isNil(offset)) {
	            if (offset < previousOffset) {
	                throw new TypeError('Keyframes are not loosely sorted by offset. Sort or specify offsets.');
	            }
	            previousOffset = offset;
	        }
	        else {
	            everyFrameHasOffset = false;
	        }
	    }
	    keyframes = keyframes.filter(function (keyframe) {
	        return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
	    });
	    function spaceKeyframes() {
	        var _a, _b;
	        var length = keyframes.length;
	        keyframes[length - 1].computedOffset = Number((_a = keyframes[length - 1].offset) !== null && _a !== void 0 ? _a : 1);
	        if (length > 1) {
	            keyframes[0].computedOffset = Number((_b = keyframes[0].offset) !== null && _b !== void 0 ? _b : 0);
	        }
	        var previousIndex = 0;
	        var previousOffset = Number(keyframes[0].computedOffset);
	        for (var i = 1; i < length; i++) {
	            var offset = keyframes[i].computedOffset;
	            if (!isNil(offset) && !isNil(previousOffset)) {
	                for (var j = 1; j < i - previousIndex; j++)
	                    keyframes[previousIndex + j].computedOffset =
	                        previousOffset + ((Number(offset) - previousOffset) * j) / (i - previousIndex);
	                previousIndex = i;
	                previousOffset = Number(offset);
	            }
	        }
	    }
	    if (!everyFrameHasOffset)
	        spaceKeyframes();
	    return keyframes;
	}

	var fills = 'backwards|forwards|both|none'.split('|');
	var directions = 'reverse|alternate|alternate-reverse'.split('|');
	function makeTiming(timingInput, forGroup) {
	    var timing = new AnimationEffectTiming();
	    if (forGroup) {
	        timing.fill = 'both';
	        timing.duration = 'auto';
	    }
	    if (typeof timingInput === 'number' && !isNaN(timingInput)) {
	        timing.duration = timingInput;
	    }
	    else if (timingInput !== undefined) {
	        Object.keys(timingInput).forEach(function (property) {
	            if (timingInput[property] !== undefined &&
	                timingInput[property] !== null &&
	                timingInput[property] !== 'auto') {
	                if (typeof timing[property] === 'number' || property === 'duration') {
	                    if (typeof timingInput[property] !== 'number' ||
	                        isNaN(timingInput[property])) {
	                        return;
	                    }
	                }
	                if (property === 'fill' &&
	                    fills.indexOf(timingInput[property]) === -1) {
	                    return;
	                }
	                if (property === 'direction' &&
	                    directions.indexOf(timingInput[property]) === -1) {
	                    return;
	                }
	                // @ts-ignore
	                timing[property] = timingInput[property];
	            }
	        });
	    }
	    return timing;
	}
	function normalizeTimingInput(timingInput, forGroup) {
	    timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : { duration: 'auto' });
	    return makeTiming(timingInput, forGroup);
	}
	function numericTimingToObject(timingInput) {
	    if (typeof timingInput === 'number') {
	        if (isNaN(timingInput)) {
	            timingInput = { duration: 'auto' };
	        }
	        else {
	            timingInput = { duration: timingInput };
	        }
	    }
	    return timingInput;
	}
	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect
	 * @example
	  const circleDownKeyframes = new KeyframeEffect(
	    circle, // element to animate
	    [
	      { transform: 'translateY(0)' }, // keyframe
	      { transform: 'translateY(100)' } // keyframe
	    ],
	    { duration: 3000, fill: 'forwards' } // keyframe options
	  );
	 *
	 */
	var KeyframeEffect = /** @class */ (function () {
	    function KeyframeEffect(target, effectInput, timingInput) {
	        var _this = this;
	        this.composite = 'replace';
	        this.iterationComposite = 'replace';
	        this.target = target;
	        this.timing = normalizeTimingInput(timingInput, false);
	        this.timing.effect = this;
	        this.timing.activeDuration = calculateActiveDuration(this.timing);
	        this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
	        this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
	        this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
	        // 不支持 proxy 时降级成 this.timing
	        var Proxy = runtime.globalThis.Proxy;
	        this.computedTiming = Proxy
	            ? new Proxy(this.timing, {
	                get: function (target, prop) {
	                    if (prop === 'duration') {
	                        return target.duration === 'auto' ? 0 : target.duration;
	                    }
	                    else if (prop === 'fill') {
	                        return target.fill === 'auto' ? 'none' : target.fill;
	                    }
	                    else if (prop === 'localTime') {
	                        return (_this.animation && _this.animation.currentTime) || null;
	                    }
	                    else if (prop === 'currentIteration') {
	                        if (!_this.animation || _this.animation.playState !== 'running') {
	                            return null;
	                        }
	                        return target.currentIteration || 0;
	                    }
	                    else if (prop === 'progress') {
	                        if (!_this.animation || _this.animation.playState !== 'running') {
	                            return null;
	                        }
	                        return target.progress || 0;
	                    }
	                    return target[prop];
	                },
	                set: function () {
	                    return true;
	                },
	            })
	            : this.timing;
	    }
	    KeyframeEffect.prototype.applyInterpolations = function () {
	        this.interpolations(this.target, Number(this.timeFraction));
	    };
	    KeyframeEffect.prototype.update = function (localTime) {
	        if (localTime === null) {
	            return false;
	        }
	        this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
	        return this.timeFraction !== null;
	    };
	    KeyframeEffect.prototype.getKeyframes = function () {
	        return this.normalizedKeyframes;
	    };
	    KeyframeEffect.prototype.setKeyframes = function (keyframes) {
	        this.normalizedKeyframes = normalizeKeyframes(keyframes);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
	     */
	    KeyframeEffect.prototype.getComputedTiming = function () {
	        return this.computedTiming;
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
	     */
	    KeyframeEffect.prototype.getTiming = function () {
	        return this.timing;
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
	     */
	    KeyframeEffect.prototype.updateTiming = function (timing) {
	        var _this = this;
	        Object.keys(timing || {}).forEach(function (name) {
	            _this.timing[name] = timing[name];
	        });
	    };
	    return KeyframeEffect;
	}());

	function compareAnimations(leftAnimation, rightAnimation) {
	    return Number(leftAnimation.id) - Number(rightAnimation.id);
	}
	/**
	 * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/web-animations-js/index.d.ts
	 */
	var AnimationTimeline = /** @class */ (function () {
	    function AnimationTimeline(document) {
	        var _this = this;
	        this.document = document;
	        /**
	         * all active animations
	         */
	        this.animations = [];
	        this.ticking = false;
	        this.timelineTicking = false;
	        this.hasRestartedThisFrame = false;
	        this.animationsWithPromises = [];
	        this.inTick = false;
	        this.pendingEffects = [];
	        this.currentTime = null;
	        this.rafId = 0;
	        this.rafCallbacks = [];
	        this.webAnimationsNextTick = function (t) {
	            _this.currentTime = t;
	            _this.discardAnimations();
	            if (_this.animations.length === 0) {
	                _this.timelineTicking = false;
	            }
	            else {
	                _this.requestAnimationFrame(_this.webAnimationsNextTick);
	            }
	        };
	        this.processRafCallbacks = function (t) {
	            var processing = _this.rafCallbacks;
	            _this.rafCallbacks = [];
	            if (t < Number(_this.currentTime))
	                t = Number(_this.currentTime);
	            _this.animations.sort(compareAnimations);
	            _this.animations = _this.tick(t, true, _this.animations)[0];
	            processing.forEach(function (entry) {
	                entry[1](t);
	            });
	            _this.applyPendingEffects();
	        };
	    }
	    AnimationTimeline.prototype.getAnimations = function () {
	        this.discardAnimations();
	        return this.animations.slice();
	    };
	    AnimationTimeline.prototype.isTicking = function () {
	        return this.inTick;
	    };
	    AnimationTimeline.prototype.play = function (target, keyframes, options) {
	        var effect = new KeyframeEffect(target, keyframes, options);
	        var animation = new Animation(effect, this);
	        this.animations.push(animation);
	        this.restartWebAnimationsNextTick();
	        animation.updatePromises();
	        animation.play();
	        animation.updatePromises();
	        return animation;
	    };
	    // RAF is supposed to be the last script to occur before frame rendering but not
	    // all browsers behave like this. This function is for synchonously updating an
	    // animation's effects whenever its state is mutated by script to work around
	    // incorrect script execution ordering by the browser.
	    AnimationTimeline.prototype.applyDirtiedAnimation = function (animation) {
	        var _this = this;
	        if (this.inTick) {
	            return;
	        }
	        // update active animations in displayobject
	        animation.markTarget();
	        var animations = animation.targetAnimations();
	        animations.sort(compareAnimations);
	        // clear inactive animations
	        var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
	        inactiveAnimations.forEach(function (animation) {
	            var index = _this.animations.indexOf(animation);
	            if (index !== -1) {
	                _this.animations.splice(index, 1);
	            }
	        });
	        this.applyPendingEffects();
	    };
	    AnimationTimeline.prototype.restart = function () {
	        if (!this.ticking) {
	            this.ticking = true;
	            this.requestAnimationFrame(function () { });
	            this.hasRestartedThisFrame = true;
	        }
	        return this.hasRestartedThisFrame;
	    };
	    AnimationTimeline.prototype.destroy = function () {
	        this.document.defaultView.cancelAnimationFrame(this.frameId);
	    };
	    AnimationTimeline.prototype.applyPendingEffects = function () {
	        this.pendingEffects.forEach(function (effect) {
	            effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();
	        });
	        this.pendingEffects = [];
	    };
	    AnimationTimeline.prototype.updateAnimationsPromises = function () {
	        this.animationsWithPromises = this.animationsWithPromises.filter(function (animation) {
	            return animation.updatePromises();
	        });
	    };
	    AnimationTimeline.prototype.discardAnimations = function () {
	        this.updateAnimationsPromises();
	        this.animations = this.animations.filter(function (animation) {
	            return animation.playState !== 'finished' && animation.playState !== 'idle';
	        });
	    };
	    AnimationTimeline.prototype.restartWebAnimationsNextTick = function () {
	        if (!this.timelineTicking) {
	            this.timelineTicking = true;
	            this.requestAnimationFrame(this.webAnimationsNextTick);
	        }
	    };
	    AnimationTimeline.prototype.rAF = function (f) {
	        var id = this.rafId++;
	        if (this.rafCallbacks.length === 0) {
	            this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
	        }
	        this.rafCallbacks.push([id, f]);
	        return id;
	    };
	    AnimationTimeline.prototype.requestAnimationFrame = function (f) {
	        var _this = this;
	        return this.rAF(function (x) {
	            _this.updateAnimationsPromises();
	            f(x);
	            _this.updateAnimationsPromises();
	        });
	    };
	    AnimationTimeline.prototype.tick = function (t, isAnimationFrame, updatingAnimations) {
	        var _a, _b;
	        var _this = this;
	        this.inTick = true;
	        this.hasRestartedThisFrame = false;
	        this.currentTime = t;
	        this.ticking = false;
	        var newPendingClears = [];
	        var newPendingEffects = [];
	        var activeAnimations = [];
	        var inactiveAnimations = [];
	        updatingAnimations.forEach(function (animation) {
	            animation.tick(t, isAnimationFrame);
	            if (!animation._inEffect) {
	                newPendingClears.push(animation.effect);
	                animation.unmarkTarget();
	            }
	            else {
	                newPendingEffects.push(animation.effect);
	                animation.markTarget();
	            }
	            if (animation._needsTick)
	                _this.ticking = true;
	            var alive = animation._inEffect || animation._needsTick;
	            animation._inTimeline = alive;
	            if (alive) {
	                activeAnimations.push(animation);
	            }
	            else {
	                inactiveAnimations.push(animation);
	            }
	        });
	        (_a = this.pendingEffects).push.apply(_a, __spreadArray([], __read(newPendingClears), false));
	        (_b = this.pendingEffects).push.apply(_b, __spreadArray([], __read(newPendingEffects), false));
	        if (this.ticking)
	            this.requestAnimationFrame(function () { });
	        this.inTick = false;
	        return [activeAnimations, inactiveAnimations];
	    };
	    return AnimationTimeline;
	}());

	runtime.EasingFunction = parseEasingFunction;
	runtime.AnimationTimeline = AnimationTimeline;

	function measureText(container, px2hd, theme) {
	  return function (text, font) {
	    var _ref = font || {},
	      _ref$fontSize = _ref.fontSize,
	      fontSize = _ref$fontSize === void 0 ? theme.fontSize : _ref$fontSize,
	      _ref$fontFamily = _ref.fontFamily,
	      fontFamily = _ref$fontFamily === void 0 ? theme.fontFamily : _ref$fontFamily,
	      _ref$fontWeight = _ref.fontWeight,
	      fontWeight = _ref$fontWeight === void 0 ? theme.fontWeight : _ref$fontWeight,
	      _ref$fontVariant = _ref.fontVariant,
	      fontVariant = _ref$fontVariant === void 0 ? theme.fontVariant : _ref$fontVariant,
	      _ref$fontStyle = _ref.fontStyle,
	      fontStyle = _ref$fontStyle === void 0 ? theme.fontStyle : _ref$fontStyle,
	      _ref$textAlign = _ref.textAlign,
	      textAlign = _ref$textAlign === void 0 ? theme.textAlign : _ref$textAlign,
	      _ref$textBaseline = _ref.textBaseline,
	      textBaseline = _ref$textBaseline === void 0 ? theme.textBaseline : _ref$textBaseline,
	      _ref$lineWidth = _ref.lineWidth,
	      lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth;
	    var style = {
	      x: 0,
	      y: 0,
	      fontSize: px2hd(fontSize),
	      fontFamily: fontFamily,
	      fontStyle: fontStyle,
	      fontWeight: fontWeight,
	      fontVariant: fontVariant,
	      text: text,
	      textAlign: textAlign,
	      textBaseline: textBaseline,
	      lineWidth: lineWidth,
	      visibility: 'hidden'
	    };
	    var result = checkCSSRule('text', style);
	    var shape = new Text({
	      style: result
	    });
	    container.appendChild(shape);
	    var _shape$getBBox = shape.getBBox(),
	      width = _shape$getBBox.width,
	      height = _shape$getBBox.height;
	    shape.remove();
	    return {
	      width: width,
	      height: height
	    };
	  };
	}
	function computeLayout$2(style) {
	  var left = style.left,
	    top = style.top,
	    width = style.width,
	    height = style.height,
	    padding = style.padding;
	  var _padding = _slicedToArray(padding, 4),
	    paddingTop = _padding[0],
	    paddingRight = _padding[1],
	    paddingBottom = _padding[2],
	    paddingLeft = _padding[3];
	  return {
	    left: left + paddingLeft,
	    top: top + paddingTop,
	    width: width - paddingLeft - paddingRight,
	    height: height - paddingTop - paddingBottom
	  };
	}
	// 顶层Canvas标签
	var Canvas$1 = /*#__PURE__*/function () {
	  function Canvas$1(props) {
	    _classCallCheck(this, Canvas$1);
	    var context = props.context,
	      _props$renderer = props.renderer,
	      renderer = _props$renderer === void 0 ? new Renderer() : _props$renderer,
	      width = props.width,
	      height = props.height,
	      customTheme = props.theme,
	      customPx2hd = props.px2hd,
	      customPixelRatio = props.pixelRatio,
	      landscape = props.landscape,
	      rendererContainer = props.container,
	      _props$animate = props.animate,
	      animate = _props$animate === void 0 ? true : _props$animate,
	      createImage = props.createImage,
	      requestAnimationFrame = props.requestAnimationFrame,
	      cancelAnimationFrame = props.cancelAnimationFrame;
	    var px2hd$1 = isFunction(customPx2hd) ? batch2hd(customPx2hd) : px2hd;
	    // 初始化主题
	    var theme = px2hd$1(_objectSpread(_objectSpread({}, THEME), customTheme));
	    var pixelRatio = theme.pixelRatio,
	      fontSize = theme.fontSize,
	      fontFamily = theme.fontFamily;
	    var devicePixelRatio = customPixelRatio ? customPixelRatio : pixelRatio;
	    // 组件更新器
	    var updater = createUpdater(this);
	    var canvasElement = createMobileCanvasElement(context);
	    var canvas = new Canvas({
	      container: rendererContainer,
	      canvas: canvasElement,
	      devicePixelRatio: devicePixelRatio,
	      renderer: renderer,
	      width: width,
	      height: height,
	      supportsTouchEvents: true,
	      // https://caniuse.com/?search=PointerEvent ios 13 以下不支持 Pointer
	      supportsPointerEvents: runtime.globalThis.PointerEvent ? true : false,
	      // 允许在canvas外部触发
	      alwaysTriggerPointerEventOnCanvas: true,
	      createImage: createImage,
	      requestAnimationFrame: requestAnimationFrame,
	      cancelAnimationFrame: cancelAnimationFrame,
	      useNativeClickEvent: true
	    });
	    var container = canvas.getRoot();
	    var _canvas$getConfig = canvas.getConfig(),
	      canvasWidth = _canvas$getConfig.width,
	      canvasHeight = _canvas$getConfig.height;
	    // 设置默认的全局样式
	    container.setAttribute('fontSize', fontSize);
	    container.setAttribute('fontFamily', fontFamily);
	    var gesture = new Gesture$1(container);
	    // 供全局使用的一些变量
	    var componentContext = {
	      ctx: context,
	      root: this,
	      canvas: canvas,
	      px2hd: px2hd$1,
	      theme: theme,
	      gesture: gesture,
	      measureText: measureText(container, px2hd$1, theme),
	      timeline: null
	    };
	    var vNode = {
	      key: undefined,
	      tag: ClassComponent,
	      // style: layout,
	      // @ts-ignore
	      type: Canvas$1,
	      props: props,
	      shape: container,
	      animate: animate,
	      // @ts-ignore
	      component: this,
	      canvas: this,
	      context: componentContext,
	      updater: updater
	    };
	    this._ee = new eventemitter3$1();
	    this.props = props;
	    this.context = componentContext;
	    this.updater = updater;
	    this.gesture = gesture;
	    this.theme = theme;
	    this.canvas = canvas;
	    this.container = container;
	    this.el = canvasElement;
	    this.vNode = vNode;
	    // todo: 横屏事件逻辑
	    this.landscape = landscape;
	    this.updateLayout(_objectSpread(_objectSpread({}, props), {}, {
	      width: canvasWidth,
	      height: canvasHeight
	    }));
	  }
	  _createClass(Canvas$1, [{
	    key: "updateComponents",
	    value: function updateComponents$1(components) {
	      updateComponents(components);
	    }
	  }, {
	    key: "update",
	    value: function () {
	      var _update = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(nextProps) {
	        var props, vNode, _props$animate2, animate;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              props = this.props, vNode = this.vNode;
	              if (!equal(nextProps, props)) {
	                _context.next = 3;
	                break;
	              }
	              return _context.abrupt("return");
	            case 3:
	              _props$animate2 = props.animate, animate = _props$animate2 === void 0 ? true : _props$animate2;
	              this.props = nextProps;
	              vNode.props = nextProps;
	              vNode.animate = animate;
	              _context.next = 9;
	              return this.render();
	            case 9:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function update(_x) {
	        return _update.apply(this, arguments);
	      }
	      return update;
	    }()
	  }, {
	    key: "render",
	    value: function () {
	      var _render2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
	        var canvas, vNode;
	        return regenerator.wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              canvas = this.canvas, vNode = this.vNode;
	              _context2.next = 3;
	              return canvas.ready;
	            case 3:
	              render(vNode);
	            case 4:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this);
	      }));
	      function render$1() {
	        return _render2.apply(this, arguments);
	      }
	      return render$1;
	    }()
	  }, {
	    key: "emit",
	    value: function emit(type, event) {
	      this._ee.emit(type, event);
	    }
	  }, {
	    key: "on",
	    value: function on(type, listener) {
	      this._ee.on(type, listener);
	    }
	  }, {
	    key: "off",
	    value: function off(type, listener) {
	      this._ee.off(type, listener);
	    }
	  }, {
	    key: "getCanvasEl",
	    value: function getCanvasEl() {
	      return this.el;
	    }
	  }, {
	    key: "resize",
	    value: function () {
	      var _resize = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(width, height) {
	        var canvas;
	        return regenerator.wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              canvas = this.canvas;
	              canvas.resize(width, height);
	              this.updateLayout(_objectSpread(_objectSpread({}, this.props), {}, {
	                width: width,
	                height: height
	              }));
	              _context3.next = 5;
	              return this.render();
	            case 5:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function resize(_x2, _x3) {
	        return _resize.apply(this, arguments);
	      }
	      return resize;
	    }()
	  }, {
	    key: "toDataURL",
	    value: function () {
	      var _toDataURL = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(type, encoderOptions) {
	        var canvas;
	        return regenerator.wrap(function _callee4$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              canvas = this.canvas;
	              return _context4.abrupt("return", new Promise(function (resolve) {
	                canvas.addEventListener('rerender', function () {
	                  canvas.getContextService().toDataURL({
	                    type: type,
	                    encoderOptions: encoderOptions
	                  }).then(resolve);
	                }, {
	                  once: true
	                });
	              }));
	            case 2:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee4, this);
	      }));
	      function toDataURL(_x4, _x5) {
	        return _toDataURL.apply(this, arguments);
	      }
	      return toDataURL;
	    }()
	  }, {
	    key: "updateLayout",
	    value: function updateLayout(props) {
	      var width = props.width,
	        height = props.height;
	      var _this$context = this.context,
	        px2hd = _this$context.px2hd,
	        theme = _this$context.theme;
	      var style = px2hd(_objectSpread({
	        left: 0,
	        top: 0,
	        width: width,
	        height: height,
	        padding: theme.padding
	      }, props.style));
	      var layout = computeLayout$2(style);
	      var left = layout.left,
	        top = layout.top;
	      // 设置 container 的位置
	      this.container.setAttribute('x', left);
	      this.container.setAttribute('y', top);
	      this.context = _objectSpread(_objectSpread({}, this.context), {}, {
	        left: left,
	        top: top,
	        width: layout.width,
	        height: layout.height
	      });
	      this.vNode = _objectSpread(_objectSpread({}, this.vNode), {}, {
	        style: layout,
	        context: this.context
	      });
	    }
	  }, {
	    key: "toRawChildren",
	    value: function toRawChildren(children) {
	      return children;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      var canvas = this.canvas,
	        children = this.children,
	        el = this.el;
	      destroyElement(children);
	      // 需要清理 canvas 画布内容，否则会导致 spa 应用 ios 下 canvas 白屏
	      // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12
	      // https://github.com/antvis/F2/issues/630
	      el.width = 0;
	      el.height = 0;
	      this.props = null;
	      this.context = null;
	      this.updater = null;
	      this.theme = null;
	      this.canvas = null;
	      this.container = null;
	      this.el = null;
	      this.vNode = null;
	      // 销毁也需要等 ready
	      canvas.ready.then(function () {
	        canvas.destroy();
	      });
	    }
	  }]);
	  return Canvas$1;
	}();

	function createRef() {
	  var ref = {
	    current: null
	  };
	  return ref;
	}

	var _excluded$2 = ["children"];
	function createContext(defaultValue) {
	  // 创建 Context 对象
	  var context = {
	    _currentValue: defaultValue
	  };
	  // 定义 Provider 组件
	  var Provider = function Provider(_ref) {
	    var value = _ref.value,
	      children = _ref.children;
	    context._currentValue = value;
	    return children;
	  };
	  // Injecter 可以往全局的 context 注入内容
	  var Injecter = function Injecter(_ref2, context) {
	    var children = _ref2.children,
	      props = _objectWithoutProperties(_ref2, _excluded$2);
	    Object.assign(context, props);
	    return children;
	  };
	  Injecter.contextInjecter = context;
	  // 定义 Consumer 组件
	  var Consumer = function Consumer(_ref3) {
	    var children = _ref3.children;
	    return children(context._currentValue);
	  };
	  context.Provider = Provider;
	  context.Injecter = Injecter;
	  context.Consumer = Consumer;
	  return context;
	}

	var Timeline = /*#__PURE__*/function (_Component) {
	  _inherits(Timeline, _Component);
	  var _super = _createSuper(Timeline);
	  function Timeline(props) {
	    var _this;
	    _classCallCheck(this, Timeline);
	    _this = _super.call(this, props);
	    _this.next = function () {
	      var _assertThisInitialize = _assertThisInitialized(_this),
	        state = _assertThisInitialize.state,
	        props = _assertThisInitialize.props;
	      var index = state.index,
	        count = state.count,
	        delay = state.delay;
	      var loop = props.loop,
	        _props$autoPlay = props.autoPlay,
	        autoPlay = _props$autoPlay === void 0 ? true : _props$autoPlay;
	      var next = loop ? (index + 1) % count : index + 1;
	      if (next < count && autoPlay) {
	        setTimeout(function () {
	          _this.setState({
	            index: next
	          });
	        }, delay || 0);
	      }
	    };
	    var delay = props.delay,
	      _props$start = props.start,
	      start = _props$start === void 0 ? 0 : _props$start,
	      children = props.children;
	    var count = Children.toArray(children).length;
	    _this.state = {
	      delay: delay,
	      count: count,
	      index: start
	    };
	    return _this;
	  }
	  _createClass(Timeline, [{
	    key: "didMount",
	    value: function didMount() {
	      var _this$props$autoPlay = this.props.autoPlay,
	        autoPlay = _this$props$autoPlay === void 0 ? true : _this$props$autoPlay;
	      if (autoPlay) {
	        this.animator.on('end', this.next);
	      }
	    }
	  }, {
	    key: "didUnmount",
	    value: function didUnmount() {
	      this.animator.off('end', this.next);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var state = this.state,
	        props = this.props;
	      var children = props.children;
	      var index = state.index;
	      var childrenArray = Children.toArray(children);
	      return childrenArray[index];
	    }
	  }]);
	  return Timeline;
	}(Component);

	var Timeline$1 = /*#__PURE__*/function () {
	  function Timeline(playComponent) {
	    _classCallCheck(this, Timeline);
	    this.frame = 0;
	    this.playState = 'play';
	    this.animations = [];
	    this.play = playComponent;
	  }
	  _createClass(Timeline, [{
	    key: "setPlayState",
	    value: function setPlayState(state) {
	      this.playState = state;
	      var animator = this.play.animator;
	      switch (state) {
	        case 'play':
	          animator.play();
	          break;
	        case 'pause':
	          animator.pause();
	          break;
	        case 'finish':
	          animator.finish();
	          break;
	      }
	    }
	  }, {
	    key: "goTo",
	    value: function goTo(frame) {
	      if (!frame) return;
	      var animator = this.play.animator;
	      animator.goTo(frame);
	    }
	  }, {
	    key: "add",
	    value: function add(animation) {
	      var frame = this.frame;
	      if (this.animations[frame]) {
	        animation.map(function (d) {
	          return d.cancel();
	        });
	        return;
	      }
	      this.animations[frame] = animation;
	    }
	  }, {
	    key: "getAnimation",
	    value: function getAnimation() {
	      var frame = this.frame;
	      return this.animations[frame];
	    }
	  }, {
	    key: "push",
	    value: function push(animation) {
	      var frame = this.frame;
	      if (!this.animations[frame]) return;
	      this.animations[0] = this.animations[frame].concat(animation);
	    }
	  }, {
	    key: "pop",
	    value: function pop() {
	      var frame = this.frame;
	      this.animations[frame].pop();
	    }
	  }, {
	    key: "delete",
	    value: function _delete(animation) {
	      var frame = this.frame;
	      if (!animation || !this.animations[frame]) return;
	      this.animations[frame].filter(function (d) {
	        return d !== animation;
	      });
	    }
	  }, {
	    key: "replace",
	    value: function replace(next) {
	      var _this = this;
	      var frame = this.frame;
	      if (!this.animations[frame]) return;
	      var newAnimation = next.map(function (index) {
	        return _this.animations[frame].map(function (d) {
	          if (index === d) {
	            return index;
	          }
	          return d;
	        });
	      });
	      this.animations = newAnimation;
	    }
	  }]);
	  return Timeline;
	}();

	var Player = /*#__PURE__*/function (_Component) {
	  _inherits(Player, _Component);
	  var _super = _createSuper(Player);
	  function Player() {
	    _classCallCheck(this, Player);
	    return _super.apply(this, arguments);
	  }
	  _createClass(Player, [{
	    key: "setPlayState",
	    value: function setPlayState() {
	      var props = this.props,
	        context = this.context;
	      var frame = props.frame,
	        playState = props.state;
	      var timeline = context.timeline;
	      timeline.goTo(frame);
	      timeline.setPlayState(playState);
	    }
	  }, {
	    key: "willMount",
	    value: function willMount() {
	      this.context.timeline = new Timeline$1(this);
	    }
	  }, {
	    key: "animationWillPlay",
	    value: function animationWillPlay() {
	      var animator = this.animator,
	        context = this.context;
	      // @ts-ignore
	      var timeline = context.timeline;
	      var animations = animator.animations;
	      timeline.add(animations);
	      animator.animations = timeline.getAnimation();
	      this.setPlayState();
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return this.props.children;
	    }
	  }]);
	  return Player;
	}(Component);

	exports.Canvas = Canvas$1;
	exports.CanvasRenderer = Renderer;
	exports.Children = Children;
	exports.Component = Component;
	exports.Fragment = fragment;
	exports.Gesture = Gesture$1;
	exports.Player = Player;
	exports.Smooth = smooth;
	exports.Timeline = Timeline;
	exports.computeLayout = computeLayout$1;
	exports.createContext = createContext;
	exports.createElement = jsx;
	exports.createRef = createRef;
	exports.isEqual = equal;
	exports.jsx = jsx;
	exports.registerTag = registerTag;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
