"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Arc = void 0;
var _tslib = require("tslib");
var _gLite = require("@antv/g-lite");
var _util = require("@antv/util");
var _util2 = require("./util/util");
function computeArcSweep(startAngle, endAngle, anticlockwise) {
  // 顺时针方向
  if (!anticlockwise) {
    if (endAngle >= startAngle) {
      return endAngle - startAngle <= Math.PI ? 0 : 1;
    }
    return endAngle - startAngle <= -Math.PI ? 0 : 1;
  }
  // 逆时针方向
  if (endAngle >= startAngle) {
    return endAngle - startAngle <= Math.PI ? 1 : 0;
  }
  return endAngle - startAngle <= -Math.PI ? 1 : 0;
}
var Arc = /** @class */function (_super) {
  (0, _tslib.__extends)(Arc, _super);
  function Arc(config) {
    var _this = _super.call(this, config) || this;
    _this.updatePath();
    return _this;
  }
  Arc.prototype.setAttribute = function (name, value, force) {
    _super.prototype.setAttribute.call(this, name, value, force);
    if (['cx', 'cy', 'startAngle', 'endAngle', 'r', 'anticlockwise'].indexOf(name) > -1) {
      this.updatePath();
    }
  };
  Arc.prototype.updatePath = function () {
    var _a = this.parsedStyle,
      _b = _a.cx,
      cx = _b === void 0 ? 0 : _b,
      _c = _a.cy,
      cy = _c === void 0 ? 0 : _c,
      startAngle = _a.startAngle,
      endAngle = _a.endAngle,
      r = _a.r,
      anticlockwise = _a.anticlockwise;
    if ((0, _util.isNil)(startAngle) || (0, _util.isNil)(endAngle) || startAngle === endAngle || (0, _util.isNil)(r) || r <= 0) {
      return;
    }
    var path = this.createPath(cx, cy, (0, _gLite.deg2rad)(startAngle), (0, _gLite.deg2rad)(endAngle), r, anticlockwise);
    _super.prototype.setAttribute.call(this, 'path', path);
  };
  Arc.prototype.createPath = function (x, y, startAngle, endAngle, r, anticlockwise) {
    var start = (0, _util2.polarToCartesian)(x, y, r, startAngle);
    var end = (0, _util2.polarToCartesian)(x, y, r, endAngle);
    var angle = Math.abs(endAngle - startAngle);
    if (angle >= Math.PI * 2 || (0, _util.isNumberEqual)(angle, Math.PI * 2)) {
      var middlePoint = (0, _util2.polarToCartesian)(x, y, r, startAngle + Math.PI);
      return [['M', start.x, start.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, middlePoint.x, middlePoint.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, start.x, start.y], ['Z']];
    }
    var arcSweep = computeArcSweep(startAngle, endAngle, anticlockwise);
    return [['M', start.x, start.y], ['A', r, r, 0, arcSweep, anticlockwise ? 0 : 1, end.x, end.y]];
  };
  return Arc;
}(_gLite.Path);
exports.Arc = Arc;