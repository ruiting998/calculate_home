"use strict";

var _fEngine = require("@antv/f-engine");
var _f2Context = require("@antv/f2-context");
var _raf = require("./raf");
function wrapEvent(e) {
  if (!e) return;
  if (!e.preventDefault) {
    e.preventDefault = function () {};
  }
  return e;
}
var getPixelRatio = function getPixelRatio() {
  return my.getSystemInfoSync().pixelRatio;
};
// 判断是否是新版 canvas 所支持的调用方法（AppX 2.7.0 及以上）
var isAppX2CanvasEnv = function isAppX2CanvasEnv() {
  return my.canIUse('canvas.onReady') && my.canIUse('createSelectorQuery.return.node');
};
Component({
  props: {
    onRender: function onRender(_props) {},
    // width height 会作为元素兜底的宽高使用
    width: null,
    height: null,
    type: '2d' // canvas 2d, 基础库 2.7 以上支持
  },

  /**
   * 组件创建时触发
   * 注意：
   *    使用该生命周期，项目配置需启用："component2": true
   */
  onInit: function onInit() {
    this.setCanvasId();
  },
  didMount: function didMount() {
    var _this = this;
    if (isAppX2CanvasEnv()) {
      return;
    }
    var id = this.data.id;
    var query = my.createSelectorQuery({
      page: this.$page
    });
    query.select("#".concat(id)).boundingClientRect().exec(function (res) {
      // 获取画布实际宽高, 用props的宽高做失败兜底
      var _a = res && res[0] ? res[0] : _this.props,
        width = _a.width,
        height = _a.height;
      var pixelRatio = getPixelRatio();
      // 高清解决方案
      _this.setData({
        width: width * pixelRatio,
        height: height * pixelRatio
      }, function () {
        var myCtx = my.createCanvasContext(id);
        var context = (0, _f2Context.my)(myCtx);
        var fCanvas = _this.createCanvas({
          width: width,
          height: height,
          context: context,
          pixelRatio: pixelRatio,
          createImage: function createImage(src) {
            return src;
          },
          requestAnimationFrame: _raf.raf,
          cancelAnimationFrame: _raf.caf
        });
        fCanvas.render();
      });
    });
  },
  didUpdate: function didUpdate() {
    var _a = this,
      canvas = _a.canvas,
      props = _a.props;
    if (!canvas) return;
    var children = props.onRender(props);
    canvas.update({
      children: children
    });
  },
  didUnmount: function didUnmount() {
    var canvas = this.canvas;
    if (!canvas) return;
    canvas.destroy();
  },
  methods: {
    setCanvasId: function setCanvasId() {
      var pageId = this.$page && this.$page.$id || 0;
      var id = "f-canvas-".concat(pageId, "-").concat(this.$id);
      this.setData({
        id: id
      });
    },
    onCanvasReady: function onCanvasReady() {
      var _this = this;
      var id = this.data.id;
      var query = my.createSelectorQuery();
      query.select("#".concat(id))
      // @ts-ignore
      .node().exec(function (res) {
        if (!res[0]) {
          return;
        }
        var canvas = res[0].node;
        var width = canvas.width,
          height = canvas.height,
          createImage = canvas.createImage,
          requestAnimationFrame = canvas.requestAnimationFrame,
          cancelAnimationFrame = canvas.cancelAnimationFrame;
        var pixelRatio = getPixelRatio();
        canvas.width = width * pixelRatio;
        canvas.height = height * pixelRatio;
        var context = canvas.getContext('2d');
        var fCanvas = _this.createCanvas({
          width: width,
          height: height,
          pixelRatio: pixelRatio,
          context: context,
          createImage: createImage,
          requestAnimationFrame: requestAnimationFrame,
          cancelAnimationFrame: cancelAnimationFrame
        });
        fCanvas.render();
      });
    },
    createCanvas: function createCanvas(_a) {
      var width = _a.width,
        height = _a.height,
        pixelRatio = _a.pixelRatio,
        context = _a.context,
        createImage = _a.createImage,
        requestAnimationFrame = _a.requestAnimationFrame,
        cancelAnimationFrame = _a.cancelAnimationFrame;
      if (!width || !height) {
        return;
      }
      var children = this.props.onRender(this.props);
      var canvas = new _fEngine.Canvas({
        pixelRatio: pixelRatio,
        width: width,
        height: height,
        context: context,
        children: children,
        createImage: createImage,
        requestAnimationFrame: requestAnimationFrame,
        cancelAnimationFrame: cancelAnimationFrame
      });
      this.canvas = canvas;
      this.canvasEl = canvas.getCanvasEl();
      return canvas;
    },
    click: function click(e) {
      var canvasEl = this.canvasEl;
      if (!canvasEl) {
        return;
      }
      var event = wrapEvent(e);
      // 包装成 touch 对象
      event.touches = [e.detail];
      canvasEl.dispatchEvent('click', event);
    },
    touchStart: function touchStart(e) {
      var canvasEl = this.canvasEl;
      if (!canvasEl) {
        return;
      }
      canvasEl.dispatchEvent('touchstart', wrapEvent(e));
    },
    touchMove: function touchMove(e) {
      var canvasEl = this.canvasEl;
      if (!canvasEl) {
        return;
      }
      canvasEl.dispatchEvent('touchmove', wrapEvent(e));
    },
    touchEnd: function touchEnd(e) {
      var canvasEl = this.canvasEl;
      if (!canvasEl) {
        return;
      }
      canvasEl.dispatchEvent('touchend', wrapEvent(e));
    }
  }
});