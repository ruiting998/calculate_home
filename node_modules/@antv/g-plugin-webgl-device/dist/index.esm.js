import { __extends, __awaiter, __generator, __values, __spreadArray, __read, __assign } from 'tslib';
import { AbstractRendererPlugin } from '@antv/g-lite';
import { ResourceType, assert, getFormatFlags, FormatFlags, getFormatTypeFlags, FormatTypeFlags, BufferFrequencyHint, GL, BufferUsage, PrimitiveTopology, getFormatCompFlags, Format, WrapMode, MipFilterMode, TexFilterMode, QueryPoolType, TextureDimension, FormatCompFlags, BlendMode, BlendFactor, align, assertExists, VertexBufferFrequency, getFormatCompByteSize, getFormatSamplerKind, isPowerOfTwo, preprocessShader_GLSL, getDefines, getAttributeLocations, parseUniformName, getUniformSetter, nArray, getFormatByteSize, defaultBindingLayoutSamplerDescriptor, copyMegaState, defaultMegaState, ViewportOrigin, ClipSpaceNearZ, TextureUsage, SamplerFormatKind, CompareMode, ChannelWriteMask, nullify, prependLineNo, colorEqual, colorCopy, CullMode, makeDataBuffer, preprocessProgramObj_GLSL, CopyProgram, TransparentWhite } from '@antv/g-plugin-device-renderer';
import EventEmitter from 'eventemitter3';
import { isNumber, isNil, clamp } from '@antv/util';

var ResourceBase_GL = /** @class */ (function (_super) {
    __extends(ResourceBase_GL, _super);
    function ResourceBase_GL(_a) {
        var id = _a.id, device = _a.device;
        var _this = _super.call(this) || this;
        _this.id = id;
        _this.device = device;
        if (_this.device.resourceCreationTracker !== null) {
            _this.device.resourceCreationTracker.trackResourceCreated(_this);
        }
        return _this;
    }
    ResourceBase_GL.prototype.destroy = function () {
        if (this.device.resourceCreationTracker !== null) {
            this.device.resourceCreationTracker.trackResourceDestroyed(this);
        }
    };
    return ResourceBase_GL;
}(EventEmitter));

var Bindings_GL = /** @class */ (function (_super) {
    __extends(Bindings_GL, _super);
    function Bindings_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.Bindings;
        var bindingLayout = descriptor.bindingLayout, uniformBufferBindings = descriptor.uniformBufferBindings, samplerBindings = descriptor.samplerBindings;
        assert(uniformBufferBindings.length >= bindingLayout.numUniformBuffers);
        assert(samplerBindings.length >= bindingLayout.numSamplers);
        for (var i = 0; i < bindingLayout.numUniformBuffers; i++) {
            assert(uniformBufferBindings[i].wordCount > 0);
        }
        _this.uniformBufferBindings = descriptor.uniformBufferBindings;
        _this.samplerBindings = descriptor.samplerBindings;
        return _this;
    }
    return Bindings_GL;
}(ResourceBase_GL));

// @see https://github.com/visgl/luma.gl/blob/30a1039573576d73641de7c1ba222e8992eb526e/modules/gltools/src/utils/webgl-checks.ts#L22
function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== 'undefined' &&
        gl instanceof WebGL2RenderingContext) {
        return true;
    }
    // Look for debug contexts, headless gl etc
    // @ts-ignore
    return Boolean(gl && gl._version === 2);
}
function isTextureFormatCompressed(fmt) {
    var typeFlags = getFormatTypeFlags(fmt);
    switch (typeFlags) {
        case FormatTypeFlags.BC1:
        case FormatTypeFlags.BC2:
        case FormatTypeFlags.BC3:
        case FormatTypeFlags.BC4_UNORM:
        case FormatTypeFlags.BC4_SNORM:
        case FormatTypeFlags.BC5_UNORM:
        case FormatTypeFlags.BC5_SNORM:
            return true;
        default:
            return false;
    }
}
function isFormatSizedInteger(fmt) {
    var flags = getFormatFlags(fmt);
    if (flags & FormatFlags.Normalized)
        return false;
    var typeFlags = getFormatTypeFlags(fmt);
    // Check for integer types.
    if (typeFlags === FormatTypeFlags.S8 ||
        typeFlags === FormatTypeFlags.S16 ||
        typeFlags === FormatTypeFlags.S32)
        return true;
    if (typeFlags === FormatTypeFlags.U8 ||
        typeFlags === FormatTypeFlags.U16 ||
        typeFlags === FormatTypeFlags.U32)
        return true;
    return false;
}
function translateBufferHint(hint) {
    switch (hint) {
        case BufferFrequencyHint.Static:
            return GL.STATIC_DRAW;
        case BufferFrequencyHint.Dynamic:
            return GL.DYNAMIC_DRAW;
    }
}
function translateBufferUsageToTarget(usage) {
    if (usage & BufferUsage.INDEX) {
        return GL.ELEMENT_ARRAY_BUFFER;
    }
    else if (usage & BufferUsage.VERTEX) {
        return GL.ARRAY_BUFFER;
    }
    else if (usage & BufferUsage.UNIFORM) {
        return GL.UNIFORM_BUFFER;
    }
}
function translatePrimitiveTopology(topology) {
    switch (topology) {
        case PrimitiveTopology.Triangles:
            return GL.TRIANGLES;
        case PrimitiveTopology.Points:
            return GL.POINTS;
        case PrimitiveTopology.TriangleStrip:
            return GL.TRIANGLE_STRIP;
        case PrimitiveTopology.Lines:
            return GL.LINES;
        case PrimitiveTopology.LineStrip:
            return GL.LINE_STRIP;
        default:
            throw new Error('Unknown primitive topology mode');
    }
}
function translateType(flags) {
    switch (flags) {
        case FormatTypeFlags.U8:
            return GL.UNSIGNED_BYTE;
        case FormatTypeFlags.U16:
            return GL.UNSIGNED_SHORT;
        case FormatTypeFlags.U32:
            return GL.UNSIGNED_INT;
        case FormatTypeFlags.S8:
            return GL.BYTE;
        case FormatTypeFlags.S16:
            return GL.SHORT;
        case FormatTypeFlags.S32:
            return GL.INT;
        case FormatTypeFlags.F16:
            return GL.HALF_FLOAT;
        case FormatTypeFlags.F32:
            return GL.FLOAT;
        default:
            throw new Error('whoops');
    }
}
function translateSize(flags) {
    switch (flags) {
        case FormatCompFlags.R:
            return 1;
        case FormatCompFlags.RG:
            return 2;
        case FormatCompFlags.RGB:
            return 3;
        case FormatCompFlags.RGBA:
            return 4;
        default:
            return 1;
    }
}
function translateVertexFormat(fmt) {
    var typeFlags = getFormatTypeFlags(fmt);
    var compFlags = getFormatCompFlags(fmt);
    var flags = getFormatFlags(fmt);
    var type = translateType(typeFlags);
    var size = translateSize(compFlags);
    var normalized = !!(flags & FormatFlags.Normalized);
    return { size: size, type: type, normalized: normalized };
}
function translateIndexFormat(format) {
    switch (format) {
        case Format.U8_R:
            return GL.UNSIGNED_BYTE;
        case Format.U16_R:
            return GL.UNSIGNED_SHORT;
        case Format.U32_R:
            return GL.UNSIGNED_INT;
        default:
            throw new Error('whoops');
    }
}
function translateWrapMode(wrapMode) {
    switch (wrapMode) {
        case WrapMode.Clamp:
            return GL.CLAMP_TO_EDGE;
        case WrapMode.Repeat:
            return GL.REPEAT;
        case WrapMode.Mirror:
            return GL.MIRRORED_REPEAT;
        default:
            throw new Error('whoops');
    }
}
function translateFilterMode(filter, mipFilter) {
    if (mipFilter === MipFilterMode.Linear && filter === TexFilterMode.Bilinear) {
        return GL.LINEAR_MIPMAP_LINEAR;
    }
    if (mipFilter === MipFilterMode.Linear && filter === TexFilterMode.Point) {
        return GL.NEAREST_MIPMAP_LINEAR;
    }
    if (mipFilter === MipFilterMode.Nearest &&
        filter === TexFilterMode.Bilinear) {
        return GL.LINEAR_MIPMAP_NEAREST;
    }
    if (mipFilter === MipFilterMode.Nearest && filter === TexFilterMode.Point) {
        return GL.NEAREST_MIPMAP_NEAREST;
    }
    if (mipFilter === MipFilterMode.NoMip && filter === TexFilterMode.Bilinear) {
        return GL.LINEAR;
    }
    if (mipFilter === MipFilterMode.NoMip && filter === TexFilterMode.Point) {
        return GL.NEAREST;
    }
    throw new Error('Unknown texture filter mode');
}
function getPlatformBuffer(buffer_, byteOffset) {
    if (byteOffset === void 0) { byteOffset = 0; }
    var buffer = buffer_;
    return buffer.gl_buffer_pages[(byteOffset / buffer.pageByteSize) | 0];
}
function getPlatformTexture(texture_) {
    var texture = texture_;
    return texture.gl_texture;
}
function getPlatformSampler(sampler_) {
    var sampler = sampler_;
    return sampler.gl_sampler;
}
function assignPlatformName(o, name) {
    o.name = name;
    o.__SPECTOR_Metadata = { name: name };
}
function findall(haystack, needle) {
    var results = [];
    while (true) {
        var result = needle.exec(haystack);
        if (!result)
            break;
        results.push(result);
    }
    return results;
}
function isBlendStateNone(blendState) {
    return (blendState.blendMode == BlendMode.Add &&
        blendState.blendSrcFactor == BlendFactor.One &&
        blendState.blendDstFactor === BlendFactor.Zero);
}
function translateQueryPoolType(type) {
    switch (type) {
        case QueryPoolType.OcclusionConservative:
            return GL.ANY_SAMPLES_PASSED_CONSERVATIVE;
        default:
            throw new Error('whoops');
    }
}
function translateTextureDimension(dimension) {
    if (dimension === TextureDimension.n2D)
        return GL.TEXTURE_2D;
    else if (dimension === TextureDimension.n2DArray)
        return GL.TEXTURE_2D_ARRAY;
    else if (dimension === TextureDimension.Cube)
        return GL.TEXTURE_CUBE_MAP;
    else if (dimension === TextureDimension.n3D)
        return GL.TEXTURE_3D;
    else
        throw new Error('whoops');
}
function isBlockCompressSized(w, h, bw, bh) {
    if (w % bw !== 0)
        return false;
    if (h % bh !== 0)
        return false;
    return true;
}

var Buffer_GL = /** @class */ (function (_super) {
    __extends(Buffer_GL, _super);
    function Buffer_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.Buffer;
        var viewOrSize = descriptor.viewOrSize, usage = descriptor.usage, hint = descriptor.hint;
        var uniformBufferMaxPageByteSize = device.uniformBufferMaxPageByteSize, gl = device.gl;
        var isStorageTexture = usage & BufferUsage.STORAGE;
        if (isStorageTexture) {
            // // Use Texture as storage instead of Buffer.
            // const texture = this.createTexture({
            //   dimension: TextureDimension.n2D,
            //   pixelFormat: Format.U8_RGBA_NORM,
            //   usage: TextureUsage.Sampled,
            //   width: 1,
            //   height: 1,
            //   depth: 1,
            //   numLevels: 1,
            //   immutable: true,
            // });
            // texture.setImageData([new Uint8Array(4 * depth)], 0);
            // Create later.
            return _this;
        }
        var isUBO = usage & BufferUsage.UNIFORM;
        if (!isUBO) {
            if (isWebGL2(gl)) {
                // Temporarily unbind VAO when creating buffers to not stomp on the VAO configuration.
                gl.bindVertexArray(null);
            }
            else {
                device.OES_vertex_array_object.bindVertexArrayOES(null);
            }
        }
        // const byteSize = isNumber(viewOrSize)
        //   ? viewOrSize * 4
        //   : viewOrSize.byteLength * 4;
        var byteSize = isNumber(viewOrSize)
            ? align(viewOrSize, 4)
            : align(viewOrSize.byteLength, 4);
        _this.gl_buffer_pages = [];
        var pageByteSize;
        if (isUBO) {
            assert(byteSize % uniformBufferMaxPageByteSize === 0);
            var byteSizeLeft = byteSize;
            while (byteSizeLeft > 0) {
                _this.gl_buffer_pages.push(_this.createBufferPage(Math.min(byteSizeLeft, uniformBufferMaxPageByteSize), usage, hint));
                byteSizeLeft -= uniformBufferMaxPageByteSize;
            }
            pageByteSize = uniformBufferMaxPageByteSize;
            // TODO: uniform in WebGL1
        }
        else {
            _this.gl_buffer_pages.push(_this.createBufferPage(byteSize, usage, hint));
            pageByteSize = byteSize;
        }
        _this.pageByteSize = pageByteSize;
        _this.byteSize = byteSize;
        _this.usage = usage;
        _this.gl_target = translateBufferUsageToTarget(usage);
        if (!isUBO) {
            if (isWebGL2(gl)) {
                gl.bindVertexArray(_this.device.currentBoundVAO);
            }
            else {
                device.OES_vertex_array_object.bindVertexArrayOES(_this.device.currentBoundVAO);
            }
        }
        return _this;
    }
    Buffer_GL.prototype.setSubData = function (dstByteOffset, data, srcByteOffset, byteSize) {
        if (srcByteOffset === void 0) { srcByteOffset = 0; }
        if (byteSize === void 0) { byteSize = data.byteLength - srcByteOffset; }
        var gl = this.device.gl;
        var _a = this, gl_target = _a.gl_target, dstByteSize = _a.byteSize, dstPageByteSize = _a.pageByteSize;
        // Account for setSubData being called with a dstByteOffset that is beyond the end of the buffer.
        if (isWebGL2(gl) && gl_target === gl.UNIFORM_BUFFER) {
            // Manually check asserts for speed.
            if (!(dstByteOffset % dstPageByteSize === 0))
                throw new Error("Assert fail: (dstByteOffset [".concat(dstByteOffset, "] % dstPageByteSize [").concat(dstPageByteSize, "]) === 0"));
            if (!(byteSize % dstPageByteSize === 0))
                throw new Error("Assert fail: (byteSize [".concat(byteSize, "] % dstPageByteSize [").concat(dstPageByteSize, "]) === 0"));
        }
        if (!(dstByteOffset + byteSize <= dstByteSize)) {
            throw new Error("Assert fail: (dstByteOffset [".concat(dstByteOffset, "] + byteSize [").concat(byteSize, "]) <= dstByteSize [").concat(dstByteSize, "], gl_target ").concat(gl_target));
            // exceed, need to recreate
        }
        var virtBufferByteOffsetEnd = dstByteOffset + byteSize;
        var virtBufferByteOffset = dstByteOffset;
        var physBufferByteOffset = dstByteOffset % dstPageByteSize;
        while (virtBufferByteOffset < virtBufferByteOffsetEnd) {
            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer#parameters
            var target = isWebGL2(gl) ? gl.COPY_WRITE_BUFFER : this.gl_target;
            gl.bindBuffer(target, getPlatformBuffer(this, virtBufferByteOffset));
            // only WebGL2 support srcOffset & length
            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferSubData
            if (isWebGL2(gl)) {
                gl.bufferSubData(target, physBufferByteOffset, data, srcByteOffset, Math.min(virtBufferByteOffsetEnd - virtBufferByteOffset, dstPageByteSize));
            }
            else {
                gl.bufferSubData(target, physBufferByteOffset, data);
            }
            virtBufferByteOffset += dstPageByteSize;
            physBufferByteOffset = 0;
            srcByteOffset += dstPageByteSize;
            this.device.debugGroupStatisticsBufferUpload();
        }
    };
    Buffer_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        for (var i = 0; i < this.gl_buffer_pages.length; i++) {
            // no ubo in WebGL1
            // @ts-ignore
            if (!this.gl_buffer_pages[i].ubo) {
                this.device.gl.deleteBuffer(this.gl_buffer_pages[i]);
            }
        }
    };
    Buffer_GL.prototype.createBufferPage = function (byteSize, usage, hint) {
        var gl = this.device.gl;
        var isUBO = usage & BufferUsage.UNIFORM;
        if (!isWebGL2(gl) && isUBO) {
            return {
                ubo: true,
            };
        }
        else {
            var gl_buffer = this.device.ensureResourceExists(gl.createBuffer());
            var gl_target = translateBufferUsageToTarget(usage);
            var gl_hint = translateBufferHint(hint);
            gl.bindBuffer(gl_target, gl_buffer);
            gl.bufferData(gl_target, byteSize, gl_hint);
            return gl_buffer;
        }
    };
    return Buffer_GL;
}(ResourceBase_GL));

var InputLayout_GL = /** @class */ (function (_super) {
    __extends(InputLayout_GL, _super);
    function InputLayout_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.InputLayout;
        var vertexAttributeDescriptors = descriptor.vertexAttributeDescriptors, vertexBufferDescriptors = descriptor.vertexBufferDescriptors, indexBufferFormat = descriptor.indexBufferFormat;
        assert(indexBufferFormat === Format.U16_R ||
            indexBufferFormat === Format.U32_R ||
            indexBufferFormat === null);
        _this.vertexAttributeDescriptors = vertexAttributeDescriptors;
        _this.vertexBufferDescriptors = vertexBufferDescriptors;
        _this.indexBufferFormat = indexBufferFormat;
        return _this;
    }
    return InputLayout_GL;
}(ResourceBase_GL));

var InputState_GL = /** @class */ (function (_super) {
    __extends(InputState_GL, _super);
    function InputState_GL(_a) {
        var id = _a.id, device = _a.device, inputLayout = _a.inputLayout, vertexBuffers = _a.vertexBuffers, indexBufferBinding = _a.indexBufferBinding, program = _a.program;
        var _this = this;
        var _b;
        _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.InputState;
        var gl = _this.device.gl;
        var vao = _this.device.ensureResourceExists(isWebGL2(gl) ? gl.createVertexArray() : device.OES_vertex_array_object.createVertexArrayOES());
        if (isWebGL2(gl)) {
            gl.bindVertexArray(vao);
        }
        else {
            device.OES_vertex_array_object.bindVertexArrayOES(vao);
        }
        device.currentBoundVAO = vao;
        for (var i = 0; i < inputLayout.vertexAttributeDescriptors.length; i++) {
            var attr = inputLayout.vertexAttributeDescriptors[i];
            var format = attr.format, _c = attr.divisor, divisor = _c === void 0 ? 1 : _c, byteStride = attr.byteStride, bufferByteOffset = attr.bufferByteOffset, bufferIndex = attr.bufferIndex;
            // find location by name in WebGL1
            var location_1 = isWebGL2(gl) ? attr.location : (_b = program.attributes[attr.location]) === null || _b === void 0 ? void 0 : _b.location;
            if (!isNil(location_1)) {
                if (isFormatSizedInteger(format)) ;
                var _d = translateVertexFormat(format), size = _d.size, type = _d.type, normalized = _d.normalized;
                var vertexBuffer = vertexBuffers[bufferIndex];
                if (vertexBuffer === null)
                    continue;
                var inputLayoutBuffer = assertExists(inputLayout.vertexBufferDescriptors[bufferIndex]);
                var buffer = vertexBuffer.buffer;
                assert(!!(buffer.usage & BufferUsage.VERTEX));
                gl.bindBuffer(gl.ARRAY_BUFFER, getPlatformBuffer(vertexBuffer.buffer));
                var bufferOffset = vertexBuffer.byteOffset + bufferByteOffset;
                gl.vertexAttribPointer(location_1, size, type, normalized, byteStride || inputLayoutBuffer.byteStride, bufferOffset);
                if (inputLayoutBuffer.frequency === VertexBufferFrequency.PerInstance) {
                    if (isWebGL2(gl)) {
                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/vertexAttribDivisor
                        gl.vertexAttribDivisor(location_1, divisor);
                    }
                    else {
                        device.ANGLE_instanced_arrays.vertexAttribDivisorANGLE(location_1, divisor);
                    }
                }
                gl.enableVertexAttribArray(location_1);
            }
        }
        var indexBufferType = null;
        var indexBufferCompByteSize = null;
        var indexBufferByteOffset = null;
        if (indexBufferBinding !== null) {
            var buffer = indexBufferBinding.buffer;
            assert(!!(buffer.usage & BufferUsage.INDEX));
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, getPlatformBuffer(indexBufferBinding.buffer));
            indexBufferType = translateIndexFormat(assertExists(inputLayout.indexBufferFormat));
            indexBufferCompByteSize = getFormatCompByteSize(inputLayout.indexBufferFormat);
            indexBufferByteOffset = indexBufferBinding.byteOffset;
        }
        if (isWebGL2(gl)) {
            gl.bindVertexArray(null);
        }
        else {
            device.OES_vertex_array_object.bindVertexArrayOES(null);
        }
        device.currentBoundVAO = null;
        _this.vao = vao;
        _this.indexBufferByteOffset = indexBufferByteOffset;
        _this.indexBufferType = indexBufferType;
        _this.indexBufferCompByteSize = indexBufferCompByteSize;
        _this.inputLayout = inputLayout;
        _this.vertexBuffers = vertexBuffers;
        return _this;
    }
    InputState_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.device.currentBoundVAO === this.vao) {
            if (isWebGL2(this.device.gl)) {
                this.device.gl.bindVertexArray(null);
                this.device.gl.deleteVertexArray(this.vao);
            }
            else {
                this.device.OES_vertex_array_object.bindVertexArrayOES(null);
                this.device.OES_vertex_array_object.deleteVertexArrayOES(this.vao);
            }
            this.device.currentBoundVAO = null;
        }
    };
    return InputState_GL;
}(ResourceBase_GL));

var Texture_GL = /** @class */ (function (_super) {
    __extends(Texture_GL, _super);
    function Texture_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor, fake = _a.fake;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.Texture;
        var gl = _this.device.gl;
        var gl_target;
        var gl_texture;
        var numLevels = _this.clampNumLevels(descriptor);
        _this.immutable = !!descriptor.immutable;
        _this.pixelStore = descriptor.pixelStore;
        _this.pixelFormat = descriptor.pixelFormat;
        _this.formatKind = getFormatSamplerKind(descriptor.pixelFormat);
        _this.width = descriptor.width;
        _this.height = descriptor.height;
        _this.depth = descriptor.depth;
        _this.mipmaps = numLevels >= 1;
        if (!fake) {
            gl_texture = _this.device.ensureResourceExists(gl.createTexture());
            var gl_type = _this.device.translateTextureType(descriptor.pixelFormat);
            var internalformat = _this.device.translateTextureInternalFormat(descriptor.pixelFormat);
            _this.device.setActiveTexture(gl.TEXTURE0);
            _this.device.currentTextures[0] = null;
            _this.preprocessImage();
            if (descriptor.dimension === TextureDimension.n2D) {
                gl_target = GL.TEXTURE_2D;
                gl.bindTexture(gl_target, gl_texture);
                if (_this.immutable) {
                    if (isWebGL2(gl)) {
                        // texStorage2D will create an immutable texture(fixed size)
                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texStorage2D
                        // @see https://github.com/visgl/luma.gl/issues/193
                        // @see https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_immutable.html
                        gl.texStorage2D(gl_target, numLevels, internalformat, descriptor.width, descriptor.height);
                    }
                    else {
                        // texImage2D: level must be 0 for DEPTH_COMPONENT format
                        // const level = internalformat === GL.DEPTH_COMPONENT || this.isNPOT() ? 0 : numLevels;
                        var level = internalformat === GL.DEPTH_COMPONENT || _this.isNPOT() ? 0 : 0;
                        if ((_this.pixelFormat === Format.D32F ||
                            _this.pixelFormat === Format.D24_S8) &&
                            !isWebGL2(gl) &&
                            !device.WEBGL_depth_texture) ;
                        else {
                            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
                            gl.texImage2D(gl_target, level, internalformat, descriptor.width, descriptor.height, 0, internalformat, gl_type, null);
                            // @see https://stackoverflow.com/questions/21954036/dartweb-gl-render-warning-texture-bound-to-texture-unit-0-is-not-renderable
                            // [.WebGL-0x106ad0400]RENDER WARNING: texture bound to texture unit 0 is not renderable. It might be non-power-of-2 or have incompatible texture filtering (maybe)?
                            if (_this.mipmaps && _this.isNPOT()) {
                                _this.mipmaps = false;
                                gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
                                gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
                                gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
                            }
                        }
                    }
                }
                assert(descriptor.depth === 1);
            }
            else if (descriptor.dimension === TextureDimension.n2DArray) {
                gl_target = GL.TEXTURE_2D_ARRAY;
                gl.bindTexture(gl_target, gl_texture);
                if (isWebGL2(gl)) {
                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texStorage3D
                    gl.texStorage3D(gl_target, numLevels, internalformat, descriptor.width, descriptor.height, descriptor.depth);
                }
            }
            else if (descriptor.dimension === TextureDimension.n3D) {
                gl_target = GL.TEXTURE_3D;
                gl.bindTexture(gl_target, gl_texture);
                if (isWebGL2(gl)) {
                    gl.texStorage3D(gl_target, numLevels, internalformat, descriptor.width, descriptor.height, descriptor.depth);
                }
            }
            else if (descriptor.dimension === TextureDimension.Cube) {
                gl_target = GL.TEXTURE_CUBE_MAP;
                gl.bindTexture(gl_target, gl_texture);
                if (isWebGL2(gl)) {
                    gl.texStorage2D(gl_target, numLevels, internalformat, descriptor.width, descriptor.height);
                }
                assert(descriptor.depth === 6);
            }
            else {
                throw new Error('whoops');
            }
        }
        _this.gl_texture = gl_texture;
        _this.gl_target = gl_target;
        _this.numLevels = numLevels;
        return _this;
    }
    Texture_GL.prototype.setImageData = function (data, level) {
        var gl = this.device.gl;
        // const isCompressed = isTextureFormatCompressed(this.pixelFormat);
        // const is3D = this.gl_target === GL.TEXTURE_3D || this.gl_target === GL.TEXTURE_2D_ARRAY;
        // const isCube = this.gl_target === GL.TEXTURE_CUBE_MAP;
        var isArray = Array.isArray(data);
        this.device.setActiveTexture(gl.TEXTURE0);
        this.device.currentTextures[0] = null;
        var width;
        var height;
        if (isArray) {
            width = this.width;
            height = this.height;
        }
        else {
            // FIXME: Property 'width' does not exist on type 'TexImageSource'.
            // Property 'width' does not exist on type 'VideoFrame'.
            // @ts-ignore
            width = data.width;
            // @ts-ignore
            height = data.height;
            // update size
            this.width = width;
            this.height = height;
        }
        gl.bindTexture(this.gl_target, this.gl_texture);
        // let w = this.width;
        // let h = this.height;
        // let d = this.depth;
        // const maxMipLevel = Math.min(firstMipLevel + levelDatasSize, this.numLevels);
        var gl_format = this.device.translateTextureFormat(this.pixelFormat);
        var gl_type = this.device.translateTextureType(this.pixelFormat);
        this.preprocessImage();
        if (this.immutable) {
            // must use texSubImage2D instead of texImage2D, since texture is immutable
            // @see https://stackoverflow.com/questions/56123201/unity-plugin-texture-is-immutable?rq=1
            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texSubImage2D
            gl.texSubImage2D(this.gl_target, 0, 0, 0, width, height, gl_format, gl_type, 
            // @ts-ignore
            isArray ? data[0] : data);
        }
        else {
            if (isWebGL2(gl)) {
                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
                gl.texImage2D(this.gl_target, 
                // level,
                0, gl_format, width, height, 0, // border must be 0
                gl_format, // TODO: can be different with gl_format
                gl_type, 
                // @ts-ignore
                isArray ? data[0] : data);
            }
            else {
                // WebGL1: upload Array & Image separately
                if (isArray) {
                    gl.texImage2D(this.gl_target, 0, gl_format, width, height, 0, gl_format, gl_type, data[0]);
                }
                else {
                    gl.texImage2D(this.gl_target, 0, gl_format, gl_format, gl_type, data);
                }
            }
        }
        if (this.mipmaps) {
            this.generateMipmap();
        }
    };
    Texture_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.device.gl.deleteTexture(getPlatformTexture(this));
    };
    Texture_GL.prototype.clampNumLevels = function (descriptor) {
        if (descriptor.dimension === TextureDimension.n2DArray &&
            descriptor.depth > 1) {
            var typeFlags = getFormatTypeFlags(descriptor.pixelFormat);
            if (typeFlags === FormatTypeFlags.BC1) {
                // Chrome/ANGLE seems to have issues with compressed miplevels of size 1/2, so clamp before they arrive...
                // https://bugs.chromium.org/p/angleproject/issues/detail?id=4056
                var w = descriptor.width, h = descriptor.height;
                for (var i = 0; i < descriptor.numLevels; i++) {
                    if (w <= 2 || h <= 2)
                        return i - 1;
                    w = Math.max((w / 2) | 0, 1);
                    h = Math.max((h / 2) | 0, 1);
                }
            }
        }
        return descriptor.numLevels;
    };
    Texture_GL.prototype.preprocessImage = function () {
        var gl = this.device.gl;
        if (this.pixelStore) {
            if (this.pixelStore.unpackFlipY) {
                gl.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, true);
            }
            if (this.pixelStore.packAlignment) {
                gl.pixelStorei(GL.PACK_ALIGNMENT, this.pixelStore.packAlignment);
            }
            if (this.pixelStore.unpackAlignment) {
                gl.pixelStorei(GL.UNPACK_ALIGNMENT, this.pixelStore.unpackAlignment);
            }
        }
    };
    Texture_GL.prototype.generateMipmap = function () {
        var gl = this.device.gl;
        if (!isWebGL2(gl) && this.isNPOT()) {
            return this;
        }
        if (this.gl_texture && this.gl_target) {
            gl.bindTexture(this.gl_target, this.gl_texture);
            gl.generateMipmap(this.gl_target);
            gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_LINEAR);
            gl.bindTexture(this.gl_target, null);
        }
        return this;
    };
    Texture_GL.prototype.isNPOT = function () {
        var gl = this.device.gl;
        if (isWebGL2(gl)) {
            // NPOT restriction is only for WebGL1
            return false;
        }
        return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
    };
    return Texture_GL;
}(ResourceBase_GL));

var quadVert = "\nlayout(location = 0) in vec2 a_Position;\n\nout vec2 v_TexCoord;\n\nvoid main() {\n  v_TexCoord = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n\n  #ifdef VIEWPORT_ORIGIN_TL\n    v_TexCoord.y = 1.0 - v_TexCoord.y;\n  #endif\n}\n";
var ProgramCompileState_GL;
(function (ProgramCompileState_GL) {
    ProgramCompileState_GL[ProgramCompileState_GL["NeedsCompile"] = 0] = "NeedsCompile";
    ProgramCompileState_GL[ProgramCompileState_GL["Compiling"] = 1] = "Compiling";
    ProgramCompileState_GL[ProgramCompileState_GL["NeedsBind"] = 2] = "NeedsBind";
    ProgramCompileState_GL[ProgramCompileState_GL["ReadyToUse"] = 3] = "ReadyToUse";
})(ProgramCompileState_GL || (ProgramCompileState_GL = {}));
var Program_GL = /** @class */ (function (_super) {
    __extends(Program_GL, _super);
    function Program_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.Program;
        _this.uniformSetters = {};
        _this.attributes = [];
        var gl = _this.device.gl;
        _this.descriptor = descriptor;
        _this.gl_program = _this.device.ensureResourceExists(gl.createProgram());
        _this.gl_shader_vert = null;
        _this.gl_shader_frag = null;
        _this.compileState = ProgramCompileState_GL.NeedsCompile;
        _this.tryCompileProgram();
        return _this;
    }
    Program_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.device.gl.deleteProgram(this.gl_program);
        this.device.gl.deleteShader(this.gl_shader_vert);
        this.device.gl.deleteShader(this.gl_shader_frag);
    };
    Program_GL.prototype.tryCompileProgram = function () {
        assert(this.compileState === ProgramCompileState_GL.NeedsCompile);
        var descriptor = this.descriptor;
        var gl = this.device.gl;
        if (this.gl_shader_vert !== null)
            gl.deleteShader(this.gl_shader_vert);
        if (this.gl_shader_frag !== null)
            gl.deleteShader(this.gl_shader_frag);
        if (descriptor.preprocessedCompute) {
            this.gl_shader_vert = this.compileShader(preprocessShader_GLSL(this.device.queryVendorInfo(), 'vert', quadVert), gl.VERTEX_SHADER);
            this.gl_shader_frag = this.compileShader(descriptor.preprocessedCompute, gl.FRAGMENT_SHADER);
        }
        else {
            this.gl_shader_vert = this.compileShader(descriptor.preprocessedVert, gl.VERTEX_SHADER);
            this.gl_shader_frag = this.compileShader(descriptor.preprocessedFrag, gl.FRAGMENT_SHADER);
        }
        gl.attachShader(this.gl_program, this.gl_shader_vert);
        gl.attachShader(this.gl_program, this.gl_shader_frag);
        gl.linkProgram(this.gl_program);
        this.compileState = ProgramCompileState_GL.Compiling;
        if (!isWebGL2(gl)) {
            // extract uniforms
            this.readUniformLocationsFromLinkedProgram();
            // extract attributes
            this.readAttributesFromLinkedProgram();
        }
    };
    Program_GL.prototype.readAttributesFromLinkedProgram = function () {
        var _a;
        var gl = this.device.gl;
        var count = gl.getProgramParameter(this.gl_program, gl.ACTIVE_ATTRIBUTES);
        var defines = getDefines(this.descriptor.preprocessedVert);
        var locations = getAttributeLocations(this.descriptor.vert, defines);
        var _loop_1 = function (index) {
            var _b = gl.getActiveAttrib(this_1.gl_program, index), name_1 = _b.name, type = _b.type, size = _b.size;
            var location_1 = gl.getAttribLocation(this_1.gl_program, name_1);
            var definedLocation = (_a = locations.find(function (l) { return l.name === name_1; })) === null || _a === void 0 ? void 0 : _a.location;
            // Add only user provided attributes, for built-in attributes like
            // `gl_InstanceID` locaiton will be < 0
            if (location_1 >= 0 && !isNil(definedLocation)) {
                this_1.attributes[definedLocation] = {
                    name: name_1,
                    location: location_1,
                    type: type,
                    size: size,
                };
            }
        };
        var this_1 = this;
        for (var index = 0; index < count; index++) {
            _loop_1(index);
        }
    };
    Program_GL.prototype.readUniformLocationsFromLinkedProgram = function () {
        var gl = this.device.gl;
        var numUniforms = gl.getProgramParameter(this.gl_program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < numUniforms; i++) {
            var info = gl.getActiveUniform(this.gl_program, i);
            var name_2 = parseUniformName(info.name).name;
            var location_2 = gl.getUniformLocation(this.gl_program, name_2);
            this.uniformSetters[name_2] = getUniformSetter(gl, location_2, info);
            if (info && info.size > 1) {
                for (var l = 0; l < info.size; l++) {
                    location_2 = gl.getUniformLocation(this.gl_program, "".concat(name_2, "[").concat(l, "]"));
                    this.uniformSetters["".concat(name_2, "[").concat(l, "]")] = getUniformSetter(gl, location_2, info);
                }
            }
        }
    };
    Program_GL.prototype.compileShader = function (contents, type) {
        var gl = this.device.gl;
        var shader = this.device.ensureResourceExists(gl.createShader(type));
        gl.shaderSource(shader, contents);
        gl.compileShader(shader);
        return shader;
    };
    Program_GL.prototype.setUniforms = function (uniforms) {
        if (uniforms === void 0) { uniforms = {}; }
        var gl = this.device.gl;
        if (!isWebGL2(gl)) {
            var programUsed = false;
            for (var uniformName in uniforms) {
                if (!programUsed) {
                    gl.useProgram(this.gl_program);
                    programUsed = true;
                }
                var uniform = uniforms[uniformName];
                var uniformSetter = this.uniformSetters[uniformName];
                if (uniformSetter) {
                    var value = uniform;
                    if (value instanceof Texture_GL) {
                        value = value.textureIndex;
                    }
                    uniformSetter(value);
                }
            }
        }
        return this;
    };
    return Program_GL;
}(ResourceBase_GL));

var QueryPool_GL = /** @class */ (function (_super) {
    __extends(QueryPool_GL, _super);
    function QueryPool_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.QueryPool;
        var gl = _this.device.gl;
        if (isWebGL2(gl)) {
            var elemCount = descriptor.elemCount, type = descriptor.type;
            _this.gl_query = nArray(elemCount, function () { return _this.device.ensureResourceExists(gl.createQuery()); });
            _this.gl_query_type = translateQueryPoolType(type);
        }
        return _this;
    }
    QueryPool_GL.prototype.queryResultOcclusion = function (dstOffs) {
        var gl = this.device.gl;
        if (isWebGL2(gl)) {
            var gl_query = this.gl_query[dstOffs];
            if (!gl.getQueryParameter(gl_query, gl.QUERY_RESULT_AVAILABLE)) {
                return null;
            }
            return !!gl.getQueryParameter(gl_query, gl.QUERY_RESULT);
        }
        return null;
    };
    QueryPool_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        var gl = this.device.gl;
        if (isWebGL2(gl)) {
            for (var i = 0; i < this.gl_query.length; i++) {
                gl.deleteQuery(this.gl_query[i]);
            }
        }
    };
    return QueryPool_GL;
}(ResourceBase_GL));

var Readback_GL = /** @class */ (function (_super) {
    __extends(Readback_GL, _super);
    function Readback_GL(_a) {
        var id = _a.id, device = _a.device;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.Readback;
        _this.gl_pbo = null;
        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLSync
        _this.gl_sync = null;
        return _this;
    }
    Readback_GL.prototype.clientWaitAsync = function (sync, flags, interval_ms) {
        if (flags === void 0) { flags = 0; }
        if (interval_ms === void 0) { interval_ms = 10; }
        var gl = this.device.gl;
        return new Promise(function (resolve, reject) {
            function test() {
                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/clientWaitSync
                var res = gl.clientWaitSync(sync, flags, 0);
                if (res == gl.WAIT_FAILED) {
                    reject();
                    return;
                }
                if (res == gl.TIMEOUT_EXPIRED) {
                    setTimeout(test, clamp(interval_ms, 0, gl.MAX_CLIENT_WAIT_TIMEOUT_WEBGL));
                    return;
                }
                resolve();
            }
            test();
        });
    };
    Readback_GL.prototype.getBufferSubDataAsync = function (target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {
        if (dstOffset === void 0) { dstOffset = 0; }
        if (length === void 0) { length = dstBuffer.byteLength || 0; }
        return __awaiter(this, void 0, void 0, function () {
            var gl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.device.gl;
                        if (!isWebGL2(gl)) return [3 /*break*/, 2];
                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/fenceSync
                        this.gl_sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        gl.flush();
                        return [4 /*yield*/, this.clientWaitAsync(this.gl_sync, 0, 10)];
                    case 1:
                        _a.sent();
                        gl.bindBuffer(target, buffer);
                        gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
                        gl.bindBuffer(target, null);
                        return [2 /*return*/, dstBuffer];
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_non-blocking_async_data_readback
     */
    Readback_GL.prototype.readTexture = function (t, x, y, width, height, dstBuffer, dstOffset, length) {
        if (dstOffset === void 0) { dstOffset = 0; }
        if (length === void 0) { length = dstBuffer.byteLength || 0; }
        return __awaiter(this, void 0, void 0, function () {
            var gl, texture, gl_format, gl_type, formatByteSize;
            return __generator(this, function (_a) {
                gl = this.device.gl;
                texture = t;
                gl_format = this.device.translateTextureFormat(texture.pixelFormat);
                gl_type = this.device.translateTextureType(texture.pixelFormat);
                formatByteSize = getFormatByteSize(texture.pixelFormat);
                if (isWebGL2(gl)) {
                    this.gl_pbo = this.device.ensureResourceExists(gl.createBuffer());
                    // PIXEL_PACK_BUFFER: Buffer used for pixel transfer operations
                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.gl_pbo);
                    // STREAM_READ: The contents are intended to be specified once by reading data from WebGL, and queried at most a few times by the application
                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData
                    gl.bufferData(gl.PIXEL_PACK_BUFFER, length, gl.STREAM_READ);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                    gl.bindFramebuffer(GL.READ_FRAMEBUFFER, this.device.readbackFramebuffer);
                    gl.framebufferTexture2D(GL.READ_FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture.gl_texture, 0);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.gl_pbo);
                    gl.readPixels(x, y, width, height, gl_format, gl_type, dstOffset * formatByteSize);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                    return [2 /*return*/, this.getBufferSubDataAsync(gl.PIXEL_PACK_BUFFER, this.gl_pbo, 0, dstBuffer, dstOffset, length)];
                }
                else {
                    gl.bindFramebuffer(GL.FRAMEBUFFER, this.device.readbackFramebuffer);
                    gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture.gl_texture, 0);
                    // slow requires roundtrip to GPU
                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei
                    gl.pixelStorei(gl.PACK_ALIGNMENT, 4);
                    gl.readPixels(x, y, width, height, gl.RGBA, gl_type, dstBuffer);
                    return [2 /*return*/, dstBuffer];
                }
            });
        });
    };
    Readback_GL.prototype.readTextureSync = function (t, x, y, width, height, dstBuffer, dstOffset, length) {
        if (length === void 0) { length = dstBuffer.byteLength || 0; }
        var gl = this.device.gl;
        var texture = t;
        var gl_type = this.device.translateTextureType(texture.pixelFormat);
        gl.bindFramebuffer(GL.FRAMEBUFFER, this.device.readbackFramebuffer);
        gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture.gl_texture, 0);
        // slow requires roundtrip to GPU
        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei
        gl.pixelStorei(gl.PACK_ALIGNMENT, 4);
        gl.readPixels(x, y, width, height, gl.RGBA, gl_type, dstBuffer);
        return dstBuffer;
    };
    Readback_GL.prototype.readBuffer = function (b, srcByteOffset, dstBuffer, dstOffset, length) {
        return __awaiter(this, void 0, void 0, function () {
            var gl;
            return __generator(this, function (_a) {
                gl = this.device.gl;
                if (isWebGL2(gl)) {
                    return [2 /*return*/, this.getBufferSubDataAsync(gl.ARRAY_BUFFER, getPlatformBuffer(b, srcByteOffset), srcByteOffset, dstBuffer, dstOffset, length)];
                }
                // TODO: WebGL1
                return [2 /*return*/, Promise.reject()];
            });
        });
    };
    Readback_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (isWebGL2(this.device.gl)) {
            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/deleteSync
            if (this.gl_sync !== null) {
                this.device.gl.deleteSync(this.gl_sync);
            }
            if (this.gl_pbo !== null) {
                this.device.gl.deleteBuffer(this.gl_pbo);
            }
        }
    };
    return Readback_GL;
}(ResourceBase_GL));

var RenderPipeline_GL = /** @class */ (function (_super) {
    __extends(RenderPipeline_GL, _super);
    function RenderPipeline_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.RenderPipeline;
        _this.bindingLayouts = _this.createBindingLayouts(descriptor.bindingLayouts);
        _this.drawMode = translatePrimitiveTopology(descriptor.topology);
        _this.program = descriptor.program;
        _this.inputLayout = descriptor.inputLayout;
        _this.megaState = descriptor.megaStateDescriptor;
        _this.colorAttachmentFormats = descriptor.colorAttachmentFormats.slice();
        _this.depthStencilAttachmentFormat = descriptor.depthStencilAttachmentFormat;
        _this.sampleCount = descriptor.sampleCount;
        return _this;
    }
    RenderPipeline_GL.prototype.createBindingLayouts = function (bindingLayouts) {
        var firstUniformBuffer = 0;
        var firstSampler = 0;
        var bindingLayoutTables = [];
        for (var i = 0; i < bindingLayouts.length; i++) {
            var _a = bindingLayouts[i], numUniformBuffers = _a.numUniformBuffers, numSamplers = _a.numSamplers, samplerEntries = _a.samplerEntries;
            var bindingSamplerEntries = [];
            if (samplerEntries !== undefined) {
                assert(samplerEntries.length === numSamplers);
            }
            for (var j = 0; j < numSamplers; j++) {
                var samplerEntry = samplerEntries !== undefined ? samplerEntries[j] : defaultBindingLayoutSamplerDescriptor;
                var dimension = samplerEntry.dimension, formatKind = samplerEntry.formatKind;
                bindingSamplerEntries.push({ gl_target: translateTextureDimension(dimension), formatKind: formatKind });
            }
            bindingLayoutTables.push({
                firstUniformBuffer: firstUniformBuffer,
                numUniformBuffers: numUniformBuffers,
                firstSampler: firstSampler,
                numSamplers: numSamplers,
                samplerEntries: bindingSamplerEntries,
            });
            firstUniformBuffer += numUniformBuffers;
            firstSampler += numSamplers;
        }
        return {
            numUniformBuffers: firstUniformBuffer,
            numSamplers: firstSampler,
            bindingLayoutTables: bindingLayoutTables,
        };
    };
    return RenderPipeline_GL;
}(ResourceBase_GL));

var RenderTarget_GL = /** @class */ (function (_super) {
    __extends(RenderTarget_GL, _super);
    function RenderTarget_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.RenderTarget;
        _this.gl_renderbuffer = null;
        _this.texture = null;
        var gl = _this.device.gl;
        var pixelFormat = descriptor.pixelFormat, width = descriptor.width, height = descriptor.height, sampleCount = descriptor.sampleCount, texture = descriptor.texture;
        var useRenderbuffer = false;
        // @see https://blog.tojicode.com/2012/07/using-webgldepthtexture.html
        if ((pixelFormat === Format.D32F || pixelFormat === Format.D24_S8) &&
            texture &&
            !isWebGL2(gl) &&
            !device.WEBGL_depth_texture) {
            // texture.destroy();
            // texture = null;
            useRenderbuffer = true;
        }
        if (!useRenderbuffer && texture) {
            _this.texture = texture;
        }
        else {
            _this.gl_renderbuffer = _this.device.ensureResourceExists(gl.createRenderbuffer());
            gl.bindRenderbuffer(gl.RENDERBUFFER, _this.gl_renderbuffer);
            var gl_format = _this.device.translateTextureInternalFormat(pixelFormat);
            if (isWebGL2(gl)) {
                // @see https://github.com/shrekshao/MoveWebGL1EngineToWebGL2/blob/master/Move-a-WebGL-1-Engine-To-WebGL-2-Blog-2.md#multisampled-renderbuffers
                gl.renderbufferStorageMultisample(GL.RENDERBUFFER, sampleCount, gl_format, width, height);
            }
            else {
                // WebGL1 can only use FXAA or other post-processing methods
                gl.renderbufferStorage(GL.RENDERBUFFER, gl_format, width, height);
            }
        }
        _this.pixelFormat = pixelFormat;
        _this.width = width;
        _this.height = height;
        _this.sampleCount = sampleCount;
        return _this;
    }
    RenderTarget_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.gl_renderbuffer !== null) {
            this.device.gl.deleteRenderbuffer(this.gl_renderbuffer);
        }
    };
    return RenderTarget_GL;
}(ResourceBase_GL));

var ComputePipeline_GL = /** @class */ (function (_super) {
    __extends(ComputePipeline_GL, _super);
    function ComputePipeline_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.ComputePipeline;
        _this.descriptor = descriptor;
        return _this;
        // const program = descriptor.program as Program_GL;
    }
    return ComputePipeline_GL;
}(ResourceBase_GL));

var ResourceCreationTracker = /** @class */ (function () {
    function ResourceCreationTracker() {
        this.liveObjects = new Set();
        this.creationStacks = new Map();
        this.deletionStacks = new Map();
    }
    ResourceCreationTracker.prototype.trackResourceCreated = function (o) {
        this.creationStacks.set(o, new Error().stack);
        this.liveObjects.add(o);
    };
    ResourceCreationTracker.prototype.trackResourceDestroyed = function (o) {
        if (this.deletionStacks.has(o))
            console.warn("Object double freed:", o, "\n\nCreation stack: ", this.creationStacks.get(o), "\n\nDeletion stack: ", this.deletionStacks.get(o), "\n\nThis stack: ", new Error().stack);
        this.deletionStacks.set(o, new Error().stack);
        this.liveObjects.delete(o);
    };
    ResourceCreationTracker.prototype.checkForLeaks = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.liveObjects.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var o = _c.value;
                console.warn('Object leaked:', o, 'Creation stack:', this.creationStacks.get(o));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    ResourceCreationTracker.prototype.setResourceLeakCheck = function (o, v) {
        if (v) {
            this.liveObjects.add(o);
        }
        else {
            this.liveObjects.delete(o);
        }
    };
    return ResourceCreationTracker;
}());

/**
 * In WebGL 1 texture image data and sampling information are both stored in texture objects
 * @see https://github.com/shrekshao/MoveWebGL1EngineToWebGL2/blob/master/Move-a-WebGL-1-Engine-To-WebGL-2-Blog-2.md#sampler-objects
 */
var Sampler_GL = /** @class */ (function (_super) {
    __extends(Sampler_GL, _super);
    function Sampler_GL(_a) {
        var id = _a.id, device = _a.device, descriptor = _a.descriptor;
        var _this = this;
        var _b, _c;
        _this = _super.call(this, { id: id, device: device }) || this;
        _this.type = ResourceType.Sampler;
        var gl = _this.device.gl;
        if (isWebGL2(gl)) {
            var gl_sampler = _this.device.ensureResourceExists(gl.createSampler());
            gl.samplerParameteri(gl_sampler, GL.TEXTURE_WRAP_S, translateWrapMode(descriptor.wrapS));
            gl.samplerParameteri(gl_sampler, GL.TEXTURE_WRAP_T, translateWrapMode(descriptor.wrapT));
            gl.samplerParameteri(gl_sampler, GL.TEXTURE_WRAP_R, translateWrapMode((_b = descriptor.wrapQ) !== null && _b !== void 0 ? _b : descriptor.wrapS));
            gl.samplerParameteri(gl_sampler, GL.TEXTURE_MIN_FILTER, translateFilterMode(descriptor.minFilter, descriptor.mipFilter));
            gl.samplerParameteri(gl_sampler, GL.TEXTURE_MAG_FILTER, translateFilterMode(descriptor.magFilter, MipFilterMode.NoMip));
            if (descriptor.minLOD !== undefined) {
                gl.samplerParameterf(gl_sampler, GL.TEXTURE_MIN_LOD, descriptor.minLOD);
            }
            if (descriptor.maxLOD !== undefined) {
                gl.samplerParameterf(gl_sampler, GL.TEXTURE_MAX_LOD, descriptor.maxLOD);
            }
            if (descriptor.compareMode !== undefined) {
                gl.samplerParameteri(gl_sampler, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                gl.samplerParameteri(gl_sampler, gl.TEXTURE_COMPARE_FUNC, descriptor.compareMode);
            }
            var maxAnisotropy = (_c = descriptor.maxAnisotropy) !== null && _c !== void 0 ? _c : 1;
            if (maxAnisotropy > 1 && _this.device.EXT_texture_filter_anisotropic !== null) {
                assert(descriptor.minFilter === TexFilterMode.Bilinear &&
                    descriptor.magFilter === TexFilterMode.Bilinear &&
                    descriptor.mipFilter === MipFilterMode.Linear);
                gl.samplerParameterf(gl_sampler, _this.device.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
            }
            _this.gl_sampler = gl_sampler;
        }
        else {
            // use later in WebGL1
            _this.descriptor = descriptor;
        }
        return _this;
    }
    Sampler_GL.prototype.setTextureParameters = function (gl_target, width, height) {
        var _a;
        var gl = this.device.gl;
        var descriptor = this.descriptor;
        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL#%E9%9D%9E2%E7%9A%84%E5%B9%82%E7%BA%B9%E7%90%86
        if (this.isNPOT(width, height)) {
            gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
        }
        else {
            gl.texParameteri(gl_target, GL.TEXTURE_MIN_FILTER, translateFilterMode(descriptor.minFilter, descriptor.mipFilter));
        }
        gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, translateWrapMode(descriptor.wrapS));
        gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, translateWrapMode(descriptor.wrapT));
        gl.texParameteri(gl_target, GL.TEXTURE_MAG_FILTER, translateFilterMode(descriptor.magFilter, MipFilterMode.NoMip));
        // if (descriptor.minLOD !== undefined) {
        //   gl.texParameterf(gl_target, GL.TEXTURE_MIN_LOD, descriptor.minLOD);
        // }
        // if (descriptor.maxLOD !== undefined) {
        //   gl.texParameterf(gl_target, GL.TEXTURE_MAX_LOD, descriptor.maxLOD);
        // }
        var maxAnisotropy = (_a = descriptor.maxAnisotropy) !== null && _a !== void 0 ? _a : 1;
        if (maxAnisotropy > 1 && this.device.EXT_texture_filter_anisotropic !== null) {
            assert(descriptor.minFilter === TexFilterMode.Bilinear &&
                descriptor.magFilter === TexFilterMode.Bilinear &&
                descriptor.mipFilter === MipFilterMode.Linear);
            gl.texParameteri(gl_target, this.device.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
        }
    };
    Sampler_GL.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (isWebGL2(this.device.gl)) {
            this.device.gl.deleteSampler(getPlatformSampler(this));
        }
    };
    Sampler_GL.prototype.isNPOT = function (width, height) {
        return !isPowerOfTwo(width) || !isPowerOfTwo(height);
    };
    return Sampler_GL;
}(ResourceBase_GL));

// import { assert, assertExists } from '@antv/g-plugin-device-renderer';
// import type { ComputePipeline_GL } from './ComputePipeline';
var ComputePass_GL = /** @class */ (function () {
    function ComputePass_GL() {
    }
    /**
     * @see https://www.w3.org/TR/webgpu/#dom-gpucomputepassencoder-dispatch
     */
    ComputePass_GL.prototype.dispatch = function (x, y, z) { };
    ComputePass_GL.prototype.finish = function () {
        // this.gpuComputePassEncoder.end();
        // this.gpuComputePassEncoder = null;
        // return this.commandEncoder.finish();
    };
    /**
     * @see https://www.w3.org/TR/webgpu/#dom-gpucommandencoder-begincomputepass
     */
    ComputePass_GL.prototype.beginComputePass = function () {
        // assert(this.gpuComputePassEncoder === null);
        // this.setComputePassDescriptor(computePassDescriptor);
        // this.gpuComputePassEncoder = this.commandEncoder.beginComputePass(
        //   this.gpuComputePassDescriptor,
        // );
    };
    ComputePass_GL.prototype.setPipeline = function (pipeline_) {
        // const pipeline = pipeline_ as ComputePipeline_WebGPU;
        // const gpuComputePipeline = assertExists(pipeline.gpuComputePipeline);
        // this.gpuComputePassEncoder.setPipeline(gpuComputePipeline);
    };
    ComputePass_GL.prototype.setBindings = function (bindingLayoutIndex, bindings_) {
        // const bindings = bindings_ as Bindings_WebGPU;
        // this.gpuComputePassEncoder.setBindGroup(bindingLayoutIndex, bindings.gpuBindGroup[0]);
    };
    return ComputePass_GL;
}());

// This is a workaround for ANGLE not supporting UBOs greater than 64kb (the limit of D3D).
// https://bugs.chromium.org/p/angleproject/issues/detail?id=3388
var UBO_PAGE_MAX_BYTE_SIZE = 0x10000;
var Device_GL = /** @class */ (function () {
    function Device_GL(gl, configuration) {
        // Configuration
        this.shaderDebug = false;
        // GL extensions
        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/OES_vertex_array_object
        this.OES_vertex_array_object = null;
        // @see https://developer.mozilla.org/en-US/docs/Web/API/ANGLE_instanced_arrays
        this.ANGLE_instanced_arrays = null;
        // @see https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float
        this.OES_texture_float = null;
        // @see https://www.khronos.org/registry/webgl/extensions/OES_draw_buffers_indexed/
        this.OES_draw_buffers_indexed = null;
        // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_draw_buffers
        // WEBGL_draw_buffers: WEBGL_draw_buffers | null = null;
        // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture
        this.WEBGL_depth_texture = null;
        this.WEBGL_compressed_texture_s3tc = null;
        this.WEBGL_compressed_texture_s3tc_srgb = null;
        this.EXT_texture_compression_rgtc = null;
        this.EXT_texture_filter_anisotropic = null;
        this.KHR_parallel_shader_compile = null;
        // @see https://developer.mozilla.org/en-US/docs/Web/API/EXT_texture_norm16
        this.EXT_texture_norm16 = null;
        this.OES_texture_float_linear = null;
        this.OES_texture_half_float_linear = null;
        // Swap Chain
        this.scTexture = null;
        this.scPlatformFramebuffer = null;
        // Device
        this.currentActiveTexture = null;
        this.currentBoundVAO = null;
        this.currentProgram = null;
        this.resourceCreationTracker = null;
        this.resourceUniqueId = 0;
        // Cached GL driver state
        this.currentColorAttachments = [];
        this.currentColorAttachmentLevels = [];
        this.currentColorResolveTos = [];
        this.currentColorResolveToLevels = [];
        this.currentDepthStencilResolveTo = null;
        this.currentSampleCount = -1;
        this.currentMegaState = copyMegaState(defaultMegaState);
        this.currentSamplers = [];
        this.currentTextures = [];
        this.currentUniformBuffers = [];
        this.currentUniformBufferByteOffsets = [];
        this.currentUniformBufferByteSizes = [];
        this.currentScissorEnabled = false;
        this.currentStencilRef = null;
        // Pass Execution
        this.currentRenderPassDescriptor = null;
        this.debugGroupStack = [];
        this.resolveColorAttachmentsChanged = false;
        this.resolveDepthStencilAttachmentsChanged = false;
        this.explicitBindingLocations = false;
        this.separateSamplerTextures = false;
        this.viewportOrigin = ViewportOrigin.LowerLeft;
        this.clipSpaceNearZ = ClipSpaceNearZ.NegativeOne;
        this.supportMRT = false;
        this.inBlitRenderPass = false;
        this.supportedSampleCounts = [];
        this.occlusionQueriesRecommended = false;
        this.gl = gl;
        this.contextAttributes = assertExists(gl.getContextAttributes());
        if (!isWebGL2(gl)) {
            this.OES_vertex_array_object = gl.getExtension('OES_vertex_array_object');
            // TODO: when ANGLE_instanced_arrays unavailable...
            this.ANGLE_instanced_arrays = gl.getExtension('ANGLE_instanced_arrays');
            this.OES_texture_float = gl.getExtension('OES_texture_float');
            // this.WEBGL_draw_buffers = gl.getExtension('WEBGL_draw_buffers');
            // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture
            // this.WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');
            // @see https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth
            gl.getExtension('EXT_frag_depth');
            // @see https://developer.mozilla.org/en-US/docs/Web/API/OES_element_index_uint
            gl.getExtension('OES_element_index_uint');
            // @see https://developer.mozilla.org/en-US/docs/Web/API/OES_standard_derivatives
            gl.getExtension('OES_standard_derivatives');
            // won't use MRT anymore...
            // if (this.WEBGL_draw_buffers) {
            //   this.supportMRT = true;
            // }
        }
        else {
            this.EXT_texture_norm16 = gl.getExtension('EXT_texture_norm16');
            // this.supportMRT = true;
        }
        this.WEBGL_compressed_texture_s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc');
        this.WEBGL_compressed_texture_s3tc_srgb = gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');
        this.EXT_texture_compression_rgtc = gl.getExtension('EXT_texture_compression_rgtc');
        this.EXT_texture_filter_anisotropic = gl.getExtension('EXT_texture_filter_anisotropic');
        this.EXT_texture_norm16 = gl.getExtension('EXT_texture_norm16');
        this.OES_texture_float_linear = gl.getExtension('OES_texture_float_linear');
        this.OES_texture_half_float_linear = gl.getExtension('OES_texture_half_float_linear');
        this.KHR_parallel_shader_compile = gl.getExtension('KHR_parallel_shader_compile');
        // this.OES_draw_buffers_indexed = gl.getExtension('OES_draw_buffers_indexed');
        if (isWebGL2(gl)) {
            this.platformString = 'WebGL2';
            this.glslVersion = '#version 300 es';
        }
        else {
            this.platformString = 'WebGL1';
            this.glslVersion = '#version 100'; // 100 es not supported
        }
        // Create our fake swap-chain texture.
        this.scTexture = new Texture_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: {
                width: 0,
                height: 0,
                depth: 1,
                dimension: TextureDimension.n2D,
                numLevels: 1,
                usage: TextureUsage.RenderTarget,
                pixelFormat: this.contextAttributes.alpha === false
                    ? Format.U8_RGB_RT
                    : Format.U8_RGBA_RT,
            },
            fake: true,
        });
        this.scTexture.formatKind = SamplerFormatKind.Float;
        this.scTexture.gl_target = null;
        this.scTexture.gl_texture = null;
        this.resolveColorReadFramebuffer = this.ensureResourceExists(gl.createFramebuffer());
        this.resolveColorDrawFramebuffer = this.ensureResourceExists(gl.createFramebuffer());
        this.resolveDepthStencilReadFramebuffer = this.ensureResourceExists(gl.createFramebuffer());
        this.resolveDepthStencilDrawFramebuffer = this.ensureResourceExists(gl.createFramebuffer());
        this.renderPassDrawFramebuffer = this.ensureResourceExists(gl.createFramebuffer());
        this.readbackFramebuffer = this.ensureResourceExists(gl.createFramebuffer());
        this.fallbackTexture2D = this.createFallbackTexture(TextureDimension.n2D, SamplerFormatKind.Float);
        this.fallbackTexture2DDepth = this.createFallbackTexture(TextureDimension.n2D, SamplerFormatKind.Depth);
        if (isWebGL2(gl)) ;
        // Adjust for GL defaults.
        this.currentMegaState.depthCompare = CompareMode.Less;
        this.currentMegaState.depthWrite = false;
        this.currentMegaState.attachmentsState[0].channelWriteMask =
            ChannelWriteMask.AllChannels;
        // always have depth test enabled.
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.STENCIL_TEST);
        this.checkLimits();
        if (configuration.shaderDebug) {
            this.shaderDebug = true;
        }
        if (configuration.trackResources) {
            this.resourceCreationTracker = new ResourceCreationTracker();
        }
    }
    Device_GL.prototype.createFallbackTexture = function (dimension, formatKind) {
        var depth = dimension === TextureDimension.Cube ? 6 : 1;
        // const supportDepthTexture =
        //   isWebGL2(this.gl) || (!isWebGL2(this.gl) && !!this.WEBGL_depth_texture);
        var pixelFormat = formatKind === SamplerFormatKind.Depth
            ? Format.D32F
            : Format.U8_RGBA_NORM;
        var texture = this.createTexture({
            dimension: dimension,
            pixelFormat: pixelFormat,
            usage: TextureUsage.Sampled,
            width: 1,
            height: 1,
            depth: depth,
            numLevels: 1,
            immutable: true,
        });
        // this.blackTexture = this.ensureResourceExists(gl.createTexture());
        // gl.bindTexture(GL.TEXTURE_2D, this.blackTexture);
        // gl.texImage2D(
        //   GL.TEXTURE_2D,
        //   0,
        //   isWebGL2(gl) ? gl.RGBA8 : gl.RGBA,
        //   1,
        //   1,
        //   0,
        //   gl.RGBA,
        //   gl.UNSIGNED_BYTE,
        //   new Uint8Array(4),
        // )
        if (formatKind === SamplerFormatKind.Float) {
            texture.setImageData([new Uint8Array(4 * depth)], 0);
        }
        return getPlatformTexture(texture);
    };
    Device_GL.prototype.getNextUniqueId = function () {
        return ++this.resourceUniqueId;
    };
    Device_GL.prototype.checkLimits = function () {
        var gl = this.gl;
        this.maxVertexAttribs = gl.getParameter(GL.MAX_VERTEX_ATTRIBS);
        if (isWebGL2(gl)) {
            this.uniformBufferMaxPageByteSize = Math.min(gl.getParameter(GL.MAX_UNIFORM_BLOCK_SIZE), UBO_PAGE_MAX_BYTE_SIZE);
            this.uniformBufferWordAlignment =
                gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT) / 4;
            var supportedSampleCounts = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.DEPTH32F_STENCIL8, gl.SAMPLES);
            this.supportedSampleCounts = supportedSampleCounts
                ? __spreadArray([], __read(supportedSampleCounts), false) : [];
            this.occlusionQueriesRecommended = true;
        }
        else {
            // mock ubo in WebGL1
            this.uniformBufferWordAlignment = 64;
            this.uniformBufferMaxPageByteSize = UBO_PAGE_MAX_BYTE_SIZE;
        }
        this.uniformBufferMaxPageWordSize = this.uniformBufferMaxPageByteSize / 4;
        if (!this.supportedSampleCounts.includes(1)) {
            this.supportedSampleCounts.push(1);
        }
        this.supportedSampleCounts.sort(function (a, b) { return a - b; });
    };
    //#region SwapChain
    Device_GL.prototype.configureSwapChain = function (width, height, platformFramebuffer) {
        var texture = this.scTexture;
        texture.width = width;
        texture.height = height;
        this.scPlatformFramebuffer = nullify(platformFramebuffer);
    };
    Device_GL.prototype.getDevice = function () {
        return this;
    };
    Device_GL.prototype.getCanvas = function () {
        return this.gl.canvas;
    };
    Device_GL.prototype.getOnscreenTexture = function () {
        return this.scTexture;
    };
    Device_GL.prototype.beginFrame = function () { };
    Device_GL.prototype.endFrame = function () { };
    //#endregion
    //#region Device
    // @see https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html
    Device_GL.prototype.translateTextureInternalFormat = function (fmt) {
        switch (fmt) {
            case Format.ALPHA:
                return GL.ALPHA;
            case Format.F16_R:
                return GL.R16F;
            case Format.F16_RG:
                return GL.RG16F;
            case Format.F16_RGB:
                return GL.RGB16F;
            case Format.F16_RGBA:
                return GL.RGBA16F;
            case Format.F32_R:
                return GL.R32F;
            case Format.F32_RG:
                return GL.RG32F;
            case Format.F32_RGB:
                return GL.RGB32F;
            case Format.F32_RGBA:
                return GL.RGBA32F;
            case Format.U8_R_NORM:
                return GL.R8;
            case Format.U8_RG_NORM:
                return GL.RG8;
            case Format.U8_RGB_NORM:
            case Format.U8_RGB_RT:
                return GL.RGB8;
            case Format.U8_RGB_SRGB:
                return GL.SRGB8;
            case Format.U8_RGBA_NORM:
            case Format.U8_RGBA_RT:
                return isWebGL2(this.gl) ? GL.RGBA8 : GL.RGBA;
            case Format.U8_RGBA_SRGB:
            case Format.U8_RGBA_RT_SRGB:
                return GL.SRGB8_ALPHA8;
            case Format.U16_R:
                return GL.R16UI;
            case Format.U16_R_NORM:
                return this.EXT_texture_norm16.R16_EXT;
            case Format.U16_RG_NORM:
                return this.EXT_texture_norm16.RG16_EXT;
            case Format.U16_RGBA_NORM:
                return this.EXT_texture_norm16.RGBA16_EXT;
            // case Format.U16_RGBA_5551:
            //   return GL.RGB5_A1;
            case Format.U32_R:
                return GL.R32UI;
            case Format.S8_RGBA_NORM:
                return GL.RGBA8_SNORM;
            case Format.S8_RG_NORM:
                return GL.RG8_SNORM;
            case Format.U16_RGBA_5551:
                return GL.UNSIGNED_SHORT_5_5_5_1;
            case Format.BC1:
                return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            case Format.BC1_SRGB:
                return this.WEBGL_compressed_texture_s3tc_srgb
                    .COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            case Format.BC2:
                return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            case Format.BC2_SRGB:
                return this.WEBGL_compressed_texture_s3tc_srgb
                    .COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            case Format.BC3:
                return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            case Format.BC3_SRGB:
                return this.WEBGL_compressed_texture_s3tc_srgb
                    .COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            case Format.BC4_UNORM:
                return this.EXT_texture_compression_rgtc.COMPRESSED_RED_RGTC1_EXT;
            case Format.BC4_SNORM:
                return this.EXT_texture_compression_rgtc
                    .COMPRESSED_SIGNED_RED_RGTC1_EXT;
            case Format.BC5_UNORM:
                return this.EXT_texture_compression_rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT;
            case Format.BC5_SNORM:
                return this.EXT_texture_compression_rgtc
                    .COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            case Format.D32F_S8:
                return isWebGL2(this.gl)
                    ? GL.DEPTH32F_STENCIL8
                    : this.WEBGL_depth_texture
                        ? GL.DEPTH_STENCIL
                        : GL.DEPTH_COMPONENT16;
            case Format.D24_S8:
                return isWebGL2(this.gl)
                    ? GL.DEPTH24_STENCIL8
                    : this.WEBGL_depth_texture
                        ? GL.DEPTH_STENCIL
                        : GL.DEPTH_COMPONENT16;
            case Format.D32F:
                return isWebGL2(this.gl)
                    ? GL.DEPTH_COMPONENT32F
                    : this.WEBGL_depth_texture
                        ? GL.DEPTH_COMPONENT
                        : GL.DEPTH_COMPONENT16;
            case Format.D24:
                return isWebGL2(this.gl)
                    ? GL.DEPTH_COMPONENT24
                    : this.WEBGL_depth_texture
                        ? GL.DEPTH_COMPONENT
                        : GL.DEPTH_COMPONENT16;
            default:
                throw new Error('whoops');
        }
    };
    Device_GL.prototype.translateTextureType = function (fmt) {
        var typeFlags = getFormatTypeFlags(fmt);
        switch (typeFlags) {
            case FormatTypeFlags.U8:
                return GL.UNSIGNED_BYTE;
            case FormatTypeFlags.U16:
                return GL.UNSIGNED_SHORT;
            case FormatTypeFlags.U32:
                return GL.UNSIGNED_INT;
            case FormatTypeFlags.S8:
                return GL.BYTE;
            case FormatTypeFlags.F16:
                return GL.HALF_FLOAT;
            case FormatTypeFlags.F32:
                return GL.FLOAT;
            case FormatTypeFlags.U16_PACKED_5551:
                return GL.UNSIGNED_SHORT_5_5_5_1;
            case FormatTypeFlags.D32F:
                return isWebGL2(this.gl)
                    ? GL.FLOAT
                    : this.WEBGL_depth_texture
                        ? GL.UNSIGNED_INT
                        : GL.UNSIGNED_BYTE;
            case FormatTypeFlags.D24:
                return isWebGL2(this.gl)
                    ? GL.UNSIGNED_INT_24_8
                    : this.WEBGL_depth_texture
                        ? GL.UNSIGNED_SHORT
                        : GL.UNSIGNED_BYTE;
            case FormatTypeFlags.D24S8:
                // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture
                return isWebGL2(this.gl)
                    ? GL.UNSIGNED_INT_24_8
                    : this.WEBGL_depth_texture
                        ? GL.UNSIGNED_INT_24_8_WEBGL
                        : GL.UNSIGNED_BYTE;
            case FormatTypeFlags.D32FS8:
                return GL.FLOAT_32_UNSIGNED_INT_24_8_REV;
            default:
                throw new Error('whoops');
        }
    };
    Device_GL.prototype.translateTextureFormat = function (fmt) {
        if (isTextureFormatCompressed(fmt)) {
            return this.translateTextureInternalFormat(fmt);
        }
        // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture
        var supportDepthTexture = isWebGL2(this.gl) || (!isWebGL2(this.gl) && !!this.WEBGL_depth_texture);
        switch (fmt) {
            case Format.D24_S8:
            case Format.D32F_S8:
                return supportDepthTexture ? GL.DEPTH_STENCIL : GL.RGBA;
            case Format.D24:
            case Format.D32F:
                return supportDepthTexture ? GL.DEPTH_COMPONENT : GL.RGBA;
        }
        var isInteger = isFormatSizedInteger(fmt);
        var compFlags = getFormatCompFlags(fmt);
        switch (compFlags) {
            case FormatCompFlags.A:
                return GL.ALPHA;
            case FormatCompFlags.R:
                return isInteger ? GL.RED_INTEGER : GL.RED;
            case FormatCompFlags.RG:
                return isInteger ? GL.RG_INTEGER : GL.RG;
            case FormatCompFlags.RGB:
                return isInteger ? GL.RGB_INTEGER : GL.RGB;
            case FormatCompFlags.RGBA:
                // TODO: Chrome throw error when readPixels RGBA_INTEGER and UNSIGNED_BYTE
                // @see https://github.com/KhronosGroup/WebGL/issues/2747
                // return isInteger ? GL.RGBA_INTEGER : GL.RGBA;
                return GL.RGBA;
        }
    };
    Device_GL.prototype.setActiveTexture = function (texture) {
        if (this.currentActiveTexture !== texture) {
            this.gl.activeTexture(texture);
            this.currentActiveTexture = texture;
        }
    };
    Device_GL.prototype.bindVAO = function (vao) {
        if (this.currentBoundVAO !== vao) {
            if (isWebGL2(this.gl)) {
                this.gl.bindVertexArray(vao);
            }
            else {
                this.OES_vertex_array_object.bindVertexArrayOES(vao);
            }
            this.currentBoundVAO = vao;
        }
    };
    Device_GL.prototype.programCompiled = function (program) {
        assert(program.compileState !== ProgramCompileState_GL.NeedsCompile);
        if (program.compileState === ProgramCompileState_GL.Compiling) {
            program.compileState = ProgramCompileState_GL.NeedsBind;
            if (this.shaderDebug) {
                this.checkProgramCompilationForErrors(program);
            }
        }
    };
    Device_GL.prototype.useProgram = function (program) {
        if (this.currentProgram === program)
            return;
        this.programCompiled(program);
        this.gl.useProgram(program.gl_program);
        this.currentProgram = program;
    };
    Device_GL.prototype.ensureResourceExists = function (resource) {
        if (resource === null) {
            var error = this.gl.getError();
            throw new Error("Created resource is null; GL error encountered: ".concat(error));
        }
        else {
            return resource;
        }
    };
    Device_GL.prototype.createBuffer = function (descriptor) {
        return new Buffer_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createTexture = function (descriptor) {
        return new Texture_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createSampler = function (descriptor) {
        return new Sampler_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createRenderTarget = function (descriptor) {
        return new RenderTarget_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createRenderTargetFromTexture = function (texture) {
        var _a = texture, pixelFormat = _a.pixelFormat, width = _a.width, height = _a.height, numLevels = _a.numLevels;
        // Render targets cannot have a mip chain currently.
        assert(numLevels === 1);
        return this.createRenderTarget({
            pixelFormat: pixelFormat,
            width: width,
            height: height,
            sampleCount: 1,
            texture: texture,
        });
    };
    Device_GL.prototype.createProgram = function (descriptor) {
        descriptor.ensurePreprocessed(this.queryVendorInfo());
        return this.createProgramSimple(descriptor);
    };
    Device_GL.prototype.createProgramSimple = function (descriptor) {
        return new Program_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createBindings = function (descriptor) {
        return new Bindings_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createInputLayout = function (descriptor) {
        return new InputLayout_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createInputState = function (_inputLayout, vertexBuffers, indexBufferBinding, program) {
        var inputLayout = _inputLayout;
        return new InputState_GL({
            id: this.getNextUniqueId(),
            device: this,
            inputLayout: inputLayout,
            vertexBuffers: vertexBuffers,
            indexBufferBinding: indexBufferBinding,
            program: program,
        });
    };
    Device_GL.prototype.createRenderPipeline = function (descriptor) {
        return new RenderPipeline_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createComputePass = function () {
        return new ComputePass_GL();
    };
    Device_GL.prototype.createComputePipeline = function (descriptor) {
        return new ComputePipeline_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: descriptor,
        });
    };
    Device_GL.prototype.createReadback = function () {
        return new Readback_GL({
            id: this.getNextUniqueId(),
            device: this,
        });
    };
    Device_GL.prototype.createQueryPool = function (type, elemCount) {
        return new QueryPool_GL({
            id: this.getNextUniqueId(),
            device: this,
            descriptor: {
                type: type,
                elemCount: elemCount,
            },
        });
    };
    Device_GL.prototype.createRenderPass = function (descriptor) {
        assert(this.currentRenderPassDescriptor === null);
        this.currentRenderPassDescriptor = descriptor;
        var colorAttachment = descriptor.colorAttachment, colorAttachmentLevel = descriptor.colorAttachmentLevel, colorClearColor = descriptor.colorClearColor, colorResolveTo = descriptor.colorResolveTo, colorResolveToLevel = descriptor.colorResolveToLevel, depthStencilAttachment = descriptor.depthStencilAttachment, depthClearValue = descriptor.depthClearValue, stencilClearValue = descriptor.stencilClearValue, depthStencilResolveTo = descriptor.depthStencilResolveTo;
        this.setRenderPassParametersBegin(colorAttachment.length);
        for (var i = 0; i < colorAttachment.length; i++) {
            this.setRenderPassParametersColor(i, colorAttachment[i], colorAttachmentLevel[i], colorResolveTo[i], colorResolveToLevel[i]);
        }
        this.setRenderPassParametersDepthStencil(depthStencilAttachment, depthStencilResolveTo);
        this.validateCurrentAttachments();
        for (var i = 0; i < colorAttachment.length; i++) {
            var clearColor = colorClearColor[i];
            if (clearColor === 'load')
                continue;
            this.setRenderPassParametersClearColor(i, clearColor.r, clearColor.g, clearColor.b, clearColor.a);
        }
        this.setRenderPassParametersClearDepthStencil(depthClearValue, stencilClearValue);
        return this;
    };
    Device_GL.prototype.submitPass = function (pass) {
        assert(this.currentRenderPassDescriptor !== null);
        this.endPass();
        this.currentRenderPassDescriptor = null;
    };
    Device_GL.prototype.copySubTexture2D = function (dst_, dstX, dstY, src_, srcX, srcY) {
        var gl = this.gl;
        var dst = dst_;
        var src = src_;
        assert(src.numLevels === 1);
        assert(dst.numLevels === 1);
        if (isWebGL2(gl)) {
            if (dst === this.scTexture) {
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.scPlatformFramebuffer);
            }
            else {
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.resolveColorDrawFramebuffer);
                this.bindFramebufferAttachment(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dst, 0);
            }
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.resolveColorReadFramebuffer);
            this.bindFramebufferAttachment(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, src, 0);
            gl.blitFramebuffer(srcX, srcY, srcX + src.width, srcY + src.height, dstX, dstY, dstX + src.width, dstY + src.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        }
    };
    Device_GL.prototype.queryLimits = function () {
        return this;
    };
    Device_GL.prototype.queryTextureFormatSupported = function (format, width, height) {
        switch (format) {
            case Format.BC1_SRGB:
            case Format.BC2_SRGB:
            case Format.BC3_SRGB:
                if (this.WEBGL_compressed_texture_s3tc_srgb !== null)
                    return isBlockCompressSized(width, height, 4, 4);
                return false;
            case Format.BC1:
            case Format.BC2:
            case Format.BC3:
                if (this.WEBGL_compressed_texture_s3tc !== null)
                    return isBlockCompressSized(width, height, 4, 4);
                return false;
            case Format.BC4_UNORM:
            case Format.BC4_SNORM:
            case Format.BC5_UNORM:
            case Format.BC5_SNORM:
                if (this.EXT_texture_compression_rgtc !== null)
                    return isBlockCompressSized(width, height, 4, 4);
                return false;
            case Format.U16_R_NORM:
            case Format.U16_RG_NORM:
            case Format.U16_RGBA_NORM:
                return this.EXT_texture_norm16 !== null;
            case Format.F32_R:
            case Format.F32_RG:
            case Format.F32_RGB:
            case Format.F32_RGBA:
                return this.OES_texture_float_linear !== null;
            case Format.F16_R:
            case Format.F16_RG:
            case Format.F16_RGB:
            case Format.F16_RGBA:
                return this.OES_texture_half_float_linear !== null;
            default:
                return true;
        }
    };
    Device_GL.prototype.queryProgramReady = function (program) {
        var gl = this.gl;
        if (program.compileState === ProgramCompileState_GL.NeedsCompile) {
            // This should not happen.
            throw new Error('whoops');
        }
        if (program.compileState === ProgramCompileState_GL.Compiling) {
            var complete = void 0;
            if (this.KHR_parallel_shader_compile !== null) {
                complete = gl.getProgramParameter(program.gl_program, this.KHR_parallel_shader_compile.COMPLETION_STATUS_KHR);
            }
            else {
                // If we don't have async shader compilation, assume all compilation is done immediately :/
                complete = true;
            }
            if (complete) {
                this.programCompiled(program);
            }
            return complete;
        }
        return (program.compileState === ProgramCompileState_GL.NeedsBind ||
            program.compileState === ProgramCompileState_GL.ReadyToUse);
    };
    Device_GL.prototype.queryPlatformAvailable = function () {
        return this.gl.isContextLost();
    };
    Device_GL.prototype.queryVendorInfo = function () {
        return this;
    };
    Device_GL.prototype.queryRenderPass = function (o) {
        return this.currentRenderPassDescriptor;
    };
    Device_GL.prototype.queryRenderTarget = function (o) {
        var renderTarget = o;
        return renderTarget;
    };
    //#endregion
    //#region Debugging
    Device_GL.prototype.setResourceName = function (o, name) {
        o.name = name;
        if (o.type === ResourceType.Buffer) {
            var gl_buffer_pages = o.gl_buffer_pages;
            for (var i = 0; i < gl_buffer_pages.length; i++)
                assignPlatformName(gl_buffer_pages[i], "".concat(name, " Page ").concat(i));
        }
        else if (o.type === ResourceType.Texture) {
            assignPlatformName(getPlatformTexture(o), name);
        }
        else if (o.type === ResourceType.Sampler) {
            assignPlatformName(getPlatformSampler(o), name);
        }
        else if (o.type === ResourceType.RenderTarget) {
            var gl_renderbuffer = o.gl_renderbuffer;
            if (gl_renderbuffer !== null)
                assignPlatformName(gl_renderbuffer, name);
        }
        else if (o.type === ResourceType.InputState) {
            assignPlatformName(o.vao, name);
        }
    };
    Device_GL.prototype.setResourceLeakCheck = function (o, v) {
        if (this.resourceCreationTracker !== null)
            this.resourceCreationTracker.setResourceLeakCheck(o, v);
    };
    Device_GL.prototype.checkForLeaks = function () {
        if (this.resourceCreationTracker !== null)
            this.resourceCreationTracker.checkForLeaks();
    };
    Device_GL.prototype.pushDebugGroup = function (debugGroup) {
        this.debugGroupStack.push(debugGroup);
    };
    Device_GL.prototype.popDebugGroup = function () {
        this.debugGroupStack.pop();
    };
    Device_GL.prototype.programPatched = function (o, descriptor) {
        assert(this.shaderDebug);
        // const program = o as Program_GL;
        // const gl = this.gl;
        // gl.deleteProgram(program.gl_program);
        // program.descriptor = descriptor;
        // program.gl_program = this.ensureResourceExists(gl.createProgram());
        // program.compileState = ProgramCompileState_GL.NeedsCompile;
        // this.tryCompileProgram(program);
        // this.checkProgramCompilationForErrors(program);
    };
    Device_GL.prototype.getBufferData = function (buffer, dstBuffer, wordOffset) {
        if (wordOffset === void 0) { wordOffset = 0; }
        var gl = this.gl;
        if (isWebGL2(gl)) {
            gl.bindBuffer(gl.COPY_READ_BUFFER, getPlatformBuffer(buffer, wordOffset * 4));
            gl.getBufferSubData(gl.COPY_READ_BUFFER, wordOffset * 4, dstBuffer);
        }
    };
    //#endregion
    Device_GL.prototype.debugGroupStatisticsDrawCall = function (count) {
        if (count === void 0) { count = 1; }
        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
            this.debugGroupStack[i].drawCallCount += count;
    };
    Device_GL.prototype.debugGroupStatisticsBufferUpload = function (count) {
        if (count === void 0) { count = 1; }
        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
            this.debugGroupStack[i].bufferUploadCount += count;
    };
    Device_GL.prototype.debugGroupStatisticsTextureBind = function (count) {
        if (count === void 0) { count = 1; }
        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
            this.debugGroupStack[i].textureBindCount += count;
    };
    Device_GL.prototype.debugGroupStatisticsTriangles = function (count) {
        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
            this.debugGroupStack[i].triangleCount += count;
    };
    Device_GL.prototype.reportShaderError = function (shader, str) {
        var gl = this.gl;
        var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!status) {
            console.error(prependLineNo(str));
            var debug_shaders = gl.getExtension('WEBGL_debug_shaders');
            if (debug_shaders)
                console.error(debug_shaders.getTranslatedShaderSource(shader));
            console.error(gl.getShaderInfoLog(shader));
        }
        return status;
    };
    Device_GL.prototype.checkProgramCompilationForErrors = function (program) {
        var gl = this.gl;
        var prog = program.gl_program;
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            var descriptor = program.descriptor;
            if (!this.reportShaderError(program.gl_shader_vert, descriptor.preprocessedVert))
                return;
            if (!this.reportShaderError(program.gl_shader_frag, descriptor.preprocessedFrag))
                return;
            // Neither shader had an error, report the program info log.
            console.error(gl.getProgramInfoLog(program.gl_program));
        }
    };
    Device_GL.prototype.bindFramebufferAttachment = function (framebuffer, binding, attachment, level) {
        var gl = this.gl;
        if (attachment === null) {
            gl.framebufferRenderbuffer(framebuffer, binding, gl.RENDERBUFFER, null);
        }
        else if (attachment.type === ResourceType.RenderTarget) {
            if (attachment.gl_renderbuffer !== null) {
                gl.framebufferRenderbuffer(framebuffer, binding, gl.RENDERBUFFER, attachment.gl_renderbuffer);
            }
            else if (attachment.texture !== null) {
                gl.framebufferTexture2D(framebuffer, binding, GL.TEXTURE_2D, getPlatformTexture(attachment.texture), level);
            }
        }
        else if (attachment.type === ResourceType.Texture) {
            // TODO: use Tex2D array with gl.framebufferTextureLayer
            gl.framebufferTexture2D(framebuffer, binding, GL.TEXTURE_2D, getPlatformTexture(attachment), level);
        }
    };
    Device_GL.prototype.bindFramebufferDepthStencilAttachment = function (framebuffer, attachment) {
        var gl = this.gl;
        var flags = attachment !== null
            ? getFormatFlags(attachment.pixelFormat)
            : FormatFlags.Depth | FormatFlags.Stencil;
        var depth = !!(flags & FormatFlags.Depth);
        var stencil = !!(flags & FormatFlags.Stencil);
        if (depth && stencil) {
            var supportDepthTexture = isWebGL2(this.gl) || (!isWebGL2(this.gl) && !!this.WEBGL_depth_texture);
            if (supportDepthTexture) {
                this.bindFramebufferAttachment(framebuffer, gl.DEPTH_STENCIL_ATTACHMENT, attachment, 0);
            }
            else {
                this.bindFramebufferAttachment(framebuffer, gl.DEPTH_ATTACHMENT, attachment, 0);
            }
        }
        else if (depth) {
            this.bindFramebufferAttachment(framebuffer, gl.DEPTH_ATTACHMENT, attachment, 0);
            this.bindFramebufferAttachment(framebuffer, gl.STENCIL_ATTACHMENT, null, 0);
        }
        else if (stencil) {
            this.bindFramebufferAttachment(framebuffer, gl.STENCIL_ATTACHMENT, attachment, 0);
            this.bindFramebufferAttachment(framebuffer, gl.DEPTH_ATTACHMENT, null, 0);
        }
    };
    Device_GL.prototype.validateCurrentAttachments = function () {
        var sampleCount = -1, width = -1, height = -1;
        for (var i = 0; i < this.currentColorAttachments.length; i++) {
            var attachment = this.currentColorAttachments[i];
            if (attachment === null)
                continue;
            if (sampleCount === -1) {
                sampleCount = attachment.sampleCount;
                width = attachment.width;
                height = attachment.height;
            }
            else {
                assert(sampleCount === attachment.sampleCount);
                assert(width === attachment.width);
                assert(height === attachment.height);
            }
        }
        if (this.currentDepthStencilAttachment !== null) {
            if (sampleCount === -1) {
                sampleCount = this.currentDepthStencilAttachment.sampleCount;
                width = this.currentDepthStencilAttachment.width;
                height = this.currentDepthStencilAttachment.height;
            }
            else {
                assert(sampleCount === this.currentDepthStencilAttachment.sampleCount);
                assert(width === this.currentDepthStencilAttachment.width);
                assert(height === this.currentDepthStencilAttachment.height);
            }
        }
        this.currentSampleCount = sampleCount;
    };
    Device_GL.prototype.setRenderPassParametersBegin = function (numColorAttachments) {
        var gl = this.gl;
        if (isWebGL2(gl)) {
            gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, this.renderPassDrawFramebuffer);
        }
        else {
            if (!this.inBlitRenderPass) {
                gl.bindFramebuffer(GL.FRAMEBUFFER, this.renderPassDrawFramebuffer);
            }
        }
        if (!this.inBlitRenderPass) {
            for (var i = numColorAttachments; i < this.currentColorAttachments.length; i++) {
                var target = isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER;
                var attachment = isWebGL2(gl)
                    ? GL.COLOR_ATTACHMENT0
                    : GL.COLOR_ATTACHMENT0_WEBGL;
                gl.framebufferRenderbuffer(target, attachment + i, GL.RENDERBUFFER, null);
                gl.framebufferTexture2D(target, attachment + i, GL.TEXTURE_2D, null, 0);
            }
        }
        this.currentColorAttachments.length = numColorAttachments;
        // if (isWebGL2(gl)) {
        //   gl.drawBuffers([
        //     GL.COLOR_ATTACHMENT0,
        //     GL.COLOR_ATTACHMENT1,
        //     GL.COLOR_ATTACHMENT2,
        //     GL.COLOR_ATTACHMENT3,
        //   ]);
        // } else {
        //   if (!this.inBlitRenderPass) {
        //     // MRT @see https://github.com/shrekshao/MoveWebGL1EngineToWebGL2/blob/master/Move-a-WebGL-1-Engine-To-WebGL-2-Blog-1.md#multiple-render-targets
        //     this.WEBGL_draw_buffers.drawBuffersWEBGL([
        //       GL.COLOR_ATTACHMENT0_WEBGL, // gl_FragData[0]
        //       GL.COLOR_ATTACHMENT1_WEBGL, // gl_FragData[1]
        //       GL.COLOR_ATTACHMENT2_WEBGL, // gl_FragData[2]
        //       GL.COLOR_ATTACHMENT3_WEBGL, // gl_FragData[3]
        //     ]);
        //   }
        // }
    };
    Device_GL.prototype.setRenderPassParametersColor = function (i, colorAttachment, attachmentLevel, colorResolveTo, resolveToLevel) {
        var gl = this.gl;
        if (this.currentColorAttachments[i] !== colorAttachment ||
            this.currentColorAttachmentLevels[i] !== attachmentLevel) {
            this.currentColorAttachments[i] = colorAttachment;
            this.currentColorAttachmentLevels[i] = attachmentLevel;
            // disable MRT in WebGL1
            if (isWebGL2(gl) || i === 0) {
                this.bindFramebufferAttachment(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, (isWebGL2(gl) ? GL.COLOR_ATTACHMENT0 : GL.COLOR_ATTACHMENT0_WEBGL) +
                    i, colorAttachment, attachmentLevel);
            }
            this.resolveColorAttachmentsChanged = true;
        }
        if (this.currentColorResolveTos[i] !== colorResolveTo ||
            this.currentColorResolveToLevels[i] !== resolveToLevel) {
            this.currentColorResolveTos[i] = colorResolveTo;
            this.currentColorResolveToLevels[i] = resolveToLevel;
            if (colorResolveTo !== null) {
                this.resolveColorAttachmentsChanged = true;
            }
        }
    };
    Device_GL.prototype.setRenderPassParametersDepthStencil = function (depthStencilAttachment, depthStencilResolveTo) {
        var gl = this.gl;
        if (this.currentDepthStencilAttachment !== depthStencilAttachment) {
            this.currentDepthStencilAttachment =
                depthStencilAttachment;
            if (!this.inBlitRenderPass) {
                this.bindFramebufferDepthStencilAttachment(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.currentDepthStencilAttachment);
            }
            this.resolveDepthStencilAttachmentsChanged = true;
        }
        if (this.currentDepthStencilResolveTo !== depthStencilResolveTo) {
            this.currentDepthStencilResolveTo = depthStencilResolveTo;
            if (depthStencilResolveTo !== null) {
                this.resolveDepthStencilAttachmentsChanged = true;
            }
        }
    };
    Device_GL.prototype.setRenderPassParametersClearColor = function (slot, r, g, b, a) {
        var gl = this.gl;
        if (this.OES_draw_buffers_indexed !== null) {
            var attachment = this.currentMegaState.attachmentsState[slot];
            if (attachment &&
                attachment.channelWriteMask !== ChannelWriteMask.AllChannels) {
                this.OES_draw_buffers_indexed.colorMaskiOES(slot, true, true, true, true);
                attachment.channelWriteMask = ChannelWriteMask.AllChannels;
            }
        }
        else {
            var attachment = this.currentMegaState.attachmentsState[0];
            if (attachment &&
                attachment.channelWriteMask !== ChannelWriteMask.AllChannels) {
                gl.colorMask(true, true, true, true);
                attachment.channelWriteMask = ChannelWriteMask.AllChannels;
            }
        }
        this.setScissorEnabled(false);
        if (isWebGL2(gl)) {
            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/clearBuffer
            gl.clearBufferfv(gl.COLOR, slot, [r, g, b, a]);
        }
        else {
            gl.clearColor(r, g, b, a);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
    };
    Device_GL.prototype.setRenderPassParametersClearDepthStencil = function (depthClearValue, stencilClearValue) {
        var gl = this.gl;
        if (depthClearValue !== 'load') {
            assert(this.currentDepthStencilAttachment !== null);
            // GL clears obey the masks... bad API or worst API?
            if (!this.currentMegaState.depthWrite) {
                gl.depthMask(true);
                this.currentMegaState.depthWrite = true;
            }
            if (isWebGL2(gl)) {
                gl.clearBufferfv(gl.DEPTH, 0, [depthClearValue]);
            }
            else {
                gl.clearDepth(depthClearValue);
                gl.clear(gl.DEPTH_BUFFER_BIT);
            }
        }
        if (stencilClearValue !== 'load') {
            assert(this.currentDepthStencilAttachment !== null);
            if (!this.currentMegaState.stencilWrite) {
                gl.enable(gl.STENCIL_TEST);
                gl.stencilMask(0xff);
                this.currentMegaState.stencilWrite = true;
            }
            if (isWebGL2(gl)) {
                gl.clearBufferiv(gl.STENCIL, 0, [stencilClearValue]);
            }
            else {
                gl.clearStencil(stencilClearValue);
                gl.clear(gl.STENCIL_BUFFER_BIT);
            }
        }
    };
    Device_GL.prototype.setBindings = function (bindingLayoutIndex, bindings_, dynamicByteOffsets) {
        var _a;
        var gl = this.gl;
        assert(bindingLayoutIndex <
            this.currentPipeline.bindingLayouts.bindingLayoutTables.length);
        var bindingLayoutTable = this.currentPipeline.bindingLayouts.bindingLayoutTables[bindingLayoutIndex];
        var _b = bindings_, uniformBufferBindings = _b.uniformBufferBindings, samplerBindings = _b.samplerBindings;
        // Ignore extra bindings.
        assert(uniformBufferBindings.length >= bindingLayoutTable.numUniformBuffers);
        assert(samplerBindings.length >= bindingLayoutTable.numSamplers);
        assert(dynamicByteOffsets.length >= uniformBufferBindings.length);
        for (var i = 0; i < uniformBufferBindings.length; i++) {
            var binding = uniformBufferBindings[i];
            if (binding.wordCount === 0)
                continue;
            var index = bindingLayoutTable.firstUniformBuffer + i;
            var buffer = binding.buffer;
            var byteOffset = dynamicByteOffsets[i];
            var byteSize = binding.wordCount * 4;
            if (buffer !== this.currentUniformBuffers[index] ||
                byteOffset !== this.currentUniformBufferByteOffsets[index] ||
                byteSize !== this.currentUniformBufferByteSizes[index]) {
                var platformBufferByteOffset = byteOffset % buffer.pageByteSize;
                var platformBuffer = buffer.gl_buffer_pages[(byteOffset / buffer.pageByteSize) | 0];
                assert(platformBufferByteOffset + byteSize <= buffer.pageByteSize);
                if (isWebGL2(gl)) {
                    gl.bindBufferRange(gl.UNIFORM_BUFFER, index, platformBuffer, platformBufferByteOffset, byteSize);
                }
                this.currentUniformBuffers[index] = buffer;
                this.currentUniformBufferByteOffsets[index] = byteOffset;
                this.currentUniformBufferByteSizes[index] = byteSize;
            }
        }
        for (var i = 0; i < bindingLayoutTable.numSamplers; i++) {
            var binding = samplerBindings[i];
            var samplerIndex = bindingLayoutTable.firstSampler + i;
            var samplerEntry = bindingLayoutTable.samplerEntries[i];
            var gl_sampler = binding !== null && binding.sampler !== null
                ? getPlatformSampler(binding.sampler)
                : null;
            var gl_texture = binding !== null && binding.texture !== null
                ? getPlatformTexture(binding.texture)
                : null;
            if (this.currentSamplers[samplerIndex] !== gl_sampler) {
                if (isWebGL2(gl)) {
                    gl.bindSampler(samplerIndex, gl_sampler);
                }
                this.currentSamplers[samplerIndex] = gl_sampler;
            }
            if (this.currentTextures[samplerIndex] !== gl_texture) {
                this.setActiveTexture(gl.TEXTURE0 + samplerIndex);
                if (gl_texture !== null) {
                    // update index
                    binding.texture.textureIndex = samplerIndex;
                    var _c = assertExists(binding)
                        .texture, gl_target = _c.gl_target, width = _c.width, height = _c.height;
                    gl.bindTexture(gl_target, gl_texture);
                    // In WebGL1 set tex's parameters @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter
                    if (!isWebGL2(gl)) {
                        (_a = binding.sampler) === null || _a === void 0 ? void 0 : _a.setTextureParameters(gl_target, width, height);
                    }
                    this.debugGroupStatisticsTextureBind();
                    assert(samplerEntry.gl_target === gl_target);
                    // assert(samplerEntry.formatKind === formatKind);
                }
                else {
                    gl.bindTexture(samplerEntry.gl_target, this.getFallbackTexture(samplerEntry));
                }
                this.currentTextures[samplerIndex] = gl_texture;
            }
        }
    };
    Device_GL.prototype.setViewport = function (x, y, w, h) {
        var gl = this.gl;
        gl.viewport(x, y, w, h);
    };
    Device_GL.prototype.setScissor = function (x, y, w, h) {
        var gl = this.gl;
        this.setScissorEnabled(true);
        gl.scissor(x, y, w, h);
    };
    Device_GL.prototype.applyAttachmentStateIndexed = function (i, currentAttachmentState, newAttachmentState) {
        var gl = this.gl;
        var dbi = this.OES_draw_buffers_indexed;
        if (currentAttachmentState.channelWriteMask !==
            newAttachmentState.channelWriteMask) {
            dbi.colorMaskiOES(i, !!(newAttachmentState.channelWriteMask & ChannelWriteMask.Red), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.Green), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.Blue), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.Alpha));
            currentAttachmentState.channelWriteMask =
                newAttachmentState.channelWriteMask;
        }
        var blendModeChanged = currentAttachmentState.rgbBlendState.blendMode !==
            newAttachmentState.rgbBlendState.blendMode ||
            currentAttachmentState.alphaBlendState.blendMode !==
                newAttachmentState.alphaBlendState.blendMode;
        var blendFuncChanged = currentAttachmentState.rgbBlendState.blendSrcFactor !==
            newAttachmentState.rgbBlendState.blendSrcFactor ||
            currentAttachmentState.alphaBlendState.blendSrcFactor !==
                newAttachmentState.alphaBlendState.blendSrcFactor ||
            currentAttachmentState.rgbBlendState.blendDstFactor !==
                newAttachmentState.rgbBlendState.blendDstFactor ||
            currentAttachmentState.alphaBlendState.blendDstFactor !==
                newAttachmentState.alphaBlendState.blendDstFactor;
        if (blendFuncChanged || blendModeChanged) {
            if (isBlendStateNone(currentAttachmentState.rgbBlendState) &&
                isBlendStateNone(currentAttachmentState.alphaBlendState))
                dbi.enableiOES(i, gl.BLEND);
            else if (isBlendStateNone(newAttachmentState.rgbBlendState) &&
                isBlendStateNone(newAttachmentState.alphaBlendState))
                dbi.disableiOES(i, gl.BLEND);
        }
        if (blendModeChanged) {
            dbi.blendEquationSeparateiOES(i, newAttachmentState.rgbBlendState.blendMode, newAttachmentState.alphaBlendState.blendMode);
            currentAttachmentState.rgbBlendState.blendMode =
                newAttachmentState.rgbBlendState.blendMode;
            currentAttachmentState.alphaBlendState.blendMode =
                newAttachmentState.alphaBlendState.blendMode;
        }
        if (blendFuncChanged) {
            dbi.blendFuncSeparateiOES(i, newAttachmentState.rgbBlendState.blendSrcFactor, newAttachmentState.rgbBlendState.blendDstFactor, newAttachmentState.alphaBlendState.blendSrcFactor, newAttachmentState.alphaBlendState.blendDstFactor);
            currentAttachmentState.rgbBlendState.blendSrcFactor =
                newAttachmentState.rgbBlendState.blendSrcFactor;
            currentAttachmentState.alphaBlendState.blendSrcFactor =
                newAttachmentState.alphaBlendState.blendSrcFactor;
            currentAttachmentState.rgbBlendState.blendDstFactor =
                newAttachmentState.rgbBlendState.blendDstFactor;
            currentAttachmentState.alphaBlendState.blendDstFactor =
                newAttachmentState.alphaBlendState.blendDstFactor;
        }
    };
    Device_GL.prototype.applyAttachmentState = function (currentAttachmentState, newAttachmentState) {
        var gl = this.gl;
        if (currentAttachmentState.channelWriteMask !==
            newAttachmentState.channelWriteMask) {
            gl.colorMask(!!(newAttachmentState.channelWriteMask & ChannelWriteMask.Red), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.Green), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.Blue), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.Alpha));
            currentAttachmentState.channelWriteMask =
                newAttachmentState.channelWriteMask;
        }
        var blendModeChanged = currentAttachmentState.rgbBlendState.blendMode !==
            newAttachmentState.rgbBlendState.blendMode ||
            currentAttachmentState.alphaBlendState.blendMode !==
                newAttachmentState.alphaBlendState.blendMode;
        var blendFuncChanged = currentAttachmentState.rgbBlendState.blendSrcFactor !==
            newAttachmentState.rgbBlendState.blendSrcFactor ||
            currentAttachmentState.alphaBlendState.blendSrcFactor !==
                newAttachmentState.alphaBlendState.blendSrcFactor ||
            currentAttachmentState.rgbBlendState.blendDstFactor !==
                newAttachmentState.rgbBlendState.blendDstFactor ||
            currentAttachmentState.alphaBlendState.blendDstFactor !==
                newAttachmentState.alphaBlendState.blendDstFactor;
        if (blendFuncChanged || blendModeChanged) {
            if (isBlendStateNone(currentAttachmentState.rgbBlendState) &&
                isBlendStateNone(currentAttachmentState.alphaBlendState)) {
                gl.enable(gl.BLEND);
            }
            else if (isBlendStateNone(newAttachmentState.rgbBlendState) &&
                isBlendStateNone(newAttachmentState.alphaBlendState)) {
                gl.disable(gl.BLEND);
            }
        }
        if (blendModeChanged) {
            gl.blendEquationSeparate(newAttachmentState.rgbBlendState.blendMode, newAttachmentState.alphaBlendState.blendMode);
            currentAttachmentState.rgbBlendState.blendMode =
                newAttachmentState.rgbBlendState.blendMode;
            currentAttachmentState.alphaBlendState.blendMode =
                newAttachmentState.alphaBlendState.blendMode;
        }
        if (blendFuncChanged) {
            gl.blendFuncSeparate(newAttachmentState.rgbBlendState.blendSrcFactor, newAttachmentState.rgbBlendState.blendDstFactor, newAttachmentState.alphaBlendState.blendSrcFactor, newAttachmentState.alphaBlendState.blendDstFactor);
            currentAttachmentState.rgbBlendState.blendSrcFactor =
                newAttachmentState.rgbBlendState.blendSrcFactor;
            currentAttachmentState.alphaBlendState.blendSrcFactor =
                newAttachmentState.alphaBlendState.blendSrcFactor;
            currentAttachmentState.rgbBlendState.blendDstFactor =
                newAttachmentState.rgbBlendState.blendDstFactor;
            currentAttachmentState.alphaBlendState.blendDstFactor =
                newAttachmentState.alphaBlendState.blendDstFactor;
        }
    };
    Device_GL.prototype.setMegaState = function (newMegaState) {
        var gl = this.gl;
        var currentMegaState = this.currentMegaState;
        if (this.OES_draw_buffers_indexed !== null) {
            for (var i = 0; i < newMegaState.attachmentsState.length; i++)
                this.applyAttachmentStateIndexed(i, currentMegaState.attachmentsState[0], newMegaState.attachmentsState[0]);
        }
        else {
            assert(newMegaState.attachmentsState.length === 1);
            this.applyAttachmentState(currentMegaState.attachmentsState[0], newMegaState.attachmentsState[0]);
        }
        if (!colorEqual(currentMegaState.blendConstant, newMegaState.blendConstant)) {
            gl.blendColor(newMegaState.blendConstant.r, newMegaState.blendConstant.g, newMegaState.blendConstant.b, newMegaState.blendConstant.a);
            colorCopy(currentMegaState.blendConstant, newMegaState.blendConstant);
        }
        if (currentMegaState.depthCompare !== newMegaState.depthCompare) {
            gl.depthFunc(newMegaState.depthCompare);
            currentMegaState.depthCompare = newMegaState.depthCompare;
        }
        if (currentMegaState.depthWrite !== newMegaState.depthWrite) {
            gl.depthMask(newMegaState.depthWrite);
            currentMegaState.depthWrite = newMegaState.depthWrite;
        }
        if (currentMegaState.stencilWrite !== newMegaState.stencilWrite) {
            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/stencilMask
            gl.stencilMask(newMegaState.stencilWrite ? 0xff : 0x00);
            currentMegaState.stencilWrite = newMegaState.stencilWrite;
        }
        if (currentMegaState.stencilPassOp !== newMegaState.stencilPassOp) {
            gl.stencilOp(gl.KEEP, gl.KEEP, newMegaState.stencilPassOp);
            currentMegaState.stencilPassOp = newMegaState.stencilPassOp;
        }
        if (currentMegaState.stencilRef !== newMegaState.stencilRef ||
            currentMegaState.stencilCompare !== newMegaState.stencilCompare) {
            currentMegaState.stencilCompare = newMegaState.stencilCompare;
            this.setStencilRef(newMegaState.stencilRef);
        }
        if (currentMegaState.cullMode !== newMegaState.cullMode) {
            if (currentMegaState.cullMode === CullMode.None) {
                gl.enable(gl.CULL_FACE);
            }
            else if (newMegaState.cullMode === CullMode.None) {
                gl.disable(gl.CULL_FACE);
            }
            if (newMegaState.cullMode === CullMode.Back) {
                gl.cullFace(gl.BACK);
            }
            else if (newMegaState.cullMode === CullMode.Front) {
                gl.cullFace(gl.FRONT);
            }
            else if (newMegaState.cullMode === CullMode.FrontAndBack) {
                gl.cullFace(gl.FRONT_AND_BACK);
            }
            currentMegaState.cullMode = newMegaState.cullMode;
        }
        if (currentMegaState.frontFace !== newMegaState.frontFace) {
            gl.frontFace(newMegaState.frontFace);
            currentMegaState.frontFace = newMegaState.frontFace;
        }
        if (currentMegaState.polygonOffset !== newMegaState.polygonOffset) {
            if (newMegaState.polygonOffset) {
                gl.polygonOffset(1, 1);
                gl.enable(gl.POLYGON_OFFSET_FILL);
            }
            else {
                gl.disable(gl.POLYGON_OFFSET_FILL);
            }
            currentMegaState.polygonOffset = newMegaState.polygonOffset;
        }
    };
    Device_GL.prototype.validatePipelineFormats = function (pipeline) {
        for (var i = 0; i < this.currentColorAttachments.length; i++) {
            var attachment = this.currentColorAttachments[i];
            if (attachment === null)
                continue;
            assert(attachment.pixelFormat === pipeline.colorAttachmentFormats[i]);
        }
        if (this.currentDepthStencilAttachment !== null) {
            assert(this.currentDepthStencilAttachment.pixelFormat ===
                pipeline.depthStencilAttachmentFormat);
        }
        if (this.currentSampleCount !== -1) {
            assert(this.currentSampleCount === pipeline.sampleCount);
        }
    };
    Device_GL.prototype.setPipeline = function (o) {
        this.currentPipeline = o;
        this.validatePipelineFormats(this.currentPipeline);
        // We allow users to use "non-ready" pipelines for emergencies. In this case, there can be a bit of stuttering.
        // assert(this.queryPipelineReady(this.currentPipeline));
        this.setMegaState(this.currentPipeline.megaState);
        var program = this.currentPipeline.program;
        this.useProgram(program);
        if (program.compileState === ProgramCompileState_GL.NeedsBind) {
            var gl = this.gl;
            var prog = program.gl_program;
            var deviceProgram = program.descriptor;
            var uniformBlocks = findall(deviceProgram.preprocessedVert, /uniform (\w+) {([^]*?)}/g);
            if (isWebGL2(gl)) {
                for (var i = 0; i < uniformBlocks.length; i++) {
                    var _a = __read(uniformBlocks[i], 2), blockName = _a[1];
                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getUniformBlockIndex
                    var blockIdx = gl.getUniformBlockIndex(prog, blockName);
                    if (blockIdx !== -1 && blockIdx !== 0xffffffff) {
                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniformBlockBinding
                        gl.uniformBlockBinding(prog, blockIdx, i);
                    }
                }
            }
            var samplers = findall(deviceProgram.preprocessedVert, /^uniform .*sampler\S+ (\w+);\s* \/\/ BINDING=(\d+)$/gm);
            for (var i = 0; i < samplers.length; i++) {
                var _b = __read(samplers[i], 3), name_1 = _b[1], location_1 = _b[2];
                var samplerUniformLocation = gl.getUniformLocation(prog, name_1);
                gl.uniform1i(samplerUniformLocation, parseInt(location_1));
            }
            program.compileState = ProgramCompileState_GL.ReadyToUse;
        }
    };
    Device_GL.prototype.setInputState = function (inputState_) {
        var inputState = inputState_;
        this.currentInputState = inputState;
        if (this.currentInputState !== null) {
            assert(this.currentPipeline.inputLayout === this.currentInputState.inputLayout);
            this.bindVAO(this.currentInputState.vao);
        }
        else {
            assert(this.currentPipeline.inputLayout === null);
            this.bindVAO(null);
        }
    };
    Device_GL.prototype.setStencilRef = function (value) {
        if (this.currentStencilRef === value) {
            return;
        }
        this.currentStencilRef = value;
        this.applyStencil();
    };
    Device_GL.prototype.draw = function (count, firstVertex) {
        var gl = this.gl;
        var pipeline = this.currentPipeline;
        gl.drawArrays(pipeline.drawMode, firstVertex, count);
        this.debugGroupStatisticsDrawCall();
        this.debugGroupStatisticsTriangles(count / 3);
    };
    Device_GL.prototype.drawIndexed = function (count, firstIndex) {
        var gl = this.gl;
        var pipeline = this.currentPipeline;
        var inputState = this.currentInputState;
        var byteOffset = assertExists(inputState.indexBufferByteOffset) +
            firstIndex * assertExists(inputState.indexBufferCompByteSize);
        gl.drawElements(pipeline.drawMode, count, assertExists(inputState.indexBufferType), byteOffset);
        this.debugGroupStatisticsDrawCall();
        this.debugGroupStatisticsTriangles(count / 3);
    };
    Device_GL.prototype.drawIndexedInstanced = function (count, firstIndex, instanceCount) {
        var _a;
        var gl = this.gl;
        var pipeline = this.currentPipeline;
        var inputState = this.currentInputState;
        var byteOffset = assertExists(inputState.indexBufferByteOffset) +
            firstIndex * assertExists(inputState.indexBufferCompByteSize);
        var params = [
            pipeline.drawMode,
            count,
            assertExists(inputState.indexBufferType),
            byteOffset,
            instanceCount,
        ];
        if (isWebGL2(gl)) {
            gl.drawElementsInstanced.apply(gl, __spreadArray([], __read(params), false));
        }
        else {
            (_a = this.ANGLE_instanced_arrays).drawElementsInstancedANGLE.apply(_a, __spreadArray([], __read(params), false));
        }
        this.debugGroupStatisticsDrawCall();
        this.debugGroupStatisticsTriangles((count / 3) * instanceCount);
    };
    Device_GL.prototype.beginOcclusionQuery = function (dstOffs) {
        var gl = this.gl;
        if (isWebGL2(gl)) {
            var queryPool = this.currentRenderPassDescriptor
                .occlusionQueryPool;
            gl.beginQuery(queryPool.gl_query_type, queryPool.gl_query[dstOffs]);
        }
    };
    Device_GL.prototype.endOcclusionQuery = function (dstOffs) {
        var gl = this.gl;
        if (isWebGL2(gl)) {
            var queryPool = this.currentRenderPassDescriptor
                .occlusionQueryPool;
            gl.endQuery(queryPool.gl_query_type);
        }
    };
    Device_GL.prototype.beginDebugGroup = function (name) { };
    Device_GL.prototype.endDebugGroup = function () { };
    Device_GL.prototype.pipelineQueryReady = function (o) {
        var pipeline = o;
        return this.queryProgramReady(pipeline.program);
    };
    Device_GL.prototype.pipelineForceReady = function (o) {
        // No need to do anything; it will be forced to compile when used naturally.
    };
    Device_GL.prototype.endPass = function () {
        var gl = this.gl;
        var didUnbindDraw = false;
        for (var i = 0; i < this.currentColorAttachments.length; i++) {
            var colorResolveFrom = this.currentColorAttachments[i];
            if (colorResolveFrom !== null) {
                var colorResolveTo = this.currentColorResolveTos[i];
                var didBindRead = false;
                if (colorResolveTo !== null) {
                    assert(colorResolveFrom.width === colorResolveTo.width &&
                        colorResolveFrom.height === colorResolveTo.height);
                    assert(colorResolveFrom.pixelFormat === colorResolveTo.pixelFormat);
                    this.setScissorEnabled(false);
                    if (isWebGL2(gl)) {
                        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.resolveColorReadFramebuffer);
                    }
                    if (this.resolveColorAttachmentsChanged) {
                        if (isWebGL2(gl)) {
                            this.bindFramebufferAttachment(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorResolveFrom, this.currentColorAttachmentLevels[i]);
                        }
                    }
                    didBindRead = true;
                    // Special case: Blitting to the on-screen.
                    if (colorResolveTo === this.scTexture) {
                        gl.bindFramebuffer(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.scPlatformFramebuffer);
                    }
                    else {
                        gl.bindFramebuffer(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveColorDrawFramebuffer);
                        if (this.resolveColorAttachmentsChanged)
                            gl.framebufferTexture2D(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorResolveTo.gl_texture, this.currentColorResolveToLevels[i]);
                    }
                    if (isWebGL2(gl)) {
                        gl.blitFramebuffer(0, 0, colorResolveFrom.width, colorResolveFrom.height, 0, 0, colorResolveTo.width, colorResolveTo.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
                        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
                    }
                    else {
                        // need an extra render pass in WebGL1
                        this.submitBlitRenderPass(colorResolveFrom, colorResolveTo);
                    }
                    didUnbindDraw = true;
                }
                if (!this.currentRenderPassDescriptor.colorStore[i]) {
                    if (!didBindRead) {
                        gl.bindFramebuffer(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveColorReadFramebuffer);
                        if (this.resolveColorAttachmentsChanged)
                            this.bindFramebufferAttachment(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorResolveFrom, this.currentColorAttachmentLevels[i]);
                    }
                    if (isWebGL2(gl)) {
                        gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [
                            gl.COLOR_ATTACHMENT0,
                        ]);
                    }
                }
                gl.bindFramebuffer(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, null);
            }
        }
        this.resolveColorAttachmentsChanged = false;
        var depthStencilResolveFrom = this.currentDepthStencilAttachment;
        if (depthStencilResolveFrom !== null) {
            var depthStencilResolveTo = this.currentDepthStencilResolveTo;
            var didBindRead = false;
            if (depthStencilResolveTo !== null) {
                assert(depthStencilResolveFrom.width === depthStencilResolveTo.width &&
                    depthStencilResolveFrom.height === depthStencilResolveTo.height);
                this.setScissorEnabled(false);
                gl.bindFramebuffer(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveDepthStencilReadFramebuffer);
                gl.bindFramebuffer(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveDepthStencilDrawFramebuffer);
                if (this.resolveDepthStencilAttachmentsChanged) {
                    this.bindFramebufferDepthStencilAttachment(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, depthStencilResolveFrom);
                    this.bindFramebufferDepthStencilAttachment(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, depthStencilResolveTo);
                }
                didBindRead = true;
                if (isWebGL2(gl)) {
                    gl.blitFramebuffer(0, 0, depthStencilResolveFrom.width, depthStencilResolveFrom.height, 0, 0, depthStencilResolveTo.width, depthStencilResolveTo.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
                }
                gl.bindFramebuffer(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, null);
                didUnbindDraw = true;
            }
            if (!this.currentRenderPassDescriptor.depthStencilStore) {
                if (!didBindRead) {
                    gl.bindFramebuffer(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveDepthStencilReadFramebuffer);
                    if (this.resolveDepthStencilAttachmentsChanged)
                        this.bindFramebufferDepthStencilAttachment(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, depthStencilResolveFrom);
                    didBindRead = true;
                }
                if (isWebGL2(gl)) {
                    gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [
                        gl.DEPTH_STENCIL_ATTACHMENT,
                    ]);
                }
            }
            if (didBindRead)
                gl.bindFramebuffer(isWebGL2(gl) ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, null);
            this.resolveDepthStencilAttachmentsChanged = false;
        }
        if (!didUnbindDraw) {
            // If we did not unbind from a resolve, then we need to unbind our render pass draw FBO here.
            gl.bindFramebuffer(isWebGL2(gl) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, null);
        }
    };
    Device_GL.prototype.setScissorEnabled = function (v) {
        if (this.currentScissorEnabled === v) {
            return;
        }
        var gl = this.gl;
        if (v) {
            gl.enable(gl.SCISSOR_TEST);
        }
        else {
            gl.disable(gl.SCISSOR_TEST);
        }
        this.currentScissorEnabled = v;
    };
    Device_GL.prototype.applyStencil = function () {
        if (this.currentStencilRef === null) {
            return;
        }
        this.gl.stencilFunc(this.currentMegaState.stencilCompare, this.currentStencilRef, 0xff);
    };
    Device_GL.prototype.getFallbackTexture = function (samplerEntry) {
        var gl_target = samplerEntry.gl_target, formatKind = samplerEntry.formatKind;
        if (gl_target === GL.TEXTURE_2D)
            return formatKind === SamplerFormatKind.Depth
                ? this.fallbackTexture2DDepth
                : this.fallbackTexture2D;
        else if (gl_target === GL.TEXTURE_2D_ARRAY)
            return this.fallbackTexture2DArray;
        else if (gl_target === GL.TEXTURE_3D)
            return this.fallbackTexture3D;
        else if (gl_target === GL.TEXTURE_CUBE_MAP)
            return this.fallbackTextureCube;
        else
            throw new Error('whoops');
    };
    Device_GL.prototype.submitBlitRenderPass = function (resolveFrom, resolveTo) {
        if (!this.blitRenderPipeline) {
            var vertexBuffer = makeDataBuffer(this, BufferUsage.VERTEX | BufferUsage.COPY_DST, new Float32Array([-4, -4, 4, -4, 0, 4]).buffer);
            var inputLayout = this.createInputLayout({
                vertexBufferDescriptors: [
                    { byteStride: 4 * 2, frequency: VertexBufferFrequency.PerVertex },
                ],
                vertexAttributeDescriptors: [
                    {
                        format: Format.F32_RG,
                        bufferIndex: 0,
                        bufferByteOffset: 4 * 0,
                        location: 0,
                    },
                ],
                indexBufferFormat: null,
            });
            var bindingLayouts = [
                { numSamplers: 1, numUniformBuffers: 0 },
            ];
            var program = this.createProgram(__assign(__assign({}, preprocessProgramObj_GLSL(this, new CopyProgram())), { ensurePreprocessed: function () { }, associate: function () { } }));
            this.blitInputState = this.createInputState(inputLayout, [{ buffer: vertexBuffer, byteOffset: 0 }], null, program);
            this.blitRenderPipeline = this.createRenderPipeline({
                topology: PrimitiveTopology.Triangles,
                sampleCount: 1,
                program: program,
                bindingLayouts: bindingLayouts,
                colorAttachmentFormats: [Format.U8_RGBA_RT],
                depthStencilAttachmentFormat: null,
                inputLayout: inputLayout,
                // megaStateDescriptor: copyMegaState(defaultMegaState),
                megaStateDescriptor: this.currentMegaState,
            });
            // const colorTexture = this.currentColorAttachments[0].texture;
            this.blitBindings = this.createBindings({
                bindingLayout: bindingLayouts[0],
                samplerBindings: [
                    {
                        sampler: null,
                        texture: resolveFrom.texture,
                        lateBinding: null,
                    },
                ],
                uniformBufferBindings: [],
            });
            program.setUniforms({
                u_Texture: resolveFrom,
            });
        }
        // save currentRenderPassDescriptor since we're already in a render pass
        var currentRenderPassDescriptor = this.currentRenderPassDescriptor;
        this.currentRenderPassDescriptor = null;
        this.inBlitRenderPass = true;
        var blitRenderPass = this.createRenderPass({
            colorAttachment: [resolveFrom],
            colorResolveToLevel: [0],
            colorResolveTo: [resolveTo],
            colorClearColor: [TransparentWhite],
            colorStore: [true],
            colorAttachmentLevel: [0],
            depthStencilAttachment: null,
            depthStencilResolveTo: null,
            depthStencilStore: true,
            depthClearValue: 'load',
            stencilClearValue: 'load',
            occlusionQueryPool: null,
        });
        var _a = this.getCanvas(), width = _a.width, height = _a.height;
        blitRenderPass.setPipeline(this.blitRenderPipeline);
        blitRenderPass.setBindings(0, this.blitBindings, [0]);
        blitRenderPass.setInputState(this.blitInputState);
        blitRenderPass.setViewport(0, 0, width, height);
        // disable blending for blit
        this.gl.disable(this.gl.BLEND);
        blitRenderPass.draw(3, 0);
        this.gl.enable(this.gl.BLEND);
        // restore
        this.currentRenderPassDescriptor = currentRenderPassDescriptor;
        this.inBlitRenderPass = false;
    };
    return Device_GL;
}());

var WebGLDeviceContribution = /** @class */ (function () {
    function WebGLDeviceContribution(pluginOptions) {
        this.pluginOptions = pluginOptions;
    }
    WebGLDeviceContribution.prototype.createSwapChain = function ($canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var options, targets, gl;
            return __generator(this, function (_a) {
                options = {
                    // alpha: true,
                    antialias: false,
                    // @see https://stackoverflow.com/questions/27746091/preservedrawingbuffer-false-is-it-worth-the-effort
                    preserveDrawingBuffer: false,
                    // @see https://webglfundamentals.org/webgl/lessons/webgl-qna-how-to-use-the-stencil-buffer.html
                    stencil: true,
                    // @see https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
                    premultipliedAlpha: true,
                };
                this.handleContextEvents($canvas);
                targets = this.pluginOptions.targets;
                if (targets.includes('webgl2')) {
                    gl =
                        $canvas.getContext('webgl2', options) ||
                            $canvas.getContext('experimental-webgl2', options);
                }
                if (!gl && targets.includes('webgl1')) {
                    gl =
                        $canvas.getContext('webgl', options) ||
                            $canvas.getContext('experimental-webgl', options);
                }
                return [2 /*return*/, new Device_GL(gl, {
                        shaderDebug: true,
                        trackResources: true,
                    })];
            });
        });
    };
    WebGLDeviceContribution.prototype.handleContextEvents = function ($canvas) {
        var _a = this.pluginOptions, onContextLost = _a.onContextLost, onContextRestored = _a.onContextRestored, onContextCreationError = _a.onContextCreationError;
        // bind context event listeners
        if (onContextCreationError) {
            // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/webglcontextcreationerror_event
            $canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
        }
        if (onContextLost) {
            $canvas.addEventListener('webglcontextlost', onContextLost, false);
        }
        if (onContextRestored) {
            $canvas.addEventListener('webglcontextrestored', onContextRestored, false);
        }
    };
    return WebGLDeviceContribution;
}());

var Plugin = /** @class */ (function (_super) {
    __extends(Plugin, _super);
    function Plugin(options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.name = 'webgl-device';
        return _this;
    }
    Plugin.prototype.init = function () {
        // @ts-ignore
        this.context.deviceContribution = new WebGLDeviceContribution(__assign({}, this.options));
    };
    Plugin.prototype.destroy = function () {
        // @ts-ignore
        delete this.context.deviceContribution;
    };
    return Plugin;
}(AbstractRendererPlugin));

export { Plugin };
//# sourceMappingURL=index.esm.js.map
